/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/plugin/js/config.js":
/*!***************************************!*\
  !*** ./resources/plugin/js/config.js ***!
  \***************************************/
/***/ (() => {

eval("$(function () {\n  /*\n  |--------------------------------------------------------------------------\n  | Configure your website\n  |--------------------------------------------------------------------------\n  |\n  | We provided several configuration variables for your ease of development.\n  | Read their complete description and modify them based on your need.\n  |\n  */\n  page.config({\n    /*\n    |--------------------------------------------------------------------------\n    | Google API Key\n    |--------------------------------------------------------------------------\n    |\n    | Here you may specify your Google API key if you need to use Google Maps\n    | in your application\n    |\n    | https://developers.google.com/maps/documentation/javascript/get-api-key\n    |\n    */\n    googleApiKey: 'AIzaSyDRBLFOTTh2NFM93HpUA4ZrA99yKnCAsto',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Google Analytics Tracking\n    |--------------------------------------------------------------------------\n    |\n    | If you want to use Google Analytics, you can specify your Tracking ID in\n    | this option. Your key would be a value like: UA-12345678-9\n    |\n    */\n    googleAnalyticsId: '',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Google reCAPTCHA\n    |--------------------------------------------------------------------------\n    |\n    | reCAPTCHA protects you against spam and other types of automated abuse.\n    | Please signup for an API key pair and insert your `Site key` value to the\n    | following variable.\n    |\n    | http://www.google.com/recaptcha/admin\n    |\n    */\n    reCaptchaSiteKey: '6Ldaf0MUAAAAAHdsMv_7dND7BSTvdrE6VcQKpM-n',\n    // See available languages: https://developers.google.com/recaptcha/docs/language\n    reCaptchaLanguage: '',\n\n    /*\n    |--------------------------------------------------------------------------\n    | Disable AOS on mobile\n    |--------------------------------------------------------------------------\n    |\n    | If true, the Animate On Scroll animations don't run on mobile devices.\n    |\n    */\n    disableAOSonMobile: true,\n\n    /*\n    |--------------------------------------------------------------------------\n    | Smooth Scroll\n    |--------------------------------------------------------------------------\n    |\n    | If true, the browser's scrollbar moves smoothly on scroll and gives your\n    | visitor a better experience for scrolling.\n    |\n    */\n    smoothScroll: true\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL2NvbmZpZy5qcz9iNWI3Il0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiY29uZmlnIiwiZ29vZ2xlQXBpS2V5IiwiZ29vZ2xlQW5hbHl0aWNzSWQiLCJyZUNhcHRjaGFTaXRlS2V5IiwicmVDYXB0Y2hhTGFuZ3VhZ2UiLCJkaXNhYmxlQU9Tb25Nb2JpbGUiLCJzbW9vdGhTY3JvbGwiXSwibWFwcGluZ3MiOiJBQUFBQSxDQUFDLENBQUMsWUFBWTtBQUdWO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVJQyxFQUFBQSxJQUFJLENBQUNDLE1BQUwsQ0FBWTtBQUVSO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFUUMsSUFBQUEsWUFBWSxFQUFFLHlDQWROOztBQWdCUjtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFUUMsSUFBQUEsaUJBQWlCLEVBQUUsRUExQlg7O0FBNEJSO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVRQyxJQUFBQSxnQkFBZ0IsRUFBRSwwQ0F6Q1Y7QUEyQ1I7QUFDQUMsSUFBQUEsaUJBQWlCLEVBQUUsRUE1Q1g7O0FBOENSO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFUUMsSUFBQUEsa0JBQWtCLEVBQUUsSUF2RFo7O0FBeURSO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVRQyxJQUFBQSxZQUFZLEVBQUU7QUFuRU4sR0FBWjtBQXVFSCxDQXBGQSxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiJChmdW5jdGlvbiAoKSB7XG5cblxuICAgIC8qXG4gICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgfCBDb25maWd1cmUgeW91ciB3ZWJzaXRlXG4gICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgfFxuICAgIHwgV2UgcHJvdmlkZWQgc2V2ZXJhbCBjb25maWd1cmF0aW9uIHZhcmlhYmxlcyBmb3IgeW91ciBlYXNlIG9mIGRldmVsb3BtZW50LlxuICAgIHwgUmVhZCB0aGVpciBjb21wbGV0ZSBkZXNjcmlwdGlvbiBhbmQgbW9kaWZ5IHRoZW0gYmFzZWQgb24geW91ciBuZWVkLlxuICAgIHxcbiAgICAqL1xuXG4gICAgcGFnZS5jb25maWcoe1xuXG4gICAgICAgIC8qXG4gICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB8IEdvb2dsZSBBUEkgS2V5XG4gICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB8XG4gICAgICAgIHwgSGVyZSB5b3UgbWF5IHNwZWNpZnkgeW91ciBHb29nbGUgQVBJIGtleSBpZiB5b3UgbmVlZCB0byB1c2UgR29vZ2xlIE1hcHNcbiAgICAgICAgfCBpbiB5b3VyIGFwcGxpY2F0aW9uXG4gICAgICAgIHxcbiAgICAgICAgfCBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9nZXQtYXBpLWtleVxuICAgICAgICB8XG4gICAgICAgICovXG5cbiAgICAgICAgZ29vZ2xlQXBpS2V5OiAnQUl6YVN5RFJCTEZPVFRoMk5GTTkzSHBVQTRackE5OXlLbkNBc3RvJyxcblxuICAgICAgICAvKlxuICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgfCBHb29nbGUgQW5hbHl0aWNzIFRyYWNraW5nXG4gICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB8XG4gICAgICAgIHwgSWYgeW91IHdhbnQgdG8gdXNlIEdvb2dsZSBBbmFseXRpY3MsIHlvdSBjYW4gc3BlY2lmeSB5b3VyIFRyYWNraW5nIElEIGluXG4gICAgICAgIHwgdGhpcyBvcHRpb24uIFlvdXIga2V5IHdvdWxkIGJlIGEgdmFsdWUgbGlrZTogVUEtMTIzNDU2NzgtOVxuICAgICAgICB8XG4gICAgICAgICovXG5cbiAgICAgICAgZ29vZ2xlQW5hbHl0aWNzSWQ6ICcnLFxuXG4gICAgICAgIC8qXG4gICAgICAgIHwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB8IEdvb2dsZSByZUNBUFRDSEFcbiAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHxcbiAgICAgICAgfCByZUNBUFRDSEEgcHJvdGVjdHMgeW91IGFnYWluc3Qgc3BhbSBhbmQgb3RoZXIgdHlwZXMgb2YgYXV0b21hdGVkIGFidXNlLlxuICAgICAgICB8IFBsZWFzZSBzaWdudXAgZm9yIGFuIEFQSSBrZXkgcGFpciBhbmQgaW5zZXJ0IHlvdXIgYFNpdGUga2V5YCB2YWx1ZSB0byB0aGVcbiAgICAgICAgfCBmb2xsb3dpbmcgdmFyaWFibGUuXG4gICAgICAgIHxcbiAgICAgICAgfCBodHRwOi8vd3d3Lmdvb2dsZS5jb20vcmVjYXB0Y2hhL2FkbWluXG4gICAgICAgIHxcbiAgICAgICAgKi9cblxuICAgICAgICByZUNhcHRjaGFTaXRlS2V5OiAnNkxkYWYwTVVBQUFBQUhkc012XzdkTkQ3QlNUdmRyRTZWY1FLcE0tbicsXG5cbiAgICAgICAgLy8gU2VlIGF2YWlsYWJsZSBsYW5ndWFnZXM6IGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3JlY2FwdGNoYS9kb2NzL2xhbmd1YWdlXG4gICAgICAgIHJlQ2FwdGNoYUxhbmd1YWdlOiAnJyxcblxuICAgICAgICAvKlxuICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgfCBEaXNhYmxlIEFPUyBvbiBtb2JpbGVcbiAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHxcbiAgICAgICAgfCBJZiB0cnVlLCB0aGUgQW5pbWF0ZSBPbiBTY3JvbGwgYW5pbWF0aW9ucyBkb24ndCBydW4gb24gbW9iaWxlIGRldmljZXMuXG4gICAgICAgIHxcbiAgICAgICAgKi9cblxuICAgICAgICBkaXNhYmxlQU9Tb25Nb2JpbGU6IHRydWUsXG5cbiAgICAgICAgLypcbiAgICAgICAgfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIHwgU21vb3RoIFNjcm9sbFxuICAgICAgICB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgfFxuICAgICAgICB8IElmIHRydWUsIHRoZSBicm93c2VyJ3Mgc2Nyb2xsYmFyIG1vdmVzIHNtb290aGx5IG9uIHNjcm9sbCBhbmQgZ2l2ZXMgeW91clxuICAgICAgICB8IHZpc2l0b3IgYSBiZXR0ZXIgZXhwZXJpZW5jZSBmb3Igc2Nyb2xsaW5nLlxuICAgICAgICB8XG4gICAgICAgICovXG5cbiAgICAgICAgc21vb3RoU2Nyb2xsOiB0cnVlLFxuXG4gICAgfSk7XG5cbn0pO1xuIl0sImZpbGUiOiIuL3Jlc291cmNlcy9wbHVnaW4vanMvY29uZmlnLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/config.js\n");

/***/ }),

/***/ "./resources/plugin/js/loaders/core.js":
/*!*********************************************!*\
  !*** ./resources/plugin/js/loaders/core.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n|--------------------------------------------------------------------------\n| Main\n|--------------------------------------------------------------------------\n|\n| The start point of the project. Include jQuery, Bootstrap and required\n| plugins and define page object. These files are mandatory.\n|\n*/\n__webpack_require__(/*! ../partials/main.js */ \"./resources/plugin/js/partials/main.js\");\n\n__webpack_require__(/*! ../vendors/jquery.js */ \"./resources/plugin/js/vendors/jquery.js\");\n\n__webpack_require__(/*! ../vendors/bootstrap.js */ \"./resources/plugin/js/vendors/bootstrap.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL2xvYWRlcnMvY29yZS5qcz82MDQ4Il0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxtQkFBTyxDQUFDLG1FQUFELENBQVA7O0FBRUFBLG1CQUFPLENBQUMscUVBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQywyRUFBRCxDQUFQIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9sb2FkZXJzL2NvcmUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgTWFpblxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58XG58IFRoZSBzdGFydCBwb2ludCBvZiB0aGUgcHJvamVjdC4gSW5jbHVkZSBqUXVlcnksIEJvb3RzdHJhcCBhbmQgcmVxdWlyZWRcbnwgcGx1Z2lucyBhbmQgZGVmaW5lIHBhZ2Ugb2JqZWN0LiBUaGVzZSBmaWxlcyBhcmUgbWFuZGF0b3J5LlxufFxuKi9cbnJlcXVpcmUoJy4uL3BhcnRpYWxzL21haW4uanMnKTtcblxucmVxdWlyZSgnLi4vdmVuZG9ycy9qcXVlcnkuanMnKTtcbnJlcXVpcmUoJy4uL3ZlbmRvcnMvYm9vdHN0cmFwLmpzJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/loaders/core.js\n");

/***/ }),

/***/ "./resources/plugin/js/loaders/partials.js":
/*!*************************************************!*\
  !*** ./resources/plugin/js/loaders/partials.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n|--------------------------------------------------------------------------\n| Partials\n|--------------------------------------------------------------------------\n|\n| Split the application code to several files. Almost all of the following\n| files are required for the application to work properly.\n|\n*/\n__webpack_require__(/*! ../partials/config.js */ \"./resources/plugin/js/partials/config.js\");\n\n__webpack_require__(/*! ../partials/bind.js */ \"./resources/plugin/js/partials/bind.js\");\n\n__webpack_require__(/*! ../partials/drawer.js */ \"./resources/plugin/js/partials/drawer.js\");\n\n__webpack_require__(/*! ../partials/font.js */ \"./resources/plugin/js/partials/font.js\");\n\n__webpack_require__(/*! ../partials/form.js */ \"./resources/plugin/js/partials/form.js\");\n\n__webpack_require__(/*! ../partials/mailer.js */ \"./resources/plugin/js/partials/mailer.js\");\n\n__webpack_require__(/*! ../partials/map.js */ \"./resources/plugin/js/partials/map.js\");\n\n__webpack_require__(/*! ../partials/modal.js */ \"./resources/plugin/js/partials/modal.js\");\n\n__webpack_require__(/*! ../partials/navbar.js */ \"./resources/plugin/js/partials/navbar.js\");\n\n__webpack_require__(/*! ../partials/offcanvas.js */ \"./resources/plugin/js/partials/offcanvas.js\");\n\n__webpack_require__(/*! ../partials/popup.js */ \"./resources/plugin/js/partials/popup.js\");\n\n__webpack_require__(/*! ../partials/recaptcha.js */ \"./resources/plugin/js/partials/recaptcha.js\");\n\n__webpack_require__(/*! ../partials/scroll.js */ \"./resources/plugin/js/partials/scroll.js\");\n\n__webpack_require__(/*! ../partials/section.js */ \"./resources/plugin/js/partials/section.js\");\n\n__webpack_require__(/*! ../partials/sidebar.js */ \"./resources/plugin/js/partials/sidebar.js\");\n\n__webpack_require__(/*! ../partials/video.js */ \"./resources/plugin/js/partials/video.js\");\n\n__webpack_require__(/*! ../partials/util.js */ \"./resources/plugin/js/partials/util.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL2xvYWRlcnMvcGFydGlhbHMuanM/YWRiOCJdLCJuYW1lcyI6WyJyZXF1aXJlIl0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsbUJBQU8sQ0FBQyx1RUFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLG1FQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsdUVBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxtRUFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLG1FQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsdUVBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxpRUFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHFFQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsdUVBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyw2RUFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHFFQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMsNkVBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyx1RUFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLHlFQUFELENBQVA7O0FBQ0FBLG1CQUFPLENBQUMseUVBQUQsQ0FBUDs7QUFDQUEsbUJBQU8sQ0FBQyxxRUFBRCxDQUFQOztBQUNBQSxtQkFBTyxDQUFDLG1FQUFELENBQVAiLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL2xvYWRlcnMvcGFydGlhbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgUGFydGlhbHNcbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufFxufCBTcGxpdCB0aGUgYXBwbGljYXRpb24gY29kZSB0byBzZXZlcmFsIGZpbGVzLiBBbG1vc3QgYWxsIG9mIHRoZSBmb2xsb3dpbmdcbnwgZmlsZXMgYXJlIHJlcXVpcmVkIGZvciB0aGUgYXBwbGljYXRpb24gdG8gd29yayBwcm9wZXJseS5cbnxcbiovXG5yZXF1aXJlKCcuLi9wYXJ0aWFscy9jb25maWcuanMnKTtcbnJlcXVpcmUoJy4uL3BhcnRpYWxzL2JpbmQuanMnKTtcbnJlcXVpcmUoJy4uL3BhcnRpYWxzL2RyYXdlci5qcycpO1xucmVxdWlyZSgnLi4vcGFydGlhbHMvZm9udC5qcycpO1xucmVxdWlyZSgnLi4vcGFydGlhbHMvZm9ybS5qcycpO1xucmVxdWlyZSgnLi4vcGFydGlhbHMvbWFpbGVyLmpzJyk7XG5yZXF1aXJlKCcuLi9wYXJ0aWFscy9tYXAuanMnKTtcbnJlcXVpcmUoJy4uL3BhcnRpYWxzL21vZGFsLmpzJyk7XG5yZXF1aXJlKCcuLi9wYXJ0aWFscy9uYXZiYXIuanMnKTtcbnJlcXVpcmUoJy4uL3BhcnRpYWxzL29mZmNhbnZhcy5qcycpO1xucmVxdWlyZSgnLi4vcGFydGlhbHMvcG9wdXAuanMnKTtcbnJlcXVpcmUoJy4uL3BhcnRpYWxzL3JlY2FwdGNoYS5qcycpO1xucmVxdWlyZSgnLi4vcGFydGlhbHMvc2Nyb2xsLmpzJyk7XG5yZXF1aXJlKCcuLi9wYXJ0aWFscy9zZWN0aW9uLmpzJyk7XG5yZXF1aXJlKCcuLi9wYXJ0aWFscy9zaWRlYmFyLmpzJyk7XG5yZXF1aXJlKCcuLi9wYXJ0aWFscy92aWRlby5qcycpO1xucmVxdWlyZSgnLi4vcGFydGlhbHMvdXRpbC5qcycpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/plugin/js/loaders/partials.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/bind.js":
/*!**********************************************!*\
  !*** ./resources/plugin/js/partials/bind.js ***!
  \**********************************************/
/***/ (() => {

eval("/**\n * Bind input changes to data attributes\n */\n+function ($) {\n  page.initBind = function () {\n    // Set the inner text\n    //\n    $('[data-bind-radio]').each(function () {\n      var e = $(this),\n          radio = e.data('bind-radio'),\n          value = $('input[name=\"' + radio + '\"]:checked').val();\n      e.text(e.dataAttr(value, e.text()));\n      $('input[name=\"' + radio + '\"]').on('change', function () {\n        var value = $('input[name=\"' + radio + '\"]:checked').val();\n        $('[data-bind-radio=\"' + radio + '\"]').each(function () {\n          var e = $(this);\n          e.text(e.dataAttr(value, e.text()));\n        });\n      });\n    }); // Set href attribute\n    //\n\n    $('[data-bind-href]').each(function () {\n      var e = $(this),\n          radio = e.data('bind-href'),\n          value = $('input[name=\"' + radio + '\"]:checked').val();\n      e.attr('href', e.dataAttr(value));\n      $('input[name=\"' + radio + '\"]').on('change', function () {\n        var value = $('input[name=\"' + radio + '\"]:checked').val();\n        $('[data-bind-href=\"' + radio + '\"]').each(function () {\n          var e = $(this);\n          e.attr('href', e.dataAttr(value));\n        });\n      });\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2JpbmQuanM/NDgyZSJdLCJuYW1lcyI6WyIkIiwicGFnZSIsImluaXRCaW5kIiwiZWFjaCIsImUiLCJyYWRpbyIsImRhdGEiLCJ2YWx1ZSIsInZhbCIsInRleHQiLCJkYXRhQXR0ciIsIm9uIiwiYXR0ciIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFFVkMsRUFBQUEsSUFBSSxDQUFDQyxRQUFMLEdBQWdCLFlBQVc7QUFFekI7QUFDQTtBQUNBRixJQUFBQSxDQUFDLENBQUMsbUJBQUQsQ0FBRCxDQUF1QkcsSUFBdkIsQ0FBNEIsWUFBVTtBQUNwQyxVQUFJQyxDQUFDLEdBQU9KLENBQUMsQ0FBQyxJQUFELENBQWI7QUFBQSxVQUNJSyxLQUFLLEdBQUdELENBQUMsQ0FBQ0UsSUFBRixDQUFPLFlBQVAsQ0FEWjtBQUFBLFVBRUlDLEtBQUssR0FBR1AsQ0FBQyxDQUFDLGlCQUFnQkssS0FBaEIsR0FBdUIsWUFBeEIsQ0FBRCxDQUF1Q0csR0FBdkMsRUFGWjtBQUdBSixNQUFBQSxDQUFDLENBQUNLLElBQUYsQ0FBUUwsQ0FBQyxDQUFDTSxRQUFGLENBQVdILEtBQVgsRUFBa0JILENBQUMsQ0FBQ0ssSUFBRixFQUFsQixDQUFSO0FBRUFULE1BQUFBLENBQUMsQ0FBQyxpQkFBZ0JLLEtBQWhCLEdBQXVCLElBQXhCLENBQUQsQ0FBK0JNLEVBQS9CLENBQWtDLFFBQWxDLEVBQTRDLFlBQVc7QUFDckQsWUFBSUosS0FBSyxHQUFHUCxDQUFDLENBQUMsaUJBQWdCSyxLQUFoQixHQUF1QixZQUF4QixDQUFELENBQXVDRyxHQUF2QyxFQUFaO0FBQ0FSLFFBQUFBLENBQUMsQ0FBQyx1QkFBc0JLLEtBQXRCLEdBQTZCLElBQTlCLENBQUQsQ0FBcUNGLElBQXJDLENBQTBDLFlBQVU7QUFDbEQsY0FBSUMsQ0FBQyxHQUFHSixDQUFDLENBQUMsSUFBRCxDQUFUO0FBQ0FJLFVBQUFBLENBQUMsQ0FBQ0ssSUFBRixDQUFRTCxDQUFDLENBQUNNLFFBQUYsQ0FBV0gsS0FBWCxFQUFrQkgsQ0FBQyxDQUFDSyxJQUFGLEVBQWxCLENBQVI7QUFDRCxTQUhEO0FBSUQsT0FORDtBQU9ELEtBYkQsRUFKeUIsQ0FvQnpCO0FBQ0E7O0FBQ0FULElBQUFBLENBQUMsQ0FBQyxrQkFBRCxDQUFELENBQXNCRyxJQUF0QixDQUEyQixZQUFVO0FBQ25DLFVBQUlDLENBQUMsR0FBT0osQ0FBQyxDQUFDLElBQUQsQ0FBYjtBQUFBLFVBQ0lLLEtBQUssR0FBR0QsQ0FBQyxDQUFDRSxJQUFGLENBQU8sV0FBUCxDQURaO0FBQUEsVUFFSUMsS0FBSyxHQUFHUCxDQUFDLENBQUMsaUJBQWdCSyxLQUFoQixHQUF1QixZQUF4QixDQUFELENBQXVDRyxHQUF2QyxFQUZaO0FBSUFKLE1BQUFBLENBQUMsQ0FBQ1EsSUFBRixDQUFRLE1BQVIsRUFBZ0JSLENBQUMsQ0FBQ00sUUFBRixDQUFXSCxLQUFYLENBQWhCO0FBRUFQLE1BQUFBLENBQUMsQ0FBQyxpQkFBZ0JLLEtBQWhCLEdBQXVCLElBQXhCLENBQUQsQ0FBK0JNLEVBQS9CLENBQWtDLFFBQWxDLEVBQTRDLFlBQVc7QUFDckQsWUFBSUosS0FBSyxHQUFHUCxDQUFDLENBQUMsaUJBQWdCSyxLQUFoQixHQUF1QixZQUF4QixDQUFELENBQXVDRyxHQUF2QyxFQUFaO0FBQ0FSLFFBQUFBLENBQUMsQ0FBQyxzQkFBcUJLLEtBQXJCLEdBQTRCLElBQTdCLENBQUQsQ0FBb0NGLElBQXBDLENBQXlDLFlBQVU7QUFDakQsY0FBSUMsQ0FBQyxHQUFHSixDQUFDLENBQUMsSUFBRCxDQUFUO0FBQ0FJLFVBQUFBLENBQUMsQ0FBQ1EsSUFBRixDQUFRLE1BQVIsRUFBZ0JSLENBQUMsQ0FBQ00sUUFBRixDQUFXSCxLQUFYLENBQWhCO0FBQ0QsU0FIRDtBQUlELE9BTkQ7QUFPRCxLQWREO0FBZ0JELEdBdENEO0FBd0NELENBMUNBLENBMENDTSxNQTFDRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEJpbmQgaW5wdXQgY2hhbmdlcyB0byBkYXRhIGF0dHJpYnV0ZXNcbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0QmluZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gU2V0IHRoZSBpbm5lciB0ZXh0XG4gICAgLy9cbiAgICAkKCdbZGF0YS1iaW5kLXJhZGlvXScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlICAgICA9ICQodGhpcyksXG4gICAgICAgICAgcmFkaW8gPSBlLmRhdGEoJ2JpbmQtcmFkaW8nKSxcbiAgICAgICAgICB2YWx1ZSA9ICQoJ2lucHV0W25hbWU9XCInKyByYWRpbyArJ1wiXTpjaGVja2VkJykudmFsKCk7XG4gICAgICBlLnRleHQoIGUuZGF0YUF0dHIodmFsdWUsIGUudGV4dCgpKSApO1xuXG4gICAgICAkKCdpbnB1dFtuYW1lPVwiJysgcmFkaW8gKydcIl0nKS5vbignY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9ICQoJ2lucHV0W25hbWU9XCInKyByYWRpbyArJ1wiXTpjaGVja2VkJykudmFsKCk7XG4gICAgICAgICQoJ1tkYXRhLWJpbmQtcmFkaW89XCInKyByYWRpbyArJ1wiXScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgZSA9ICQodGhpcyk7XG4gICAgICAgICAgZS50ZXh0KCBlLmRhdGFBdHRyKHZhbHVlLCBlLnRleHQoKSkgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuXG4gICAgLy8gU2V0IGhyZWYgYXR0cmlidXRlXG4gICAgLy9cbiAgICAkKCdbZGF0YS1iaW5kLWhyZWZdJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyIGUgICAgID0gJCh0aGlzKSxcbiAgICAgICAgICByYWRpbyA9IGUuZGF0YSgnYmluZC1ocmVmJyksXG4gICAgICAgICAgdmFsdWUgPSAkKCdpbnB1dFtuYW1lPVwiJysgcmFkaW8gKydcIl06Y2hlY2tlZCcpLnZhbCgpO1xuXG4gICAgICBlLmF0dHIoICdocmVmJywgZS5kYXRhQXR0cih2YWx1ZSkgKTtcblxuICAgICAgJCgnaW5wdXRbbmFtZT1cIicrIHJhZGlvICsnXCJdJykub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSAkKCdpbnB1dFtuYW1lPVwiJysgcmFkaW8gKydcIl06Y2hlY2tlZCcpLnZhbCgpO1xuICAgICAgICAkKCdbZGF0YS1iaW5kLWhyZWY9XCInKyByYWRpbyArJ1wiXScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgICAgICB2YXIgZSA9ICQodGhpcyk7XG4gICAgICAgICAgZS5hdHRyKCAnaHJlZicsIGUuZGF0YUF0dHIodmFsdWUpICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgfVxuXG59KGpRdWVyeSk7XG5cbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2JpbmQuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/bind.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/config.js":
/*!************************************************!*\
  !*** ./resources/plugin/js/partials/config.js ***!
  \************************************************/
/***/ (() => {

eval("/**\n * Config the application behaviour.\n */\n+function ($) {\n  page.config = function (options) {\n    // Return config value\n    if (typeof options === 'string') {\n      return page.defaults[options];\n    } // Save configs\n\n\n    $.extend(true, page.defaults, options); // Make necessary changes\n    //\n\n    if (!page.defaults.smoothScroll) {\n      SmoothScroll.destroy();\n    } // Google map\n    //\n\n\n    if ($('[data-provide~=\"map\"]').length && window[\"google.maps.Map\"] === undefined) {\n      $.getScript(\"https://maps.googleapis.com/maps/api/js?key=\" + page.defaults.googleApiKey + \"&callback=page.initMap\");\n    } // Google Analytics\n    //\n\n\n    if (page.defaults.googleAnalyticsId) {\n      (function (i, s, o, g, r, a, m) {\n        i['GoogleAnalyticsObject'] = r;\n        i[r] = i[r] || function () {\n          (i[r].q = i[r].q || []).push(arguments);\n        }, i[r].l = 1 * new Date();\n        a = s.createElement(o), m = s.getElementsByTagName(o)[0];\n        a.async = 1;\n        a.src = g;\n        m.parentNode.insertBefore(a, m);\n      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');\n\n      ga('create', page.defaults.googleAnalyticsId, 'auto');\n      ga('send', 'pageview');\n    } // Google reCAPTCHA\n    //\n\n\n    if ($('[data-provide~=\"recaptcha\"]').length && window[\"grecaptcha\"] === undefined) {\n      var url = \"https://www.google.com/recaptcha/api.js?onload=recaptchaLoadCallback\";\n\n      if (page.defaults.reCaptchaLanguage != '') {\n        url += '&hl=' + page.defaults.reCaptchaLanguage;\n      }\n\n      $.getScript(url);\n    } // DOM is loaded, let's init the page.\n    //\n\n\n    page.init();\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2NvbmZpZy5qcz9lMTVhIl0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiY29uZmlnIiwib3B0aW9ucyIsImRlZmF1bHRzIiwiZXh0ZW5kIiwic21vb3RoU2Nyb2xsIiwiU21vb3RoU2Nyb2xsIiwiZGVzdHJveSIsImxlbmd0aCIsIndpbmRvdyIsInVuZGVmaW5lZCIsImdldFNjcmlwdCIsImdvb2dsZUFwaUtleSIsImdvb2dsZUFuYWx5dGljc0lkIiwiaSIsInMiLCJvIiwiZyIsInIiLCJhIiwibSIsInEiLCJwdXNoIiwiYXJndW1lbnRzIiwibCIsIkRhdGUiLCJjcmVhdGVFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhc3luYyIsInNyYyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJkb2N1bWVudCIsImdhIiwidXJsIiwicmVDYXB0Y2hhTGFuZ3VhZ2UiLCJpbml0IiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLE1BQUwsR0FBYyxVQUFTQyxPQUFULEVBQWtCO0FBRTlCO0FBQ0EsUUFBSyxPQUFPQSxPQUFQLEtBQW1CLFFBQXhCLEVBQW1DO0FBQ2pDLGFBQU9GLElBQUksQ0FBQ0csUUFBTCxDQUFjRCxPQUFkLENBQVA7QUFDRCxLQUw2QixDQU85Qjs7O0FBQ0FILElBQUFBLENBQUMsQ0FBQ0ssTUFBRixDQUFTLElBQVQsRUFBZUosSUFBSSxDQUFDRyxRQUFwQixFQUE4QkQsT0FBOUIsRUFSOEIsQ0FVOUI7QUFDQTs7QUFDQSxRQUFLLENBQUVGLElBQUksQ0FBQ0csUUFBTCxDQUFjRSxZQUFyQixFQUFvQztBQUNsQ0MsTUFBQUEsWUFBWSxDQUFDQyxPQUFiO0FBQ0QsS0FkNkIsQ0FnQjlCO0FBQ0E7OztBQUNBLFFBQUtSLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCUyxNQUEzQixJQUFxQ0MsTUFBTSxDQUFDLGlCQUFELENBQU4sS0FBOEJDLFNBQXhFLEVBQW9GO0FBQ2xGWCxNQUFBQSxDQUFDLENBQUNZLFNBQUYsQ0FBWSxpREFBZ0RYLElBQUksQ0FBQ0csUUFBTCxDQUFjUyxZQUE5RCxHQUE0RSx3QkFBeEY7QUFDRCxLQXBCNkIsQ0FzQjlCO0FBQ0E7OztBQUNBLFFBQUtaLElBQUksQ0FBQ0csUUFBTCxDQUFjVSxpQkFBbkIsRUFBdUM7QUFDckMsT0FBQyxVQUFTQyxDQUFULEVBQVdDLENBQVgsRUFBYUMsQ0FBYixFQUFlQyxDQUFmLEVBQWlCQyxDQUFqQixFQUFtQkMsQ0FBbkIsRUFBcUJDLENBQXJCLEVBQXVCO0FBQUNOLFFBQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELEdBQTJCSSxDQUEzQjtBQUE2QkosUUFBQUEsQ0FBQyxDQUFDSSxDQUFELENBQUQsR0FBS0osQ0FBQyxDQUFDSSxDQUFELENBQUQsSUFBTSxZQUFVO0FBQzNFLFdBQUNKLENBQUMsQ0FBQ0ksQ0FBRCxDQUFELENBQUtHLENBQUwsR0FBT1AsQ0FBQyxDQUFDSSxDQUFELENBQUQsQ0FBS0csQ0FBTCxJQUFRLEVBQWhCLEVBQW9CQyxJQUFwQixDQUF5QkMsU0FBekI7QUFBb0MsU0FEa0IsRUFDakJULENBQUMsQ0FBQ0ksQ0FBRCxDQUFELENBQUtNLENBQUwsR0FBTyxJQUFFLElBQUlDLElBQUosRUFEUTtBQUNHTixRQUFBQSxDQUFDLEdBQUNKLENBQUMsQ0FBQ1csYUFBRixDQUFnQlYsQ0FBaEIsQ0FBRixFQUN6REksQ0FBQyxHQUFDTCxDQUFDLENBQUNZLG9CQUFGLENBQXVCWCxDQUF2QixFQUEwQixDQUExQixDQUR1RDtBQUMxQkcsUUFBQUEsQ0FBQyxDQUFDUyxLQUFGLEdBQVEsQ0FBUjtBQUFVVCxRQUFBQSxDQUFDLENBQUNVLEdBQUYsR0FBTVosQ0FBTjtBQUFRRyxRQUFBQSxDQUFDLENBQUNVLFVBQUYsQ0FBYUMsWUFBYixDQUEwQlosQ0FBMUIsRUFBNEJDLENBQTVCO0FBQ2hELE9BSEQsRUFHR1gsTUFISCxFQUdVdUIsUUFIVixFQUdtQixRQUhuQixFQUc0QiwrQ0FINUIsRUFHNEUsSUFINUU7O0FBS0FDLE1BQUFBLEVBQUUsQ0FBQyxRQUFELEVBQVdqQyxJQUFJLENBQUNHLFFBQUwsQ0FBY1UsaUJBQXpCLEVBQTRDLE1BQTVDLENBQUY7QUFDQW9CLE1BQUFBLEVBQUUsQ0FBQyxNQUFELEVBQVMsVUFBVCxDQUFGO0FBQ0QsS0FoQzZCLENBbUM5QjtBQUNBOzs7QUFDQSxRQUFLbEMsQ0FBQyxDQUFDLDZCQUFELENBQUQsQ0FBaUNTLE1BQWpDLElBQTJDQyxNQUFNLENBQUMsWUFBRCxDQUFOLEtBQXlCQyxTQUF6RSxFQUFxRjtBQUNuRixVQUFJd0IsR0FBRyxHQUFHLHNFQUFWOztBQUNBLFVBQUtsQyxJQUFJLENBQUNHLFFBQUwsQ0FBY2dDLGlCQUFkLElBQW1DLEVBQXhDLEVBQTZDO0FBQzNDRCxRQUFBQSxHQUFHLElBQUksU0FBU2xDLElBQUksQ0FBQ0csUUFBTCxDQUFjZ0MsaUJBQTlCO0FBQ0Q7O0FBQ0RwQyxNQUFBQSxDQUFDLENBQUNZLFNBQUYsQ0FBWXVCLEdBQVo7QUFDRCxLQTNDNkIsQ0E2QzlCO0FBQ0E7OztBQUNBbEMsSUFBQUEsSUFBSSxDQUFDb0MsSUFBTDtBQUVELEdBakREO0FBbURELENBckRBLENBcURDQyxNQXJERCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIENvbmZpZyB0aGUgYXBwbGljYXRpb24gYmVoYXZpb3VyLlxuICovXG5cbitmdW5jdGlvbigkKXtcblxuICBwYWdlLmNvbmZpZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblxuICAgIC8vIFJldHVybiBjb25maWcgdmFsdWVcbiAgICBpZiAoIHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJyApIHtcbiAgICAgIHJldHVybiBwYWdlLmRlZmF1bHRzW29wdGlvbnNdO1xuICAgIH1cblxuICAgIC8vIFNhdmUgY29uZmlnc1xuICAgICQuZXh0ZW5kKHRydWUsIHBhZ2UuZGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gTWFrZSBuZWNlc3NhcnkgY2hhbmdlc1xuICAgIC8vXG4gICAgaWYgKCAhIHBhZ2UuZGVmYXVsdHMuc21vb3RoU2Nyb2xsICkge1xuICAgICAgU21vb3RoU2Nyb2xsLmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICAvLyBHb29nbGUgbWFwXG4gICAgLy9cbiAgICBpZiAoICQoJ1tkYXRhLXByb3ZpZGV+PVwibWFwXCJdJykubGVuZ3RoICYmIHdpbmRvd1tcImdvb2dsZS5tYXBzLk1hcFwiXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgJC5nZXRTY3JpcHQoXCJodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvanM/a2V5PVwiKyBwYWdlLmRlZmF1bHRzLmdvb2dsZUFwaUtleSArXCImY2FsbGJhY2s9cGFnZS5pbml0TWFwXCIpO1xuICAgIH1cblxuICAgIC8vIEdvb2dsZSBBbmFseXRpY3NcbiAgICAvL1xuICAgIGlmICggcGFnZS5kZWZhdWx0cy5nb29nbGVBbmFseXRpY3NJZCApIHtcbiAgICAgIChmdW5jdGlvbihpLHMsbyxnLHIsYSxtKXtpWydHb29nbGVBbmFseXRpY3NPYmplY3QnXT1yO2lbcl09aVtyXXx8ZnVuY3Rpb24oKXtcbiAgICAgIChpW3JdLnE9aVtyXS5xfHxbXSkucHVzaChhcmd1bWVudHMpfSxpW3JdLmw9MSpuZXcgRGF0ZSgpO2E9cy5jcmVhdGVFbGVtZW50KG8pLFxuICAgICAgbT1zLmdldEVsZW1lbnRzQnlUYWdOYW1lKG8pWzBdO2EuYXN5bmM9MTthLnNyYz1nO20ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSxtKVxuICAgICAgfSkod2luZG93LGRvY3VtZW50LCdzY3JpcHQnLCdodHRwczovL3d3dy5nb29nbGUtYW5hbHl0aWNzLmNvbS9hbmFseXRpY3MuanMnLCdnYScpO1xuXG4gICAgICBnYSgnY3JlYXRlJywgcGFnZS5kZWZhdWx0cy5nb29nbGVBbmFseXRpY3NJZCwgJ2F1dG8nKTtcbiAgICAgIGdhKCdzZW5kJywgJ3BhZ2V2aWV3Jyk7XG4gICAgfVxuXG5cbiAgICAvLyBHb29nbGUgcmVDQVBUQ0hBXG4gICAgLy9cbiAgICBpZiAoICQoJ1tkYXRhLXByb3ZpZGV+PVwicmVjYXB0Y2hhXCJdJykubGVuZ3RoICYmIHdpbmRvd1tcImdyZWNhcHRjaGFcIl0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgIHZhciB1cmwgPSBcImh0dHBzOi8vd3d3Lmdvb2dsZS5jb20vcmVjYXB0Y2hhL2FwaS5qcz9vbmxvYWQ9cmVjYXB0Y2hhTG9hZENhbGxiYWNrXCI7XG4gICAgICBpZiAoIHBhZ2UuZGVmYXVsdHMucmVDYXB0Y2hhTGFuZ3VhZ2UgIT0gJycgKSB7XG4gICAgICAgIHVybCArPSAnJmhsPScgKyBwYWdlLmRlZmF1bHRzLnJlQ2FwdGNoYUxhbmd1YWdlO1xuICAgICAgfVxuICAgICAgJC5nZXRTY3JpcHQodXJsKTtcbiAgICB9XG5cbiAgICAvLyBET00gaXMgbG9hZGVkLCBsZXQncyBpbml0IHRoZSBwYWdlLlxuICAgIC8vXG4gICAgcGFnZS5pbml0KCk7XG5cbiAgfVxuXG59KGpRdWVyeSk7XG5cblxuXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9jb25maWcuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/config.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/drawer.js":
/*!************************************************!*\
  !*** ./resources/plugin/js/partials/drawer.js ***!
  \************************************************/
/***/ (() => {

eval("/**\n *\n */\n+function ($) {\n  page.initDrawer = function () {\n    $(document).on('click', '.drawer-toggler, .drawer-close, .backdrop-drawer', function () {\n      $('body').toggleClass('drawer-open');\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2RyYXdlci5qcz85N2E1Il0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiaW5pdERyYXdlciIsImRvY3VtZW50Iiwib24iLCJ0b2dnbGVDbGFzcyIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFFVkMsRUFBQUEsSUFBSSxDQUFDQyxVQUFMLEdBQWtCLFlBQVc7QUFFM0JGLElBQUFBLENBQUMsQ0FBQ0csUUFBRCxDQUFELENBQVlDLEVBQVosQ0FBZ0IsT0FBaEIsRUFBeUIsa0RBQXpCLEVBQTZFLFlBQVc7QUFDdEZKLE1BQUFBLENBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVUssV0FBVixDQUF1QixhQUF2QjtBQUNELEtBRkQ7QUFJRCxHQU5EO0FBUUQsQ0FWQSxDQVVDQyxNQVZELENBQUQiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICpcbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0RHJhd2VyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAkKGRvY3VtZW50KS5vbiggJ2NsaWNrJywgJy5kcmF3ZXItdG9nZ2xlciwgLmRyYXdlci1jbG9zZSwgLmJhY2tkcm9wLWRyYXdlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgJCgnYm9keScpLnRvZ2dsZUNsYXNzKCAnZHJhd2VyLW9wZW4nICk7XG4gICAgfSk7XG5cbiAgfVxuXG59KGpRdWVyeSk7XG5cbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2RyYXdlci5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/drawer.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/font.js":
/*!**********************************************!*\
  !*** ./resources/plugin/js/partials/font.js ***!
  \**********************************************/
/***/ (() => {

eval("/**\n *\n */\n+function ($) {\n  page.initFont = function () {\n    var fonts = [];\n    $('[data-font]').each(function () {\n      var tag = $(this),\n          font = tag.data('font');\n      part = font.split(':');\n      fonts.push(font);\n      tag.css({\n        'font-family': part[0],\n        'font-weight': part[1]\n      });\n    });\n\n    if (fonts.length > 0) {\n      $(\"head\").append(\"<link href='https://fonts.googleapis.com/css?family=\" + fonts.join('|') + \"' rel='stylesheet'>\");\n    }\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2ZvbnQuanM/NjAwMiJdLCJuYW1lcyI6WyIkIiwicGFnZSIsImluaXRGb250IiwiZm9udHMiLCJlYWNoIiwidGFnIiwiZm9udCIsImRhdGEiLCJwYXJ0Iiwic3BsaXQiLCJwdXNoIiwiY3NzIiwibGVuZ3RoIiwiYXBwZW5kIiwiam9pbiIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFFVkMsRUFBQUEsSUFBSSxDQUFDQyxRQUFMLEdBQWdCLFlBQVc7QUFFekIsUUFBSUMsS0FBSyxHQUFHLEVBQVo7QUFFQUgsSUFBQUEsQ0FBQyxDQUFDLGFBQUQsQ0FBRCxDQUFpQkksSUFBakIsQ0FBc0IsWUFBVTtBQUM5QixVQUFJQyxHQUFHLEdBQUlMLENBQUMsQ0FBQyxJQUFELENBQVo7QUFBQSxVQUNJTSxJQUFJLEdBQUdELEdBQUcsQ0FBQ0UsSUFBSixDQUFTLE1BQVQsQ0FEWDtBQUVJQyxNQUFBQSxJQUFJLEdBQUdGLElBQUksQ0FBQ0csS0FBTCxDQUFXLEdBQVgsQ0FBUDtBQUVKTixNQUFBQSxLQUFLLENBQUNPLElBQU4sQ0FBV0osSUFBWDtBQUNBRCxNQUFBQSxHQUFHLENBQUNNLEdBQUosQ0FBUTtBQUFDLHVCQUFlSCxJQUFJLENBQUMsQ0FBRCxDQUFwQjtBQUF5Qix1QkFBZUEsSUFBSSxDQUFDLENBQUQ7QUFBNUMsT0FBUjtBQUNELEtBUEQ7O0FBU0EsUUFBSUwsS0FBSyxDQUFDUyxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDcEJaLE1BQUFBLENBQUMsQ0FBQyxNQUFELENBQUQsQ0FBVWEsTUFBVixDQUFpQix5REFBeURWLEtBQUssQ0FBQ1csSUFBTixDQUFXLEdBQVgsQ0FBekQsR0FBMkUscUJBQTVGO0FBQ0Q7QUFFRixHQWpCRDtBQW1CRCxDQXJCQSxDQXFCQ0MsTUFyQkQsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKlxuICovXG5cbitmdW5jdGlvbigkKXtcblxuICBwYWdlLmluaXRGb250ID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgZm9udHMgPSBbXTtcblxuICAgICQoJ1tkYXRhLWZvbnRdJykuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyIHRhZyAgPSAkKHRoaXMpLFxuICAgICAgICAgIGZvbnQgPSB0YWcuZGF0YSgnZm9udCcpXG4gICAgICAgICAgcGFydCA9IGZvbnQuc3BsaXQoJzonKTtcblxuICAgICAgZm9udHMucHVzaChmb250KTtcbiAgICAgIHRhZy5jc3Moeydmb250LWZhbWlseSc6IHBhcnRbMF0sICdmb250LXdlaWdodCc6IHBhcnRbMV19KTtcbiAgICB9KTtcblxuICAgIGlmIChmb250cy5sZW5ndGggPiAwKSB7XG4gICAgICAkKFwiaGVhZFwiKS5hcHBlbmQoXCI8bGluayBocmVmPSdodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9XCIgKyBmb250cy5qb2luKCd8JykgKyBcIicgcmVsPSdzdHlsZXNoZWV0Jz5cIik7XG4gICAgfVxuXG4gIH1cblxufShqUXVlcnkpO1xuXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9mb250LmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/font.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/form.js":
/*!**********************************************!*\
  !*** ./resources/plugin/js/partials/form.js ***!
  \**********************************************/
/***/ (() => {

eval("/**\n * All the form related methods.\n */\n+function ($) {\n  page.initForm = function () {\n    /**\n     * Add/remove .focus to .input-group\n     */\n    $(document).on('focusin', '.input-group', function () {\n      $(this).addClass('focus');\n    });\n    $(document).on('focusout', '.input-group', function () {\n      $(this).removeClass('focus');\n    }); // Switch\n    //\n\n    $(document).on('click', '.switch', function () {\n      var input = $(this).children('.switch-input').not(':disabled');\n      input.prop('checked', !input.prop('checked')).trigger(\"change\");\n    }); // Upload\n    //\n\n    $(document).on('click', '.file-browser', function () {\n      var browser = $(this);\n      var file = browser.closest('.file-group').find('[type=\"file\"]');\n\n      if (browser.hasClass('form-control')) {\n        setTimeout(function () {\n          file.trigger('click');\n        }, 300);\n      } else {\n        file.trigger('click');\n      }\n    }); // Event to change file name after file selection\n\n    $(document).on('change', '.file-group [type=\"file\"]', function () {\n      var input = $(this);\n      var filename = input.val().split('\\\\').pop();\n      input.closest('.file-group').find('.file-value').val(filename).text(filename).focus();\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL2Zvcm0uanM/OGU3NSJdLCJuYW1lcyI6WyIkIiwicGFnZSIsImluaXRGb3JtIiwiZG9jdW1lbnQiLCJvbiIsImFkZENsYXNzIiwicmVtb3ZlQ2xhc3MiLCJpbnB1dCIsImNoaWxkcmVuIiwibm90IiwicHJvcCIsInRyaWdnZXIiLCJicm93c2VyIiwiZmlsZSIsImNsb3Nlc3QiLCJmaW5kIiwiaGFzQ2xhc3MiLCJzZXRUaW1lb3V0IiwiZmlsZW5hbWUiLCJ2YWwiLCJzcGxpdCIsInBvcCIsInRleHQiLCJmb2N1cyIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFFVkMsRUFBQUEsSUFBSSxDQUFDQyxRQUFMLEdBQWdCLFlBQVc7QUFHekI7QUFDSjtBQUNBO0FBQ0lGLElBQUFBLENBQUMsQ0FBQ0csUUFBRCxDQUFELENBQVlDLEVBQVosQ0FBZSxTQUFmLEVBQTBCLGNBQTFCLEVBQTBDLFlBQVc7QUFDbkRKLE1BQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUUssUUFBUixDQUFpQixPQUFqQjtBQUNELEtBRkQ7QUFJQUwsSUFBQUEsQ0FBQyxDQUFDRyxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLFVBQWYsRUFBMkIsY0FBM0IsRUFBMkMsWUFBVztBQUNwREosTUFBQUEsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRTSxXQUFSLENBQW9CLE9BQXBCO0FBQ0QsS0FGRCxFQVZ5QixDQWV6QjtBQUNBOztBQUNBTixJQUFBQSxDQUFDLENBQUNHLFFBQUQsQ0FBRCxDQUFZQyxFQUFaLENBQWUsT0FBZixFQUF3QixTQUF4QixFQUFtQyxZQUFXO0FBQzVDLFVBQUlHLEtBQUssR0FBR1AsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRUSxRQUFSLENBQWlCLGVBQWpCLEVBQWtDQyxHQUFsQyxDQUFzQyxXQUF0QyxDQUFaO0FBQ0FGLE1BQUFBLEtBQUssQ0FBQ0csSUFBTixDQUFXLFNBQVgsRUFBc0IsQ0FBRUgsS0FBSyxDQUFDRyxJQUFOLENBQVcsU0FBWCxDQUF4QixFQUErQ0MsT0FBL0MsQ0FBdUQsUUFBdkQ7QUFDRCxLQUhELEVBakJ5QixDQXVCekI7QUFDQTs7QUFDQVgsSUFBQUEsQ0FBQyxDQUFDRyxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLE9BQWYsRUFBd0IsZUFBeEIsRUFBeUMsWUFBVztBQUNsRCxVQUFJUSxPQUFPLEdBQUdaLENBQUMsQ0FBQyxJQUFELENBQWY7QUFDQSxVQUFJYSxJQUFJLEdBQUdELE9BQU8sQ0FBQ0UsT0FBUixDQUFnQixhQUFoQixFQUErQkMsSUFBL0IsQ0FBb0MsZUFBcEMsQ0FBWDs7QUFDQSxVQUFLSCxPQUFPLENBQUNJLFFBQVIsQ0FBaUIsY0FBakIsQ0FBTCxFQUF3QztBQUN0Q0MsUUFBQUEsVUFBVSxDQUFDLFlBQVU7QUFDbkJKLFVBQUFBLElBQUksQ0FBQ0YsT0FBTCxDQUFhLE9BQWI7QUFDRCxTQUZTLEVBRVIsR0FGUSxDQUFWO0FBR0QsT0FKRCxNQUtLO0FBQ0hFLFFBQUFBLElBQUksQ0FBQ0YsT0FBTCxDQUFhLE9BQWI7QUFDRDtBQUNGLEtBWEQsRUF6QnlCLENBc0N6Qjs7QUFDQVgsSUFBQUEsQ0FBQyxDQUFDRyxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLFFBQWYsRUFBeUIsMkJBQXpCLEVBQXNELFlBQVU7QUFDOUQsVUFBSUcsS0FBSyxHQUFHUCxDQUFDLENBQUMsSUFBRCxDQUFiO0FBQ0EsVUFBSWtCLFFBQVEsR0FBR1gsS0FBSyxDQUFDWSxHQUFOLEdBQVlDLEtBQVosQ0FBa0IsSUFBbEIsRUFBd0JDLEdBQXhCLEVBQWY7QUFDQWQsTUFBQUEsS0FBSyxDQUFDTyxPQUFOLENBQWMsYUFBZCxFQUE2QkMsSUFBN0IsQ0FBa0MsYUFBbEMsRUFBaURJLEdBQWpELENBQXFERCxRQUFyRCxFQUErREksSUFBL0QsQ0FBb0VKLFFBQXBFLEVBQThFSyxLQUE5RTtBQUNELEtBSkQ7QUFPRCxHQTlDRDtBQWdERCxDQWxEQSxDQWtEQ0MsTUFsREQsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBBbGwgdGhlIGZvcm0gcmVsYXRlZCBtZXRob2RzLlxuICovXG5cbitmdW5jdGlvbigkKXtcblxuICBwYWdlLmluaXRGb3JtID0gZnVuY3Rpb24oKSB7XG5cblxuICAgIC8qKlxuICAgICAqIEFkZC9yZW1vdmUgLmZvY3VzIHRvIC5pbnB1dC1ncm91cFxuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLm9uKCdmb2N1c2luJywgJy5pbnB1dC1ncm91cCcsIGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS5hZGRDbGFzcygnZm9jdXMnKTtcbiAgICB9KTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCdmb2N1c291dCcsICcuaW5wdXQtZ3JvdXAnLCBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2ZvY3VzJyk7XG4gICAgfSk7XG5cblxuICAgIC8vIFN3aXRjaFxuICAgIC8vXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5zd2l0Y2gnLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dCA9ICQodGhpcykuY2hpbGRyZW4oJy5zd2l0Y2gtaW5wdXQnKS5ub3QoJzpkaXNhYmxlZCcpO1xuICAgICAgaW5wdXQucHJvcCgnY2hlY2tlZCcsICEgaW5wdXQucHJvcCgnY2hlY2tlZCcpKS50cmlnZ2VyKFwiY2hhbmdlXCIpO1xuICAgIH0pO1xuXG5cbiAgICAvLyBVcGxvYWRcbiAgICAvL1xuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcuZmlsZS1icm93c2VyJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYnJvd3NlciA9ICQodGhpcyk7XG4gICAgICB2YXIgZmlsZSA9IGJyb3dzZXIuY2xvc2VzdCgnLmZpbGUtZ3JvdXAnKS5maW5kKCdbdHlwZT1cImZpbGVcIl0nKTtcbiAgICAgIGlmICggYnJvd3Nlci5oYXNDbGFzcygnZm9ybS1jb250cm9sJykgKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBmaWxlLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICAgIH0sMzAwKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBmaWxlLnRyaWdnZXIoJ2NsaWNrJyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFdmVudCB0byBjaGFuZ2UgZmlsZSBuYW1lIGFmdGVyIGZpbGUgc2VsZWN0aW9uXG4gICAgJChkb2N1bWVudCkub24oJ2NoYW5nZScsICcuZmlsZS1ncm91cCBbdHlwZT1cImZpbGVcIl0nLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKTtcbiAgICAgIHZhciBmaWxlbmFtZSA9IGlucHV0LnZhbCgpLnNwbGl0KCdcXFxcJykucG9wKCk7XG4gICAgICBpbnB1dC5jbG9zZXN0KCcuZmlsZS1ncm91cCcpLmZpbmQoJy5maWxlLXZhbHVlJykudmFsKGZpbGVuYW1lKS50ZXh0KGZpbGVuYW1lKS5mb2N1cygpO1xuICAgIH0pO1xuXG5cbiAgfVxuXG59KGpRdWVyeSk7XG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9mb3JtLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/form.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/mailer.js":
/*!************************************************!*\
  !*** ./resources/plugin/js/partials/mailer.js ***!
  \************************************************/
/***/ (() => {

eval("/**\n * Send a form details to the sendmail.php file.\n */\n+function ($) {\n  page.initMailer = function () {\n    var validEmail = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n    $('[data-form=\"mailer\"]').each(function () {\n      var form = $(this),\n          email = form.find('[name=\"email\"]'),\n          message = form.find('[name=\"message\"]'),\n          onSuccess = form.dataAttr('on-success', null),\n          onError = form.dataAttr('on-error', null);\n      form.on('submit', function (e) {\n        e.preventDefault();\n        e.stopPropagation();\n        form.children('.alert-danger').remove();\n        form.find('[required]').each(function () {\n          if ($(this).val().length < 1) {\n            $(this).addClass('is-invalid');\n          } else {\n            $(this).removeClass('is-invalid');\n          }\n        });\n        form.find('[type=\"email\"]').each(function () {\n          if (!validEmail.test($(this).val())) {\n            $(this).addClass('is-invalid');\n          } else {\n            $(this).removeClass('is-invalid');\n          }\n        });\n\n        if (email.length) {\n          if (email.val().length < 1 || !validEmail.test(email.val())) {\n            email.addClass('is-invalid'); //return false;\n          }\n        }\n\n        if (message.length) {\n          if (message.val().length < 1) {\n            message.addClass('is-invalid'); //return false;\n          }\n        }\n\n        if (form.find('.is-invalid').length) {\n          return false;\n        }\n\n        $.ajax({\n          type: \"POST\",\n          url: form.attr('action'),\n          data: form.serializeArray()\n        }).done(function (data) {\n          var response = $.parseJSON(data);\n\n          if ('success' == response.status) {\n            form.find('.alert-success').fadeIn(1000);\n            form.find(':input').val('');\n\n            if (onSuccess !== null) {\n              window[onSuccess]();\n            }\n          } else {\n            form.prepend('<div class=\"alert alert-danger\">' + response.message + '</div>');\n            console.log(response.reason);\n\n            if (onError !== null) {\n              window[onError](response.reason);\n            }\n          }\n        });\n        return false;\n      });\n      form.find('[required], [type=\"email\"]').each(function () {\n        $(this).on('focus', function () {\n          $(this).removeClass('is-invalid');\n        });\n      });\n      email.on('focus', function () {\n        $(this).removeClass('is-invalid');\n      });\n      message.on('focus', function () {\n        $(this).removeClass('is-invalid');\n      });\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21haWxlci5qcz81YWFhIl0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiaW5pdE1haWxlciIsInZhbGlkRW1haWwiLCJlYWNoIiwiZm9ybSIsImVtYWlsIiwiZmluZCIsIm1lc3NhZ2UiLCJvblN1Y2Nlc3MiLCJkYXRhQXR0ciIsIm9uRXJyb3IiLCJvbiIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImNoaWxkcmVuIiwicmVtb3ZlIiwidmFsIiwibGVuZ3RoIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInRlc3QiLCJhamF4IiwidHlwZSIsInVybCIsImF0dHIiLCJkYXRhIiwic2VyaWFsaXplQXJyYXkiLCJkb25lIiwicmVzcG9uc2UiLCJwYXJzZUpTT04iLCJzdGF0dXMiLCJmYWRlSW4iLCJ3aW5kb3ciLCJwcmVwZW5kIiwiY29uc29sZSIsImxvZyIsInJlYXNvbiIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFFVkMsRUFBQUEsSUFBSSxDQUFDQyxVQUFMLEdBQWtCLFlBQVc7QUFFM0IsUUFBSUMsVUFBVSxHQUFHLHdKQUFqQjtBQUVBSCxJQUFBQSxDQUFDLENBQUMsc0JBQUQsQ0FBRCxDQUEwQkksSUFBMUIsQ0FBK0IsWUFBVztBQUV4QyxVQUFJQyxJQUFJLEdBQVFMLENBQUMsQ0FBQyxJQUFELENBQWpCO0FBQUEsVUFDSU0sS0FBSyxHQUFPRCxJQUFJLENBQUNFLElBQUwsQ0FBVSxnQkFBVixDQURoQjtBQUFBLFVBRUlDLE9BQU8sR0FBS0gsSUFBSSxDQUFDRSxJQUFMLENBQVUsa0JBQVYsQ0FGaEI7QUFBQSxVQUdJRSxTQUFTLEdBQUdKLElBQUksQ0FBQ0ssUUFBTCxDQUFjLFlBQWQsRUFBNEIsSUFBNUIsQ0FIaEI7QUFBQSxVQUlJQyxPQUFPLEdBQUtOLElBQUksQ0FBQ0ssUUFB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QUN0QixPQUE3QyxHQUFzRCxRQUFuRTtBQUNBNEIsWUFBQUEsT0FBTyxDQUFDQyxHQUFSLENBQWFQLFFBQVEsQ0FBQ1EsTUFBdEI7O0FBQ0EsZ0JBQUszQixPQUFPLEtBQUssSUFBakIsRUFBd0I7QUFDdEJ1QixjQUFBQSxNQUFNLENBQUN2QixPQUFELENBQU4sQ0FBZ0JtQixRQUFRLENBQUNRLE1BQXpCO0FBQ0Q7QUFDRjtBQUNGLFNBckJEO0FBdUJBLGVBQU8sS0FBUDtBQUNELE9BckVEO0FBd0VBakMsTUFBQUEsSUFBSSxDQUFDRSxJQUFMLENBQVUsNEJBQVYsRUFBd0NILElBQXhDLENBQTZDLFlBQVc7QUFDdERKLFFBQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUVksRUFBUixDQUFXLE9BQVgsRUFBb0IsWUFBVztBQUM3QlosVUFBQUEsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRcUIsV0FBUixDQUFvQixZQUFwQjtBQUNELFNBRkQ7QUFHRCxPQUpEO0FBT0FmLE1BQUFBLEtBQUssQ0FBQ00sRUFBTixDQUFTLE9BQVQsRUFBa0IsWUFBVztBQUMzQlosUUFBQUEsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRcUIsV0FBUixDQUFvQixZQUFwQjtBQUNELE9BRkQ7QUFJQWIsTUFBQUEsT0FBTyxDQUFDSSxFQUFSLENBQVcsT0FBWCxFQUFvQixZQUFXO0FBQzdCWixRQUFBQSxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFxQixXQUFSLENBQW9CLFlBQXBCO0FBQ0QsT0FGRDtBQUlELEtBL0ZEO0FBaUdELEdBckdEO0FBdUdELENBekdBLENBeUdDa0IsTUF6R0QsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBTZW5kIGEgZm9ybSBkZXRhaWxzIHRvIHRoZSBzZW5kbWFpbC5waHAgZmlsZS5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0TWFpbGVyID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgdmFsaWRFbWFpbCA9IC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvO1xuXG4gICAgJCgnW2RhdGEtZm9ybT1cIm1haWxlclwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBmb3JtICAgICAgPSAkKHRoaXMpLFxuICAgICAgICAgIGVtYWlsICAgICA9IGZvcm0uZmluZCgnW25hbWU9XCJlbWFpbFwiXScpLFxuICAgICAgICAgIG1lc3NhZ2UgICA9IGZvcm0uZmluZCgnW25hbWU9XCJtZXNzYWdlXCJdJyksXG4gICAgICAgICAgb25TdWNjZXNzID0gZm9ybS5kYXRhQXR0cignb24tc3VjY2VzcycsIG51bGwpLFxuICAgICAgICAgIG9uRXJyb3IgICA9IGZvcm0uZGF0YUF0dHIoJ29uLWVycm9yJywgbnVsbCk7XG5cbiAgICAgIGZvcm0ub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIGZvcm0uY2hpbGRyZW4oJy5hbGVydC1kYW5nZXInKS5yZW1vdmUoKTtcblxuICAgICAgICBmb3JtLmZpbmQoJ1tyZXF1aXJlZF0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggJCh0aGlzKS52YWwoKS5sZW5ndGggPCAxICkge1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2lzLWludmFsaWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZvcm0uZmluZCgnW3R5cGU9XCJlbWFpbFwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKCAhIHZhbGlkRW1haWwudGVzdCggJCh0aGlzKS52YWwoKSApICkge1xuICAgICAgICAgICAgJCh0aGlzKS5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2lzLWludmFsaWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICBpZiAoIGVtYWlsLmxlbmd0aCApIHtcbiAgICAgICAgICBpZiAoIGVtYWlsLnZhbCgpLmxlbmd0aCA8IDEgfHwgISB2YWxpZEVtYWlsLnRlc3QoIGVtYWlsLnZhbCgpICkgKSB7XG4gICAgICAgICAgICBlbWFpbC5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xuICAgICAgICAgICAgLy9yZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBpZiAoIG1lc3NhZ2UubGVuZ3RoICkge1xuICAgICAgICAgIGlmICggbWVzc2FnZS52YWwoKS5sZW5ndGggPCAxICkge1xuICAgICAgICAgICAgbWVzc2FnZS5hZGRDbGFzcygnaXMtaW52YWxpZCcpO1xuICAgICAgICAgICAgLy9yZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZvcm0uZmluZCgnLmlzLWludmFsaWQnKS5sZW5ndGgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICAgIHVybDogZm9ybS5hdHRyKCdhY3Rpb24nKSxcbiAgICAgICAgICBkYXRhOiBmb3JtLnNlcmlhbGl6ZUFycmF5KCksXG4gICAgICAgIH0pXG4gICAgICAgIC5kb25lKCBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICB2YXIgcmVzcG9uc2UgPSAkLnBhcnNlSlNPTiggZGF0YSApO1xuICAgICAgICAgIGlmICggJ3N1Y2Nlc3MnID09IHJlc3BvbnNlLnN0YXR1cyApIHtcbiAgICAgICAgICAgIGZvcm0uZmluZCgnLmFsZXJ0LXN1Y2Nlc3MnKS5mYWRlSW4oMTAwMCk7XG4gICAgICAgICAgICBmb3JtLmZpbmQoJzppbnB1dCcpLnZhbCgnJyk7XG4gICAgICAgICAgICBpZiAoIG9uU3VjY2VzcyAhPT0gbnVsbCApIHtcbiAgICAgICAgICAgICAgd2luZG93W29uU3VjY2Vzc10oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtLnByZXBlbmQoJzxkaXYgY2xhc3M9XCJhbGVydCBhbGVydC1kYW5nZXJcIj4nKyByZXNwb25zZS5tZXNzYWdlICsnPC9kaXY+Jyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyggcmVzcG9uc2UucmVhc29uICk7XG4gICAgICAgICAgICBpZiAoIG9uRXJyb3IgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgIHdpbmRvd1tvbkVycm9yXShyZXNwb25zZS5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG5cblxuICAgICAgZm9ybS5maW5kKCdbcmVxdWlyZWRdLCBbdHlwZT1cImVtYWlsXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgJCh0aGlzKS5vbignZm9jdXMnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdpcy1pbnZhbGlkJyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cblxuICAgICAgZW1haWwub24oJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICQodGhpcykucmVtb3ZlQ2xhc3MoJ2lzLWludmFsaWQnKTtcbiAgICAgIH0pO1xuXG4gICAgICBtZXNzYWdlLm9uKCdmb2N1cycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKHRoaXMpLnJlbW92ZUNsYXNzKCdpcy1pbnZhbGlkJyk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuXG4gIH1cblxufShqUXVlcnkpO1xuXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9tYWlsZXIuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/mailer.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/main.js":
/*!**********************************************!*\
  !*** ./resources/plugin/js/partials/main.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Load required plugins.\n */\nwindow.$ = window.jQuery = __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\");\nwindow.Popper = __webpack_require__(/*! popper.js/dist/umd/popper */ \"./node_modules/popper.js/dist/umd/popper.js\");\n\n__webpack_require__(/*! bootstrap */ \"./node_modules/bootstrap/dist/js/bootstrap.js\");\n\nwindow.SmoothScroll = __webpack_require__(/*! smoothscroll-for-websites */ \"./node_modules/smoothscroll-for-websites/SmoothScroll.js\");\n\n__webpack_require__(/*! objectFitPolyfill */ \"./node_modules/objectFitPolyfill/dist/objectFitPolyfill.min.js\");\n/**\n * Create window.page and init the application.\n */\n\n\n+function ($, window) {\n  var page = {\n    name: 'CustomFramework',\n    version: '2.0.0',\n    vendors: [],\n    // Cache popular elements\n    body: $('body'),\n    navbar: $('.navbar'),\n    header: $('.header'),\n    footer: $('.footer')\n  };\n  page.defaults = {\n    googleApiKey: null,\n    googleAnalyticsKey: null,\n    reCaptchaSiteKey: null,\n    reCaptchaLanguage: null,\n    disableAOSonMobile: true,\n    smoothScroll: false\n  };\n  /**\n   * Call all the required initializers.\n   */\n\n  page.init = function () {\n    // Vendors\n    //\n    page.initVendors(); // Partials\n    //\n\n    page.initBind();\n    page.initDrawer();\n    page.initFont();\n    page.initForm();\n    page.initMailer();\n    page.initModal();\n    page.initNavbar();\n    page.initOffcanvas();\n    page.initPopup();\n    page.initScroll();\n    page.initSection();\n    page.initSidebar();\n    page.initVideo(); // Anchor for headings\n    //\n\n    $('[data-provide=\"anchor\"]').each(function () {\n      var heading = $(this);\n      heading.append('<a class=\"anchor\" href=\"#' + heading.attr('id') + '\"></a>');\n    });\n  };\n  /**\n   * Initialize all of the loaded vendors.\n   */\n\n\n  page.initVendors = function () {\n    page.vendors.forEach(function (vendor) {\n      var fn = window.page['init' + vendor];\n\n      if (typeof fn === 'function') {\n        fn();\n      }\n    });\n  };\n  /**\n   * Register loaded vendor to be initialized after DOM load.\n   * It's case sensitive, since it calls \"initVendorName\" method.\n   */\n\n\n  page.registerVendor = function ($name) {\n    page.vendors.push($name);\n  };\n\n  window.page = page;\n}(jQuery, window);\n/**\n * Once the DOM is loaded, start the magic.\n */\n\n$(function () {//page.init();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21haW4uanM/M2M3YiJdLCJuYW1lcyI6WyJ3aW5kb3ciLCIkIiwialF1ZXJ5IiwicmVxdWlyZSIsIlBvcHBlciIsIlNtb290aFNjcm9sbCIsInBhZ2UiLCJuYW1lIiwidmVyc2lvbiIsInZlbmRvcnMiLCJib2R5IiwibmF2YmFyIiwiaGVhZGVyIiwiZm9vdGVyIiwiZGVmYXVsdHMiLCJnb29nbGVBcGlLZXkiLCJnb29nbGVBbmFseXRpY3NLZXkiLCJyZUNhcHRjaGFTaXRlS2V5IiwicmVDYXB0Y2hhTGFuZ3VhZ2UiLCJkaXNhYmxlQU9Tb25Nb2JpbGUiLCJzbW9vdGhTY3JvbGwiLCJpbml0IiwiaW5pdFZlbmRvcnMiLCJpbml0QmluZCIsImluaXREcmF3ZXIiLCJpbml0Rm9udCIsImluaXRGb3JtIiwiaW5pdE1haWxlciIsImluaXRNb2RhbCIsImluaXROYXZiYXIiLCJpbml0T2ZmY2FudmFzIiwiaW5pdFBvcHVwIiwiaW5pdFNjcm9sbCIsImluaXRTZWN0aW9uIiwiaW5pdFNpZGViYXIiLCJpbml0VmlkZW8iLCJlYWNoIiwiaGVhZGluZyIsImFwcGVuZCIsImF0dHIiLCJmb3JFYWNoIiwidmVuZG9yIiwiZm4iLCJyZWdpc3RlclZlbmRvciIsIiRuYW1lIiwicHVzaCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0FBLE1BQU0sQ0FBQ0MsQ0FBUCxHQUFXRCxNQUFNLENBQUNFLE1BQVAsR0FBZ0JDLG1CQUFPLENBQUMsb0RBQUQsQ0FBbEM7QUFDQUgsTUFBTSxDQUFDSSxNQUFQLEdBQWdCRCxtQkFBTyxDQUFDLDhFQUFELENBQXZCOztBQUNBQSxtQkFBTyxDQUFDLGdFQUFELENBQVA7O0FBQ0FILE1BQU0sQ0FBQ0ssWUFBUCxHQUFzQkYsbUJBQU8sQ0FBQywyRkFBRCxDQUE3Qjs7QUFDQUEsbUJBQU8sQ0FBQyx5RkFBRCxDQUFQO0FBRUE7QUFDQTtBQUNBOzs7QUFFQSxDQUFFLFVBQVVGLENBQVYsRUFBYUQsTUFBYixFQUFxQjtBQUNuQixNQUFJTSxJQUFJLEdBQUc7QUFDUEMsUUFBSSxFQUFFLGlCQURDO0FBRVBDLFdBQU8sRUFBRSxPQUZGO0FBR1BDLFdBQU8sRUFBRSxFQUhGO0FBS1A7QUFDQUMsUUFBSSxFQUFFVCxDQUFDLENBQUMsTUFBRCxDQU5BO0FBT1BVLFVBQU0sRUFBRVYsQ0FBQyxDQUFDLFNBQUQsQ0FQRjtBQVFQVyxVQUFNLEVBQUVYLENBQUMsQ0FBQyxTQUFELENBUkY7QUFTUFksVUFBTSxFQUFFWixDQUFDLENBQUMsU0FBRDtBQVRGLEdBQVg7QUFZQUssTUFBSSxDQUFDUSxRQUFMLEdBQWdCO0FBQ1pDLGdCQUFZLEVBQUUsSUFERjtBQUVaQyxzQkFBa0IsRUFBRSxJQUZSO0FBR1pDLG9CQUFnQixFQUFFLElBSE47QUFJWkMscUJBQWlCLEVBQUUsSUFKUDtBQUtaQyxzQkFBa0IsRUFBRSxJQUxSO0FBTVpDLGdCQUFZLEVBQUU7QUFORixHQUFoQjtBQVNBO0FBQ0o7QUFDQTs7QUFDSWQsTUFBSSxDQUFDZSxJQUFMLEdBQVksWUFBWTtBQUNwQjtBQUNBO0FBQ0FmLFFBQUksQ0FBQ2dCLFdBQUwsR0FIb0IsQ0FLcEI7QUFDQTs7QUFDQWhCLFFBQUksQ0FBQ2lCLFFBQUw7QUFDQWpCLFFBQUksQ0FBQ2tCLFVBQUw7QUFDQWxCLFFBQUksQ0FBQ21CLFFBQUw7QUFDQW5CLFFBQUksQ0FBQ29CLFFBQUw7QUFDQXBCLFFBQUksQ0FBQ3FCLFVBQUw7QUFDQXJCLFFBQUksQ0FBQ3NCLFNBQUw7QUFDQXRCLFFBQUksQ0FBQ3VCLFVBQUw7QUFDQXZCLFFBQUksQ0FBQ3dCLGFBQUw7QUFDQXhCLFFBQUksQ0FBQ3lCLFNBQUw7QUFDQXpCLFFBQUksQ0FBQzBCLFVBQUw7QUFDQTFCLFFBQUksQ0FBQzJCLFdBQUw7QUFDQTNCLFFBQUksQ0FBQzRCLFdBQUw7QUFDQTVCLFFBQUksQ0FBQzZCLFNBQUwsR0FuQm9CLENBcUJwQjtBQUNBOztBQUNBbEMsS0FBQyxDQUFDLHlCQUFELENBQUQsQ0FBNkJtQyxJQUE3QixDQUFrQyxZQUFZO0FBQzFDLFVBQUlDLE9BQU8sR0FBR3BDLENBQUMsQ0FBQyxJQUFELENBQWY7QUFDQW9DLGFBQU8sQ0FBQ0MsTUFBUixDQUFlLDhCQUE4QkQsT0FBTyxDQUFDRSxJQUFSLENBQWEsSUFBYixDQUE5QixHQUFtRCxRQUFsRTtBQUNILEtBSEQ7QUFJSCxHQTNCRDtBQTZCQTtBQUNKO0FBQ0E7OztBQUNJakMsTUFBSSxDQUFDZ0IsV0FBTCxHQUFtQixZQUFZO0FBQzNCaEIsUUFBSSxDQUFDRyxPQUFMLENBQWErQixPQUFiLENBQXFCLFVBQVVDLE1BQVYsRUFBa0I7QUFDbkMsVUFBSUMsRUFBRSxHQUFHMUMsTUFBTSxDQUFDTSxJQUFQLENBQVksU0FBU21DLE1BQXJCLENBQVQ7O0FBQ0EsVUFBSSxPQUFPQyxFQUFQLEtBQWMsVUFBbEIsRUFBOEI7QUFDMUJBLFVBQUU7QUFDTDtBQUNKLEtBTEQ7QUFNSCxHQVBEO0FBU0E7QUFDSjtBQUNBO0FBQ0E7OztBQUNJcEMsTUFBSSxDQUFDcUMsY0FBTCxHQUFzQixVQUFVQyxLQUFWLEVBQWlCO0FBQ25DdEMsUUFBSSxDQUFDRyxPQUFMLENBQWFvQyxJQUFiLENBQWtCRCxLQUFsQjtBQUNILEdBRkQ7O0FBSUE1QyxRQUFNLENBQUNNLElBQVAsR0FBY0EsSUFBZDtBQUNILENBM0VBLENBMkVFSixNQTNFRixFQTJFVUYsTUEzRVYsQ0FBRDtBQTZFQTtBQUNBO0FBQ0E7O0FBQ0FDLENBQUMsQ0FBQyxZQUFZLENBQ1Y7QUFDSCxDQUZBLENBQUQiLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21haW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvYWQgcmVxdWlyZWQgcGx1Z2lucy5cbiAqL1xud2luZG93LiQgPSB3aW5kb3cualF1ZXJ5ID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XG53aW5kb3cuUG9wcGVyID0gcmVxdWlyZSgncG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlcicpO1xucmVxdWlyZSgnYm9vdHN0cmFwJyk7XG53aW5kb3cuU21vb3RoU2Nyb2xsID0gcmVxdWlyZSgnc21vb3Roc2Nyb2xsLWZvci13ZWJzaXRlcycpO1xucmVxdWlyZSgnb2JqZWN0Rml0UG9seWZpbGwnKTtcblxuLyoqXG4gKiBDcmVhdGUgd2luZG93LnBhZ2UgYW5kIGluaXQgdGhlIGFwcGxpY2F0aW9uLlxuICovXG5cbisoZnVuY3Rpb24gKCQsIHdpbmRvdykge1xuICAgIHZhciBwYWdlID0ge1xuICAgICAgICBuYW1lOiAnQ3VzdG9tRnJhbWV3b3JrJyxcbiAgICAgICAgdmVyc2lvbjogJzIuMC4wJyxcbiAgICAgICAgdmVuZG9yczogW10sXG5cbiAgICAgICAgLy8gQ2FjaGUgcG9wdWxhciBlbGVtZW50c1xuICAgICAgICBib2R5OiAkKCdib2R5JyksXG4gICAgICAgIG5hdmJhcjogJCgnLm5hdmJhcicpLFxuICAgICAgICBoZWFkZXI6ICQoJy5oZWFkZXInKSxcbiAgICAgICAgZm9vdGVyOiAkKCcuZm9vdGVyJyksXG4gICAgfTtcblxuICAgIHBhZ2UuZGVmYXVsdHMgPSB7XG4gICAgICAgIGdvb2dsZUFwaUtleTogbnVsbCxcbiAgICAgICAgZ29vZ2xlQW5hbHl0aWNzS2V5OiBudWxsLFxuICAgICAgICByZUNhcHRjaGFTaXRlS2V5OiBudWxsLFxuICAgICAgICByZUNhcHRjaGFMYW5ndWFnZTogbnVsbCxcbiAgICAgICAgZGlzYWJsZUFPU29uTW9iaWxlOiB0cnVlLFxuICAgICAgICBzbW9vdGhTY3JvbGw6IGZhbHNlLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGFsbCB0aGUgcmVxdWlyZWQgaW5pdGlhbGl6ZXJzLlxuICAgICAqL1xuICAgIHBhZ2UuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVmVuZG9yc1xuICAgICAgICAvL1xuICAgICAgICBwYWdlLmluaXRWZW5kb3JzKCk7XG5cbiAgICAgICAgLy8gUGFydGlhbHNcbiAgICAgICAgLy9cbiAgICAgICAgcGFnZS5pbml0QmluZCgpO1xuICAgICAgICBwYWdlLmluaXREcmF3ZXIoKTtcbiAgICAgICAgcGFnZS5pbml0Rm9udCgpO1xuICAgICAgICBwYWdlLmluaXRGb3JtKCk7XG4gICAgICAgIHBhZ2UuaW5pdE1haWxlcigpO1xuICAgICAgICBwYWdlLmluaXRNb2RhbCgpO1xuICAgICAgICBwYWdlLmluaXROYXZiYXIoKTtcbiAgICAgICAgcGFnZS5pbml0T2ZmY2FudmFzKCk7XG4gICAgICAgIHBhZ2UuaW5pdFBvcHVwKCk7XG4gICAgICAgIHBhZ2UuaW5pdFNjcm9sbCgpO1xuICAgICAgICBwYWdlLmluaXRTZWN0aW9uKCk7XG4gICAgICAgIHBhZ2UuaW5pdFNpZGViYXIoKTtcbiAgICAgICAgcGFnZS5pbml0VmlkZW8oKTtcblxuICAgICAgICAvLyBBbmNob3IgZm9yIGhlYWRpbmdzXG4gICAgICAgIC8vXG4gICAgICAgICQoJ1tkYXRhLXByb3ZpZGU9XCJhbmNob3JcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBoZWFkaW5nID0gJCh0aGlzKTtcbiAgICAgICAgICAgIGhlYWRpbmcuYXBwZW5kKCc8YSBjbGFzcz1cImFuY2hvclwiIGhyZWY9XCIjJyArIGhlYWRpbmcuYXR0cignaWQnKSArICdcIj48L2E+Jyk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIGFsbCBvZiB0aGUgbG9hZGVkIHZlbmRvcnMuXG4gICAgICovXG4gICAgcGFnZS5pbml0VmVuZG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGFnZS52ZW5kb3JzLmZvckVhY2goZnVuY3Rpb24gKHZlbmRvcikge1xuICAgICAgICAgICAgdmFyIGZuID0gd2luZG93LnBhZ2VbJ2luaXQnICsgdmVuZG9yXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgbG9hZGVkIHZlbmRvciB0byBiZSBpbml0aWFsaXplZCBhZnRlciBET00gbG9hZC5cbiAgICAgKiBJdCdzIGNhc2Ugc2Vuc2l0aXZlLCBzaW5jZSBpdCBjYWxscyBcImluaXRWZW5kb3JOYW1lXCIgbWV0aG9kLlxuICAgICAqL1xuICAgIHBhZ2UucmVnaXN0ZXJWZW5kb3IgPSBmdW5jdGlvbiAoJG5hbWUpIHtcbiAgICAgICAgcGFnZS52ZW5kb3JzLnB1c2goJG5hbWUpO1xuICAgIH07XG5cbiAgICB3aW5kb3cucGFnZSA9IHBhZ2U7XG59KShqUXVlcnksIHdpbmRvdyk7XG5cbi8qKlxuICogT25jZSB0aGUgRE9NIGlzIGxvYWRlZCwgc3RhcnQgdGhlIG1hZ2ljLlxuICovXG4kKGZ1bmN0aW9uICgpIHtcbiAgICAvL3BhZ2UuaW5pdCgpO1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/main.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/map.js":
/*!*********************************************!*\
  !*** ./resources/plugin/js/partials/map.js ***!
  \*********************************************/
/***/ (() => {

eval("/**\n * Display google map.\n */\n+function ($) {\n  page.initMap = function () {\n    $('[data-provide~=\"map\"]').each(function () {\n      var tag = $(this),\n          setting = {\n        lat: '',\n        lng: '',\n        zoom: 13,\n        markerLat: '',\n        markerLng: '',\n        markerIcon: '',\n        markers: '',\n        style: '',\n        removeControls: false\n      };\n      setting = $.extend(setting, page.getDataOptions(tag));\n      var map = new google.maps.Map(tag[0], {\n        center: {\n          lat: Number(setting.lat),\n          lng: Number(setting.lng)\n        },\n        zoom: Number(setting.zoom),\n        disableDefaultUI: setting.removeControls\n      }); // Multiple locations\n      //\n\n      if (setting.markers != '') {\n        var locations = JSON.parse(\"[\" + setting.markers.replace(/'/g, '\"') + \"]\"),\n            infowindow = new google.maps.InfoWindow(),\n            marker,\n            i;\n\n        for (i = 0; i < locations.length; i++) {\n          var markerIcon = setting.markerIcon;\n\n          if (locations[i].length > 3 && locations[i][3] != '') {\n            markerIcon = locations[i][3];\n          }\n\n          marker = new google.maps.Marker({\n            position: {\n              lat: Number(locations[i][0]),\n              lng: Number(locations[i][1])\n            },\n            map: map,\n            animation: google.maps.Animation.DROP,\n            icon: markerIcon\n          });\n\n          if (locations[i].length > 2 && locations[i][2] != '') {\n            google.maps.event.addListener(marker, 'click', function (marker, i) {\n              return function () {\n                infowindow.setContent(locations[i][2]);\n                infowindow.open(map, marker);\n              };\n            }(marker, i));\n          }\n        }\n      } // Single location\n      //\n      else {\n          var marker = new google.maps.Marker({\n            position: {\n              lat: Number(setting.markerLat),\n              lng: Number(setting.markerLng)\n            },\n            map: map,\n            animation: google.maps.Animation.DROP,\n            icon: setting.markerIcon\n          });\n\n          if (tag.is('[data-info]')) {\n            var infowindow = new google.maps.InfoWindow({\n              content: tag.dataAttr('info', '')\n            });\n            marker.addListener('click', function () {\n              infowindow.open(map, marker);\n            });\n          }\n        }\n\n      switch (setting.style) {\n        case 'light':\n          map.set('styles', [{\n            \"featureType\": \"water\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#e9e9e9\"\n            }, {\n              \"lightness\": 17\n            }]\n          }, {\n            \"featureType\": \"landscape\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#f5f5f5\"\n            }, {\n              \"lightness\": 20\n            }]\n          }, {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [{\n              \"color\": \"#ffffff\"\n            }, {\n              \"lightness\": 17\n            }]\n          }, {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"geometry.stroke\",\n            \"stylers\": [{\n              \"color\": \"#ffffff\"\n            }, {\n              \"lightness\": 29\n            }, {\n              \"weight\": 0.2\n            }]\n          }, {\n            \"featureType\": \"road.arterial\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#ffffff\"\n            }, {\n              \"lightness\": 18\n            }]\n          }, {\n            \"featureType\": \"road.local\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#ffffff\"\n            }, {\n              \"lightness\": 16\n            }]\n          }, {\n            \"featureType\": \"poi\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#f5f5f5\"\n            }, {\n              \"lightness\": 21\n            }]\n          }, {\n            \"featureType\": \"poi.park\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#dedede\"\n            }, {\n              \"lightness\": 21\n            }]\n          }, {\n            \"elementType\": \"labels.text.stroke\",\n            \"stylers\": [{\n              \"visibility\": \"on\"\n            }, {\n              \"color\": \"#ffffff\"\n            }, {\n              \"lightness\": 16\n            }]\n          }, {\n            \"elementType\": \"labels.text.fill\",\n            \"stylers\": [{\n              \"saturation\": 36\n            }, {\n              \"color\": \"#333333\"\n            }, {\n              \"lightness\": 40\n            }]\n          }, {\n            \"elementType\": \"labels.icon\",\n            \"stylers\": [{\n              \"visibility\": \"off\"\n            }]\n          }, {\n            \"featureType\": \"transit\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#f2f2f2\"\n            }, {\n              \"lightness\": 19\n            }]\n          }, {\n            \"featureType\": \"administrative\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [{\n              \"color\": \"#fefefe\"\n            }, {\n              \"lightness\": 20\n            }]\n          }, {\n            \"featureType\": \"administrative\",\n            \"elementType\": \"geometry.stroke\",\n            \"stylers\": [{\n              \"color\": \"#fefefe\"\n            }, {\n              \"lightness\": 17\n            }, {\n              \"weight\": 1.2\n            }]\n          }]);\n          break;\n\n        case 'dark':\n          map.set('styles', [{\n            \"featureType\": \"all\",\n            \"elementType\": \"labels.text.fill\",\n            \"stylers\": [{\n              \"saturation\": 36\n            }, {\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 40\n            }]\n          }, {\n            \"featureType\": \"all\",\n            \"elementType\": \"labels.text.stroke\",\n            \"stylers\": [{\n              \"visibility\": \"on\"\n            }, {\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 16\n            }]\n          }, {\n            \"featureType\": \"all\",\n            \"elementType\": \"labels.icon\",\n            \"stylers\": [{\n              \"visibility\": \"off\"\n            }]\n          }, {\n            \"featureType\": \"administrative\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 20\n            }]\n          }, {\n            \"featureType\": \"administrative\",\n            \"elementType\": \"geometry.stroke\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 17\n            }, {\n              \"weight\": 1.2\n            }]\n          }, {\n            \"featureType\": \"landscape\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 20\n            }]\n          }, {\n            \"featureType\": \"poi\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 21\n            }]\n          }, {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"geometry.fill\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 17\n            }]\n          }, {\n            \"featureType\": \"road.highway\",\n            \"elementType\": \"geometry.stroke\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 29\n            }, {\n              \"weight\": 0.2\n            }]\n          }, {\n            \"featureType\": \"road.arterial\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 18\n            }]\n          }, {\n            \"featureType\": \"road.local\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 16\n            }]\n          }, {\n            \"featureType\": \"transit\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 19\n            }]\n          }, {\n            \"featureType\": \"water\",\n            \"elementType\": \"geometry\",\n            \"stylers\": [{\n              \"color\": \"#000000\"\n            }, {\n              \"lightness\": 17\n            }]\n          }]);\n          break;\n\n        default:\n          if (Array.isArray(setting.style)) {\n            map.set('styles', setting.style);\n          }\n\n      }\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21hcC5qcz8wYjkyIl0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiaW5pdE1hcCIsImVhY2giLCJ0YWciLCJzZXR0aW5nIiwibGF0IiwibG5nIiwiem9vbSIsIm1hcmtlckxhdCIsIm1hcmtlckxuZyIsIm1hcmtlckljb24iLCJtYXJrZXJzIiwic3R5bGUiLCJyZW1vdmVDb250cm9scyIsImV4dGVuZCIsImdldERhdGFPcHRpb25zIiwibWFwIiwiZ29vZ2xlIiwibWFwcyIsIk1hcCIsImNlbnRlciIsIk51bWJlciIsImRpc2FibGVEZWZhdWx0VUkiLCJsb2NhdGlvbnMiLCJKU09OIiwicGFyc2UiLCJyZXBsYWNlIiwiaW5mb3dpbmRvdyIsIkluZm9XaW5kb3ciLCJtYXJrZXIiLCJpIiwibGVuZ3RoIiwiTWFya2VyIiwicG9zaXRpb24iLCJhbmltYXRpb24iLCJBbmltYXRpb24iLCJEUk9QIiwiaWNvbiIsImV2ZW50IiwiYWRkTGlzdGVuZXIiLCJzZXRDb250ZW50Iiwib3BlbiIsImlzIiwiY29udGVudCIsImRhdGFBdHRyIiwic2V0IiwiQXJyYXkiLCJpc0FycmF5IiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLE9BQUwsR0FBZSxZQUFXO0FBRXhCRixJQUFBQSxDQUFDLENBQUMsdUJBQUQsQ0FBRCxDQUEyQkcsSUFBM0IsQ0FBZ0MsWUFBVztBQUN6QyxVQUFJQyxHQUFHLEdBQUdKLENBQUMsQ0FBQyxJQUFELENBQVg7QUFBQSxVQUNJSyxPQUFPLEdBQUc7QUFDUkMsUUFBQUEsR0FBRyxFQUFFLEVBREc7QUFFUkMsUUFBQUEsR0FBRyxFQUFFLEVBRkc7QUFHUkMsUUFBQUEsSUFBSSxFQUFFLEVBSEU7QUFJUkMsUUFBQUEsU0FBUyxFQUFFLEVBSkg7QUFLUkMsUUFBQUEsU0FBUyxF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USxRQUFSLEVBQWtCekMsT0FBTyxDQUFDUSxLQUExQjtBQUNEOztBQVpMO0FBZUQsS0F6R0Q7QUEyR0QsR0E3R0Q7QUErR0QsQ0FqSEEsQ0FpSENvQyxNQWpIRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIERpc3BsYXkgZ29vZ2xlIG1hcC5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0TWFwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAkKCdbZGF0YS1wcm92aWRlfj1cIm1hcFwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFnID0gJCh0aGlzKSxcbiAgICAgICAgICBzZXR0aW5nID0ge1xuICAgICAgICAgICAgbGF0OiAnJyxcbiAgICAgICAgICAgIGxuZzogJycsXG4gICAgICAgICAgICB6b29tOiAxMyxcbiAgICAgICAgICAgIG1hcmtlckxhdDogJycsXG4gICAgICAgICAgICBtYXJrZXJMbmc6ICcnLFxuICAgICAgICAgICAgbWFya2VySWNvbjogJycsXG4gICAgICAgICAgICBtYXJrZXJzOiAnJyxcbiAgICAgICAgICAgIHN0eWxlOiAnJyxcbiAgICAgICAgICAgIHJlbW92ZUNvbnRyb2xzOiBmYWxzZSxcbiAgICAgICAgICB9O1xuXG4gICAgICBzZXR0aW5nID0gJC5leHRlbmQoc2V0dGluZywgcGFnZS5nZXREYXRhT3B0aW9ucyh0YWcpKTtcblxuICAgICAgdmFyIG1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoIHRhZ1swXSwge1xuICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICBsYXQ6IE51bWJlcihzZXR0aW5nLmxhdCksXG4gICAgICAgICAgbG5nOiBOdW1iZXIoc2V0dGluZy5sbmcpXG4gICAgICAgIH0sXG4gICAgICAgIHpvb206IE51bWJlcihzZXR0aW5nLnpvb20pLFxuICAgICAgICBkaXNhYmxlRGVmYXVsdFVJOiBzZXR0aW5nLnJlbW92ZUNvbnRyb2xzLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIE11bHRpcGxlIGxvY2F0aW9uc1xuICAgICAgLy9cbiAgICAgIGlmIChzZXR0aW5nLm1hcmtlcnMgIT0gJycpIHtcblxuICAgICAgICB2YXIgbG9jYXRpb25zID0gSlNPTi5wYXJzZShcIltcIiArIHNldHRpbmcubWFya2Vycy5yZXBsYWNlKC8nL2csICdcIicpICsgXCJdXCIpLFxuICAgICAgICAgICAgaW5mb3dpbmRvdyA9IG5ldyBnb29nbGUubWFwcy5JbmZvV2luZG93KCksXG4gICAgICAgICAgICBtYXJrZXIsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBtYXJrZXJJY29uID0gc2V0dGluZy5tYXJrZXJJY29uO1xuXG4gICAgICAgICAgaWYgKCBsb2NhdGlvbnNbaV0ubGVuZ3RoID4gMyAmJiBsb2NhdGlvbnNbaV1bM10gIT0gJycgKSB7XG4gICAgICAgICAgICBtYXJrZXJJY29uID0gbG9jYXRpb25zW2ldWzNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1hcmtlciA9IG5ldyBnb29nbGUubWFwcy5NYXJrZXIoe1xuICAgICAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICAgICAgbGF0OiBOdW1iZXIobG9jYXRpb25zW2ldWzBdKSxcbiAgICAgICAgICAgICAgbG5nOiBOdW1iZXIobG9jYXRpb25zW2ldWzFdKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1hcDogbWFwLFxuICAgICAgICAgICAgYW5pbWF0aW9uOiBnb29nbGUubWFwcy5BbmltYXRpb24uRFJPUCxcbiAgICAgICAgICAgIGljb246IG1hcmtlckljb25cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICggbG9jYXRpb25zW2ldLmxlbmd0aCA+IDIgJiYgbG9jYXRpb25zW2ldWzJdICE9ICcnICkge1xuICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQuYWRkTGlzdGVuZXIobWFya2VyLCAnY2xpY2snLCAoZnVuY3Rpb24obWFya2VyLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpbmZvd2luZG93LnNldENvbnRlbnQobG9jYXRpb25zW2ldWzJdKTtcbiAgICAgICAgICAgICAgICBpbmZvd2luZG93Lm9wZW4obWFwLCBtYXJrZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KShtYXJrZXIsIGkpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIC8vIFNpbmdsZSBsb2NhdGlvblxuICAgICAgLy9cbiAgICAgIGVsc2Uge1xuXG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHtcbiAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgbGF0OiBOdW1iZXIoc2V0dGluZy5tYXJrZXJMYXQpLFxuICAgICAgICAgICAgbG5nOiBOdW1iZXIoc2V0dGluZy5tYXJrZXJMbmcpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtYXA6IG1hcCxcbiAgICAgICAgICBhbmltYXRpb246IGdvb2dsZS5tYXBzLkFuaW1hdGlvbi5EUk9QLFxuICAgICAgICAgIGljb246IHNldHRpbmcubWFya2VySWNvblxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGFnLmlzKCdbZGF0YS1pbmZvXScpKSB7XG4gICAgICAgICAgdmFyIGluZm93aW5kb3cgPSBuZXcgZ29vZ2xlLm1hcHMuSW5mb1dpbmRvdyh7XG4gICAgICAgICAgICBjb250ZW50OiB0YWcuZGF0YUF0dHIoJ2luZm8nLCAnJylcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIG1hcmtlci5hZGRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGluZm93aW5kb3cub3BlbihtYXAsIG1hcmtlcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgfVxuXG5cbiAgICAgIHN3aXRjaCAoc2V0dGluZy5zdHlsZSkge1xuICAgICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgICAgbWFwLnNldCgnc3R5bGVzJywgW3tcImZlYXR1cmVUeXBlXCI6XCJ3YXRlclwiLFwiZWxlbWVudFR5cGVcIjpcImdlb21ldHJ5XCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjZTllOWU5XCJ9LHtcImxpZ2h0bmVzc1wiOjE3fV19LHtcImZlYXR1cmVUeXBlXCI6XCJsYW5kc2NhcGVcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeVwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiI2Y1ZjVmNVwifSx7XCJsaWdodG5lc3NcIjoyMH1dfSx7XCJmZWF0dXJlVHlwZVwiOlwicm9hZC5oaWdod2F5XCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnkuZmlsbFwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiI2ZmZmZmZlwifSx7XCJsaWdodG5lc3NcIjoxN31dfSx7XCJmZWF0dXJlVHlwZVwiOlwicm9hZC5oaWdod2F5XCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnkuc3Ryb2tlXCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjZmZmZmZmXCJ9LHtcImxpZ2h0bmVzc1wiOjI5fSx7XCJ3ZWlnaHRcIjowLjJ9XX0se1wiZmVhdHVyZVR5cGVcIjpcInJvYWQuYXJ0ZXJpYWxcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeVwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiI2ZmZmZmZlwifSx7XCJsaWdodG5lc3NcIjoxOH1dfSx7XCJmZWF0dXJlVHlwZVwiOlwicm9hZC5sb2NhbFwiLFwiZWxlbWVudFR5cGVcIjpcImdlb21ldHJ5XCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjZmZmZmZmXCJ9LHtcImxpZ2h0bmVzc1wiOjE2fV19LHtcImZlYXR1cmVUeXBlXCI6XCJwb2lcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeVwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiI2Y1ZjVmNVwifSx7XCJsaWdodG5lc3NcIjoyMX1dfSx7XCJmZWF0dXJlVHlwZVwiOlwicG9pLnBhcmtcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeVwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiI2RlZGVkZVwifSx7XCJsaWdodG5lc3NcIjoyMX1dfSx7XCJlbGVtZW50VHlwZVwiOlwibGFiZWxzLnRleHQuc3Ryb2tlXCIsXCJzdHlsZXJzXCI6W3tcInZpc2liaWxpdHlcIjpcIm9uXCJ9LHtcImNvbG9yXCI6XCIjZmZmZmZmXCJ9LHtcImxpZ2h0bmVzc1wiOjE2fV19LHtcImVsZW1lbnRUeXBlXCI6XCJsYWJlbHMudGV4dC5maWxsXCIsXCJzdHlsZXJzXCI6W3tcInNhdHVyYXRpb25cIjozNn0se1wiY29sb3JcIjpcIiMzMzMzMzNcIn0se1wibGlnaHRuZXNzXCI6NDB9XX0se1wiZWxlbWVudFR5cGVcIjpcImxhYmVscy5pY29uXCIsXCJzdHlsZXJzXCI6W3tcInZpc2liaWxpdHlcIjpcIm9mZlwifV19LHtcImZlYXR1cmVUeXBlXCI6XCJ0cmFuc2l0XCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnlcIixcInN0eWxlcnNcIjpbe1wiY29sb3JcIjpcIiNmMmYyZjJcIn0se1wibGlnaHRuZXNzXCI6MTl9XX0se1wiZmVhdHVyZVR5cGVcIjpcImFkbWluaXN0cmF0aXZlXCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnkuZmlsbFwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiI2ZlZmVmZVwifSx7XCJsaWdodG5lc3NcIjoyMH1dfSx7XCJmZWF0dXJlVHlwZVwiOlwiYWRtaW5pc3RyYXRpdmVcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeS5zdHJva2VcIixcInN0eWxlcnNcIjpbe1wiY29sb3JcIjpcIiNmZWZlZmVcIn0se1wibGlnaHRuZXNzXCI6MTd9LHtcIndlaWdodFwiOjEuMn1dfV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2RhcmsnOlxuICAgICAgICAgIG1hcC5zZXQoJ3N0eWxlcycsIFt7XCJmZWF0dXJlVHlwZVwiOlwiYWxsXCIsXCJlbGVtZW50VHlwZVwiOlwibGFiZWxzLnRleHQuZmlsbFwiLFwic3R5bGVyc1wiOlt7XCJzYXR1cmF0aW9uXCI6MzZ9LHtcImNvbG9yXCI6XCIjMDAwMDAwXCJ9LHtcImxpZ2h0bmVzc1wiOjQwfV19LHtcImZlYXR1cmVUeXBlXCI6XCJhbGxcIixcImVsZW1lbnRUeXBlXCI6XCJsYWJlbHMudGV4dC5zdHJva2VcIixcInN0eWxlcnNcIjpbe1widmlzaWJpbGl0eVwiOlwib25cIn0se1wiY29sb3JcIjpcIiMwMDAwMDBcIn0se1wibGlnaHRuZXNzXCI6MTZ9XX0se1wiZmVhdHVyZVR5cGVcIjpcImFsbFwiLFwiZWxlbWVudFR5cGVcIjpcImxhYmVscy5pY29uXCIsXCJzdHlsZXJzXCI6W3tcInZpc2liaWxpdHlcIjpcIm9mZlwifV19LHtcImZlYXR1cmVUeXBlXCI6XCJhZG1pbmlzdHJhdGl2ZVwiLFwiZWxlbWVudFR5cGVcIjpcImdlb21ldHJ5LmZpbGxcIixcInN0eWxlcnNcIjpbe1wiY29sb3JcIjpcIiMwMDAwMDBcIn0se1wibGlnaHRuZXNzXCI6MjB9XX0se1wiZmVhdHVyZVR5cGVcIjpcImFkbWluaXN0cmF0aXZlXCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnkuc3Ryb2tlXCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjMDAwMDAwXCJ9LHtcImxpZ2h0bmVzc1wiOjE3fSx7XCJ3ZWlnaHRcIjoxLjJ9XX0se1wiZmVhdHVyZVR5cGVcIjpcImxhbmRzY2FwZVwiLFwiZWxlbWVudFR5cGVcIjpcImdlb21ldHJ5XCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjMDAwMDAwXCJ9LHtcImxpZ2h0bmVzc1wiOjIwfV19LHtcImZlYXR1cmVUeXBlXCI6XCJwb2lcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeVwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiIzAwMDAwMFwifSx7XCJsaWdodG5lc3NcIjoyMX1dfSx7XCJmZWF0dXJlVHlwZVwiOlwicm9hZC5oaWdod2F5XCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnkuZmlsbFwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiIzAwMDAwMFwifSx7XCJsaWdodG5lc3NcIjoxN31dfSx7XCJmZWF0dXJlVHlwZVwiOlwicm9hZC5oaWdod2F5XCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnkuc3Ryb2tlXCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjMDAwMDAwXCJ9LHtcImxpZ2h0bmVzc1wiOjI5fSx7XCJ3ZWlnaHRcIjowLjJ9XX0se1wiZmVhdHVyZVR5cGVcIjpcInJvYWQuYXJ0ZXJpYWxcIixcImVsZW1lbnRUeXBlXCI6XCJnZW9tZXRyeVwiLFwic3R5bGVyc1wiOlt7XCJjb2xvclwiOlwiIzAwMDAwMFwifSx7XCJsaWdodG5lc3NcIjoxOH1dfSx7XCJmZWF0dXJlVHlwZVwiOlwicm9hZC5sb2NhbFwiLFwiZWxlbWVudFR5cGVcIjpcImdlb21ldHJ5XCIsXCJzdHlsZXJzXCI6W3tcImNvbG9yXCI6XCIjMDAwMDAwXCJ9LHtcImxpZ2h0bmVzc1wiOjE2fV19LHtcImZlYXR1cmVUeXBlXCI6XCJ0cmFuc2l0XCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnlcIixcInN0eWxlcnNcIjpbe1wiY29sb3JcIjpcIiMwMDAwMDBcIn0se1wibGlnaHRuZXNzXCI6MTl9XX0se1wiZmVhdHVyZVR5cGVcIjpcIndhdGVyXCIsXCJlbGVtZW50VHlwZVwiOlwiZ2VvbWV0cnlcIixcInN0eWxlcnNcIjpbe1wiY29sb3JcIjpcIiMwMDAwMDBcIn0se1wibGlnaHRuZXNzXCI6MTd9XX1dKVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KHNldHRpbmcuc3R5bGUpICkge1xuICAgICAgICAgICAgbWFwLnNldCgnc3R5bGVzJywgc2V0dGluZy5zdHlsZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfVxuXG59KGpRdWVyeSk7XG5cbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21hcC5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/map.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/modal.js":
/*!***********************************************!*\
  !*** ./resources/plugin/js/partials/modal.js ***!
  \***********************************************/
/***/ (() => {

eval("/**\n * All the modal related methods.\n */\n+function ($) {\n  page.initModal = function () {\n    var body = page.body;\n    /**\n     * Autoshow\n     */\n\n    $('.modal[data-autoshow]').each(function () {\n      var modal = $(this),\n          delay = parseInt(modal.dataAttr('autoshow'));\n      setTimeout(function () {\n        modal.modal('show');\n      }, delay);\n    });\n    /**\n     * Exit\n     */\n\n    $('.modal[data-exitshow]').each(function () {\n      var modal = $(this),\n          delay = parseInt(modal.dataAttr('delay', 0)),\n          target = modal.dataAttr('exitshow');\n\n      if ($(target).length) {\n        $(document).one('mouseleave', target, function () {\n          setTimeout(function () {\n            modal.modal('show');\n          }, delay);\n        });\n      }\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21vZGFsLmpzPzFhOGYiXSwibmFtZXMiOlsiJCIsInBhZ2UiLCJpbml0TW9kYWwiLCJib2R5IiwiZWFjaCIsIm1vZGFsIiwiZGVsYXkiLCJwYXJzZUludCIsImRhdGFBdHRyIiwic2V0VGltZW91dCIsInRhcmdldCIsImxlbmd0aCIsImRvY3VtZW50Iiwib25lIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLFNBQUwsR0FBaUIsWUFBVztBQUMxQixRQUFJQyxJQUFJLEdBQUdGLElBQUksQ0FBQ0UsSUFBaEI7QUFFQTtBQUNKO0FBQ0E7O0FBQ0lILElBQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCSSxJQUEzQixDQUFnQyxZQUFVO0FBQ3hDLFVBQUlDLEtBQUssR0FBR0wsQ0FBQyxDQUFDLElBQUQsQ0FBYjtBQUFBLFVBQ0lNLEtBQUssR0FBR0MsUUFBUSxDQUFFRixLQUFLLENBQUNHLFFBQU4sQ0FBZSxVQUFmLENBQUYsQ0FEcEI7QUFFQUMsTUFBQUEsVUFBVSxDQUFFLFlBQVc7QUFBRUosUUFBQUEsS0FBSyxDQUFDQSxLQUFOLENBQVksTUFBWjtBQUFxQixPQUFwQyxFQUFzQ0MsS0FBdEMsQ0FBVjtBQUNELEtBSkQ7QUFPQztBQUNMO0FBQ0E7O0FBQ0lOLElBQUFBLENBQUMsQ0FBQyx1QkFBRCxDQUFELENBQTJCSSxJQUEzQixDQUFnQyxZQUFVO0FBQ3hDLFVBQUlDLEtBQUssR0FBSUwsQ0FBQyxDQUFDLElBQUQsQ0FBZDtBQUFBLFVBQ0lNLEtBQUssR0FBSUMsUUFBUSxDQUFFRixLQUFLLENBQUNHLFFBQU4sQ0FBZSxPQUFmLEVBQXdCLENBQXhCLENBQUYsQ0FEckI7QUFBQSxVQUVJRSxNQUFNLEdBQUdMLEtBQUssQ0FBQ0csUUFBTixDQUFlLFVBQWYsQ0FGYjs7QUFJQSxVQUFLUixDQUFDLENBQUNVLE1BQUQsQ0FBRCxDQUFVQyxNQUFmLEVBQXdCO0FBQ3RCWCxRQUFBQSxDQUFDLENBQUNZLFFBQUQsQ0FBRCxDQUFZQyxHQUFaLENBQWdCLFlBQWhCLEVBQThCSCxNQUE5QixFQUFzQyxZQUFXO0FBQy9DRCxVQUFBQSxVQUFVLENBQUUsWUFBVztBQUFFSixZQUFBQSxLQUFLLENBQUNBLEtBQU4sQ0FBWSxNQUFaO0FBQXFCLFdBQXBDLEVBQXNDQyxLQUF0QyxDQUFWO0FBQ0QsU0FGRDtBQUdEO0FBRUYsS0FYRDtBQWFELEdBN0JEO0FBK0JELENBakNBLENBaUNDUSxNQWpDRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEFsbCB0aGUgbW9kYWwgcmVsYXRlZCBtZXRob2RzLlxuICovXG5cbitmdW5jdGlvbigkKXtcblxuICBwYWdlLmluaXRNb2RhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBib2R5ID0gcGFnZS5ib2R5O1xuXG4gICAgLyoqXG4gICAgICogQXV0b3Nob3dcbiAgICAgKi9cbiAgICAkKCcubW9kYWxbZGF0YS1hdXRvc2hvd10nKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbW9kYWwgPSAkKHRoaXMpLFxuICAgICAgICAgIGRlbGF5ID0gcGFyc2VJbnQoIG1vZGFsLmRhdGFBdHRyKCdhdXRvc2hvdycpICk7XG4gICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgbW9kYWwubW9kYWwoJ3Nob3cnKSB9LCBkZWxheSk7XG4gICAgfSk7XG5cblxuICAgICAvKipcbiAgICAgICogRXhpdFxuICAgICAgKi9cbiAgICAkKCcubW9kYWxbZGF0YS1leGl0c2hvd10nKS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbW9kYWwgID0gJCh0aGlzKSxcbiAgICAgICAgICBkZWxheSAgPSBwYXJzZUludCggbW9kYWwuZGF0YUF0dHIoJ2RlbGF5JywgMCkgKSxcbiAgICAgICAgICB0YXJnZXQgPSBtb2RhbC5kYXRhQXR0cignZXhpdHNob3cnKTtcblxuICAgICAgaWYgKCAkKHRhcmdldCkubGVuZ3RoICkge1xuICAgICAgICAkKGRvY3VtZW50KS5vbmUoJ21vdXNlbGVhdmUnLCB0YXJnZXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyBtb2RhbC5tb2RhbCgnc2hvdycpIH0sIGRlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9XG5cbn0oalF1ZXJ5KTtcbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL21vZGFsLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/modal.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/navbar.js":
/*!************************************************!*\
  !*** ./resources/plugin/js/partials/navbar.js ***!
  \************************************************/
/***/ (() => {

eval("/**\n * All the navbar related methods.\n */\n+function ($) {\n  page.initNavbar = function () {\n    /**\n     * Toggle navbar\n     */\n    $(document).on('click', '.navbar-toggler', function () {\n      page.navbarToggle();\n    });\n    /**\n     * Tapping on the backdrop will close the navbar\n     */\n\n    $(document).on('click', '.backdrop-navbar', function () {\n      page.navbarClose();\n    });\n    /**\n     * Toggle menu open on small screen devices\n     */\n\n    $(document).on('click', '.navbar-open .nav-navbar > .nav-item > .nav-link', function () {\n      $(this).closest('.nav-item').siblings('.nav-item').find('> .nav:visible').slideUp(333, 'linear');\n      $(this).next('.nav').slideToggle(333, 'linear');\n    });\n  };\n\n  page.navbarToggle = function () {\n    var body = page.body,\n        navbar = page.navbar;\n    body.toggleClass('navbar-open');\n\n    if (body.hasClass('navbar-open')) {\n      navbar.prepend('<div class=\"backdrop backdrop-navbar\"></div>');\n    }\n  };\n\n  page.navbarClose = function () {\n    page.body.removeClass('navbar-open');\n    $('.backdrop-navbar').remove();\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL25hdmJhci5qcz9mYjI0Il0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiaW5pdE5hdmJhciIsImRvY3VtZW50Iiwib24iLCJuYXZiYXJUb2dnbGUiLCJuYXZiYXJDbG9zZSIsImNsb3Nlc3QiLCJzaWJsaW5ncyIsImZpbmQiLCJzbGlkZVVwIiwibmV4dCIsInNsaWRlVG9nZ2xlIiwiYm9keSIsIm5hdmJhciIsInRvZ2dsZUNsYXNzIiwiaGFzQ2xhc3MiLCJwcmVwZW5kIiwicmVtb3ZlQ2xhc3MiLCJyZW1vdmUiLCJqUXVlcnkiXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUVBLENBQUMsVUFBU0EsQ0FBVCxFQUFXO0FBRVZDLEVBQUFBLElBQUksQ0FBQ0MsVUFBTCxHQUFrQixZQUFXO0FBRTNCO0FBQ0o7QUFDQTtBQUNJRixJQUFBQSxDQUFDLENBQUNHLFFBQUQsQ0FBRCxDQUFZQyxFQUFaLENBQWUsT0FBZixFQUF3QixpQkFBeEIsRUFBMkMsWUFBVztBQUNwREgsTUFBQUEsSUFBSSxDQUFDSSxZQUFMO0FBQ0QsS0FGRDtBQUtBO0FBQ0o7QUFDQTs7QUFDSUwsSUFBQUEsQ0FBQyxDQUFDRyxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLE9BQWYsRUFBd0Isa0JBQXhCLEVBQTRDLFlBQVc7QUFDckRILE1BQUFBLElBQUksQ0FBQ0ssV0FBTDtBQUNELEtBRkQ7QUFLQTtBQUNKO0FBQ0E7O0FBQ0lOLElBQUFBLENBQUMsQ0FBQ0csUUFBRCxDQUFELENBQVlDLEVBQVosQ0FBZSxPQUFmLEVBQXdCLGtEQUF4QixFQUE0RSxZQUFXO0FBQ3JGSixNQUFBQSxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFPLE9BQVIsQ0FBZ0IsV0FBaEIsRUFBNkJDLFFBQTdCLENBQXNDLFdBQXRDLEVBQW1EQyxJQUFuRCxDQUF3RCxnQkFBeEQsRUFBMEVDLE9BQTFFLENBQWtGLEdBQWxGLEVBQXVGLFFBQXZGO0FBQ0FWLE1BQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUVcsSUFBUixDQUFhLE1BQWIsRUFBcUJDLFdBQXJCLENBQWlDLEdBQWpDLEVBQXNDLFFBQXRDO0FBQ0QsS0FIRDtBQUtELEdBMUJEOztBQTZCQVgsRUFBQUEsSUFBSSxDQUFDSSxZQUFMLEdBQW9CLFlBQVc7QUFDN0IsUUFBSVEsSUFBSSxHQUFLWixJQUFJLENBQUNZLElBQWxCO0FBQUEsUUFDSUMsTUFBTSxHQUFHYixJQUFJLENBQUNhLE1BRGxCO0FBR0FELElBQUFBLElBQUksQ0FBQ0UsV0FBTCxDQUFpQixhQUFqQjs7QUFDQSxRQUFJRixJQUFJLENBQUNHLFFBQUwsQ0FBYyxhQUFkLENBQUosRUFBa0M7QUFDaENGLE1BQUFBLE1BQU0sQ0FBQ0csT0FBUCxDQUFlLDhDQUFmO0FBQ0Q7QUFDRixHQVJEOztBQVVBaEIsRUFBQUEsSUFBSSxDQUFDSyxXQUFMLEdBQW1CLFlBQVc7QUFDNUJMLElBQUFBLElBQUksQ0FBQ1ksSUFBTCxDQUFVSyxXQUFWLENBQXNCLGFBQXRCO0FBQ0FsQixJQUFBQSxDQUFDLENBQUMsa0JBQUQsQ0FBRCxDQUFzQm1CLE1BQXRCO0FBQ0QsR0FIRDtBQUtELENBOUNBLENBOENDQyxNQTlDRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEFsbCB0aGUgbmF2YmFyIHJlbGF0ZWQgbWV0aG9kcy5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0TmF2YmFyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgbmF2YmFyXG4gICAgICovXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5uYXZiYXItdG9nZ2xlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgcGFnZS5uYXZiYXJUb2dnbGUoKTtcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogVGFwcGluZyBvbiB0aGUgYmFja2Ryb3Agd2lsbCBjbG9zZSB0aGUgbmF2YmFyXG4gICAgICovXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5iYWNrZHJvcC1uYXZiYXInLCBmdW5jdGlvbigpIHtcbiAgICAgIHBhZ2UubmF2YmFyQ2xvc2UoKTtcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlIG1lbnUgb3BlbiBvbiBzbWFsbCBzY3JlZW4gZGV2aWNlc1xuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLm9uKCdjbGljaycsICcubmF2YmFyLW9wZW4gLm5hdi1uYXZiYXIgPiAubmF2LWl0ZW0gPiAubmF2LWxpbmsnLCBmdW5jdGlvbigpIHtcbiAgICAgICQodGhpcykuY2xvc2VzdCgnLm5hdi1pdGVtJykuc2libGluZ3MoJy5uYXYtaXRlbScpLmZpbmQoJz4gLm5hdjp2aXNpYmxlJykuc2xpZGVVcCgzMzMsICdsaW5lYXInKTtcbiAgICAgICQodGhpcykubmV4dCgnLm5hdicpLnNsaWRlVG9nZ2xlKDMzMywgJ2xpbmVhcicpO1xuICAgIH0pO1xuXG4gIH1cblxuXG4gIHBhZ2UubmF2YmFyVG9nZ2xlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJvZHkgICA9IHBhZ2UuYm9keSxcbiAgICAgICAgbmF2YmFyID0gcGFnZS5uYXZiYXI7XG5cbiAgICBib2R5LnRvZ2dsZUNsYXNzKCduYXZiYXItb3BlbicpO1xuICAgIGlmIChib2R5Lmhhc0NsYXNzKCduYXZiYXItb3BlbicpKSB7XG4gICAgICBuYXZiYXIucHJlcGVuZCgnPGRpdiBjbGFzcz1cImJhY2tkcm9wIGJhY2tkcm9wLW5hdmJhclwiPjwvZGl2PicpO1xuICAgIH1cbiAgfVxuXG4gIHBhZ2UubmF2YmFyQ2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICBwYWdlLmJvZHkucmVtb3ZlQ2xhc3MoJ25hdmJhci1vcGVuJyk7XG4gICAgJCgnLmJhY2tkcm9wLW5hdmJhcicpLnJlbW92ZSgpO1xuICB9XG5cbn0oalF1ZXJ5KTtcbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL25hdmJhci5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/navbar.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/offcanvas.js":
/*!***************************************************!*\
  !*** ./resources/plugin/js/partials/offcanvas.js ***!
  \***************************************************/
/***/ (() => {

eval("/**\n * All the popup related methods.\n */\n+function ($) {\n  page.initOffcanvas = function () {\n    /**\n     * Toggle\n     */\n    $(document).on('click', '[data-toggle=\"offcanvas\"]', function () {\n      var target = $(this).data('target'),\n          offcanvas = $(target);\n\n      if (target !== undefined && offcanvas.length) {\n        if (offcanvas.hasClass('show')) {\n          $('.backdrop-offcanvas').remove();\n          offcanvas.removeClass('show');\n        } else {\n          offcanvas.before('<div class=\"backdrop backdrop-offcanvas\"></div>');\n          offcanvas.addClass('show');\n          setTimeout(function () {\n            offcanvas.find('input:text:visible:first').focus();\n          }, 300);\n        }\n      }\n    });\n    /**\n     * Dismiss\n     */\n\n    $(document).on('click', '.offcanvas [data-dismiss], .backdrop-offcanvas', function () {\n      $('.offcanvas.show').removeClass('show');\n      $('.backdrop-offcanvas').remove();\n    });\n    /**\n     * Esc key\n     */\n\n    $(document).on('keyup', function (e) {\n      if ($('.offcanvas.show').length && e.keyCode == 27) {\n        // esc keycode\n        $('.offcanvas.show').removeClass('show');\n        $('.backdrop-offcanvas').remove();\n      }\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL29mZmNhbnZhcy5qcz8wZmRkIl0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiaW5pdE9mZmNhbnZhcyIsImRvY3VtZW50Iiwib24iLCJ0YXJnZXQiLCJkYXRhIiwib2ZmY2FudmFzIiwidW5kZWZpbmVkIiwibGVuZ3RoIiwiaGFzQ2xhc3MiLCJyZW1vdmUiLCJyZW1vdmVDbGFzcyIsImJlZm9yZSIsImFkZENsYXNzIiwic2V0VGltZW91dCIsImZpbmQiLCJmb2N1cyIsImUiLCJrZXlDb2RlIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLGFBQUwsR0FBcUIsWUFBVztBQUU5QjtBQUNKO0FBQ0E7QUFDSUYsSUFBQUEsQ0FBQyxDQUFDRyxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLE9BQWYsRUFBd0IsMkJBQXhCLEVBQXFELFlBQVc7QUFDOUQsVUFBSUMsTUFBTSxHQUFPTCxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFNLElBQVIsQ0FBYSxRQUFiLENBQWpCO0FBQUEsVUFDSUMsU0FBUyxHQUFJUCxDQUFDLENBQUNLLE1BQUQsQ0FEbEI7O0FBR0EsVUFBS0EsTUFBTSxLQUFLRyxTQUFYLElBQXdCRCxTQUFTLENBQUNFLE1BQXZDLEVBQWdEO0FBQzlDLFlBQUlGLFNBQVMsQ0FBQ0csUUFBVixDQUFtQixNQUFuQixDQUFKLEVBQWdDO0FBQzlCVixVQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QlcsTUFBekI7QUFDQUosVUFBQUEsU0FBUyxDQUFDSyxXQUFWLENBQXNCLE1BQXRCO0FBQ0QsU0FIRCxNQUlLO0FBQ0hMLFVBQUFBLFNBQVMsQ0FBQ00sTUFBVixDQUFpQixpREFBakI7QUFDQU4sVUFBQUEsU0FBUyxDQUFDTyxRQUFWLENBQW1CLE1BQW5CO0FBQ0FDLFVBQUFBLFVBQVUsQ0FBQyxZQUFXO0FBQUVSLFlBQUFBLFNBQVMsQ0FBQ1MsSUFBVixDQUFlLDBCQUFmLEVBQTJDQyxLQUEzQztBQUFxRCxXQUFuRSxFQUFxRSxHQUFyRSxDQUFWO0FBQ0Q7QUFDRjtBQUNGLEtBZkQ7QUFrQkE7QUFDSjtBQUNBOztBQUNJakIsSUFBQUEsQ0FBQyxDQUFDRyxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLE9BQWYsRUFBd0IsZ0RBQXhCLEVBQTBFLFlBQVc7QUFDbkZKLE1BQUFBLENBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCWSxXQUFyQixDQUFpQyxNQUFqQztBQUNBWixNQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QlcsTUFBekI7QUFDRCxLQUhEO0FBTUE7QUFDSjtBQUNBOztBQUNJWCxJQUFBQSxDQUFDLENBQUNHLFFBQUQsQ0FBRCxDQUFZQyxFQUFaLENBQWUsT0FBZixFQUF3QixVQUFTYyxDQUFULEVBQVk7QUFDbEMsVUFBSWxCLENBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCUyxNQUFyQixJQUErQlMsQ0FBQyxDQUFDQyxPQUFGLElBQWEsRUFBaEQsRUFBb0Q7QUFBRTtBQUNwRG5CLFFBQUFBLENBQUMsQ0FBQyxpQkFBRCxDQUFELENBQXFCWSxXQUFyQixDQUFpQyxNQUFqQztBQUNBWixRQUFBQSxDQUFDLENBQUMscUJBQUQsQ0FBRCxDQUF5QlcsTUFBekI7QUFDRDtBQUNGLEtBTEQ7QUFNRCxHQXpDRDtBQTJDRCxDQTdDQSxDQTZDQ1MsTUE3Q0QsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBBbGwgdGhlIHBvcHVwIHJlbGF0ZWQgbWV0aG9kcy5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0T2ZmY2FudmFzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVcbiAgICAgKi9cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnW2RhdGEtdG9nZ2xlPVwib2ZmY2FudmFzXCJdJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFyZ2V0ICAgICA9ICQodGhpcykuZGF0YSgndGFyZ2V0JyksXG4gICAgICAgICAgb2ZmY2FudmFzICA9ICQodGFyZ2V0KTtcblxuICAgICAgaWYgKCB0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZjYW52YXMubGVuZ3RoICkge1xuICAgICAgICBpZiAob2ZmY2FudmFzLmhhc0NsYXNzKCdzaG93JykpIHtcbiAgICAgICAgICAkKCcuYmFja2Ryb3Atb2ZmY2FudmFzJykucmVtb3ZlKCk7XG4gICAgICAgICAgb2ZmY2FudmFzLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgb2ZmY2FudmFzLmJlZm9yZSgnPGRpdiBjbGFzcz1cImJhY2tkcm9wIGJhY2tkcm9wLW9mZmNhbnZhc1wiPjwvZGl2PicpO1xuICAgICAgICAgIG9mZmNhbnZhcy5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IG9mZmNhbnZhcy5maW5kKCdpbnB1dDp0ZXh0OnZpc2libGU6Zmlyc3QnKS5mb2N1cygpOyB9LCAzMDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8qKlxuICAgICAqIERpc21pc3NcbiAgICAgKi9cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLm9mZmNhbnZhcyBbZGF0YS1kaXNtaXNzXSwgLmJhY2tkcm9wLW9mZmNhbnZhcycsIGZ1bmN0aW9uKCkge1xuICAgICAgJCgnLm9mZmNhbnZhcy5zaG93JykucmVtb3ZlQ2xhc3MoJ3Nob3cnKTtcbiAgICAgICQoJy5iYWNrZHJvcC1vZmZjYW52YXMnKS5yZW1vdmUoKTtcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogRXNjIGtleVxuICAgICAqL1xuICAgICQoZG9jdW1lbnQpLm9uKCdrZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICgkKCcub2ZmY2FudmFzLnNob3cnKS5sZW5ndGggJiYgZS5rZXlDb2RlID09IDI3KSB7IC8vIGVzYyBrZXljb2RlXG4gICAgICAgICQoJy5vZmZjYW52YXMuc2hvdycpLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgICAgICQoJy5iYWNrZHJvcC1vZmZjYW52YXMnKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59KGpRdWVyeSk7XG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9vZmZjYW52YXMuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/offcanvas.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/popup.js":
/*!***********************************************!*\
  !*** ./resources/plugin/js/partials/popup.js ***!
  \***********************************************/
/***/ (() => {

eval("/**\n * All the popup related methods.\n */\n+function ($) {\n  page.initPopup = function () {\n    var body = page.body;\n    /**\n     * Toggle\n     */\n\n    $(document).on('click', '[data-toggle=\"popup\"]', function () {\n      var target = $(this).data('target'),\n          popup = $(target);\n\n      if (target !== undefined && popup.length) {\n        if (popup.hasClass('show')) {\n          popup.removeClass('show');\n        } else {\n          popupShow(popup);\n        }\n      }\n    });\n    /**\n     * Dismiss\n     */\n\n    $(document).on('click', '.popup [data-dismiss]', function () {\n      $(this).closest('.popup').removeClass('show');\n    });\n    /**\n     * Autoshow\n     */\n\n    $('.popup[data-autoshow]').each(function () {\n      var popup = $(this),\n          delay = parseInt(popup.dataAttr('autoshow'));\n      setTimeout(function () {\n        popupShow(popup);\n      }, delay);\n    });\n    /**\n     * Exit\n     */\n\n    $('.popup[data-exitshow]').each(function () {\n      var popup = $(this),\n          delay = parseInt(popup.dataAttr('delay', 0)),\n          target = popup.dataAttr('exitshow');\n\n      if ($(target).length) {\n        $(document).one('mouseleave', target, function () {\n          setTimeout(function () {\n            popupShow(popup);\n          }, delay);\n        });\n      }\n    });\n    /**\n     * Show\n     */\n\n    var popupShow = function popupShow(popup) {\n      var autohide = parseInt(popup.dataAttr('autohide', 0)),\n          once_key = popup.dataAttr('once', ''); // Check if it was a once popup\n\n      if (once_key != '') {\n        if (localStorage.getItem(once_key) == 'displayed') {\n          return;\n        }\n\n        var once_btn = popup.find('[data-once-button=\"true\"]');\n\n        if (once_btn.length) {\n          once_btn.on('click', function () {\n            localStorage.setItem(once_key, 'displayed');\n          });\n        } else {\n          localStorage.setItem(once_key, 'displayed');\n        }\n      }\n\n      popup.addClass('show');\n      setTimeout(function () {\n        popup.find('input:text:visible:first').focus();\n      }, 300);\n\n      if (autohide > 0) {\n        setTimeout(function () {\n          popup.removeClass('show');\n        }, autohide);\n      }\n    };\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3BvcHVwLmpzPzJhNjciXSwibmFtZXMiOlsiJCIsInBhZ2UiLCJpbml0UG9wdXAiLCJib2R5IiwiZG9jdW1lbnQiLCJvbiIsInRhcmdldCIsImRhdGEiLCJwb3B1cCIsInVuZGVmaW5lZCIsImxlbmd0aCIsImhhc0NsYXNzIiwicmVtb3ZlQ2xhc3MiLCJwb3B1cFNob3ciLCJjbG9zZXN0IiwiZWFjaCIsImRlbGF5IiwicGFyc2VJbnQiLCJkYXRhQXR0ciIsInNldFRpbWVvdXQiLCJvbmUiLCJhdXRvaGlkZSIsIm9uY2Vfa2V5IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIm9uY2VfYnRuIiwiZmluZCIsInNldEl0ZW0iLCJhZGRDbGFzcyIsImZvY3VzIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLFNBQUwsR0FBaUIsWUFBVztBQUMxQixRQUFJQyxJQUFJLEdBQUdGLElBQUksQ0FBQ0UsSUFBaEI7QUFHQTtBQUNKO0FBQ0E7O0FBQ0lILElBQUFBLENBQUMsQ0FBQ0ksUUFBRCxDQUFELENBQVlDLEVBQVosQ0FBZSxPQUFmLEVBQXdCLHVCQUF4QixFQUFpRCxZQUFXO0FBQzFELFVBQUlDLE1BQU0sR0FBR04sQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRTyxJQUFSLENBQWEsUUFBYixDQUFiO0FBQUEsVUFDSUMsS0FBSyxHQUFJUixDQUFDLENBQUNNLE1BQUQsQ0FEZDs7QUFHQSxVQUFLQSxNQUFNLEtBQUtHLFNBQVgsSUFBd0JELEtBQUssQ0FBQ0UsTUFBbkMsRUFBNEM7QUFDMUMsWUFBSUYsS0FBSyxDQUFDRyxRQUFOLENBQWUsTUFBZixDQUFKLEVBQTRCO0FBQzFCSCxVQUFBQSxLQUFLLENBQUNJLFdBQU4sQ0FBa0IsTUFBbEI7QUFDRCxTQUZELE1BR0s7QUFDSEMsVUFB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QUcsQ0FBZixFQUFrQjtBQUNoQkYsUUFBQUEsVUFBVSxDQUFFLFlBQVc7QUFBRVgsVUFBQUEsS0FBSyxDQUFDSSxXQUFOLENBQWtCLE1BQWxCO0FBQTJCLFNBQTFDLEVBQTRDUyxRQUE1QyxDQUFWO0FBQ0Q7QUFDRixLQTVCRDtBQTZCRCxHQXpGRDtBQTJGRCxDQTdGQSxDQTZGQ1MsTUE3RkQsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBBbGwgdGhlIHBvcHVwIHJlbGF0ZWQgbWV0aG9kcy5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0UG9wdXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keSA9IHBhZ2UuYm9keTtcblxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlXG4gICAgICovXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJ1tkYXRhLXRvZ2dsZT1cInBvcHVwXCJdJywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gJCh0aGlzKS5kYXRhKCd0YXJnZXQnKSxcbiAgICAgICAgICBwb3B1cCAgPSAkKHRhcmdldCk7XG5cbiAgICAgIGlmICggdGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgcG9wdXAubGVuZ3RoICkge1xuICAgICAgICBpZiAocG9wdXAuaGFzQ2xhc3MoJ3Nob3cnKSkge1xuICAgICAgICAgIHBvcHVwLnJlbW92ZUNsYXNzKCdzaG93Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcG9wdXBTaG93KHBvcHVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBEaXNtaXNzXG4gICAgICovXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5wb3B1cCBbZGF0YS1kaXNtaXNzXScsIGZ1bmN0aW9uKCkge1xuICAgICAgJCh0aGlzKS5jbG9zZXN0KCcucG9wdXAnKS5yZW1vdmVDbGFzcygnc2hvdycpO1xuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2hvd1xuICAgICAqL1xuICAgICQoJy5wb3B1cFtkYXRhLWF1dG9zaG93XScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwb3B1cCA9ICQodGhpcyksXG4gICAgICAgICAgZGVsYXkgPSBwYXJzZUludCggcG9wdXAuZGF0YUF0dHIoJ2F1dG9zaG93JykgKTtcbiAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyBwb3B1cFNob3cocG9wdXApIH0sIGRlbGF5KTtcbiAgICB9KTtcblxuXG4gICAgLyoqXG4gICAgICogRXhpdFxuICAgICAqL1xuICAgICQoJy5wb3B1cFtkYXRhLWV4aXRzaG93XScpLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwb3B1cCAgPSAkKHRoaXMpLFxuICAgICAgICAgIGRlbGF5ICA9IHBhcnNlSW50KCBwb3B1cC5kYXRhQXR0cignZGVsYXknLCAwKSApLFxuICAgICAgICAgIHRhcmdldCA9IHBvcHVwLmRhdGFBdHRyKCdleGl0c2hvdycpO1xuXG4gICAgICBpZiAoICQodGFyZ2V0KS5sZW5ndGggKSB7XG4gICAgICAgICQoZG9jdW1lbnQpLm9uZSgnbW91c2VsZWF2ZScsIHRhcmdldCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IHBvcHVwU2hvdyhwb3B1cCkgfSwgZGVsYXkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICAvKipcbiAgICAgKiBTaG93XG4gICAgICovXG4gICAgdmFyIHBvcHVwU2hvdyA9IGZ1bmN0aW9uKHBvcHVwKSB7XG5cbiAgICAgIHZhciBhdXRvaGlkZSA9IHBhcnNlSW50KCBwb3B1cC5kYXRhQXR0cignYXV0b2hpZGUnLCAwKSApLFxuICAgICAgICAgIG9uY2Vfa2V5ID0gcG9wdXAuZGF0YUF0dHIoJ29uY2UnLCAnJyk7XG5cbiAgICAgIC8vIENoZWNrIGlmIGl0IHdhcyBhIG9uY2UgcG9wdXBcbiAgICAgIGlmIChvbmNlX2tleSAhPSAnJykge1xuICAgICAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0ob25jZV9rZXkpID09ICdkaXNwbGF5ZWQnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9uY2VfYnRuID0gcG9wdXAuZmluZCgnW2RhdGEtb25jZS1idXR0b249XCJ0cnVlXCJdJyk7XG4gICAgICAgIGlmIChvbmNlX2J0bi5sZW5ndGgpIHtcbiAgICAgICAgICBvbmNlX2J0bi5vbignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG9uY2Vfa2V5LCAnZGlzcGxheWVkJyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0ob25jZV9rZXksICdkaXNwbGF5ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwb3B1cC5hZGRDbGFzcygnc2hvdycpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgcG9wdXAuZmluZCgnaW5wdXQ6dGV4dDp2aXNpYmxlOmZpcnN0JykuZm9jdXMoKTsgfSwgMzAwKTtcblxuICAgICAgaWYgKGF1dG9oaWRlID4gMCkge1xuICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgcG9wdXAucmVtb3ZlQ2xhc3MoJ3Nob3cnKSB9LCBhdXRvaGlkZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn0oalF1ZXJ5KTtcbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3BvcHVwLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/popup.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/recaptcha.js":
/*!***************************************************!*\
  !*** ./resources/plugin/js/partials/recaptcha.js ***!
  \***************************************************/
/***/ (() => {

eval("/**\n *\n */\n+function ($) {\n  page.initRecaptcha = function () {\n    $('[data-provide~=\"recaptcha\"]').each(function () {\n      var options = {\n        sitekey: page.defaults.reCaptchaSiteKey\n      };\n      options = $.extend(options, page.getDataOptions($(this)));\n\n      if (options.enable) {\n        options.callback = function () {\n          $(options.enable).removeAttr('disabled');\n        };\n\n        options['expired-callback'] = function () {\n          $(options.enable).attr('disabled', 'true');\n        };\n\n        $(this).closest('form').on('submit', function (e) {\n          if ($(this).find(options.enable).attr('disabled') === 'true') {\n            e.preventDefault();\n            e.stopPropagation();\n          }\n        });\n      }\n\n      grecaptcha.render($(this)[0], options);\n    });\n  };\n\n  window.recaptchaLoadCallback = function () {\n    page.initRecaptcha();\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3JlY2FwdGNoYS5qcz9lNjIzIl0sIm5hbWVzIjpbIiQiLCJwYWdlIiwiaW5pdFJlY2FwdGNoYSIsImVhY2giLCJvcHRpb25zIiwic2l0ZWtleSIsImRlZmF1bHRzIiwicmVDYXB0Y2hhU2l0ZUtleSIsImV4dGVuZCIsImdldERhdGFPcHRpb25zIiwiZW5hYmxlIiwiY2FsbGJhY2siLCJyZW1vdmVBdHRyIiwiYXR0ciIsImNsb3Nlc3QiLCJvbiIsImUiLCJmaW5kIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJncmVjYXB0Y2hhIiwicmVuZGVyIiwid2luZG93IiwicmVjYXB0Y2hhTG9hZENhbGxiYWNrIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLGFBQUwsR0FBcUIsWUFBVztBQUM5QkYsSUFBQUEsQ0FBQyxDQUFDLDZCQUFELENBQUQsQ0FBaUNHLElBQWpDLENBQXNDLFlBQVc7QUFFL0MsVUFBSUMsT0FBTyxHQUFHO0FBQ1pDLFFBQUFBLE9BQU8sRUFBRUosSUFBSSxDQUFDSyxRQUFMLENBQWNDO0FBRFgsT0FBZDtBQUlBSCxNQUFBQSxPQUFPLEdBQUdKLENBQUMsQ0FBQ1EsTUFBRixDQUFTSixPQUFULEVBQWtCSCxJQUFJLENBQUNRLGNBQUwsQ0FBb0JULENBQUMsQ0FBQyxJQUFELENBQXJCLENBQWxCLENBQVY7O0FBRUEsVUFBSUksT0FBTyxDQUFDTSxNQUFaLEVBQW9CO0FBQ2xCTixRQUFBQSxPQUFPLENBQUNPLFFBQVIsR0FBbUIsWUFBVztBQUM1QlgsVUFBQUEsQ0FBQyxDQUFDSSxPQUFPLENBQUNNLE1BQVQsQ0FBRCxDQUFrQkUsVUFBbEIsQ0FBNkIsVUFBN0I7QUFDRCxTQUZEOztBQUlBUixRQUFBQSxPQUFPLENBQUMsa0JBQUQsQ0FBUCxHQUE4QixZQUFXO0FBQ3ZDSixVQUFBQSxDQUFDLENBQUNJLE9BQU8sQ0FBQ00sTUFBVCxDQUFELENBQWtCRyxJQUFsQixDQUF1QixVQUF2QixFQUFtQyxNQUFuQztBQUNELFNBRkQ7O0FBSUFiLFFBQUFBLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUWMsT0FBUixDQUFnQixNQUFoQixFQUF3QkMsRUFBeEIsQ0FBMkIsUUFBM0IsRUFBcUMsVUFBU0MsQ0FBVCxFQUFZO0FBQy9DLGNBQUtoQixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFpQixJQUFSLENBQWNiLE9BQU8sQ0FBQ00sTUFBdEIsRUFBK0JHLElBQS9CLENBQW9DLFVBQXBDLE1BQW9ELE1BQXpELEVBQWtFO0FBQ2hFRyxZQUFBQSxDQUFDLENBQUNFLGNBQUY7QUFDQUYsWUFBQUEsQ0FBQyxDQUFDRyxlQUFGO0FBQ0Q7QUFDRixTQUxEO0FBTUQ7O0FBRURDLE1BQUFBLFVBQVUsQ0FBQ0MsTUFBWCxDQUFtQnJCLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUSxDQUFSLENBQW5CLEVBQStCSSxPQUEvQjtBQUNELEtBMUJEO0FBMkJELEdBNUJEOztBQThCQWtCLEVBQUFBLE1BQU0sQ0FBQ0MscUJBQVAsR0FBK0IsWUFBVztBQUN4Q3RCLElBQUFBLElBQUksQ0FBQ0MsYUFBTDtBQUNELEdBRkQ7QUFLRCxDQXJDQSxDQXFDQ3NCLE1BckNELENBQUQiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICpcbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0UmVjYXB0Y2hhID0gZnVuY3Rpb24oKSB7XG4gICAgJCgnW2RhdGEtcHJvdmlkZX49XCJyZWNhcHRjaGFcIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgc2l0ZWtleTogcGFnZS5kZWZhdWx0cy5yZUNhcHRjaGFTaXRlS2V5XG4gICAgICB9XG5cbiAgICAgIG9wdGlvbnMgPSAkLmV4dGVuZChvcHRpb25zLCBwYWdlLmdldERhdGFPcHRpb25zKCQodGhpcykpKTtcblxuICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlKSB7XG4gICAgICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkKG9wdGlvbnMuZW5hYmxlKS5yZW1vdmVBdHRyKCdkaXNhYmxlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0aW9uc1snZXhwaXJlZC1jYWxsYmFjayddID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJChvcHRpb25zLmVuYWJsZSkuYXR0cignZGlzYWJsZWQnLCAndHJ1ZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgJCh0aGlzKS5jbG9zZXN0KCdmb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoICQodGhpcykuZmluZCggb3B0aW9ucy5lbmFibGUgKS5hdHRyKCdkaXNhYmxlZCcpID09PSAndHJ1ZScgKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGdyZWNhcHRjaGEucmVuZGVyKCAkKHRoaXMpWzBdLCBvcHRpb25zKTtcbiAgICB9KTtcbiAgfVxuXG4gIHdpbmRvdy5yZWNhcHRjaGFMb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICBwYWdlLmluaXRSZWNhcHRjaGEoKTtcbiAgfVxuXG5cbn0oalF1ZXJ5KTtcblxuIl0sImZpbGUiOiIuL3Jlc291cmNlcy9wbHVnaW4vanMvcGFydGlhbHMvcmVjYXB0Y2hhLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/recaptcha.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/scroll.js":
/*!************************************************!*\
  !*** ./resources/plugin/js/partials/scroll.js ***!
  \************************************************/
/***/ (() => {

eval("/**\n * All methods related to the page scroll and link click.\n */\n+function ($) {\n  var body = page.body,\n      footer = page.footer,\n      hasHeader = page.header.length,\n      navbarHeight = page.navbar.outerHeight(),\n      headerHeight = page.header.innerHeight(),\n      scrollOffsetTop = 0,\n      prevOffsetTop = 0;\n\n  page.initScroll = function () {\n    if ($('[data-navbar=\"fixed\"], [data-navbar=\"sticky\"], [data-navbar=\"smart\"]').length) {\n      scrollOffsetTop = navbarHeight;\n    }\n\n    $(document).on('click', \"a[href='#']\", function () {\n      return false;\n    }); // Back to top\n    //\n\n    $(document).on('click', '.scroll-top', function () {\n      smoothlyScrollTo(0);\n      return false;\n    }); // Smooth scroll for anchors\n    //\n\n    $(document).on('click', \"a[href^='#']\", function () {\n      if ($(this).attr('href').length < 2) {\n        return;\n      }\n\n      if ($(this)[0].hasAttribute('data-toggle')) {\n        return;\n      }\n\n      var target = $($(this).attr('href'));\n\n      if (target.length) {\n        var targetTop = target.offset().top,\n            windowTop = $(window).scrollTop(); // We don't need offsetTop for scroll down with smart navbar\n        //\n\n        if (targetTop > windowTop && $('.navbar[data-navbar=\"smart\"]').length) {\n          smoothlyScrollTo(targetTop);\n        } else {\n          smoothlyScrollTo(targetTop - scrollOffsetTop);\n        }\n\n        if (body.hasClass('navbar-open')) {\n          page.navbarClose();\n        }\n\n        return false;\n      }\n    }); // Smoothscroll to anchor in page load\n    //\n\n    var hash = location.hash.replace('#', '');\n\n    if (hash != '') {\n      var el = $(\"#\" + hash);\n\n      if (el.length > 0) {\n        smoothlyScrollTo(el.offset().top - scrollOffsetTop);\n      }\n    } // Actions which are related to the page scroll position\n\n\n    windowScrollActions();\n    $(window).on('scroll', function () {\n      windowScrollActions();\n    }); // In page navigation\n    //\n\n    if ($('.nav-page').length) {\n      var tooltip_pos = 'left',\n          tooltip_offset = '0, 12';\n\n      if ($('.nav-page.nav-page-left').length) {\n        tooltip_pos = 'right';\n        tooltip_offset = '0, 12';\n      }\n\n      var spy_offset = parseInt($('.nav-page').dataAttr('spy-offset', 200)); // Enable tooltip\n\n      $('.nav-page .nav-link').tooltip({\n        container: 'body',\n        placement: tooltip_pos,\n        offset: tooltip_offset,\n        trigger: 'hover'\n      }); // Enable Scroll Spy\n\n      $('body').scrollspy({\n        target: '.nav-page',\n        offset: spy_offset\n      });\n    } // Sticky sidebar width\n    //\n\n\n    $('.sidebar-sticky').each(function () {\n      var tag = $(this),\n          width = tag.closest('div').width();\n      tag.css('width', width);\n\n      if (body.width() / width < 1.8) {\n        tag.addClass('is-mobile-wide');\n      }\n    });\n  };\n\n  var windowScrollActions = function windowScrollActions() {\n    var window_top = $(window).scrollTop(); // .body-scrolled\n    //\n\n    if (window_top > 1) {\n      body.addClass('body-scrolled');\n    } else {\n      body.removeClass('body-scrolled');\n    } // .navbar-scrolled\n    //\n\n\n    if (window_top > navbarHeight) {\n      body.addClass('navbar-scrolled');\n    } else {\n      body.removeClass('navbar-scrolled');\n    } // .header-scrolled\n    //\n\n\n    if (window_top > headerHeight - navbarHeight - 1) {\n      body.addClass('header-scrolled');\n    } else {\n      body.removeClass('header-scrolled');\n    } // Sticky elements\n    //\n\n\n    $('[data-sticky=\"true\"]').each(function () {\n      var tag = $(this),\n          top = tag.offset().top;\n\n      if (!tag.hasDataAttr('original-top')) {\n        tag.attr('data-original-top', top);\n      }\n\n      var stick_start = tag.dataAttr('original-top'),\n          stick_end = footer.offset().top - tag.outerHeight();\n\n      if (window_top > stick_start) {\n        // && window_top <= stick_end) {\n        tag.addClass('stick');\n      } else {\n        tag.removeClass('stick');\n      }\n    }); // Smart navbar\n    //\n\n    $('[data-navbar=\"smart\"]').each(function () {\n      var tag = $(this); //toggleFixClass(tag);\n\n      if (window_top < prevOffsetTop) {\n        toggleStickClass(tag);\n      } else {\n        tag.removeClass('stick');\n      }\n    }); // Sticky navbar\n    //\n\n    $('[data-navbar=\"sticky\"]').each(function () {\n      var tag = $(this);\n      toggleStickClass(tag);\n    }); // Fixed navbar\n    //\n\n    $('[data-navbar=\"fixed\"]').each(function () {\n      var tag = $(this);\n\n      if (body.hasClass('body-scrolled')) {\n        tag.addClass('stick');\n      } else {\n        tag.removeClass('stick');\n      }\n    }); // Sticky sidebar\n    //\n\n    $('.sidebar-sticky').each(function () {\n      var tag = $(this);\n      toggleStickClass(tag);\n    }); // Fadeout effect\n    //\n\n    $('.header.fadeout').css('opacity', 1 - window_top - 200 / window.innerHeight);\n    prevOffsetTop = window_top;\n  };\n\n  var smoothlyScrollTo = function smoothlyScrollTo(pos) {\n    $('html, body').animate({\n      scrollTop: pos\n    }, 600);\n  };\n\n  var toggleFixClass = function toggleFixClass(tag) {\n    if (body.hasClass('navbar-scrolled')) {\n      tag.addClass('fix');\n    } else {\n      tag.removeClass('fix');\n    }\n  };\n\n  var toggleStickClass = function toggleStickClass(tag) {\n    var requiredClass = 'navbar-scrolled';\n\n    if (hasHeader) {\n      requiredClass = 'header-scrolled';\n    }\n\n    if (body.hasClass(requiredClass)) {\n      tag.addClass('stick');\n    } else {\n      tag.removeClass('stick');\n    }\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3Njcm9sbC5qcz8yNTEwIl0sIm5hbWVzIjpbIiQiLCJib2R5IiwicGFnZSIsImZvb3RlciIsImhhc0hlYWRlciIsImhlYWRlciIsImxlbmd0aCIsIm5hdmJhckhlaWdodCIsIm5hdmJhciIsIm91dGVySGVpZ2h0IiwiaGVhZGVySGVpZ2h0IiwiaW5uZXJIZWlnaHQiLCJzY3JvbGxPZmZzZXRUb3AiLCJwcmV2T2Zmc2V0VG9wIiwiaW5pdFNjcm9sbCIsImRvY3VtZW50Iiwib24iLCJzbW9vdGhseVNjcm9sbFRvIiwiYXR0ciIsImhhc0F0dHJpYnV0ZSIsInRhcmdldCIsInRhcmdldFRvcCIsIm9mZnNldCIsInRvcCIsIndpbmRvd1RvcCIsIndpbmRvdyIsInNjcm9sbFRvcCIsImhhc0NsYXNzIiwibmF2YmFyQ2xvc2UiLCJoYXNoIiwibG9jYXRpb24iLCJyZXBsYWNlIiwiZWwiLCJ3aW5kb3dTY3JvbGxBY3Rpb25zIiwidG9vbHRpcF9wb3MiLCJ0b29sdGlwX29mZnNldCIsInNweV9vZmZzZXQiLCJwYXJzZUludCIsImRhdGFBdHRyIiwidG9vbHRpcCIsImNvbnRhaW5lciIsInBsYWNlbWVudCIsInRyaWdnZXIiLCJzY3JvbGxzcHkiLCJlYWNoIiwidGFnIiwid2lkdGgiLCJjbG9zZXN0IiwiY3NzIiwiYWRkQ2xhc3MiLCJ3aW5kb3dfdG9wIiwicmVtb3ZlQ2xhc3MiLCJoYXNEYXRhQXR0ciIsInN0aWNrX3N0YXJ0Iiwic3RpY2tfZW5kIiwidG9nZ2xlU3RpY2tDbGFzcyIsInBvcyIsImFuaW1hdGUiLCJ0b2dnbGVGaXhDbGFzcyIsInJlcXVpcmVkQ2xhc3MiLCJqUXVlcnkiXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUVBLENBQUMsVUFBU0EsQ0FBVCxFQUFXO0FBRVYsTUFBSUMsSUFBSSxHQUFHQyxJQUFJLENBQUNELElBQWhCO0FBQUEsTUFDSUUsTUFBTSxHQUFHRCxJ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QVNiLEdBQVQsRUFBYztBQUNqQyxRQUFJNUMsSUFBSSxDQUFDMEIsUUFBTCxDQUFjLGlCQUFkLENBQUosRUFBc0M7QUFDcENrQixNQUFBQSxHQUFHLENBQUNJLFFBQUosQ0FBYSxLQUFiO0FBQ0QsS0FGRCxNQUdLO0FBQ0hKLE1BQUFBLEdBQUcsQ0FBQ00sV0FBSixDQUFnQixLQUFoQjtBQUNEO0FBQ0YsR0FQRDs7QUFTQSxNQUFJSSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQVNWLEdBQVQsRUFBYztBQUNuQyxRQUFJYyxhQUFhLEdBQUcsaUJBQXBCOztBQUNBLFFBQUt2RCxTQUFMLEVBQWlCO0FBQ2Z1RCxNQUFBQSxhQUFhLEdBQUcsaUJBQWhCO0FBQ0Q7O0FBRUQsUUFBSTFELElBQUksQ0FBQzBCLFFBQUwsQ0FBY2dDLGFBQWQsQ0FBSixFQUFrQztBQUNoQ2QsTUFBQUEsR0FBRyxDQUFDSSxRQUFKLENBQWEsT0FBYjtBQUNELEtBRkQsTUFHSztBQUNISixNQUFBQSxHQUFHLENBQUNNLFdBQUosQ0FBZ0IsT0FBaEI7QUFDRDtBQUNGLEdBWkQ7QUFjRCxDQXBRQSxDQW9RQ1MsTUFwUUQsQ0FBRCIsInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBBbGwgbWV0aG9kcyByZWxhdGVkIHRvIHRoZSBwYWdlIHNjcm9sbCBhbmQgbGluayBjbGljay5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgdmFyIGJvZHkgPSBwYWdlLmJvZHksXG4gICAgICBmb290ZXIgPSBwYWdlLmZvb3RlcixcbiAgICAgIGhhc0hlYWRlciA9IHBhZ2UuaGVhZGVyLmxlbmd0aCxcbiAgICAgIG5hdmJhckhlaWdodCA9IHBhZ2UubmF2YmFyLm91dGVySGVpZ2h0KCksXG4gICAgICBoZWFkZXJIZWlnaHQgPSBwYWdlLmhlYWRlci5pbm5lckhlaWdodCgpLFxuICAgICAgc2Nyb2xsT2Zmc2V0VG9wID0gMCxcbiAgICAgIHByZXZPZmZzZXRUb3AgPSAwO1xuXG4gIHBhZ2UuaW5pdFNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuXG5cbiAgICBpZiAoICQoJ1tkYXRhLW5hdmJhcj1cImZpeGVkXCJdLCBbZGF0YS1uYXZiYXI9XCJzdGlja3lcIl0sIFtkYXRhLW5hdmJhcj1cInNtYXJ0XCJdJykubGVuZ3RoICkge1xuICAgICAgc2Nyb2xsT2Zmc2V0VG9wID0gbmF2YmFySGVpZ2h0O1xuICAgIH1cblxuICAgICQoZG9jdW1lbnQpLm9uKCAnY2xpY2snLCBcImFbaHJlZj0nIyddXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG5cbiAgICAvLyBCYWNrIHRvIHRvcFxuICAgIC8vXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5zY3JvbGwtdG9wJywgZnVuY3Rpb24oKSB7XG4gICAgICBzbW9vdGhseVNjcm9sbFRvKDApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG5cbiAgICAvLyBTbW9vdGggc2Nyb2xsIGZvciBhbmNob3JzXG4gICAgLy9cbiAgICAkKGRvY3VtZW50KS5vbiggJ2NsaWNrJywgXCJhW2hyZWZePScjJ11cIiwgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoICQodGhpcykuYXR0cignaHJlZicpLmxlbmd0aCA8IDIgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCAkKHRoaXMpWzBdLmhhc0F0dHJpYnV0ZSgnZGF0YS10b2dnbGUnKSApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gJCggJCh0aGlzKS5hdHRyKCdocmVmJykgKTtcbiAgICAgIGlmICggdGFyZ2V0Lmxlbmd0aCApIHtcbiAgICAgICAgdmFyIHRhcmdldFRvcCA9IHRhcmdldC5vZmZzZXQoKS50b3AsXG4gICAgICAgICAgICB3aW5kb3dUb3AgPSAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBvZmZzZXRUb3AgZm9yIHNjcm9sbCBkb3duIHdpdGggc21hcnQgbmF2YmFyXG4gICAgICAgIC8vXG4gICAgICAgIGlmICggdGFyZ2V0VG9wID4gd2luZG93VG9wICYmICQoJy5uYXZiYXJbZGF0YS1uYXZiYXI9XCJzbWFydFwiXScpLmxlbmd0aCApIHtcbiAgICAgICAgICBzbW9vdGhseVNjcm9sbFRvKCB0YXJnZXRUb3AgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzbW9vdGhseVNjcm9sbFRvKCB0YXJnZXRUb3AgLSBzY3JvbGxPZmZzZXRUb3AgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5Lmhhc0NsYXNzKCduYXZiYXItb3BlbicpKSB7XG4gICAgICAgICAgcGFnZS5uYXZiYXJDbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gU21vb3Roc2Nyb2xsIHRvIGFuY2hvciBpbiBwYWdlIGxvYWRcbiAgICAvL1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaC5yZXBsYWNlKCcjJywnJyk7XG4gICAgaWYgKCBoYXNoICE9ICcnICkge1xuICAgICAgdmFyIGVsID0gJChcIiNcIitoYXNoKTtcbiAgICAgIGlmIChlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNtb290aGx5U2Nyb2xsVG8oIGVsLm9mZnNldCgpLnRvcCAtIHNjcm9sbE9mZnNldFRvcCApO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gQWN0aW9ucyB3aGljaCBhcmUgcmVsYXRlZCB0byB0aGUgcGFnZSBzY3JvbGwgcG9zaXRpb25cbiAgICB3aW5kb3dTY3JvbGxBY3Rpb25zKCk7XG5cbiAgICAkKHdpbmRvdykub24oJ3Njcm9sbCcsIGZ1bmN0aW9uKCkge1xuICAgICAgd2luZG93U2Nyb2xsQWN0aW9ucygpXG4gICAgfSk7XG5cblxuXG4gICAgLy8gSW4gcGFnZSBuYXZpZ2F0aW9uXG4gICAgLy9cbiAgICBpZiAoICQoJy5uYXYtcGFnZScpLmxlbmd0aCApIHtcblxuICAgICAgdmFyIHRvb2x0aXBfcG9zID0gJ2xlZnQnLFxuICAgICAgICAgIHRvb2x0aXBfb2Zmc2V0ID0gJzAsIDEyJztcblxuICAgICAgaWYgKCAkKCcubmF2LXBhZ2UubmF2LXBhZ2UtbGVmdCcpLmxlbmd0aCApIHtcbiAgICAgICAgdG9vbHRpcF9wb3MgPSAncmlnaHQnO1xuICAgICAgICB0b29sdGlwX29mZnNldCA9ICcwLCAxMic7XG4gICAgICB9XG5cbiAgICAgIHZhciBzcHlfb2Zmc2V0ID0gcGFyc2VJbnQoICQoJy5uYXYtcGFnZScpLmRhdGFBdHRyKCdzcHktb2Zmc2V0JywgMjAwKSApO1xuXG4gICAgICAvLyBFbmFibGUgdG9vbHRpcFxuICAgICAgJCgnLm5hdi1wYWdlIC5uYXYtbGluaycpLnRvb2x0aXAoe1xuICAgICAgICBjb250YWluZXI6ICdib2R5JyxcbiAgICAgICAgcGxhY2VtZW50OiB0b29sdGlwX3BvcyxcbiAgICAgICAgb2Zmc2V0OiB0b29sdGlwX29mZnNldCxcbiAgICAgICAgdHJpZ2dlcjogJ2hvdmVyJ1xuICAgICAgfSk7XG5cblxuICAgICAgLy8gRW5hYmxlIFNjcm9sbCBTcHlcbiAgICAgICQoJ2JvZHknKS5zY3JvbGxzcHkoe1xuICAgICAgICB0YXJnZXQ6ICcubmF2LXBhZ2UnLFxuICAgICAgICBvZmZzZXQ6IHNweV9vZmZzZXRcbiAgICAgIH0pO1xuXG4gICAgfVxuXG5cbiAgICAvLyBTdGlja3kgc2lkZWJhciB3aWR0aFxuICAgIC8vXG4gICAgJCgnLnNpZGViYXItc3RpY2t5JykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YWcgPSAkKHRoaXMpLFxuICAgICAgICAgIHdpZHRoID0gdGFnLmNsb3Nlc3QoJ2RpdicpLndpZHRoKCk7XG4gICAgICB0YWcuY3NzKCd3aWR0aCcsIHdpZHRoKTtcblxuICAgICAgaWYgKGJvZHkud2lkdGgoKSAvIHdpZHRoIDwgMS44KSB7XG4gICAgICAgIHRhZy5hZGRDbGFzcygnaXMtbW9iaWxlLXdpZGUnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cblxuICB2YXIgd2luZG93U2Nyb2xsQWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3aW5kb3dfdG9wID0gJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xuXG4gICAgLy8gLmJvZHktc2Nyb2xsZWRcbiAgICAvL1xuICAgIGlmICh3aW5kb3dfdG9wID4gMSkge1xuICAgICAgYm9keS5hZGRDbGFzcygnYm9keS1zY3JvbGxlZCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGJvZHkucmVtb3ZlQ2xhc3MoJ2JvZHktc2Nyb2xsZWQnKTtcbiAgICB9XG5cbiAgICAvLyAubmF2YmFyLXNjcm9sbGVkXG4gICAgLy9cblxuICAgIGlmICh3aW5kb3dfdG9wID4gbmF2YmFySGVpZ2h0KSB7XG4gICAgICBib2R5LmFkZENsYXNzKCduYXZiYXItc2Nyb2xsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBib2R5LnJlbW92ZUNsYXNzKCduYXZiYXItc2Nyb2xsZWQnKTtcbiAgICB9XG5cblxuICAgIC8vIC5oZWFkZXItc2Nyb2xsZWRcbiAgICAvL1xuICAgIGlmICh3aW5kb3dfdG9wID4gaGVhZGVySGVpZ2h0IC0gbmF2YmFySGVpZ2h0IC0gMSkge1xuICAgICAgYm9keS5hZGRDbGFzcygnaGVhZGVyLXNjcm9sbGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYm9keS5yZW1vdmVDbGFzcygnaGVhZGVyLXNjcm9sbGVkJyk7XG4gICAgfVxuXG4gICAgLy8gU3RpY2t5IGVsZW1lbnRzXG4gICAgLy9cbiAgICAkKCdbZGF0YS1zdGlja3k9XCJ0cnVlXCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YWcgPSAkKHRoaXMpLFxuICAgICAgICAgIHRvcCA9IHRhZy5vZmZzZXQoKS50b3A7XG5cbiAgICAgIGlmICggISB0YWcuaGFzRGF0YUF0dHIoJ29yaWdpbmFsLXRvcCcpICkge1xuICAgICAgICB0YWcuYXR0cignZGF0YS1vcmlnaW5hbC10b3AnLCB0b3ApO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RpY2tfc3RhcnQgPSB0YWcuZGF0YUF0dHIoJ29yaWdpbmFsLXRvcCcpLFxuICAgICAgICAgIHN0aWNrX2VuZCAgID0gZm9vdGVyLm9mZnNldCgpLnRvcCAtIHRhZy5vdXRlckhlaWdodCgpO1xuXG4gICAgICBpZiAod2luZG93X3RvcCA+IHN0aWNrX3N0YXJ0KSB7Ly8gJiYgd2luZG93X3RvcCA8PSBzdGlja19lbmQpIHtcbiAgICAgICAgdGFnLmFkZENsYXNzKCdzdGljaycpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRhZy5yZW1vdmVDbGFzcygnc3RpY2snKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNtYXJ0IG5hdmJhclxuICAgIC8vXG4gICAgJCgnW2RhdGEtbmF2YmFyPVwic21hcnRcIl0nKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhZyA9ICQodGhpcyk7XG5cbiAgICAgIC8vdG9nZ2xlRml4Q2xhc3ModGFnKTtcbiAgICAgIGlmICh3aW5kb3dfdG9wIDwgcHJldk9mZnNldFRvcCkge1xuICAgICAgICB0b2dnbGVTdGlja0NsYXNzKHRhZyk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGFnLnJlbW92ZUNsYXNzKCdzdGljaycpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU3RpY2t5IG5hdmJhclxuICAgIC8vXG4gICAgJCgnW2RhdGEtbmF2YmFyPVwic3RpY2t5XCJdJykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0YWcgPSAkKHRoaXMpO1xuICAgICAgdG9nZ2xlU3RpY2tDbGFzcyh0YWcpO1xuICAgIH0pO1xuXG4gICAgLy8gRml4ZWQgbmF2YmFyXG4gICAgLy9cbiAgICAkKCdbZGF0YS1uYXZiYXI9XCJmaXhlZFwiXScpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGFnID0gJCh0aGlzKTtcbiAgICAgIGlmIChib2R5Lmhhc0NsYXNzKCdib2R5LXNjcm9sbGVkJykpIHtcbiAgICAgICAgdGFnLmFkZENsYXNzKCdzdGljaycpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRhZy5yZW1vdmVDbGFzcygnc3RpY2snKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFN0aWNreSBzaWRlYmFyXG4gICAgLy9cbiAgICAkKCcuc2lkZWJhci1zdGlja3knKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhZyA9ICQodGhpcyk7XG4gICAgICB0b2dnbGVTdGlja0NsYXNzKHRhZyk7XG4gICAgfSk7XG5cbiAgICAvLyBGYWRlb3V0IGVmZmVjdFxuICAgIC8vXG4gICAgJCgnLmhlYWRlci5mYWRlb3V0JykuY3NzKCdvcGFjaXR5JywgKDEtd2luZG93X3RvcC0yMDAgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICk7XG5cblxuICAgIHByZXZPZmZzZXRUb3AgPSB3aW5kb3dfdG9wO1xuICB9XG5cblxuICB2YXIgc21vb3RobHlTY3JvbGxUbyA9IGZ1bmN0aW9uKHBvcykge1xuICAgICQoJ2h0bWwsIGJvZHknKS5hbmltYXRlKHtzY3JvbGxUb3A6IHBvc30sIDYwMCk7XG4gIH1cblxuXG4gIHZhciB0b2dnbGVGaXhDbGFzcyA9IGZ1bmN0aW9uKHRhZykge1xuICAgIGlmIChib2R5Lmhhc0NsYXNzKCduYXZiYXItc2Nyb2xsZWQnKSkge1xuICAgICAgdGFnLmFkZENsYXNzKCdmaXgnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0YWcucmVtb3ZlQ2xhc3MoJ2ZpeCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB0b2dnbGVTdGlja0NsYXNzID0gZnVuY3Rpb24odGFnKSB7XG4gICAgdmFyIHJlcXVpcmVkQ2xhc3MgPSAnbmF2YmFyLXNjcm9sbGVkJztcbiAgICBpZiAoIGhhc0hlYWRlciApIHtcbiAgICAgIHJlcXVpcmVkQ2xhc3MgPSAnaGVhZGVyLXNjcm9sbGVkJztcbiAgICB9XG5cbiAgICBpZiAoYm9keS5oYXNDbGFzcyhyZXF1aXJlZENsYXNzKSkge1xuICAgICAgdGFnLmFkZENsYXNzKCdzdGljaycpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRhZy5yZW1vdmVDbGFzcygnc3RpY2snKTtcbiAgICB9XG4gIH1cblxufShqUXVlcnkpO1xuIl0sImZpbGUiOiIuL3Jlc291cmNlcy9wbHVnaW4vanMvcGFydGlhbHMvc2Nyb2xsLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/scroll.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/section.js":
/*!*************************************************!*\
  !*** ./resources/plugin/js/partials/section.js ***!
  \*************************************************/
/***/ (() => {

eval("/**\n *\n */\n+function ($) {\n  page.initSection = function () {};\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3NlY3Rpb24uanM/MmI4NyJdLCJuYW1lcyI6WyIkIiwicGFnZSIsImluaXRTZWN0aW9uIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLFdBQUwsR0FBbUIsWUFBVyxDQUU3QixDQUZEO0FBSUQsQ0FOQSxDQU1DQyxNQU5ELENBQUQiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICpcbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG5cbiAgcGFnZS5pbml0U2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXG4gIH1cblxufShqUXVlcnkpO1xuXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9zZWN0aW9uLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/section.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/sidebar.js":
/*!*************************************************!*\
  !*** ./resources/plugin/js/partials/sidebar.js ***!
  \*************************************************/
/***/ (() => {

eval("/**\n *\n */\n+function ($) {\n  page.initSidebar = function () {\n    var body = page.body;\n    $(document).on('click', '.sidebar-toggler, .sidebar-close, .backdrop-sidebar', function () {\n      body.toggleClass('sidebar-open');\n\n      if (body.hasClass('sidebar-open')) {\n        body.prepend('<div class=\"backdrop backdrop-sidebar\"></div>');\n      } else {\n        $('.backdrop-sidebar').remove();\n      }\n    }); // Sidebar nav\n    //\n\n    var navItemShow = $('.nav-sidebar .nav-item.show');\n    navItemShow.find('> .nav-link .nav-angle').addClass('rotate');\n    navItemShow.find('> .nav').css('display', 'block');\n    navItemShow.removeClass('show');\n    var navSidebarIsAccordion = false;\n\n    if ('true' == $('.nav-sidebar').dataAttr('accordion', 'false')) {\n      navSidebarIsAccordion = true;\n    }\n\n    $(document).on('click', '.nav-sidebar > .nav-item > .nav-link', function () {\n      var link = $(this);\n      link.next('.nav').slideToggle();\n\n      if (navSidebarIsAccordion) {\n        link.closest('.nav-item').siblings('.nav-item').children('.nav:visible').slideUp().prev('.nav-link').children('.nav-angle').removeClass('rotate');\n      }\n\n      link.children('.nav-angle').toggleClass('rotate');\n    }); // Perfect scrollbar\n    //\n\n    $('.sidebar-body').each(function (e) {\n      var ps = new PerfectScrollbar($(this)[0], {\n        wheelSpeed: 0.4,\n        minScrollbarLength: 20\n      });\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3NpZGViYXIuanM/M2YzMSJdLCJuYW1lcyI6WyIkIiwicGFnZSIsImluaXRTaWRlYmFyIiwiYm9keSIsImRvY3VtZW50Iiwib24iLCJ0b2dnbGVDbGFzcyIsImhhc0NsYXNzIiwicHJlcGVuZCIsInJlbW92ZSIsIm5hdkl0ZW1TaG93IiwiZmluZCIsImFkZENsYXNzIiwiY3NzIiwicmVtb3ZlQ2xhc3MiLCJuYXZTaWRlYmFySXNBY2NvcmRpb24iLCJkYXRhQXR0ciIsImxpbmsiLCJuZXh0Iiwic2xpZGVUb2dnbGUiLCJjbG9zZXN0Iiwic2libGluZ3MiLCJjaGlsZHJlbiIsInNsaWRlVXAiLCJwcmV2IiwiZWFjaCIsImUiLCJwcyIsIlBlcmZlY3RTY3JvbGxiYXIiLCJ3aGVlbFNwZWVkIiwibWluU2Nyb2xsYmFyTGVuZ3RoIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFDQTtBQUNBO0FBQ0E7QUFFQSxDQUFDLFVBQVNBLENBQVQsRUFBVztBQUVWQyxFQUFBQSxJQUFJLENBQUNDLFdBQUwsR0FBbUIsWUFBVztBQUM1QixRQUFJQyxJQUFJLEdBQUdGLElBQUksQ0FBQ0UsSUFBaEI7QUFFQUgsSUFBQUEsQ0FBQyxDQUFDSSxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFnQixPQUFoQixFQUF5QixxREFBekIsRUFBZ0YsWUFBVztBQUN6RkYsTUFBQUEsSUFBSSxDQUFDRyxXQUFMLENBQWtCLGNBQWxCOztBQUNBLFVBQUtILElBQUksQ0FBQ0ksUUFBTCxDQUFjLGNBQWQsQ0FBTCxFQUFxQztBQUNuQ0osUUFBQUEsSUFBSSxDQUFDSyxPQUFMLENBQWEsK0NBQWI7QUFDRCxPQUZELE1BR0s7QUFDSFIsUUFBQUEsQ0FBQyxDQUFDLG1CQUFELENBQUQsQ0FBdUJTLE1BQXZCO0FBQ0Q7QUFDRixLQVJELEVBSDRCLENBYTVCO0FBQ0E7O0FBQ0EsUUFBSUMsV0FBVyxHQUFHVixDQUFDLENBQUMsNkJBQUQsQ0FBbkI7QUFDQVUsSUFBQUEsV0FBVyxDQUFDQyxJQUFaLENBQWlCLHdCQUFqQixFQUEyQ0MsUUFBM0MsQ0FBb0QsUUFBcEQ7QUFDQUYsSUFBQUEsV0FBVyxDQUFDQyxJQUFaLENBQWlCLFFBQWpCLEVBQTJCRSxHQUEzQixDQUErQixTQUEvQixFQUEwQyxPQUExQztBQUNBSCxJQUFBQSxXQUFXLENBQUNJLFdBQVosQ0FBd0IsTUFBeEI7QUFFQSxRQUFJQyxxQkFBcUIsR0FBRyxLQUE1Qjs7QUFDQSxRQUFLLFVBQVVmLENBQUMsQ0FBQyxjQUFELENBQUQsQ0FBa0JnQixRQUFsQixDQUEyQixXQUEzQixFQUF3QyxPQUF4QyxDQUFmLEVBQWtFO0FBQ2hFRCxNQUFBQSxxQkFBcUIsR0FBRyxJQUF4QjtBQUNEOztBQUVEZixJQUFBQSxDQUFDLENBQUNJLFFBQUQsQ0FBRCxDQUFZQyxFQUFaLENBQWdCLE9BQWhCLEVBQXlCLHNDQUF6QixFQUFpRSxZQUFXO0FBQzFFLFVBQUlZLElBQUksR0FBR2pCLENBQUMsQ0FBQyxJQUFELENBQVo7QUFDQWlCLE1BQUFBLElBQUksQ0FBQ0MsSUFBTCxDQUFVLE1BQVYsRUFBa0JDLFdBQWxCOztBQUNBLFVBQUtKLHFCQUFMLEVBQTZCO0FBQzNCRSxRQUFBQSxJQUFJLENBQUNHLE9BQUwsQ0FBYSxXQUFiLEVBQTBCQyxRQUExQixDQUFtQyxXQUFuQyxFQUFnREMsUUFBaEQsQ0FBeUQsY0FBekQsRUFBeUVDLE9BQXpFLEdBQW1GQyxJQUFuRixDQUF3RixXQUF4RixFQUFxR0YsUUFBckcsQ0FBOEcsWUFBOUcsRUFBNEhSLFdBQTVILENBQXdJLFFBQXhJO0FBQ0Q7O0FBQ0RHLE1BQUFBLElBQUksQ0FBQ0ssUUFBTCxDQUFjLFlBQWQsRUFBNEJoQixXQUE1QixDQUF3QyxRQUF4QztBQUNELEtBUEQsRUF6QjRCLENBbUM1QjtBQUNBOztBQUNBTixJQUFBQSxDQUFDLENBQUMsZUFBRCxDQUFELENBQW1CeUIsSUFBbkIsQ0FBd0IsVUFBU0MsQ0FBVCxFQUFZO0FBQ2xDLFVBQUlDLEVBQUUsR0FBRyxJQUFJQyxnQkFBSixDQUFxQjVCLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUSxDQUFSLENBQXJCLEVBQWlDO0FBQ3hDNkIsUUFBQUEsVUFBVSxFQUFFLEdBRDRCO0FBRXhDQyxRQUFBQSxrQkFBa0IsRUFBRTtBQUZvQixPQUFqQyxDQUFUO0FBSUQsS0FMRDtBQU9ELEdBNUNEO0FBOENELENBaERBLENBZ0RDQyxNQWhERCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqXG4gKi9cblxuK2Z1bmN0aW9uKCQpe1xuXG4gIHBhZ2UuaW5pdFNpZGViYXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYm9keSA9IHBhZ2UuYm9keTtcblxuICAgICQoZG9jdW1lbnQpLm9uKCAnY2xpY2snLCAnLnNpZGViYXItdG9nZ2xlciwgLnNpZGViYXItY2xvc2UsIC5iYWNrZHJvcC1zaWRlYmFyJywgZnVuY3Rpb24oKSB7XG4gICAgICBib2R5LnRvZ2dsZUNsYXNzKCAnc2lkZWJhci1vcGVuJyApO1xuICAgICAgaWYgKCBib2R5Lmhhc0NsYXNzKCdzaWRlYmFyLW9wZW4nKSApIHtcbiAgICAgICAgYm9keS5wcmVwZW5kKCc8ZGl2IGNsYXNzPVwiYmFja2Ryb3AgYmFja2Ryb3Atc2lkZWJhclwiPjwvZGl2PicpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgJCgnLmJhY2tkcm9wLXNpZGViYXInKS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFNpZGViYXIgbmF2XG4gICAgLy9cbiAgICB2YXIgbmF2SXRlbVNob3cgPSAkKCcubmF2LXNpZGViYXIgLm5hdi1pdGVtLnNob3cnKTtcbiAgICBuYXZJdGVtU2hvdy5maW5kKCc+IC5uYXYtbGluayAubmF2LWFuZ2xlJykuYWRkQ2xhc3MoJ3JvdGF0ZScpO1xuICAgIG5hdkl0ZW1TaG93LmZpbmQoJz4gLm5hdicpLmNzcygnZGlzcGxheScsICdibG9jaycpO1xuICAgIG5hdkl0ZW1TaG93LnJlbW92ZUNsYXNzKCdzaG93Jyk7XG5cbiAgICB2YXIgbmF2U2lkZWJhcklzQWNjb3JkaW9uID0gZmFsc2U7XG4gICAgaWYgKCAndHJ1ZScgPT0gJCgnLm5hdi1zaWRlYmFyJykuZGF0YUF0dHIoJ2FjY29yZGlvbicsICdmYWxzZScpICkge1xuICAgICAgbmF2U2lkZWJhcklzQWNjb3JkaW9uID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAkKGRvY3VtZW50KS5vbiggJ2NsaWNrJywgJy5uYXYtc2lkZWJhciA+IC5uYXYtaXRlbSA+IC5uYXYtbGluaycsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxpbmsgPSAkKHRoaXMpO1xuICAgICAgbGluay5uZXh0KCcubmF2Jykuc2xpZGVUb2dnbGUoKTtcbiAgICAgIGlmICggbmF2U2lkZWJhcklzQWNjb3JkaW9uICkge1xuICAgICAgICBsaW5rLmNsb3Nlc3QoJy5uYXYtaXRlbScpLnNpYmxpbmdzKCcubmF2LWl0ZW0nKS5jaGlsZHJlbignLm5hdjp2aXNpYmxlJykuc2xpZGVVcCgpLnByZXYoJy5uYXYtbGluaycpLmNoaWxkcmVuKCcubmF2LWFuZ2xlJykucmVtb3ZlQ2xhc3MoJ3JvdGF0ZScpO1xuICAgICAgfVxuICAgICAgbGluay5jaGlsZHJlbignLm5hdi1hbmdsZScpLnRvZ2dsZUNsYXNzKCdyb3RhdGUnKTtcbiAgICB9KTtcblxuXG4gICAgLy8gUGVyZmVjdCBzY3JvbGxiYXJcbiAgICAvL1xuICAgICQoJy5zaWRlYmFyLWJvZHknKS5lYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwcyA9IG5ldyBQZXJmZWN0U2Nyb2xsYmFyKCQodGhpcylbMF0sIHtcbiAgICAgICAgd2hlZWxTcGVlZDogMC40LFxuICAgICAgICBtaW5TY3JvbGxiYXJMZW5ndGg6IDIwXG4gICAgICB9KTtcbiAgICB9KVxuXG4gIH1cblxufShqUXVlcnkpO1xuXG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy9zaWRlYmFyLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/sidebar.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/util.js":
/*!**********************************************!*\
  !*** ./resources/plugin/js/partials/util.js ***!
  \**********************************************/
/***/ (() => {

eval("/**\n * Utility functions to be used in the whole application.\n */\n+function ($) {\n  // Convert data-attributes options to Javascript object\n  //\n  page.getDataOptions = function (el, castList) {\n    var options = {};\n    $.each($(el).data(), function (key, value) {\n      key = page.dataToOption(key); // Escape data-provide\n\n      if (key == 'provide') {\n        return;\n      }\n\n      if (castList != undefined) {\n        var type = castList[key];\n\n        switch (type) {\n          case 'bool':\n            value = Boolean(value);\n            break;\n\n          case 'num':\n            value = Number(value);\n            break;\n\n          case 'array':\n            value = value.split(',');\n            break;\n\n          default:\n        }\n      }\n\n      options[key] = value;\n    });\n    return options;\n  }; // Get target of an action from element.\n  //\n  // It can be 'data-target' or 'href' attribute.\n  // We support 'next' and 'prev' values to target next or previous element. In this case, we return jQuery element.\n  //\n\n\n  page.getTarget = function (e) {\n    var target;\n\n    if (e.hasDataAttr('target')) {\n      target = e.data('target');\n    } else {\n      target = e.attr('href');\n    }\n\n    if (target == 'next') {\n      target = $(e).next();\n    } else if (target == 'prev') {\n      target = $(e).prev();\n    }\n\n    if (target == undefined) {\n      return false;\n    }\n\n    return target;\n  }; // Get URL of an action from element.\n  //\n  // It can be 'data-url' or 'href' attribute.\n  //\n\n\n  page.getURL = function (e) {\n    var url;\n\n    if (e.hasDataAttr('url')) {\n      url = e.data('url');\n    } else {\n      url = e.attr('href');\n    }\n\n    return url;\n  }; // Convert fooBarBaz to foo-bar-baz\n  //\n\n\n  page.optionToData = function (name) {\n    return name.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n  }; // Convert foo-bar-baz to fooBarBaz\n  //\n\n\n  page.dataToOption = function (name) {\n    return name.replace(/-([a-z])/g, function (x) {\n      return x[1].toUpperCase();\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3V0aWwuanM/MWNjNiJdLCJuYW1lcyI6WyIkIiwicGFnZSIsImdldERhdGFPcHRpb25zIiwiZWwiLCJjYXN0TGlzdCIsIm9wdGlvbnMiLCJlYWNoIiwiZGF0YSIsImtleSIsInZhbHVlIiwiZGF0YVRvT3B0aW9uIiwidW5kZWZpbmVkIiwidHlwZSIsIkJvb2xlYW4iLCJOdW1iZXIiLCJzcGxpdCIsImdldFRhcmdldCIsImUiLCJ0YXJnZXQiLCJoYXNEYXRhQXR0ciIsImF0dHIiLCJuZXh0IiwicHJldiIsImdldFVSTCIsInVybCIsIm9wdGlvblRvRGF0YSIsIm5hbWUiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJ4IiwidG9VcHBlckNhc2UiLCJqUXVlcnkiXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUVBLENBQUMsVUFBU0EsQ0FBVCxFQUFXO0FBRVY7QUFDQTtBQUNBQyxFQUFBQSxJQUFJLENBQUNDLGNBQUwsR0FBc0IsVUFBU0MsRUFBVCxFQUFhQyxRQUFiLEVBQXVCO0FBQzNDLFFBQUlDLE9BQU8sR0FBRyxFQUFkO0FBRUFMLElBQUFBLENBQUMsQ0FBQ00sSUFBRixDQUFRTixDQUFDLENBQUNHLEVBQUQsQ0FBRCxDQUFNSSxJQUFOLEVBQVIsRUFBc0IsVUFBU0MsR0FBVCxFQUFjQyxLQUFkLEVBQW9CO0FBRXhDRCxNQUFBQSxHQUFHLEdBQUdQLElBQUksQ0FBQ1MsWUFBTCxDQUFrQkYsR0FBbEIsQ0FBTixDQUZ3QyxDQUl4Qzs7QUFDQSxVQUFLQSxHQUFHLElBQUksU0FBWixFQUF3QjtBQUN0QjtBQUNEOztBQUVELFVBQUtKLFFBQVEsSUFBSU8sU0FBakIsRUFBNkI7QUFDM0IsWUFBSUMsSUFBSSxHQUFHUixRQUFRLENBQUNJLEdBQUQsQ0FBbkI7O0FBQ0EsZ0JBQVFJLElBQVI7QUFDRSxlQUFLLE1BQUw7QUFDRUgsWUFBQUEsS0FBSyxHQUFHSSxPQUFPLENBQUNKLEtBQUQsQ0FBZjtBQUNBOztBQUVGLGVBQUssS0FBTDtBQUNFQSxZQUFBQSxLQUFLLEdBQUdLLE1BQU0sQ0FBQ0wsS0FBRCxDQUFkO0FBQ0E7O0FBRUYsZUFBSyxPQUFMO0FBQ0VBLFlBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDTSxLQUFOLENBQVksR0FBWixDQUFSO0FBQ0E7O0FBRUY7QUFiRjtBQWdCRDs7QUFFRFYsTUFBQUEsT0FBTyxDQUFDRyxHQUFELENBQVAsR0FBZUMsS0FBZjtBQUNELEtBOUJEO0FBZ0NBLFdBQU9KLE9BQVA7QUFDRCxHQXBDRCxDQUpVLENBMkNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBSixFQUFBQSxJQUFJLENBQUNlLFNBQUwsR0FBaUIsVUFBU0MsQ0FBVCxFQUFZO0FBQzNCLFFBQUlDLE1BQUo7O0FBQ0EsUUFBS0QsQ0FBQyxDQUFDRSxXQUFGLENBQWMsUUFBZCxDQUFMLEVBQStCO0FBQzdCRCxNQUFBQSxNQUFNLEdBQUdELENBQUMsQ0FBQ1YsSUFBRixDQUFPLFFBQVAsQ0FBVDtBQUNELEtBRkQsTUFHSztBQUNIVyxNQUFBQSxNQUFNLEdBQUdELENBQUMsQ0FBQ0csSUFBRixDQUFPLE1BQVAsQ0FBVDtBQUNEOztBQUVELFFBQUtGLE1BQU0sSUFBSSxNQUFmLEVBQXdCO0FBQ3RCQSxNQUFBQSxNQUFNLEdBQUdsQixDQUFDLENBQUNpQixDQUFELENBQUQsQ0FBS0ksSUFBTCxFQUFUO0FBQ0QsS0FGRCxNQUdLLElBQUtILE1BQU0sSUFBSSxNQUFmLEVBQXdCO0FBQzNCQSxNQUFBQSxNQUFNLEdBQUdsQixDQUFDLENBQUNpQixDQUFELENBQUQsQ0FBS0ssSUFBTCxFQUFUO0FBQ0Q7O0FBRUQsUUFBS0osTUFBTSxJQUFJUCxTQUFmLEVBQTJCO0FBQ3pCLGFBQU8sS0FBUDtBQUNEOztBQUVELFdBQU9PLE1BQVA7QUFDRCxHQXJCRCxDQWhEVSxDQTJFVjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FqQixFQUFBQSxJQUFJLENBQUNzQixNQUFMLEdBQWMsVUFBU04sQ0FBVCxFQUFZO0FBQ3hCLFFBQUlPLEdBQUo7O0FBQ0EsUUFBS1AsQ0FBQyxDQUFDRSxXQUFGLENBQWMsS0FBZCxDQUFMLEVBQTRCO0FBQzFCSyxNQUFBQSxHQUFHLEdBQUdQLENBQUMsQ0FBQ1YsSUFBRixDQUFPLEtBQVAsQ0FBTjtBQUNELEtBRkQsTUFHSztBQUNIaUIsTUFBQUEsR0FBRyxHQUFHUCxDQUFDLENBQUNHLElBQUYsQ0FBTyxNQUFQLENBQU47QUFDRDs7QUFFRCxXQUFPSSxHQUFQO0FBQ0QsR0FWRCxDQS9FVSxDQTZGVjtBQUNBOzs7QUFDQXZCLEVBQUFBLElBQUksQ0FBQ3dCLFlBQUwsR0FBb0IsVUFBU0MsSUFBVCxFQUFlO0FBQ2pDLFdBQU9BLElBQUksQ0FBQ0MsT0FBTCxDQUFhLFVBQWIsRUFBeUIsS0FBekIsRUFBZ0NDLFdBQWhDLEVBQVA7QUFDRCxHQUZELENBL0ZVLENBb0dWO0FBQ0E7OztBQUNBM0IsRUFBQUEsSUFBSSxDQUFDUyxZQUFMLEdBQW9CLFVBQVNnQixJQUFULEVBQWU7QUFDakMsV0FBT0EsSUFBSSxDQUFDQyxPQUFMLENBQWEsV0FBYixFQUEwQixVQUFTRSxDQUFULEVBQVc7QUFBQyxhQUFPQSxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUtDLFdBQUwsRUFBUDtBQUEyQixLQUFqRSxDQUFQO0FBQ0QsR0FGRDtBQUlELENBMUdBLENBMEdDQyxNQTFHRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIHRvIGJlIHVzZWQgaW4gdGhlIHdob2xlIGFwcGxpY2F0aW9uLlxuICovXG5cbitmdW5jdGlvbigkKXtcblxuICAvLyBDb252ZXJ0IGRhdGEtYXR0cmlidXRlcyBvcHRpb25zIHRvIEphdmFzY3JpcHQgb2JqZWN0XG4gIC8vXG4gIHBhZ2UuZ2V0RGF0YU9wdGlvbnMgPSBmdW5jdGlvbihlbCwgY2FzdExpc3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXG4gICAgJC5lYWNoKCAkKGVsKS5kYXRhKCksIGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuXG4gICAgICBrZXkgPSBwYWdlLmRhdGFUb09wdGlvbihrZXkpO1xuXG4gICAgICAvLyBFc2NhcGUgZGF0YS1wcm92aWRlXG4gICAgICBpZiAoIGtleSA9PSAncHJvdmlkZScgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCBjYXN0TGlzdCAhPSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHZhciB0eXBlID0gY2FzdExpc3Rba2V5XTtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgICB2YWx1ZSA9IEJvb2xlYW4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdudW0nOlxuICAgICAgICAgICAgdmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdhcnJheSc6XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCcsJyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvcHRpb25zW2tleV0gPSB2YWx1ZTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG5cblxuICAvLyBHZXQgdGFyZ2V0IG9mIGFuIGFjdGlvbiBmcm9tIGVsZW1lbnQuXG4gIC8vXG4gIC8vIEl0IGNhbiBiZSAnZGF0YS10YXJnZXQnIG9yICdocmVmJyBhdHRyaWJ1dGUuXG4gIC8vIFdlIHN1cHBvcnQgJ25leHQnIGFuZCAncHJldicgdmFsdWVzIHRvIHRhcmdldCBuZXh0IG9yIHByZXZpb3VzIGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgd2UgcmV0dXJuIGpRdWVyeSBlbGVtZW50LlxuICAvL1xuICBwYWdlLmdldFRhcmdldCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIGlmICggZS5oYXNEYXRhQXR0cigndGFyZ2V0JykgKSB7XG4gICAgICB0YXJnZXQgPSBlLmRhdGEoJ3RhcmdldCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGUuYXR0cignaHJlZicpO1xuICAgIH1cblxuICAgIGlmICggdGFyZ2V0ID09ICduZXh0JyApIHtcbiAgICAgIHRhcmdldCA9ICQoZSkubmV4dCgpO1xuICAgIH1cbiAgICBlbHNlIGlmICggdGFyZ2V0ID09ICdwcmV2JyApIHtcbiAgICAgIHRhcmdldCA9ICQoZSkucHJldigpO1xuICAgIH1cblxuICAgIGlmICggdGFyZ2V0ID09IHVuZGVmaW5lZCApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG5cblxuXG5cbiAgLy8gR2V0IFVSTCBvZiBhbiBhY3Rpb24gZnJvbSBlbGVtZW50LlxuICAvL1xuICAvLyBJdCBjYW4gYmUgJ2RhdGEtdXJsJyBvciAnaHJlZicgYXR0cmlidXRlLlxuICAvL1xuICBwYWdlLmdldFVSTCA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdXJsO1xuICAgIGlmICggZS5oYXNEYXRhQXR0cigndXJsJykgKSB7XG4gICAgICB1cmwgPSBlLmRhdGEoJ3VybCcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHVybCA9IGUuYXR0cignaHJlZicpO1xuICAgIH1cblxuICAgIHJldHVybiB1cmw7XG4gIH07XG5cblxuXG4gIC8vIENvbnZlcnQgZm9vQmFyQmF6IHRvIGZvby1iYXItYmF6XG4gIC8vXG4gIHBhZ2Uub3B0aW9uVG9EYXRhID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBuYW1lLnJlcGxhY2UoLyhbQS1aXSkvZywgXCItJDFcIikudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG5cbiAgLy8gQ29udmVydCBmb28tYmFyLWJheiB0byBmb29CYXJCYXpcbiAgLy9cbiAgcGFnZS5kYXRhVG9PcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZSgvLShbYS16XSkvZywgZnVuY3Rpb24oeCl7cmV0dXJuIHhbMV0udG9VcHBlckNhc2UoKTt9KTtcbiAgfVxuXG59KGpRdWVyeSk7XG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy91dGlsLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/util.js\n");

/***/ }),

/***/ "./resources/plugin/js/partials/video.js":
/*!***********************************************!*\
  !*** ./resources/plugin/js/partials/video.js ***!
  \***********************************************/
/***/ (() => {

eval("/**\n * All the video related methods.\n */\n+function ($) {\n  page.initVideo = function () {\n    // Video-wrapper\n    //\n    $(document).on('click', '.video-wrapper .btn', function () {\n      var wrapper = $(this).closest('.video-wrapper');\n      wrapper.addClass('reveal');\n      if (wrapper.find('video').length) wrapper.find('video').get(0).play();\n\n      if (wrapper.find('iframe').length) {\n        var iframe = wrapper.find('iframe');\n        var src = iframe.attr('src');\n        if (src.indexOf('?') > 0) iframe.get(0).src += \"&autoplay=1\";else iframe.get(0).src += \"?autoplay=1\";\n      }\n    }); // Object-fit polyfill\n    //\n\n    objectFitPolyfill($('.bg-video'));\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3BhcnRpYWxzL3ZpZGVvLmpzPzU4MGMiXSwibmFtZXMiOlsiJCIsInBhZ2UiLCJpbml0VmlkZW8iLCJkb2N1bWVudCIsIm9uIiwid3JhcHBlciIsImNsb3Nlc3QiLCJhZGRDbGFzcyIsImZpbmQiLCJsZW5ndGgiLCJnZXQiLCJwbGF5IiwiaWZyYW1lIiwic3JjIiwiYXR0ciIsImluZGV4T2YiLCJvYmplY3RGaXRQb2x5ZmlsbCIsImpRdWVyeSJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFFVkMsRUFBQUEsSUFBSSxDQUFDQyxTQUFMLEdBQWlCLFlBQVc7QUFFMUI7QUFDQTtBQUNBRixJQUFBQSxDQUFDLENBQUNHLFFBQUQsQ0FBRCxDQUFZQyxFQUFaLENBQWUsT0FBZixFQUF3QixxQkFBeEIsRUFBK0MsWUFBVTtBQUN2RCxVQUFJQyxPQUFPLEdBQUdMLENBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUU0sT0FBUixDQUFnQixnQkFBaEIsQ0FBZDtBQUNBRCxNQUFBQSxPQUFPLENBQUNFLFFBQVIsQ0FBaUIsUUFBakI7QUFFQSxVQUFLRixPQUFPLENBQUNHLElBQVIsQ0FBYSxPQUFiLEVBQXNCQyxNQUEzQixFQUNFSixPQUFPLENBQUNHLElBQVIsQ0FBYSxPQUFiLEVBQXNCRSxHQUF0QixDQUEwQixDQUExQixFQUE2QkMsSUFBN0I7O0FBRUYsVUFBS04sT0FBTyxDQUFDRyxJQUFSLENBQWEsUUFBYixFQUF1QkMsTUFBNUIsRUFBcUM7QUFDbkMsWUFBSUcsTUFBTSxHQUFHUCxPQUFPLENBQUNHLElBQVIsQ0FBYSxRQUFiLENBQWI7QUFDQSxZQUFJSyxHQUFHLEdBQUdELE1BQU0sQ0FBQ0UsSUFBUCxDQUFZLEtBQVosQ0FBVjtBQUVBLFlBQUtELEdBQUcsQ0FBQ0UsT0FBSixDQUFZLEdBQVosSUFBbUIsQ0FBeEIsRUFDRUgsTUFBTSxDQUFDRixHQUFQLENBQVcsQ0FBWCxFQUFjRyxHQUFkLElBQXFCLGFBQXJCLENBREYsS0FHRUQsTUFBTSxDQUFDRixHQUFQLENBQVcsQ0FBWCxFQUFjRyxHQUFkLElBQXFCLGFBQXJCO0FBQ0g7QUFDRixLQWhCRCxFQUowQixDQXVCMUI7QUFDQTs7QUFDQUcsSUFBQUEsaUJBQWlCLENBQUVoQixDQUFDLENBQUMsV0FBRCxDQUFILENBQWpCO0FBRUQsR0EzQkQ7QUE2QkQsQ0EvQkEsQ0ErQkNpQixNQS9CRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEFsbCB0aGUgdmlkZW8gcmVsYXRlZCBtZXRob2RzLlxuICovXG5cbitmdW5jdGlvbigkKXtcblxuICBwYWdlLmluaXRWaWRlbyA9IGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gVmlkZW8td3JhcHBlclxuICAgIC8vXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy52aWRlby13cmFwcGVyIC5idG4nLCBmdW5jdGlvbigpe1xuICAgICAgdmFyIHdyYXBwZXIgPSAkKHRoaXMpLmNsb3Nlc3QoJy52aWRlby13cmFwcGVyJyk7XG4gICAgICB3cmFwcGVyLmFkZENsYXNzKCdyZXZlYWwnKTtcblxuICAgICAgaWYgKCB3cmFwcGVyLmZpbmQoJ3ZpZGVvJykubGVuZ3RoIClcbiAgICAgICAgd3JhcHBlci5maW5kKCd2aWRlbycpLmdldCgwKS5wbGF5KCk7XG5cbiAgICAgIGlmICggd3JhcHBlci5maW5kKCdpZnJhbWUnKS5sZW5ndGggKSB7XG4gICAgICAgIHZhciBpZnJhbWUgPSB3cmFwcGVyLmZpbmQoJ2lmcmFtZScpO1xuICAgICAgICB2YXIgc3JjID0gaWZyYW1lLmF0dHIoJ3NyYycpO1xuXG4gICAgICAgIGlmICggc3JjLmluZGV4T2YoJz8nKSA+IDAgKVxuICAgICAgICAgIGlmcmFtZS5nZXQoMCkuc3JjICs9IFwiJmF1dG9wbGF5PTFcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGlmcmFtZS5nZXQoMCkuc3JjICs9IFwiP2F1dG9wbGF5PTFcIjtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gT2JqZWN0LWZpdCBwb2x5ZmlsbFxuICAgIC8vXG4gICAgb2JqZWN0Rml0UG9seWZpbGwoICQoJy5iZy12aWRlbycpICk7XG5cbiAgfVxuXG59KGpRdWVyeSk7XG4iXSwiZmlsZSI6Ii4vcmVzb3VyY2VzL3BsdWdpbi9qcy9wYXJ0aWFscy92aWRlby5qcy5qcyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/plugin/js/partials/video.js\n");

/***/ }),

/***/ "./resources/plugin/js/vendors/bootstrap.js":
/*!**************************************************!*\
  !*** ./resources/plugin/js/vendors/bootstrap.js ***!
  \**************************************************/
/***/ (() => {

eval("/**\n * Initialize some of the core Bootstrap components.\n */\n+function ($) {\n  page.registerVendor('Bootstrap');\n\n  page.initBootstrap = function () {\n    $('[data-toggle=\"tooltip\"]').tooltip();\n    $('[data-toggle=\"popover\"]').popover(); // Custom control check\n    //\n    // Since BS4-beta-3, custom-controls needs id and for attributes.\n    // We bypass this requirement.\n    //\n\n    $(document).on('click', '.custom-checkbox', function () {\n      var input = $(this).children('.custom-control-input').not(':disabled');\n      input.prop('checked', !input.prop('checked')).trigger(\"change\");\n    });\n    $(document).on('click', '.custom-radio', function () {\n      var input = $(this).children('.custom-control-input').not(':disabled');\n      input.prop('checked', true).trigger(\"change\");\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3ZlbmRvcnMvYm9vdHN0cmFwLmpzP2JlY2MiXSwibmFtZXMiOlsiJCIsInBhZ2UiLCJyZWdpc3RlclZlbmRvciIsImluaXRCb290c3RyYXAiLCJ0b29sdGlwIiwicG9wb3ZlciIsImRvY3VtZW50Iiwib24iLCJpbnB1dCIsImNoaWxkcmVuIiwibm90IiwicHJvcCIsInRyaWdnZXIiLCJqUXVlcnkiXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUVBLENBQUMsVUFBU0EsQ0FBVCxFQUFXO0FBQ1ZDLEVBQUFBLElBQUksQ0FBQ0MsY0FBTCxDQUFvQixXQUFwQjs7QUFFQUQsRUFBQUEsSUFBSSxDQUFDRSxhQUFMLEdBQXFCLFlBQVc7QUFDOUJILElBQUFBLENBQUMsQ0FBQyx5QkFBRCxDQUFELENBQTZCSSxPQUE3QjtBQUNBSixJQUFBQSxDQUFDLENBQUMseUJBQUQsQ0FBRCxDQUE2QkssT0FBN0IsR0FGOEIsQ0FLOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQUwsSUFBQUEsQ0FBQyxDQUFDTSxRQUFELENBQUQsQ0FBWUMsRUFBWixDQUFlLE9BQWYsRUFBd0Isa0JBQXhCLEVBQTRDLFlBQVc7QUFDckQsVUFBSUMsS0FBSyxHQUFHUixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFTLFFBQVIsQ0FBaUIsdUJBQWpCLEVBQTBDQyxHQUExQyxDQUE4QyxXQUE5QyxDQUFaO0FBQ0FGLE1BQUFBLEtBQUssQ0FBQ0csSUFBTixDQUFXLFNBQVgsRUFBc0IsQ0FBRUgsS0FBSyxDQUFDRyxJQUFOLENBQVcsU0FBWCxDQUF4QixFQUErQ0MsT0FBL0MsQ0FBd0QsUUFBeEQ7QUFDRCxLQUhEO0FBS0FaLElBQUFBLENBQUMsQ0FBQ00sUUFBRCxDQUFELENBQVlDLEVBQVosQ0FBZSxPQUFmLEVBQXdCLGVBQXhCLEVBQXlDLFlBQVc7QUFDbEQsVUFBSUMsS0FBSyxHQUFHUixDQUFDLENBQUMsSUFBRCxDQUFELENBQVFTLFFBQVIsQ0FBaUIsdUJBQWpCLEVBQTBDQyxHQUExQyxDQUE4QyxXQUE5QyxDQUFaO0FBQ0FGLE1BQUFBLEtBQUssQ0FBQ0csSUFBTixDQUFXLFNBQVgsRUFBc0IsSUFBdEIsRUFBNEJDLE9BQTVCLENBQXFDLFFBQXJDO0FBQ0QsS0FIRDtBQU1ELEdBckJEO0FBdUJELENBMUJBLENBMEJDQyxNQTFCRCxDQUFEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIEluaXRpYWxpemUgc29tZSBvZiB0aGUgY29yZSBCb290c3RyYXAgY29tcG9uZW50cy5cbiAqL1xuXG4rZnVuY3Rpb24oJCl7XG4gIHBhZ2UucmVnaXN0ZXJWZW5kb3IoJ0Jvb3RzdHJhcCcpO1xuXG4gIHBhZ2UuaW5pdEJvb3RzdHJhcCA9IGZ1bmN0aW9uKCkge1xuICAgICQoJ1tkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIl0nKS50b29sdGlwKCk7XG4gICAgJCgnW2RhdGEtdG9nZ2xlPVwicG9wb3ZlclwiXScpLnBvcG92ZXIoKTtcblxuXG4gICAgLy8gQ3VzdG9tIGNvbnRyb2wgY2hlY2tcbiAgICAvL1xuICAgIC8vIFNpbmNlIEJTNC1iZXRhLTMsIGN1c3RvbS1jb250cm9scyBuZWVkcyBpZCBhbmQgZm9yIGF0dHJpYnV0ZXMuXG4gICAgLy8gV2UgYnlwYXNzIHRoaXMgcmVxdWlyZW1lbnQuXG4gICAgLy9cbiAgICAkKGRvY3VtZW50KS5vbignY2xpY2snLCAnLmN1c3RvbS1jaGVja2JveCcsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGlucHV0ID0gJCh0aGlzKS5jaGlsZHJlbignLmN1c3RvbS1jb250cm9sLWlucHV0Jykubm90KCc6ZGlzYWJsZWQnKTtcbiAgICAgIGlucHV0LnByb3AoJ2NoZWNrZWQnLCAhIGlucHV0LnByb3AoJ2NoZWNrZWQnKSkudHJpZ2dlciggXCJjaGFuZ2VcIiApO1xuICAgIH0pO1xuXG4gICAgJChkb2N1bWVudCkub24oJ2NsaWNrJywgJy5jdXN0b20tcmFkaW8nLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbnB1dCA9ICQodGhpcykuY2hpbGRyZW4oJy5jdXN0b20tY29udHJvbC1pbnB1dCcpLm5vdCgnOmRpc2FibGVkJyk7XG4gICAgICBpbnB1dC5wcm9wKCdjaGVja2VkJywgdHJ1ZSkudHJpZ2dlciggXCJjaGFuZ2VcIiApO1xuICAgIH0pO1xuXG5cbiAgfVxuXG59KGpRdWVyeSk7XG5cbiJdLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3ZlbmRvcnMvYm9vdHN0cmFwLmpzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/vendors/bootstrap.js\n");

/***/ }),

/***/ "./resources/plugin/js/vendors/datatables.js":
/*!***************************************************!*\
  !*** ./resources/plugin/js/vendors/datatables.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Load required plugin.\n */\n// Reference:\n// https://datatables.net/download/\n// require('pdfmake'); // Export to PDF\n// require('datatables.net'); // Core\n// require('datatables.net-bs4'); // Bootstrasp 4 Core\n// require('datatables.net-buttons'); // Buttons extension\n__webpack_require__(/*! datatables.net-buttons-bs4 */ \"./node_modules/datatables.net-buttons-bs4/js/buttons.bootstrap4.js\")(); // Buttons extension for Bootstrap 4\n\n\n__webpack_require__(/*! datatables.net-buttons/js/buttons.colVis.js */ \"./node_modules/datatables.net-buttons/js/buttons.colVis.js\")(); // Column visibility\n\n\n__webpack_require__(/*! datatables.net-buttons/js/buttons.html5.js */ \"./node_modules/datatables.net-buttons/js/buttons.html5.js\")(); // HTML 5 file export\n// require('datatables.net-buttons/js/buttons.flash.js')();\n\n\n__webpack_require__(/*! datatables.net-buttons/js/buttons.print.js */ \"./node_modules/datatables.net-buttons/js/buttons.print.js\")(); // Print view button\n// require('datatables.net-responsive-bs4')();\n\n/**\n * Configure the plugin.\n */\n\n\n+function ($) {\n  page.registerVendor('Datatables');\n\n  page.initDatatables = function () {\n    $('[data-provide~=\"datatables-full\"]').each(function () {\n      // Custom with some options\n      var table = $(this).DataTable({\n        dom: 'Bfrltip',\n        buttons: [{\n          extend: 'colvis',\n          text: 'Show Columns'\n        }, 'copy', 'csv', 'print'],\n        columnDefs: [{\n          \"targets\": [0, 1, 3, 6, 7, 8, 10, 12, 13, 15, 16, 17, 18, 19, 21],\n          \"visible\": false\n        }],\n        lengthMenu: [[10, 25, 50, 100, 250, 500, -1], [10, 25, 50, 100, 250, 500, \"All\"]]\n      });\n    });\n    $('[data-provide~=\"datatables\"]').each(function () {\n      // Custom with some options\n      var table = $(this).DataTable({\n        dom: 'frltip',\n        lengthMenu: [[10, 25, 50, 100, 250, 500, -1], [10, 25, 50, 100, 250, 500, \"All\"]],\n        fnInfoCallback: function fnInfoCallback(oSettings) {\n          if (typeof loadSwitch === \"function\") {\n            loadSwitch();\n          }\n        }\n      });\n    });\n  };\n}(jQuery);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3ZlbmRvcnMvZGF0YXRhYmxlcy5qcz81Y2E1Il0sIm5hbWVzIjpbInJlcXVpcmUiLCIkIiwicGFnZSIsInJlZ2lzdGVyVmVuZG9yIiwiaW5pdERhdGF0YWJsZXMiLCJlYWNoIiwidGFibGUiLCJEYXRhVGFibGUiLCJkb20iLCJidXR0b25zIiwiZXh0ZW5kIiwidGV4dCIsImNvbHVtbkRlZnMiLCJsZW5ndGhNZW51IiwiZm5JbmZvQ2FsbGJhY2siLCJvU2V0dGluZ3MiLCJsb2FkU3dpdGNoIiwialF1ZXJ5Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQUEsbUJBQU8sQ0FBQyxzR0FBRCxDQUFQLEcsQ0FBeUM7OztBQUN6Q0EsbUJBQU8sQ0FBQywrR0FBRCxDQUFQLEcsQ0FBMEQ7OztBQUMxREEsbUJBQU8sQ0FBQyw2R0FBRCxDQUFQLEcsQ0FBMEQ7QUFDMUQ7OztBQUNBQSxtQkFBTyxDQUFDLDZHQUFELENBQVAsRyxDQUEwRDtBQUMxRDs7QUFHQTtBQUNBO0FBQ0E7OztBQUVBLENBQUUsVUFBVUMsQ0FBVixFQUFhO0FBQ1hDLE1BQUksQ0FBQ0MsY0FBTCxDQUFvQixZQUFwQjs7QUFFQUQsTUFBSSxDQUFDRSxjQUFMLEdBQXNCLFlBQVk7QUFFOUJILEtBQUMsQ0FBQyxtQ0FBRCxDQUFELENBQXVDSSxJQUF2QyxDQUE0QyxZQUFZO0FBRXBEO0FBQ0EsVUFBSUMsS0FBSyxHQUFHTCxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFNLFNBQVIsQ0FBa0I7QUFDMUJDLFdBQUcsRUFBRSxTQURxQjtBQUUxQkMsZUFBTyxFQUFFLENBQ0w7QUFDSUMsZ0JBQU0sRUFBRSxRQURaO0FBRUlDLGNBQUksRUFBRTtBQUZWLFNBREssRUFLTCxNQUxLLEVBS0csS0FMSCxFQUtVLE9BTFYsQ0FGaUI7QUFTMUJDLGtCQUFVLEVBQUUsQ0FDUjtBQUNJLHFCQUFXLENBQUMsQ0FBRCxFQUFJLENBQUosRUFBTyxDQUFQLEVBQVUsQ0FBVixFQUFhLENBQWIsRUFBZ0IsQ0FBaEIsRUFBbUIsRUFBbkIsRUFBdUIsRUFBdkIsRUFBMkIsRUFBM0IsRUFBK0IsRUFBL0IsRUFBbUMsRUFBbkMsRUFBdUMsRUFBdkMsRUFBMkMsRUFBM0MsRUFBK0MsRUFBL0MsRUFBbUQsRUFBbkQsQ0FEZjtBQUVJLHFCQUFXO0FBRmYsU0FEUSxDQVRjO0FBZTFCQyxrQkFBVSxFQUFFLENBQUMsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxHQUFiLEVBQWtCLEdBQWxCLEVBQXVCLEdBQXZCLEVBQTRCLENBQUMsQ0FBN0IsQ0FBRCxFQUFrQyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEdBQWIsRUFBa0IsR0FBbEIsRUFBdUIsR0FBdkIsRUFBNEIsS0FBNUIsQ0FBbEM7QUFmYyxPQUFsQixDQUFaO0FBaUJILEtBcEJEO0FBc0JBWixLQUFDLENBQUMsOEJBQUQsQ0FBRCxDQUFrQ0ksSUFBbEMsQ0FBdUMsWUFBWTtBQUUvQztBQUNBLFVBQUlDLEtBQUssR0FBR0wsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRTSxTQUFSLENBQWtCO0FBQzFCQyxXQUFHLEVBQUUsUUFEcUI7QUFFMUJLLGtCQUFVLEVBQUUsQ0FBQyxDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsRUFBVCxFQUFhLEdBQWIsRUFBa0IsR0FBbEIsRUFBdUIsR0FBdkIsRUFBNEIsQ0FBQyxDQUE3QixDQUFELEVBQWtDLENBQUMsRUFBRCxFQUFLLEVBQUwsRUFBUyxFQUFULEVBQWEsR0FBYixFQUFrQixHQUFsQixFQUF1QixHQUF2QixFQUE0QixLQUE1QixDQUFsQyxDQUZjO0FBRzFCQyxzQkFBYyxFQUFFLHdCQUFVQyxTQUFWLEVBQXFCO0FBQ2pDLGNBQUksT0FBT0MsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQ0Esc0JBQVU7QUFDYjtBQUNKO0FBUHlCLE9BQWxCLENBQVo7QUFTSCxLQVpEO0FBYUgsR0FyQ0Q7QUFzQ0gsQ0F6Q0MsQ0F5Q0FDLE1BekNBLENBQUYiLCJmaWxlIjoiLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3ZlbmRvcnMvZGF0YXRhYmxlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTG9hZCByZXF1aXJlZCBwbHVnaW4uXG4gKi9cblxuLy8gUmVmZXJlbmNlOlxuLy8gaHR0cHM6Ly9kYXRhdGFibGVzLm5ldC9kb3dubG9hZC9cblxuXG4vLyByZXF1aXJlKCdwZGZtYWtlJyk7IC8vIEV4cG9ydCB0byBQREZcbi8vIHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0Jyk7IC8vIENvcmVcbi8vIHJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJzNCcpOyAvLyBCb290c3RyYXNwIDQgQ29yZVxuLy8gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucycpOyAvLyBCdXR0b25zIGV4dGVuc2lvblxucmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy1iczQnKSgpOyAvLyBCdXR0b25zIGV4dGVuc2lvbiBmb3IgQm9vdHN0cmFwIDRcbnJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJ1dHRvbnMvanMvYnV0dG9ucy5jb2xWaXMuanMnKSgpOyAvLyBDb2x1bW4gdmlzaWJpbGl0eVxucmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9idXR0b25zLmh0bWw1LmpzJykoKTsgIC8vIEhUTUwgNSBmaWxlIGV4cG9ydFxuLy8gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9idXR0b25zLmZsYXNoLmpzJykoKTtcbnJlcXVpcmUoJ2RhdGF0YWJsZXMubmV0LWJ1dHRvbnMvanMvYnV0dG9ucy5wcmludC5qcycpKCk7ICAvLyBQcmludCB2aWV3IGJ1dHRvblxuLy8gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtcmVzcG9uc2l2ZS1iczQnKSgpO1xuXG5cbi8qKlxuICogQ29uZmlndXJlIHRoZSBwbHVnaW4uXG4gKi9cblxuKyBmdW5jdGlvbiAoJCkge1xuICAgIHBhZ2UucmVnaXN0ZXJWZW5kb3IoJ0RhdGF0YWJsZXMnKTtcblxuICAgIHBhZ2UuaW5pdERhdGF0YWJsZXMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgJCgnW2RhdGEtcHJvdmlkZX49XCJkYXRhdGFibGVzLWZ1bGxcIl0nKS5lYWNoKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgLy8gQ3VzdG9tIHdpdGggc29tZSBvcHRpb25zXG4gICAgICAgICAgICB2YXIgdGFibGUgPSAkKHRoaXMpLkRhdGFUYWJsZSh7XG4gICAgICAgICAgICAgICAgZG9tOiAnQmZybHRpcCcsXG4gICAgICAgICAgICAgICAgYnV0dG9uczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmQ6ICdjb2x2aXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1Nob3cgQ29sdW1ucydcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NvcHknLCAnY3N2JywgJ3ByaW50J1xuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgY29sdW1uRGVmczogW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInRhcmdldHNcIjogWzAsIDEsIDMsIDYsIDcsIDgsIDEwLCAxMiwgMTMsIDE1LCAxNiwgMTcsIDE4LCAxOSwgMjFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2aXNpYmxlXCI6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGxlbmd0aE1lbnU6IFtbMTAsIDI1LCA1MCwgMTAwLCAyNTAsIDUwMCwgLTFdLCBbMTAsIDI1LCA1MCwgMTAwLCAyNTAsIDUwMCwgXCJBbGxcIl1dXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgJCgnW2RhdGEtcHJvdmlkZX49XCJkYXRhdGFibGVzXCJdJykuZWFjaChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIC8vIEN1c3RvbSB3aXRoIHNvbWUgb3B0aW9uc1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gJCh0aGlzKS5EYXRhVGFibGUoe1xuICAgICAgICAgICAgICAgIGRvbTogJ2ZybHRpcCcsXG4gICAgICAgICAgICAgICAgbGVuZ3RoTWVudTogW1sxMCwgMjUsIDUwLCAxMDAsIDI1MCwgNTAwLCAtMV0sIFsxMCwgMjUsIDUwLCAxMDAsIDI1MCwgNTAwLCBcIkFsbFwiXV0sXG4gICAgICAgICAgICAgICAgZm5JbmZvQ2FsbGJhY2s6IGZ1bmN0aW9uIChvU2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkU3dpdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRTd2l0Y2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59KGpRdWVyeSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/plugin/js/vendors/datatables.js\n");

/***/ }),

/***/ "./resources/plugin/js/vendors/jquery.js":
/*!***********************************************!*\
  !*** ./resources/plugin/js/vendors/jquery.js ***!
  \***********************************************/
/***/ (() => {

eval("/**\n * Configure the plugin.\n */\n+function ($) {\n  page.registerVendor('Jquery');\n\n  page.initJquery = function () {\n    /**\n     * We will register the CSRF Token as a common header with jQuery so that\n     * all outgoing HTTP requests automatically have it attached. This is just\n     * a simple convenience so we don't have to attach every token manually.\n     */\n    var token = document.head.querySelector('meta[name=\"csrf-token\"]');\n\n    if (token) {\n      $.ajaxSetup({\n        headers: {\n          'X-CSRF-TOKEN': token.content\n        }\n      });\n    }\n  };\n}(jQuery); // Check if an element has a specific data attribute\n//\n\njQuery.fn.hasDataAttr = function (name) {\n  return $(this)[0].hasAttribute('data-' + name);\n}; // Get data attribute. If element doesn't have the attribute, return default value\n//\n\n\njQuery.fn.dataAttr = function (name, def) {\n  if ($(this)[0] == undefined) {\n    return def;\n  }\n\n  return $(this)[0].getAttribute('data-' + name) || def;\n}; // Instance search\n//\n//$.expr[':'] -> $.expr.pseudos\n\n\njQuery.expr[':'].search = function (a, i, m) {\n  return $(a).html().toUpperCase().indexOf(m[3].toUpperCase()) >= 0;\n}; // Return outerHTML (inclusing the element) code\n//\n\n\njQuery.fn.outerHTML = function () {\n  var html = '';\n  this.each(function () {\n    html += $(this).prop(\"outerHTML\");\n  });\n  return html;\n}; // Return HTML code of all the selected elements\n//\n\n\njQuery.fn.fullHTML = function () {\n  var html = '';\n  $(this).each(function () {\n    html += $(this).outerHTML();\n  });\n  return html;\n}; // Scroll to end\n//\n\n\njQuery.fn.scrollToEnd = function () {\n  $(this).scrollTop($(this).prop(\"scrollHeight\"));\n  return this;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvcGx1Z2luL2pzL3ZlbmRvcnMvanF1ZXJ5LmpzPzg1MWEiXSwibmFtZXMiOlsiJCIsInBhZ2UiLCJyZWdpc3RlclZlbmRvciIsImluaXRKcXVlcnkiLCJ0b2tlbiIsImRvY3VtZW50IiwiaGVhZCIsInF1ZXJ5U2VsZWN0b3IiLCJhamF4U2V0dXAiLCJoZWFkZXJzIiwiY29udGVudCIsImpRdWVyeSIsImZuIiwiaGFzRGF0YUF0dHIiLCJuYW1lIiwiaGFzQXR0cmlidXRlIiwiZGF0YUF0dHIiLCJkZWYiLCJ1bmRlZmluZWQiLCJnZXRBdHRyaWJ1dGUiLCJleHByIiwic2VhcmNoIiwiYSIsImkiLCJtIiwiaHRtbCIsInRvVXBwZXJDYXNlIiwiaW5kZXhPZiIsIm91dGVySFRNTCIsImVhY2giLCJwcm9wIiwiZnVsbEhUTUwiLCJzY3JvbGxUb0VuZCIsInNjcm9sbFRvcCJdLCJtYXBwaW5ncyI6IkFBQ0E7QUFDQTtBQUNBO0FBRUEsQ0FBQyxVQUFTQSxDQUFULEVBQVc7QUFDVkMsRUFBQUEsSUFBSSxDQUFDQyxjQUFMLENBQW9CLFFBQXBCOztBQUVBRCxFQUFBQSxJQUFJLENBQUNFLFVBQUwsR0FBa0IsWUFBVztBQUUzQjtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBRUksUUFBSUMsS0FBSyxHQUFHQyxRQUFRLENBQUNDLElBQVQsQ0FBY0MsYUFBZCxDQUE0Qix5QkFBNUIsQ0FBWjs7QUFFQSxRQUFJSCxLQUFKLEVBQVc7QUFDVEosTUFBQUEsQ0FBQyxDQUFDUSxTQUFGLENBQVk7QUFDVkMsUUFBQUEsT0FBTyxFQUFFO0FBQUUsMEJBQWdCTCxLQUFLLENBQUNNO0FBQXhCO0FBREMsT0FBWjtBQUdEO0FBRUYsR0FoQkQ7QUFrQkQsQ0FyQkEsQ0FxQkNDLE1BckJELENBQUQsQyxDQTBCQTtBQUNBOztBQUNBQSxNQUFNLENBQUNDLEVBQVAsQ0FBVUMsV0FBVixHQUF3QixVQUFTQyxJQUFULEVBQWU7QUFDckMsU0FBT2QsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRLENBQVIsRUFBV2UsWUFBWCxDQUF3QixVQUFTRCxJQUFqQyxDQUFQO0FBQ0QsQ0FGRCxDLENBTUE7QUFDQTs7O0FBQ0FILE1BQU0sQ0FBQ0MsRUFBUCxDQUFVSSxRQUFWLEdBQXFCLFVBQVNGLElBQVQsRUFBZUcsR0FBZixFQUFvQjtBQUN2QyxNQUFJakIsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRLENBQVIsS0FBY2tCLFNBQWxCLEVBQTZCO0FBQzNCLFdBQU9ELEdBQVA7QUFDRDs7QUFDRCxTQUFPakIsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRLENBQVIsRUFBV21CLFlBQVgsQ0FBd0IsVUFBU0wsSUFBakMsS0FBMENHLEdBQWpEO0FBQ0QsQ0FMRCxDLENBU0E7QUFDQTtBQUNBOzs7QUFDQU4sTUFBTSxDQUFDUyxJQUFQLENBQVksR0FBWixFQUFpQkMsTUFBakIsR0FBMEIsVUFBU0MsQ0FBVCxFQUFZQyxDQUFaLEVBQWVDLENBQWYsRUFBa0I7QUFDMUMsU0FBT3hCLENBQUMsQ0FBQ3NCLENBQUQsQ0FBRCxDQUFLRyxJQUFMLEdBQVlDLFdBQVosR0FBMEJDLE9BQTFCLENBQWtDSCxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUtFLFdBQUwsRUFBbEMsS0FBeUQsQ0FBaEU7QUFDRCxDQUZELEMsQ0FLQTtBQUNBOzs7QUFDQWYsTUFBTSxDQUFDQyxFQUFQLENBQVVnQixTQUFWLEdBQXNCLFlBQVc7QUFDL0IsTUFBSUgsSUFBSSxHQUFHLEVBQVg7QUFDQSxPQUFLSSxJQUFMLENBQVUsWUFBVTtBQUNsQkosSUFBQUEsSUFBSSxJQUFJekIsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFROEIsSUFBUixDQUFhLFdBQWIsQ0FBUjtBQUNELEdBRkQ7QUFHQSxTQUFPTCxJQUFQO0FBQ0QsQ0FORCxDLENBU0E7QUFDQTs7O0FBQ0FkLE1BQU0sQ0FBQ0MsRUFBUCxDQUFVbUIsUUFBVixHQUFxQixZQUFXO0FBQzlCLE1BQUlOLElBQUksR0FBRyxFQUFYO0FBQ0F6QixFQUFBQSxDQUFDLENBQUMsSUFBRCxDQUFELENBQVE2QixJQUFSLENBQWEsWUFBVTtBQUNyQkosSUFBQUEsSUFBSSxJQUFJekIsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFRNEIsU0FBUixFQUFSO0FBQ0QsR0FGRDtBQUdBLFNBQU9ILElBQVA7QUFDRCxDQU5ELEMsQ0FRQTtBQUNBOzs7QUFDQWQsTUFBTSxDQUFDQyxFQUFQLENBQVVvQixXQUFWLEdBQXdCLFlBQVc7QUFDakNoQyxFQUFBQSxDQUFDLENBQUMsSUFBRCxDQUFELENBQVFpQyxTQUFSLENBQW1CakMsQ0FBQyxDQUFDLElBQUQsQ0FBRCxDQUFROEIsSUFBUixDQUFhLGNBQWIsQ0FBbkI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUhEIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIENvbmZpZ3VyZSB0aGUgcGx1Z2luLlxuICovXG5cbitmdW5jdGlvbigkKXtcbiAgcGFnZS5yZWdpc3RlclZlbmRvcignSnF1ZXJ5Jyk7XG5cbiAgcGFnZS5pbml0SnF1ZXJ5ID0gZnVuY3Rpb24oKSB7XG5cbiAgICAvKipcbiAgICAgKiBXZSB3aWxsIHJlZ2lzdGVyIHRoZSBDU1JGIFRva2VuIGFzIGEgY29tbW9uIGhlYWRlciB3aXRoIGpRdWVyeSBzbyB0aGF0XG4gICAgICogYWxsIG91dGdvaW5nIEhUVFAgcmVxdWVzdHMgYXV0b21hdGljYWxseSBoYXZlIGl0IGF0dGFjaGVkLiBUaGlzIGlzIGp1c3RcbiAgICAgKiBhIHNpbXBsZSBjb252ZW5pZW5jZSBzbyB3ZSBkb24ndCBoYXZlIHRvIGF0dGFjaCBldmVyeSB0b2tlbiBtYW51YWxseS5cbiAgICAgKi9cblxuICAgIHZhciB0b2tlbiA9IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NyZi10b2tlblwiXScpO1xuXG4gICAgaWYgKHRva2VuKSB7XG4gICAgICAkLmFqYXhTZXR1cCh7XG4gICAgICAgIGhlYWRlcnM6IHsgJ1gtQ1NSRi1UT0tFTic6IHRva2VuLmNvbnRlbnQgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gIH1cblxufShqUXVlcnkpO1xuXG5cblxuXG4vLyBDaGVjayBpZiBhbiBlbGVtZW50IGhhcyBhIHNwZWNpZmljIGRhdGEgYXR0cmlidXRlXG4vL1xualF1ZXJ5LmZuLmhhc0RhdGFBdHRyID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gJCh0aGlzKVswXS5oYXNBdHRyaWJ1dGUoJ2RhdGEtJysgbmFtZSk7XG59O1xuXG5cblxuLy8gR2V0IGRhdGEgYXR0cmlidXRlLiBJZiBlbGVtZW50IGRvZXNuJ3QgaGF2ZSB0aGUgYXR0cmlidXRlLCByZXR1cm4gZGVmYXVsdCB2YWx1ZVxuLy9cbmpRdWVyeS5mbi5kYXRhQXR0ciA9IGZ1bmN0aW9uKG5hbWUsIGRlZikge1xuICBpZiAoJCh0aGlzKVswXSA9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZGVmO1xuICB9XG4gIHJldHVybiAkKHRoaXMpWzBdLmdldEF0dHJpYnV0ZSgnZGF0YS0nKyBuYW1lKSB8fCBkZWY7XG59O1xuXG5cblxuLy8gSW5zdGFuY2Ugc2VhcmNoXG4vL1xuLy8kLmV4cHJbJzonXSAtPiAkLmV4cHIucHNldWRvc1xualF1ZXJ5LmV4cHJbJzonXS5zZWFyY2ggPSBmdW5jdGlvbihhLCBpLCBtKSB7XG4gIHJldHVybiAkKGEpLmh0bWwoKS50b1VwcGVyQ2FzZSgpLmluZGV4T2YobVszXS50b1VwcGVyQ2FzZSgpKSA+PSAwO1xufTtcblxuXG4vLyBSZXR1cm4gb3V0ZXJIVE1MIChpbmNsdXNpbmcgdGhlIGVsZW1lbnQpIGNvZGVcbi8vXG5qUXVlcnkuZm4ub3V0ZXJIVE1MID0gZnVuY3Rpb24oKSB7XG4gIHZhciBodG1sID0gJyc7XG4gIHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgIGh0bWwgKz0gJCh0aGlzKS5wcm9wKFwib3V0ZXJIVE1MXCIpO1xuICB9KVxuICByZXR1cm4gaHRtbDtcbn07XG5cblxuLy8gUmV0dXJuIEhUTUwgY29kZSBvZiBhbGwgdGhlIHNlbGVjdGVkIGVsZW1lbnRzXG4vL1xualF1ZXJ5LmZuLmZ1bGxIVE1MID0gZnVuY3Rpb24oKSB7XG4gIHZhciBodG1sID0gJyc7XG4gICQodGhpcykuZWFjaChmdW5jdGlvbigpe1xuICAgIGh0bWwgKz0gJCh0aGlzKS5vdXRlckhUTUwoKTtcbiAgfSk7XG4gIHJldHVybiBodG1sO1xufTtcblxuLy8gU2Nyb2xsIHRvIGVuZFxuLy9cbmpRdWVyeS5mbi5zY3JvbGxUb0VuZCA9IGZ1bmN0aW9uKCkge1xuICAkKHRoaXMpLnNjcm9sbFRvcCggJCh0aGlzKS5wcm9wKFwic2Nyb2xsSGVpZ2h0XCIpICk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuIl0sImZpbGUiOiIuL3Jlc291cmNlcy9wbHVnaW4vanMvdmVuZG9ycy9qcXVlcnkuanMuanMiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/plugin/js/vendors/jquery.js\n");

/***/ }),

/***/ "./node_modules/bootstrap/dist/js/bootstrap.js":
/*!*****************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("/*!\n  * Bootstrap v4.6.0 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n   true ? factory(exports, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! popper.js */ \"./node_modules/popper.js/dist/esm/popper.js\")) :\n  0;\n}(this, (function (exports, $, Popper) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n  var Popper__default = /*#__PURE__*/_interopDefaultLegacy(Popper);\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.0): util.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * ------------------------------------------------------------------------\n   * Private TransitionEnd Helpers\n   * ------------------------------------------------------------------------\n   */\n\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    if (obj === null || typeof obj === 'undefined') {\n      return \"\" + obj;\n    }\n\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($__default['default'](event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined;\n      }\n    };\n  }\n\n  function transitionEndEmulator(duration) {\n    var _this = this;\n\n    var called = false;\n    $__default['default'](this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n\n  function setTransitionEndSupport() {\n    $__default['default'].fn.emulateTransitionEnd = transitionEndEmulator;\n    $__default['default'].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * --------------------------------------------------------------------------\n   * Public Util Api\n   * --------------------------------------------------------------------------\n   */\n\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n\n      if (!selector || selector === '#') {\n        var hrefAttr = element.getAttribute('href');\n        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\n      }\n\n      try {\n        return document.querySelector(selector) ? selector : null;\n      } catch (_) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n\n      var transitionDuration = $__default['default'](element).css('transition-duration');\n      var transitionDelay = $__default['default'](element).css('transition-delay');\n      var floatTransitionDuration = parseFloat(transitionDuration);\n      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration && !floatTransitionDelay) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n\n      transitionDuration = transitionDuration.split(',')[0];\n      transitionDelay = transitionDelay.split(',')[0];\n      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $__default['default'](element).trigger(TRANSITION_END);\n    },\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    },\n    findShadowRoot: function findShadowRoot(element) {\n      if (!document.documentElement.attachShadow) {\n        return null;\n      } // Can find the shadow root otherwise it'll return the document\n\n\n      if (typeof element.getRootNode === 'function') {\n        var root = element.getRootNode();\n        return root instanceof ShadowRoot ? root : null;\n      }\n\n      if (element instanceof ShadowRoot) {\n        return element;\n      } // when we don't find a shadow root\n\n\n      if (!element.parentNode) {\n        return null;\n      }\n\n      return Util.findShadowRoot(element.parentNode);\n    },\n    jQueryDetection: function jQueryDetection() {\n      if (typeof $__default['default'] === 'undefined') {\n        throw new TypeError('Bootstrap\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\'s JavaScript.');\n      }\n\n      var version = $__default['default'].fn.jquery.split(' ')[0].split('.');\n      var minMajor = 1;\n      var ltMajor = 2;\n      var minMinor = 9;\n      var minPatch = 1;\n      var maxMajor = 4;\n\n      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {\n        throw new Error('Bootstrap\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');\n      }\n    }\n  };\n  Util.jQueryDetection();\n  setTransitionEndSupport();\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME = 'alert';\n  var VERSION = '4.6.0';\n  var DATA_KEY = 'bs.alert';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT = $__default['default'].fn[NAME];\n  var SELECTOR_DISMISS = '[data-dismiss=\"alert\"]';\n  var EVENT_CLOSE = \"close\" + EVENT_KEY;\n  var EVENT_CLOSED = \"closed\" + EVENT_KEY;\n  var EVENT_CLICK_DATA_API = \"click\" + EVENT_KEY + DATA_API_KEY;\n  var CLASS_NAME_ALERT = 'alert';\n  var CLASS_NAME_FADE = 'fade';\n  var CLASS_NAME_SHOW = 'show';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Alert = /*#__PURE__*/function () {\n    function Alert(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Alert.prototype;\n\n    // Public\n    _proto.close = function close(element) {\n      var rootElement = this._element;\n\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n\n      var customEvent = this._triggerCloseEvent(rootElement);\n\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._removeElement(rootElement);\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n\n      if (!parent) {\n        parent = $__default['default'](element).closest(\".\" + CLASS_NAME_ALERT)[0];\n      }\n\n      return parent;\n    };\n\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $__default['default'].Event(EVENT_CLOSE);\n      $__default['default'](element).trigger(closeEvent);\n      return closeEvent;\n    };\n\n    _proto._removeElement = function _removeElement(element) {\n      var _this = this;\n\n      $__default['default'](element).removeClass(CLASS_NAME_SHOW);\n\n      if (!$__default['default'](element).hasClass(CLASS_NAME_FADE)) {\n        this._destroyElement(element);\n\n        return;\n      }\n\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\n      $__default['default'](element).one(Util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto._destroyElement = function _destroyElement(element) {\n      $__default['default'](element).detach().trigger(EVENT_CLOSED).remove();\n    } // Static\n    ;\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY);\n\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY, data);\n        }\n\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    };\n\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n\n        alertInstance.close(this);\n      };\n    };\n\n    _createClass(Alert, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }]);\n\n    return Alert;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME] = Alert._jQueryInterface;\n  $__default['default'].fn[NAME].Constructor = Alert;\n\n  $__default['default'].fn[NAME].noConflict = function () {\n    $__default['default'].fn[NAME] = JQUERY_NO_CONFLICT;\n    return Alert._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$1 = 'button';\n  var VERSION$1 = '4.6.0';\n  var DATA_KEY$1 = 'bs.button';\n  var EVENT_KEY$1 = \".\" + DATA_KEY$1;\n  var DATA_API_KEY$1 = '.data-api';\n  var JQUERY_NO_CONFLICT$1 = $__default['default'].fn[NAME$1];\n  var CLASS_NAME_ACTIVE = 'active';\n  var CLASS_NAME_BUTTON = 'btn';\n  var CLASS_NAME_FOCUS = 'focus';\n  var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^=\"button\"]';\n  var SELECTOR_DATA_TOGGLES = '[data-toggle=\"buttons\"]';\n  var SELECTOR_DATA_TOGGLE = '[data-toggle=\"button\"]';\n  var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle=\"buttons\"] .btn';\n  var SELECTOR_INPUT = 'input:not([type=\"hidden\"])';\n  var SELECTOR_ACTIVE = '.active';\n  var SELECTOR_BUTTON = '.btn';\n  var EVENT_CLICK_DATA_API$1 = \"click\" + EVENT_KEY$1 + DATA_API_KEY$1;\n  var EVENT_FOCUS_BLUR_DATA_API = \"focus\" + EVENT_KEY$1 + DATA_API_KEY$1 + \" \" + (\"blur\" + EVENT_KEY$1 + DATA_API_KEY$1);\n  var EVENT_LOAD_DATA_API = \"load\" + EVENT_KEY$1 + DATA_API_KEY$1;\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Button = /*#__PURE__*/function () {\n    function Button(element) {\n      this._element = element;\n      this.shouldAvoidTriggerChange = false;\n    } // Getters\n\n\n    var _proto = Button.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = $__default['default'](this._element).closest(SELECTOR_DATA_TOGGLES)[0];\n\n      if (rootElement) {\n        var input = this._element.querySelector(SELECTOR_INPUT);\n\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = rootElement.querySelector(SELECTOR_ACTIVE);\n\n              if (activeElement) {\n                $__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE);\n              }\n            }\n          }\n\n          if (triggerChangeEvent) {\n            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input\n            if (input.type === 'checkbox' || input.type === 'radio') {\n              input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE);\n            }\n\n            if (!this.shouldAvoidTriggerChange) {\n              $__default['default'](input).trigger('change');\n            }\n          }\n\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n\n      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {\n        if (addAriaPressed) {\n          this._element.setAttribute('aria-pressed', !this._element.classList.contains(CLASS_NAME_ACTIVE));\n        }\n\n        if (triggerChangeEvent) {\n          $__default['default'](this._element).toggleClass(CLASS_NAME_ACTIVE);\n        }\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$1);\n      this._element = null;\n    } // Static\n    ;\n\n    Button._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$1);\n\n        if (!data) {\n          data = new Button(this);\n          $element.data(DATA_KEY$1, data);\n        }\n\n        data.shouldAvoidTriggerChange = avoidTriggerChange;\n\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Button, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$1;\n      }\n    }]);\n\n    return Button;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = event.target;\n    var initialButton = button;\n\n    if (!$__default['default'](button).hasClass(CLASS_NAME_BUTTON)) {\n      button = $__default['default'](button).closest(SELECTOR_BUTTON)[0];\n    }\n\n    if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {\n      event.preventDefault(); // work around Firefox bug #1540995\n    } else {\n      var inputBtn = button.querySelector(SELECTOR_INPUT);\n\n      if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {\n        event.preventDefault(); // work around Firefox bug #1540995\n\n        return;\n      }\n\n      if (initialButton.tagName === 'INPUT' || button.tagName !== 'LABEL') {\n        Button._jQueryInterface.call($__default['default'](button), 'toggle', initialButton.tagName === 'INPUT');\n      }\n    }\n  }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = $__default['default'](event.target).closest(SELECTOR_BUTTON)[0];\n    $__default['default'](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));\n  });\n  $__default['default'](window).on(EVENT_LOAD_DATA_API, function () {\n    // ensure correct active class is set to match the controls' actual values/states\n    // find all checkboxes/readio buttons inside data-toggle groups\n    var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));\n\n    for (var i = 0, len = buttons.length; i < len; i++) {\n      var button = buttons[i];\n      var input = button.querySelector(SELECTOR_INPUT);\n\n      if (input.checked || input.hasAttribute('checked')) {\n        button.classList.add(CLASS_NAME_ACTIVE);\n      } else {\n        button.classList.remove(CLASS_NAME_ACTIVE);\n      }\n    } // find all button toggles\n\n\n    buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE));\n\n    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {\n      var _button = buttons[_i];\n\n      if (_button.getAttribute('aria-pressed') === 'true') {\n        _button.classList.add(CLASS_NAME_ACTIVE);\n      } else {\n        _button.classList.remove(CLASS_NAME_ACTIVE);\n      }\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$1] = Button._jQueryInterface;\n  $__default['default'].fn[NAME$1].Constructor = Button;\n\n  $__default['default'].fn[NAME$1].noConflict = function () {\n    $__default['default'].fn[NAME$1] = JQUERY_NO_CONFLICT$1;\n    return Button._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$2 = 'carousel';\n  var VERSION$2 = '4.6.0';\n  var DATA_KEY$2 = 'bs.carousel';\n  var EVENT_KEY$2 = \".\" + DATA_KEY$2;\n  var DATA_API_KEY$2 = '.data-api';\n  var JQUERY_NO_CONFLICT$2 = $__default['default'].fn[NAME$2];\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var SWIPE_THRESHOLD = 40;\n  var Default = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true,\n    touch: true\n  };\n  var DefaultType = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean',\n    touch: 'boolean'\n  };\n  var DIRECTION_NEXT = 'next';\n  var DIRECTION_PREV = 'prev';\n  var DIRECTION_LEFT = 'left';\n  var DIRECTION_RIGHT = 'right';\n  var EVENT_SLIDE = \"slide\" + EVENT_KEY$2;\n  var EVENT_SLID = \"slid\" + EVENT_KEY$2;\n  var EVENT_KEYDOWN = \"keydown\" + EVENT_KEY$2;\n  var EVENT_MOUSEENTER = \"mouseenter\" + EVENT_KEY$2;\n  var EVENT_MOUSELEAVE = \"mouseleave\" + EVENT_KEY$2;\n  var EVENT_TOUCHSTART = \"touchstart\" + EVENT_KEY$2;\n  var EVENT_TOUCHMOVE = \"touchmove\" + EVENT_KEY$2;\n  var EVENT_TOUCHEND = \"touchend\" + EVENT_KEY$2;\n  var EVENT_POINTERDOWN = \"pointerdown\" + EVENT_KEY$2;\n  var EVENT_POINTERUP = \"pointerup\" + EVENT_KEY$2;\n  var EVENT_DRAG_START = \"dragstart\" + EVENT_KEY$2;\n  var EVENT_LOAD_DATA_API$1 = \"load\" + EVENT_KEY$2 + DATA_API_KEY$2;\n  var EVENT_CLICK_DATA_API$2 = \"click\" + EVENT_KEY$2 + DATA_API_KEY$2;\n  var CLASS_NAME_CAROUSEL = 'carousel';\n  var CLASS_NAME_ACTIVE$1 = 'active';\n  var CLASS_NAME_SLIDE = 'slide';\n  var CLASS_NAME_RIGHT = 'carousel-item-right';\n  var CLASS_NAME_LEFT = 'carousel-item-left';\n  var CLASS_NAME_NEXT = 'carousel-item-next';\n  var CLASS_NAME_PREV = 'carousel-item-prev';\n  var CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  var SELECTOR_ACTIVE$1 = '.active';\n  var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\n  var SELECTOR_ITEM = '.carousel-item';\n  var SELECTOR_ITEM_IMG = '.carousel-item img';\n  var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\n  var SELECTOR_INDICATORS = '.carousel-indicators';\n  var SELECTOR_DATA_SLIDE = '[data-slide], [data-slide-to]';\n  var SELECTOR_DATA_RIDE = '[data-ride=\"carousel\"]';\n  var PointerType = {\n    TOUCH: 'touch',\n    PEN: 'pen'\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Carousel = /*#__PURE__*/function () {\n    function Carousel(element, config) {\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this.touchStartX = 0;\n      this.touchDeltaX = 0;\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);\n      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Carousel.prototype;\n\n    // Public\n    _proto.next = function next() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_NEXT);\n      }\n    };\n\n    _proto.nextWhenVisible = function nextWhenVisible() {\n      var $element = $__default['default'](this._element); // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n\n      if (!document.hidden && $element.is(':visible') && $element.css('visibility') !== 'hidden') {\n        this.next();\n      }\n    };\n\n    _proto.prev = function prev() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_PREV);\n      }\n    };\n\n    _proto.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n\n      if (this._element.querySelector(SELECTOR_NEXT_PREV)) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n\n    _proto.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n\n      if (this._config.interval && !this._isPaused) {\n        this._updateInterval();\n\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n\n    _proto.to = function to(index) {\n      var _this = this;\n\n      this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n\n      var activeIndex = this._getItemIndex(this._activeElement);\n\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n\n      if (this._isSliding) {\n        $__default['default'](this._element).one(EVENT_SLID, function () {\n          return _this.to(index);\n        });\n        return;\n      }\n\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n\n      var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;\n\n      this._slide(direction, this._items[index]);\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'](this._element).off(EVENT_KEY$2);\n      $__default['default'].removeData(this._element, DATA_KEY$2);\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default, config);\n      Util.typeCheckConfig(NAME$2, config, DefaultType);\n      return config;\n    };\n\n    _proto._handleSwipe = function _handleSwipe() {\n      var absDeltax = Math.abs(this.touchDeltaX);\n\n      if (absDeltax <= SWIPE_THRESHOLD) {\n        return;\n      }\n\n      var direction = absDeltax / this.touchDeltaX;\n      this.touchDeltaX = 0; // swipe left\n\n      if (direction > 0) {\n        this.prev();\n      } // swipe right\n\n\n      if (direction < 0) {\n        this.next();\n      }\n    };\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this2 = this;\n\n      if (this._config.keyboard) {\n        $__default['default'](this._element).on(EVENT_KEYDOWN, function (event) {\n          return _this2._keydown(event);\n        });\n      }\n\n      if (this._config.pause === 'hover') {\n        $__default['default'](this._element).on(EVENT_MOUSEENTER, function (event) {\n          return _this2.pause(event);\n        }).on(EVENT_MOUSELEAVE, function (event) {\n          return _this2.cycle(event);\n        });\n      }\n\n      if (this._config.touch) {\n        this._addTouchEventListeners();\n      }\n    };\n\n    _proto._addTouchEventListeners = function _addTouchEventListeners() {\n      var _this3 = this;\n\n      if (!this._touchSupported) {\n        return;\n      }\n\n      var start = function start(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchStartX = event.originalEvent.clientX;\n        } else if (!_this3._pointerEvent) {\n          _this3.touchStartX = event.originalEvent.touches[0].clientX;\n        }\n      };\n\n      var move = function move(event) {\n        // ensure swiping with one touch and not pinching\n        if (event.originalEvent.touches && event.originalEvent.touches.length > 1) {\n          _this3.touchDeltaX = 0;\n        } else {\n          _this3.touchDeltaX = event.originalEvent.touches[0].clientX - _this3.touchStartX;\n        }\n      };\n\n      var end = function end(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;\n        }\n\n        _this3._handleSwipe();\n\n        if (_this3._config.pause === 'hover') {\n          // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          _this3.pause();\n\n          if (_this3.touchTimeout) {\n            clearTimeout(_this3.touchTimeout);\n          }\n\n          _this3.touchTimeout = setTimeout(function (event) {\n            return _this3.cycle(event);\n          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);\n        }\n      };\n\n      $__default['default'](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function (e) {\n        return e.preventDefault();\n      });\n\n      if (this._pointerEvent) {\n        $__default['default'](this._element).on(EVENT_POINTERDOWN, function (event) {\n          return start(event);\n        });\n        $__default['default'](this._element).on(EVENT_POINTERUP, function (event) {\n          return end(event);\n        });\n\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        $__default['default'](this._element).on(EVENT_TOUCHSTART, function (event) {\n          return start(event);\n        });\n        $__default['default'](this._element).on(EVENT_TOUCHMOVE, function (event) {\n          return move(event);\n        });\n        $__default['default'](this._element).on(EVENT_TOUCHEND, function (event) {\n          return end(event);\n        });\n      }\n    };\n\n    _proto._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n      }\n    };\n\n    _proto._getItemIndex = function _getItemIndex(element) {\n      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];\n      return this._items.indexOf(element);\n    };\n\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === DIRECTION_NEXT;\n      var isPrevDirection = direction === DIRECTION_PREV;\n\n      var activeIndex = this._getItemIndex(activeElement);\n\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n\n      var delta = direction === DIRECTION_PREV ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var targetIndex = this._getItemIndex(relatedTarget);\n\n      var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));\n\n      var slideEvent = $__default['default'].Event(EVENT_SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n      $__default['default'](this._element).trigger(slideEvent);\n      return slideEvent;\n    };\n\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));\n        $__default['default'](indicators).removeClass(CLASS_NAME_ACTIVE$1);\n\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n\n        if (nextIndicator) {\n          $__default['default'](nextIndicator).addClass(CLASS_NAME_ACTIVE$1);\n        }\n      }\n    };\n\n    _proto._updateInterval = function _updateInterval() {\n      var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n\n      if (!element) {\n        return;\n      }\n\n      var elementInterval = parseInt(element.getAttribute('data-interval'), 10);\n\n      if (elementInterval) {\n        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n        this._config.interval = elementInterval;\n      } else {\n        this._config.interval = this._config.defaultInterval || this._config.interval;\n      }\n    };\n\n    _proto._slide = function _slide(direction, element) {\n      var _this4 = this;\n\n      var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n\n      var activeElementIndex = this._getItemIndex(activeElement);\n\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n\n      var nextElementIndex = this._getItemIndex(nextElement);\n\n      var isCycling = Boolean(this._interval);\n      var directionalClassName;\n      var orderClassName;\n      var eventDirectionName;\n\n      if (direction === DIRECTION_NEXT) {\n        directionalClassName = CLASS_NAME_LEFT;\n        orderClassName = CLASS_NAME_NEXT;\n        eventDirectionName = DIRECTION_LEFT;\n      } else {\n        directionalClassName = CLASS_NAME_RIGHT;\n        orderClassName = CLASS_NAME_PREV;\n        eventDirectionName = DIRECTION_RIGHT;\n      }\n\n      if (nextElement && $__default['default'](nextElement).hasClass(CLASS_NAME_ACTIVE$1)) {\n        this._isSliding = false;\n        return;\n      }\n\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n\n      this._isSliding = true;\n\n      if (isCycling) {\n        this.pause();\n      }\n\n      this._setActiveIndicatorElement(nextElement);\n\n      this._activeElement = nextElement;\n      var slidEvent = $__default['default'].Event(EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n\n      if ($__default['default'](this._element).hasClass(CLASS_NAME_SLIDE)) {\n        $__default['default'](nextElement).addClass(orderClassName);\n        Util.reflow(nextElement);\n        $__default['default'](activeElement).addClass(directionalClassName);\n        $__default['default'](nextElement).addClass(directionalClassName);\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\n        $__default['default'](activeElement).one(Util.TRANSITION_END, function () {\n          $__default['default'](nextElement).removeClass(directionalClassName + \" \" + orderClassName).addClass(CLASS_NAME_ACTIVE$1);\n          $__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE$1 + \" \" + orderClassName + \" \" + directionalClassName);\n          _this4._isSliding = false;\n          setTimeout(function () {\n            return $__default['default'](_this4._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        $__default['default'](activeElement).removeClass(CLASS_NAME_ACTIVE$1);\n        $__default['default'](nextElement).addClass(CLASS_NAME_ACTIVE$1);\n        this._isSliding = false;\n        $__default['default'](this._element).trigger(slidEvent);\n      }\n\n      if (isCycling) {\n        this.cycle();\n      }\n    } // Static\n    ;\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$2);\n\n        var _config = _extends({}, Default, $__default['default'](this).data());\n\n        if (typeof config === 'object') {\n          _config = _extends({}, _config, config);\n        }\n\n        var action = typeof config === 'string' ? config : _config.slide;\n\n        if (!data) {\n          data = new Carousel(this, _config);\n          $__default['default'](this).data(DATA_KEY$2, data);\n        }\n\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (typeof data[action] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + action + \"\\\"\");\n          }\n\n          data[action]();\n        } else if (_config.interval && _config.ride) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n\n      if (!selector) {\n        return;\n      }\n\n      var target = $__default['default'](selector)[0];\n\n      if (!target || !$__default['default'](target).hasClass(CLASS_NAME_CAROUSEL)) {\n        return;\n      }\n\n      var config = _extends({}, $__default['default'](target).data(), $__default['default'](this).data());\n\n      var slideIndex = this.getAttribute('data-slide-to');\n\n      if (slideIndex) {\n        config.interval = false;\n      }\n\n      Carousel._jQueryInterface.call($__default['default'](target), config);\n\n      if (slideIndex) {\n        $__default['default'](target).data(DATA_KEY$2).to(slideIndex);\n      }\n\n      event.preventDefault();\n    };\n\n    _createClass(Carousel, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$2;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n\n    return Carousel;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);\n  $__default['default'](window).on(EVENT_LOAD_DATA_API$1, function () {\n    var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));\n\n    for (var i = 0, len = carousels.length; i < len; i++) {\n      var $carousel = $__default['default'](carousels[i]);\n\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$2] = Carousel._jQueryInterface;\n  $__default['default'].fn[NAME$2].Constructor = Carousel;\n\n  $__default['default'].fn[NAME$2].noConflict = function () {\n    $__default['default'].fn[NAME$2] = JQUERY_NO_CONFLICT$2;\n    return Carousel._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$3 = 'collapse';\n  var VERSION$3 = '4.6.0';\n  var DATA_KEY$3 = 'bs.collapse';\n  var EVENT_KEY$3 = \".\" + DATA_KEY$3;\n  var DATA_API_KEY$3 = '.data-api';\n  var JQUERY_NO_CONFLICT$3 = $__default['default'].fn[NAME$3];\n  var Default$1 = {\n    toggle: true,\n    parent: ''\n  };\n  var DefaultType$1 = {\n    toggle: 'boolean',\n    parent: '(string|element)'\n  };\n  var EVENT_SHOW = \"show\" + EVENT_KEY$3;\n  var EVENT_SHOWN = \"shown\" + EVENT_KEY$3;\n  var EVENT_HIDE = \"hide\" + EVENT_KEY$3;\n  var EVENT_HIDDEN = \"hidden\" + EVENT_KEY$3;\n  var EVENT_CLICK_DATA_API$3 = \"click\" + EVENT_KEY$3 + DATA_API_KEY$3;\n  var CLASS_NAME_SHOW$1 = 'show';\n  var CLASS_NAME_COLLAPSE = 'collapse';\n  var CLASS_NAME_COLLAPSING = 'collapsing';\n  var CLASS_NAME_COLLAPSED = 'collapsed';\n  var DIMENSION_WIDTH = 'width';\n  var DIMENSION_HEIGHT = 'height';\n  var SELECTOR_ACTIVES = '.show, .collapsing';\n  var SELECTOR_DATA_TOGGLE$1 = '[data-toggle=\"collapse\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Collapse = /*#__PURE__*/function () {\n    function Collapse(element, config) {\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = [].slice.call(document.querySelectorAll(\"[data-toggle=\\\"collapse\\\"][href=\\\"#\" + element.id + \"\\\"],\" + (\"[data-toggle=\\\"collapse\\\"][data-target=\\\"#\" + element.id + \"\\\"]\")));\n      var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$1));\n\n      for (var i = 0, len = toggleList.length; i < len; i++) {\n        var elem = toggleList[i];\n        var selector = Util.getSelectorFromElement(elem);\n        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\n          return foundElem === element;\n        });\n\n        if (selector !== null && filterElement.length > 0) {\n          this._selector = selector;\n\n          this._triggerArray.push(elem);\n        }\n      }\n\n      this._parent = this._config.parent ? this._getParent() : null;\n\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n\n    var _proto = Collapse.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if ($__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._isTransitioning || $__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {\n        return;\n      }\n\n      var actives;\n      var activesData;\n\n      if (this._parent) {\n        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {\n          if (typeof _this._config.parent === 'string') {\n            return elem.getAttribute('data-parent') === _this._config.parent;\n          }\n\n          return elem.classList.contains(CLASS_NAME_COLLAPSE);\n        });\n\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n\n      if (actives) {\n        activesData = $__default['default'](actives).not(this._selector).data(DATA_KEY$3);\n\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n\n      var startEvent = $__default['default'].Event(EVENT_SHOW);\n      $__default['default'](this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (actives) {\n        Collapse._jQueryInterface.call($__default['default'](actives).not(this._selector), 'hide');\n\n        if (!activesData) {\n          $__default['default'](actives).data(DATA_KEY$3, null);\n        }\n      }\n\n      var dimension = this._getDimension();\n\n      $__default['default'](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);\n      this._element.style[dimension] = 0;\n\n      if (this._triggerArray.length) {\n        $__default['default'](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        $__default['default'](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + \" \" + CLASS_NAME_SHOW$1);\n        _this._element.style[dimension] = '';\n\n        _this.setTransitioning(false);\n\n        $__default['default'](_this._element).trigger(EVENT_SHOWN);\n      };\n\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = \"scroll\" + capitalizedDimension;\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = this._element[scrollSize] + \"px\";\n    };\n\n    _proto.hide = function hide() {\n      var _this2 = this;\n\n      if (this._isTransitioning || !$__default['default'](this._element).hasClass(CLASS_NAME_SHOW$1)) {\n        return;\n      }\n\n      var startEvent = $__default['default'].Event(EVENT_HIDE);\n      $__default['default'](this._element).trigger(startEvent);\n\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      var dimension = this._getDimension();\n\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \"px\";\n      Util.reflow(this._element);\n      $__default['default'](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + \" \" + CLASS_NAME_SHOW$1);\n      var triggerArrayLength = this._triggerArray.length;\n\n      if (triggerArrayLength > 0) {\n        for (var i = 0; i < triggerArrayLength; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = Util.getSelectorFromElement(trigger);\n\n          if (selector !== null) {\n            var $elem = $__default['default']([].slice.call(document.querySelectorAll(selector)));\n\n            if (!$elem.hasClass(CLASS_NAME_SHOW$1)) {\n              $__default['default'](trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);\n            }\n          }\n        }\n      }\n\n      this.setTransitioning(true);\n\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n\n        $__default['default'](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN);\n      };\n\n      this._element.style[dimension] = '';\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    };\n\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$3);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$1, config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      Util.typeCheckConfig(NAME$3, config, DefaultType$1);\n      return config;\n    };\n\n    _proto._getDimension = function _getDimension() {\n      var hasWidth = $__default['default'](this._element).hasClass(DIMENSION_WIDTH);\n      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;\n    };\n\n    _proto._getParent = function _getParent() {\n      var _this3 = this;\n\n      var parent;\n\n      if (Util.isElement(this._config.parent)) {\n        parent = this._config.parent; // It's a jQuery object\n\n        if (typeof this._config.parent.jquery !== 'undefined') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = document.querySelector(this._config.parent);\n      }\n\n      var selector = \"[data-toggle=\\\"collapse\\\"][data-parent=\\\"\" + this._config.parent + \"\\\"]\";\n      var children = [].slice.call(parent.querySelectorAll(selector));\n      $__default['default'](children).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    };\n\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      var isOpen = $__default['default'](element).hasClass(CLASS_NAME_SHOW$1);\n\n      if (triggerArray.length) {\n        $__default['default'](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n      }\n    } // Static\n    ;\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? document.querySelector(selector) : null;\n    };\n\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$3);\n\n        var _config = _extends({}, Default$1, $element.data(), typeof config === 'object' && config ? config : {});\n\n        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n\n        if (!data) {\n          data = new Collapse(this, _config);\n          $element.data(DATA_KEY$3, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Collapse, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$3;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$1;\n      }\n    }]);\n\n    return Collapse;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$1, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.currentTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n\n    var $trigger = $__default['default'](this);\n    var selector = Util.getSelectorFromElement(this);\n    var selectors = [].slice.call(document.querySelectorAll(selector));\n    $__default['default'](selectors).each(function () {\n      var $target = $__default['default'](this);\n      var data = $target.data(DATA_KEY$3);\n      var config = data ? 'toggle' : $trigger.data();\n\n      Collapse._jQueryInterface.call($target, config);\n    });\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$3] = Collapse._jQueryInterface;\n  $__default['default'].fn[NAME$3].Constructor = Collapse;\n\n  $__default['default'].fn[NAME$3].noConflict = function () {\n    $__default['default'].fn[NAME$3] = JQUERY_NO_CONFLICT$3;\n    return Collapse._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$4 = 'dropdown';\n  var VERSION$4 = '4.6.0';\n  var DATA_KEY$4 = 'bs.dropdown';\n  var EVENT_KEY$4 = \".\" + DATA_KEY$4;\n  var DATA_API_KEY$4 = '.data-api';\n  var JQUERY_NO_CONFLICT$4 = $__default['default'].fn[NAME$4];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\n\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\n\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + \"|\" + ARROW_DOWN_KEYCODE + \"|\" + ESCAPE_KEYCODE);\n  var EVENT_HIDE$1 = \"hide\" + EVENT_KEY$4;\n  var EVENT_HIDDEN$1 = \"hidden\" + EVENT_KEY$4;\n  var EVENT_SHOW$1 = \"show\" + EVENT_KEY$4;\n  var EVENT_SHOWN$1 = \"shown\" + EVENT_KEY$4;\n  var EVENT_CLICK = \"click\" + EVENT_KEY$4;\n  var EVENT_CLICK_DATA_API$4 = \"click\" + EVENT_KEY$4 + DATA_API_KEY$4;\n  var EVENT_KEYDOWN_DATA_API = \"keydown\" + EVENT_KEY$4 + DATA_API_KEY$4;\n  var EVENT_KEYUP_DATA_API = \"keyup\" + EVENT_KEY$4 + DATA_API_KEY$4;\n  var CLASS_NAME_DISABLED = 'disabled';\n  var CLASS_NAME_SHOW$2 = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPRIGHT = 'dropright';\n  var CLASS_NAME_DROPLEFT = 'dropleft';\n  var CLASS_NAME_MENURIGHT = 'dropdown-menu-right';\n  var CLASS_NAME_POSITION_STATIC = 'position-static';\n  var SELECTOR_DATA_TOGGLE$2 = '[data-toggle=\"dropdown\"]';\n  var SELECTOR_FORM_CHILD = '.dropdown form';\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = 'top-start';\n  var PLACEMENT_TOPEND = 'top-end';\n  var PLACEMENT_BOTTOM = 'bottom-start';\n  var PLACEMENT_BOTTOMEND = 'bottom-end';\n  var PLACEMENT_RIGHT = 'right-start';\n  var PLACEMENT_LEFT = 'left-start';\n  var Default$2 = {\n    offset: 0,\n    flip: true,\n    boundary: 'scrollParent',\n    reference: 'toggle',\n    display: 'dynamic',\n    popperConfig: null\n  };\n  var DefaultType$2 = {\n    offset: '(number|string|function)',\n    flip: 'boolean',\n    boundary: '(string|element)',\n    reference: '(string|element)',\n    display: 'string',\n    popperConfig: '(null|object)'\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Dropdown = /*#__PURE__*/function () {\n    function Dropdown(element, config) {\n      this._element = element;\n      this._popper = null;\n      this._config = this._getConfig(config);\n      this._menu = this._getMenuElement();\n      this._inNavbar = this._detectNavbar();\n\n      this._addEventListeners();\n    } // Getters\n\n\n    var _proto = Dropdown.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n\n      var isActive = $__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2);\n\n      Dropdown._clearMenus();\n\n      if (isActive) {\n        return;\n      }\n\n      this.show(true);\n    };\n\n    _proto.show = function show(usePopper) {\n      if (usePopper === void 0) {\n        usePopper = false;\n      }\n\n      if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED) || $__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2)) {\n        return;\n      }\n\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = $__default['default'].Event(EVENT_SHOW$1, relatedTarget);\n\n      var parent = Dropdown._getParentFromElement(this._element);\n\n      $__default['default'](parent).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      } // Totally disable Popper for Dropdowns in Navbar\n\n\n      if (!this._inNavbar && usePopper) {\n        /**\n         * Check for Popper dependency\n         * Popper - https://popper.js.org\n         */\n        if (typeof Popper__default['default'] === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n\n        var referenceElement = this._element;\n\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (Util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference; // Check if it's jQuery element\n\n          if (typeof this._config.reference.jquery !== 'undefined') {\n            referenceElement = this._config.reference[0];\n          }\n        } // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to \"escape\" the scroll parent's boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n\n\n        if (this._config.boundary !== 'scrollParent') {\n          $__default['default'](parent).addClass(CLASS_NAME_POSITION_STATIC);\n        }\n\n        this._popper = new Popper__default['default'](referenceElement, this._menu, this._getPopperConfig());\n      } // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n\n      if ('ontouchstart' in document.documentElement && $__default['default'](parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {\n        $__default['default'](document.body).children().on('mouseover', null, $__default['default'].noop);\n      }\n\n      this._element.focus();\n\n      this._element.setAttribute('aria-expanded', true);\n\n      $__default['default'](this._menu).toggleClass(CLASS_NAME_SHOW$2);\n      $__default['default'](parent).toggleClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_SHOWN$1, relatedTarget));\n    };\n\n    _proto.hide = function hide() {\n      if (this._element.disabled || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED) || !$__default['default'](this._menu).hasClass(CLASS_NAME_SHOW$2)) {\n        return;\n      }\n\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$1, relatedTarget);\n\n      var parent = Dropdown._getParentFromElement(this._element);\n\n      $__default['default'](parent).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      $__default['default'](this._menu).toggleClass(CLASS_NAME_SHOW$2);\n      $__default['default'](parent).toggleClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_HIDDEN$1, relatedTarget));\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$4);\n      $__default['default'](this._element).off(EVENT_KEY$4);\n      this._element = null;\n      this._menu = null;\n\n      if (this._popper !== null) {\n        this._popper.destroy();\n\n        this._popper = null;\n      }\n    };\n\n    _proto.update = function update() {\n      this._inNavbar = this._detectNavbar();\n\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Private\n    ;\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this = this;\n\n      $__default['default'](this._element).on(EVENT_CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        _this.toggle();\n      });\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, this.constructor.Default, $__default['default'](this._element).data(), config);\n      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._getMenuElement = function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n\n        if (parent) {\n          this._menu = parent.querySelector(SELECTOR_MENU);\n        }\n      }\n\n      return this._menu;\n    };\n\n    _proto._getPlacement = function _getPlacement() {\n      var $parentDropdown = $__default['default'](this._element.parentNode);\n      var placement = PLACEMENT_BOTTOM; // Handle dropup\n\n      if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {\n        placement = $__default['default'](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {\n        placement = PLACEMENT_RIGHT;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {\n        placement = PLACEMENT_LEFT;\n      } else if ($__default['default'](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {\n        placement = PLACEMENT_BOTTOMEND;\n      }\n\n      return placement;\n    };\n\n    _proto._detectNavbar = function _detectNavbar() {\n      return $__default['default'](this._element).closest('.navbar').length > 0;\n    };\n\n    _proto._getOffset = function _getOffset() {\n      var _this2 = this;\n\n      var offset = {};\n\n      if (typeof this._config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = _extends({}, data.offsets, _this2._config.offset(data.offsets, _this2._element) || {});\n          return data;\n        };\n      } else {\n        offset.offset = this._config.offset;\n      }\n\n      return offset;\n    };\n\n    _proto._getPopperConfig = function _getPopperConfig() {\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        }\n      }; // Disable Popper if we have a static display\n\n      if (this._config.display === 'static') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n\n      return _extends({}, popperConfig, this._config.popperConfig);\n    } // Static\n    ;\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$4);\n\n        var _config = typeof config === 'object' ? config : null;\n\n        if (!data) {\n          data = new Dropdown(this, _config);\n          $__default['default'](this).data(DATA_KEY$4, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n\n      var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));\n\n      for (var i = 0, len = toggles.length; i < len; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n\n        var context = $__default['default'](toggles[i]).data(DATA_KEY$4);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n\n        if (event && event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n\n        if (!context) {\n          continue;\n        }\n\n        var dropdownMenu = context._menu;\n\n        if (!$__default['default'](parent).hasClass(CLASS_NAME_SHOW$2)) {\n          continue;\n        }\n\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $__default['default'].contains(parent, event.target)) {\n          continue;\n        }\n\n        var hideEvent = $__default['default'].Event(EVENT_HIDE$1, relatedTarget);\n        $__default['default'](parent).trigger(hideEvent);\n\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n\n        if ('ontouchstart' in document.documentElement) {\n          $__default['default'](document.body).children().off('mouseover', null, $__default['default'].noop);\n        }\n\n        toggles[i].setAttribute('aria-expanded', 'false');\n\n        if (context._popper) {\n          context._popper.destroy();\n        }\n\n        $__default['default'](dropdownMenu).removeClass(CLASS_NAME_SHOW$2);\n        $__default['default'](parent).removeClass(CLASS_NAME_SHOW$2).trigger($__default['default'].Event(EVENT_HIDDEN$1, relatedTarget));\n      }\n    };\n\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent;\n      var selector = Util.getSelectorFromElement(element);\n\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n\n      return parent || element.parentNode;\n    } // eslint-disable-next-line complexity\n    ;\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default['default'](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n\n      if (this.disabled || $__default['default'](this).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n\n      var parent = Dropdown._getParentFromElement(this);\n\n      var isActive = $__default['default'](parent).hasClass(CLASS_NAME_SHOW$2);\n\n      if (!isActive && event.which === ESCAPE_KEYCODE) {\n        return;\n      }\n\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (!isActive || event.which === ESCAPE_KEYCODE || event.which === SPACE_KEYCODE) {\n        if (event.which === ESCAPE_KEYCODE) {\n          $__default['default'](parent.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger('focus');\n        }\n\n        $__default['default'](this).trigger('click');\n        return;\n      }\n\n      var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {\n        return $__default['default'](item).is(':visible');\n      });\n\n      if (items.length === 0) {\n        return;\n      }\n\n      var index = items.indexOf(event.target);\n\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n\n      if (index < 0) {\n        index = 0;\n      }\n\n      items[index].focus();\n    };\n\n    _createClass(Dropdown, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$4;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$2;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }]);\n\n    return Dropdown;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$4 + \" \" + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$2, function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n\n    Dropdown._jQueryInterface.call($__default['default'](this), 'toggle');\n  }).on(EVENT_CLICK_DATA_API$4, SELECTOR_FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$4] = Dropdown._jQueryInterface;\n  $__default['default'].fn[NAME$4].Constructor = Dropdown;\n\n  $__default['default'].fn[NAME$4].noConflict = function () {\n    $__default['default'].fn[NAME$4] = JQUERY_NO_CONFLICT$4;\n    return Dropdown._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$5 = 'modal';\n  var VERSION$5 = '4.6.0';\n  var DATA_KEY$5 = 'bs.modal';\n  var EVENT_KEY$5 = \".\" + DATA_KEY$5;\n  var DATA_API_KEY$5 = '.data-api';\n  var JQUERY_NO_CONFLICT$5 = $__default['default'].fn[NAME$5];\n  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var Default$3 = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n  var DefaultType$3 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean',\n    show: 'boolean'\n  };\n  var EVENT_HIDE$2 = \"hide\" + EVENT_KEY$5;\n  var EVENT_HIDE_PREVENTED = \"hidePrevented\" + EVENT_KEY$5;\n  var EVENT_HIDDEN$2 = \"hidden\" + EVENT_KEY$5;\n  var EVENT_SHOW$2 = \"show\" + EVENT_KEY$5;\n  var EVENT_SHOWN$2 = \"shown\" + EVENT_KEY$5;\n  var EVENT_FOCUSIN = \"focusin\" + EVENT_KEY$5;\n  var EVENT_RESIZE = \"resize\" + EVENT_KEY$5;\n  var EVENT_CLICK_DISMISS = \"click.dismiss\" + EVENT_KEY$5;\n  var EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\" + EVENT_KEY$5;\n  var EVENT_MOUSEUP_DISMISS = \"mouseup.dismiss\" + EVENT_KEY$5;\n  var EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\" + EVENT_KEY$5;\n  var EVENT_CLICK_DATA_API$5 = \"click\" + EVENT_KEY$5 + DATA_API_KEY$5;\n  var CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';\n  var CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';\n  var CLASS_NAME_BACKDROP = 'modal-backdrop';\n  var CLASS_NAME_OPEN = 'modal-open';\n  var CLASS_NAME_FADE$1 = 'fade';\n  var CLASS_NAME_SHOW$3 = 'show';\n  var CLASS_NAME_STATIC = 'modal-static';\n  var SELECTOR_DIALOG = '.modal-dialog';\n  var SELECTOR_MODAL_BODY = '.modal-body';\n  var SELECTOR_DATA_TOGGLE$3 = '[data-toggle=\"modal\"]';\n  var SELECTOR_DATA_DISMISS = '[data-dismiss=\"modal\"]';\n  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  var SELECTOR_STICKY_CONTENT = '.sticky-top';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Modal = /*#__PURE__*/function () {\n    function Modal(element, config) {\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = element.querySelector(SELECTOR_DIALOG);\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._isTransitioning = false;\n      this._scrollbarWidth = 0;\n    } // Getters\n\n\n    var _proto = Modal.prototype;\n\n    // Public\n    _proto.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n\n    _proto.show = function show(relatedTarget) {\n      var _this = this;\n\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      if ($__default['default'](this._element).hasClass(CLASS_NAME_FADE$1)) {\n        this._isTransitioning = true;\n      }\n\n      var showEvent = $__default['default'].Event(EVENT_SHOW$2, {\n        relatedTarget: relatedTarget\n      });\n      $__default['default'](this._element).trigger(showEvent);\n\n      if (this._isShown || showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = true;\n\n      this._checkScrollbar();\n\n      this._setScrollbar();\n\n      this._adjustDialog();\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $__default['default'](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function (event) {\n        return _this.hide(event);\n      });\n      $__default['default'](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {\n        $__default['default'](_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {\n          if ($__default['default'](event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    };\n\n    _proto.hide = function hide(event) {\n      var _this2 = this;\n\n      if (event) {\n        event.preventDefault();\n      }\n\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$2);\n      $__default['default'](this._element).trigger(hideEvent);\n\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._isShown = false;\n      var transition = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1);\n\n      if (transition) {\n        this._isTransitioning = true;\n      }\n\n      this._setEscapeEvent();\n\n      this._setResizeEvent();\n\n      $__default['default'](document).off(EVENT_FOCUSIN);\n      $__default['default'](this._element).removeClass(CLASS_NAME_SHOW$3);\n      $__default['default'](this._element).off(EVENT_CLICK_DISMISS);\n      $__default['default'](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default['default'](this._element).one(Util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      [window, this._element, this._dialog].forEach(function (htmlElement) {\n        return $__default['default'](htmlElement).off(EVENT_KEY$5);\n      });\n      /**\n       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n       * Do not move `document` in `htmlElements` array\n       * It will remove `EVENT_CLICK_DATA_API` event that should remain\n       */\n\n      $__default['default'](document).off(EVENT_FOCUSIN);\n      $__default['default'].removeData(this._element, DATA_KEY$5);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._isTransitioning = null;\n      this._scrollbarWidth = null;\n    };\n\n    _proto.handleUpdate = function handleUpdate() {\n      this._adjustDialog();\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$3, config);\n      Util.typeCheckConfig(NAME$5, config, DefaultType$3);\n      return config;\n    };\n\n    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {\n      var _this3 = this;\n\n      var hideEventPrevented = $__default['default'].Event(EVENT_HIDE_PREVENTED);\n      $__default['default'](this._element).trigger(hideEventPrevented);\n\n      if (hideEventPrevented.isDefaultPrevented()) {\n        return;\n      }\n\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = 'hidden';\n      }\n\n      this._element.classList.add(CLASS_NAME_STATIC);\n\n      var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n      $__default['default'](this._element).off(Util.TRANSITION_END);\n      $__default['default'](this._element).one(Util.TRANSITION_END, function () {\n        _this3._element.classList.remove(CLASS_NAME_STATIC);\n\n        if (!isModalOverflowing) {\n          $__default['default'](_this3._element).one(Util.TRANSITION_END, function () {\n            _this3._element.style.overflowY = '';\n          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);\n        }\n      }).emulateTransitionEnd(modalTransitionDuration);\n\n      this._element.focus();\n    };\n\n    _proto._showElement = function _showElement(relatedTarget) {\n      var _this4 = this;\n\n      var transition = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1);\n      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;\n\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don't move modal's DOM position\n        document.body.appendChild(this._element);\n      }\n\n      this._element.style.display = 'block';\n\n      this._element.removeAttribute('aria-hidden');\n\n      this._element.setAttribute('aria-modal', true);\n\n      this._element.setAttribute('role', 'dialog');\n\n      if ($__default['default'](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {\n        modalBody.scrollTop = 0;\n      } else {\n        this._element.scrollTop = 0;\n      }\n\n      if (transition) {\n        Util.reflow(this._element);\n      }\n\n      $__default['default'](this._element).addClass(CLASS_NAME_SHOW$3);\n\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n\n      var shownEvent = $__default['default'].Event(EVENT_SHOWN$2, {\n        relatedTarget: relatedTarget\n      });\n\n      var transitionComplete = function transitionComplete() {\n        if (_this4._config.focus) {\n          _this4._element.focus();\n        }\n\n        _this4._isTransitioning = false;\n        $__default['default'](_this4._element).trigger(shownEvent);\n      };\n\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n        $__default['default'](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    };\n\n    _proto._enforceFocus = function _enforceFocus() {\n      var _this5 = this;\n\n      $__default['default'](document).off(EVENT_FOCUSIN) // Guard against infinite focus loop\n      .on(EVENT_FOCUSIN, function (event) {\n        if (document !== event.target && _this5._element !== event.target && $__default['default'](_this5._element).has(event.target).length === 0) {\n          _this5._element.focus();\n        }\n      });\n    };\n\n    _proto._setEscapeEvent = function _setEscapeEvent() {\n      var _this6 = this;\n\n      if (this._isShown) {\n        $__default['default'](this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {\n          if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE$1) {\n            event.preventDefault();\n\n            _this6.hide();\n          } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE$1) {\n            _this6._triggerBackdropTransition();\n          }\n        });\n      } else if (!this._isShown) {\n        $__default['default'](this._element).off(EVENT_KEYDOWN_DISMISS);\n      }\n    };\n\n    _proto._setResizeEvent = function _setResizeEvent() {\n      var _this7 = this;\n\n      if (this._isShown) {\n        $__default['default'](window).on(EVENT_RESIZE, function (event) {\n          return _this7.handleUpdate(event);\n        });\n      } else {\n        $__default['default'](window).off(EVENT_RESIZE);\n      }\n    };\n\n    _proto._hideModal = function _hideModal() {\n      var _this8 = this;\n\n      this._element.style.display = 'none';\n\n      this._element.setAttribute('aria-hidden', true);\n\n      this._element.removeAttribute('aria-modal');\n\n      this._element.removeAttribute('role');\n\n      this._isTransitioning = false;\n\n      this._showBackdrop(function () {\n        $__default['default'](document.body).removeClass(CLASS_NAME_OPEN);\n\n        _this8._resetAdjustments();\n\n        _this8._resetScrollbar();\n\n        $__default['default'](_this8._element).trigger(EVENT_HIDDEN$2);\n      });\n    };\n\n    _proto._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $__default['default'](this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n\n    _proto._showBackdrop = function _showBackdrop(callback) {\n      var _this9 = this;\n\n      var animate = $__default['default'](this._element).hasClass(CLASS_NAME_FADE$1) ? CLASS_NAME_FADE$1 : '';\n\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = CLASS_NAME_BACKDROP;\n\n        if (animate) {\n          this._backdrop.classList.add(animate);\n        }\n\n        $__default['default'](this._backdrop).appendTo(document.body);\n        $__default['default'](this._element).on(EVENT_CLICK_DISMISS, function (event) {\n          if (_this9._ignoreBackdropClick) {\n            _this9._ignoreBackdropClick = false;\n            return;\n          }\n\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n\n          if (_this9._config.backdrop === 'static') {\n            _this9._triggerBackdropTransition();\n          } else {\n            _this9.hide();\n          }\n        });\n\n        if (animate) {\n          Util.reflow(this._backdrop);\n        }\n\n        $__default['default'](this._backdrop).addClass(CLASS_NAME_SHOW$3);\n\n        if (!callback) {\n          return;\n        }\n\n        if (!animate) {\n          callback();\n          return;\n        }\n\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n        $__default['default'](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        $__default['default'](this._backdrop).removeClass(CLASS_NAME_SHOW$3);\n\n        var callbackRemove = function callbackRemove() {\n          _this9._removeBackdrop();\n\n          if (callback) {\n            callback();\n          }\n        };\n\n        if ($__default['default'](this._element).hasClass(CLASS_NAME_FADE$1)) {\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n\n          $__default['default'](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    } // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n    ;\n\n    _proto._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + \"px\";\n      }\n\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + \"px\";\n      }\n    };\n\n    _proto._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    };\n\n    _proto._checkScrollbar = function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n\n    _proto._setScrollbar = function _setScrollbar() {\n      var _this10 = this;\n\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\n        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding\n\n        $__default['default'](fixedContent).each(function (index, element) {\n          var actualPadding = element.style.paddingRight;\n          var calculatedPadding = $__default['default'](element).css('padding-right');\n          $__default['default'](element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + \"px\");\n        }); // Adjust sticky content margin\n\n        $__default['default'](stickyContent).each(function (index, element) {\n          var actualMargin = element.style.marginRight;\n          var calculatedMargin = $__default['default'](element).css('margin-right');\n          $__default['default'](element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + \"px\");\n        }); // Adjust body padding\n\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = $__default['default'](document.body).css('padding-right');\n        $__default['default'](document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \"px\");\n      }\n\n      $__default['default'](document.body).addClass(CLASS_NAME_OPEN);\n    };\n\n    _proto._resetScrollbar = function _resetScrollbar() {\n      // Restore fixed content padding\n      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n      $__default['default'](fixedContent).each(function (index, element) {\n        var padding = $__default['default'](element).data('padding-right');\n        $__default['default'](element).removeData('padding-right');\n        element.style.paddingRight = padding ? padding : '';\n      }); // Restore sticky content\n\n      var elements = [].slice.call(document.querySelectorAll(\"\" + SELECTOR_STICKY_CONTENT));\n      $__default['default'](elements).each(function (index, element) {\n        var margin = $__default['default'](element).data('margin-right');\n\n        if (typeof margin !== 'undefined') {\n          $__default['default'](element).css('margin-right', margin).removeData('margin-right');\n        }\n      }); // Restore body padding\n\n      var padding = $__default['default'](document.body).data('padding-right');\n      $__default['default'](document.body).removeData('padding-right');\n      document.body.style.paddingRight = padding ? padding : '';\n    };\n\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    } // Static\n    ;\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$5);\n\n        var _config = _extends({}, Default$3, $__default['default'](this).data(), typeof config === 'object' && config ? config : {});\n\n        if (!data) {\n          data = new Modal(this, _config);\n          $__default['default'](this).data(DATA_KEY$5, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n\n    _createClass(Modal, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$5;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$3;\n      }\n    }]);\n\n    return Modal;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE$3, function (event) {\n    var _this11 = this;\n\n    var target;\n    var selector = Util.getSelectorFromElement(this);\n\n    if (selector) {\n      target = document.querySelector(selector);\n    }\n\n    var config = $__default['default'](target).data(DATA_KEY$5) ? 'toggle' : _extends({}, $__default['default'](target).data(), $__default['default'](this).data());\n\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\n      event.preventDefault();\n    }\n\n    var $target = $__default['default'](target).one(EVENT_SHOW$2, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // Only register focus restorer if modal will actually get shown\n        return;\n      }\n\n      $target.one(EVENT_HIDDEN$2, function () {\n        if ($__default['default'](_this11).is(':visible')) {\n          _this11.focus();\n        }\n      });\n    });\n\n    Modal._jQueryInterface.call($__default['default'](target), config, this);\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$5] = Modal._jQueryInterface;\n  $__default['default'].fn[NAME$5].Constructor = Modal;\n\n  $__default['default'].fn[NAME$5].noConflict = function () {\n    $__default['default'].fn[NAME$5] = JQUERY_NO_CONFLICT$5;\n    return Modal._jQueryInterface;\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.0): tools/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  var DefaultWhitelist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n\n  function allowedAttribute(attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n\n    if (allowedAttributeList.indexOf(attrName) !== -1) {\n      if (uriAttrs.indexOf(attrName) !== -1) {\n        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));\n      }\n\n      return true;\n    }\n\n    var regExp = allowedAttributeList.filter(function (attrRegex) {\n      return attrRegex instanceof RegExp;\n    }); // Check if a regular expression validates the attribute.\n\n    for (var i = 0, len = regExp.length; i < len; i++) {\n      if (attrName.match(regExp[i])) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {\n    if (unsafeHtml.length === 0) {\n      return unsafeHtml;\n    }\n\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\n      return sanitizeFn(unsafeHtml);\n    }\n\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    var whitelistKeys = Object.keys(whiteList);\n    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));\n\n    var _loop = function _loop(i, len) {\n      var el = elements[i];\n      var elName = el.nodeName.toLowerCase();\n\n      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {\n        el.parentNode.removeChild(el);\n        return \"continue\";\n      }\n\n      var attributeList = [].slice.call(el.attributes);\n      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n      attributeList.forEach(function (attr) {\n        if (!allowedAttribute(attr, whitelistedAttributes)) {\n          el.removeAttribute(attr.nodeName);\n        }\n      });\n    };\n\n    for (var i = 0, len = elements.length; i < len; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n    }\n\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$6 = 'tooltip';\n  var VERSION$6 = '4.6.0';\n  var DATA_KEY$6 = 'bs.tooltip';\n  var EVENT_KEY$6 = \".\" + DATA_KEY$6;\n  var JQUERY_NO_CONFLICT$6 = $__default['default'].fn[NAME$6];\n  var CLASS_PREFIX = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\n  var DefaultType$4 = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string|function)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)',\n    customClass: '(string|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    whiteList: 'object',\n    popperConfig: '(null|object)'\n  };\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default$4 = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent',\n    customClass: '',\n    sanitize: true,\n    sanitizeFn: null,\n    whiteList: DefaultWhitelist,\n    popperConfig: null\n  };\n  var HOVER_STATE_SHOW = 'show';\n  var HOVER_STATE_OUT = 'out';\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY$6,\n    HIDDEN: \"hidden\" + EVENT_KEY$6,\n    SHOW: \"show\" + EVENT_KEY$6,\n    SHOWN: \"shown\" + EVENT_KEY$6,\n    INSERTED: \"inserted\" + EVENT_KEY$6,\n    CLICK: \"click\" + EVENT_KEY$6,\n    FOCUSIN: \"focusin\" + EVENT_KEY$6,\n    FOCUSOUT: \"focusout\" + EVENT_KEY$6,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY$6,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY$6\n  };\n  var CLASS_NAME_FADE$2 = 'fade';\n  var CLASS_NAME_SHOW$4 = 'show';\n  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  var SELECTOR_ARROW = '.arrow';\n  var TRIGGER_HOVER = 'hover';\n  var TRIGGER_FOCUS = 'focus';\n  var TRIGGER_CLICK = 'click';\n  var TRIGGER_MANUAL = 'manual';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Tooltip = /*#__PURE__*/function () {\n    function Tooltip(element, config) {\n      if (typeof Popper__default['default'] === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      } // private\n\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $__default['default'](event.currentTarget).data(dataKey);\n\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $__default['default'](event.currentTarget).data(dataKey, context);\n        }\n\n        context._activeTrigger.click = !context._activeTrigger.click;\n\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($__default['default'](this.getTipElement()).hasClass(CLASS_NAME_SHOW$4)) {\n          this._leave(null, this);\n\n          return;\n        }\n\n        this._enter(null, this);\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $__default['default'].removeData(this.element, this.constructor.DATA_KEY);\n      $__default['default'](this.element).off(this.constructor.EVENT_KEY);\n      $__default['default'](this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);\n\n      if (this.tip) {\n        $__default['default'](this.tip).remove();\n      }\n\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n\n      if (this._popper) {\n        this._popper.destroy();\n      }\n\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n\n    _proto.show = function show() {\n      var _this = this;\n\n      if ($__default['default'](this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n\n      var showEvent = $__default['default'].Event(this.constructor.Event.SHOW);\n\n      if (this.isWithContent() && this._isEnabled) {\n        $__default['default'](this.element).trigger(showEvent);\n        var shadowRoot = Util.findShadowRoot(this.element);\n        var isInTheDom = $__default['default'].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\n\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n\n        if (this.config.animation) {\n          $__default['default'](tip).addClass(CLASS_NAME_FADE$2);\n        }\n\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n\n        var attachment = this._getAttachment(placement);\n\n        this.addAttachmentClass(attachment);\n\n        var container = this._getContainer();\n\n        $__default['default'](tip).data(this.constructor.DATA_KEY, this);\n\n        if (!$__default['default'].contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $__default['default'](tip).appendTo(container);\n        }\n\n        $__default['default'](this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper__default['default'](this.element, tip, this._getPopperConfig(attachment));\n        $__default['default'](tip).addClass(CLASS_NAME_SHOW$4);\n        $__default['default'](tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $__default['default'](document.body).children().on('mouseover', null, $__default['default'].noop);\n        }\n\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $__default['default'](_this.element).trigger(_this.constructor.Event.SHOWN);\n\n          if (prevHoverState === HOVER_STATE_OUT) {\n            _this._leave(null, _this);\n          }\n        };\n\n        if ($__default['default'](this.tip).hasClass(CLASS_NAME_FADE$2)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $__default['default'](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n\n      var tip = this.getTipElement();\n      var hideEvent = $__default['default'].Event(this.constructor.Event.HIDE);\n\n      var complete = function complete() {\n        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n\n        _this2._cleanTipClass();\n\n        _this2.element.removeAttribute('aria-describedby');\n\n        $__default['default'](_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n\n        if (callback) {\n          callback();\n        }\n      };\n\n      $__default['default'](this.element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      $__default['default'](tip).removeClass(CLASS_NAME_SHOW$4); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $__default['default'](document.body).children().off('mouseover', null, $__default['default'].noop);\n      }\n\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n\n      if ($__default['default'](this.tip).hasClass(CLASS_NAME_FADE$2)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $__default['default'](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n\n      this._hoverState = '';\n    };\n\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Protected\n    ;\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default['default'](this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default['default'](this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var tip = this.getTipElement();\n      this.setElementContent($__default['default'](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());\n      $__default['default'](tip).removeClass(CLASS_NAME_FADE$2 + \" \" + CLASS_NAME_SHOW$4);\n    };\n\n    _proto.setElementContent = function setElementContent($element, content) {\n      if (typeof content === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (this.config.html) {\n          if (!$__default['default'](content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($__default['default'](content).text());\n        }\n\n        return;\n      }\n\n      if (this.config.html) {\n        if (this.config.sanitize) {\n          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\n        }\n\n        $element.html(content);\n      } else {\n        $element.text(content);\n      }\n    };\n\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n\n      return title;\n    } // Private\n    ;\n\n    _proto._getPopperConfig = function _getPopperConfig(attachment) {\n      var _this3 = this;\n\n      var defaultBsConfig = {\n        placement: attachment,\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            behavior: this.config.fallbackPlacement\n          },\n          arrow: {\n            element: SELECTOR_ARROW\n          },\n          preventOverflow: {\n            boundariesElement: this.config.boundary\n          }\n        },\n        onCreate: function onCreate(data) {\n          if (data.originalPlacement !== data.placement) {\n            _this3._handlePopperPlacementChange(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          return _this3._handlePopperPlacementChange(data);\n        }\n      };\n      return _extends({}, defaultBsConfig, this.config.popperConfig);\n    };\n\n    _proto._getOffset = function _getOffset() {\n      var _this4 = this;\n\n      var offset = {};\n\n      if (typeof this.config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = _extends({}, data.offsets, _this4.config.offset(data.offsets, _this4.element) || {});\n          return data;\n        };\n      } else {\n        offset.offset = this.config.offset;\n      }\n\n      return offset;\n    };\n\n    _proto._getContainer = function _getContainer() {\n      if (this.config.container === false) {\n        return document.body;\n      }\n\n      if (Util.isElement(this.config.container)) {\n        return $__default['default'](this.config.container);\n      }\n\n      return $__default['default'](document).find(this.config.container);\n    };\n\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this5 = this;\n\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $__default['default'](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {\n            return _this5.toggle(event);\n          });\n        } else if (trigger !== TRIGGER_MANUAL) {\n          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;\n          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;\n          $__default['default'](_this5.element).on(eventIn, _this5.config.selector, function (event) {\n            return _this5._enter(event);\n          }).on(eventOut, _this5.config.selector, function (event) {\n            return _this5._leave(event);\n          });\n        }\n      });\n\n      this._hideModalHandler = function () {\n        if (_this5.element) {\n          _this5.hide();\n        }\n      };\n\n      $__default['default'](this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);\n\n      if (this.config.selector) {\n        this.config = _extends({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = typeof this.element.getAttribute('data-original-title');\n\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default['default'](event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default['default'](event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n      }\n\n      if ($__default['default'](context.getTipElement()).hasClass(CLASS_NAME_SHOW$4) || context._hoverState === HOVER_STATE_SHOW) {\n        context._hoverState = HOVER_STATE_SHOW;\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_SHOW;\n\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default['default'](event.currentTarget).data(dataKey);\n\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default['default'](event.currentTarget).data(dataKey, context);\n      }\n\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;\n      }\n\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_OUT;\n\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    _proto._getConfig = function _getConfig(config) {\n      var dataAttributes = $__default['default'](this.element).data();\n      Object.keys(dataAttributes).forEach(function (dataAttr) {\n        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\n          delete dataAttributes[dataAttr];\n        }\n      });\n      config = _extends({}, this.constructor.Default, dataAttributes, typeof config === 'object' && config ? config : {});\n\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n\n      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);\n\n      if (config.sanitize) {\n        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\n      }\n\n      return config;\n    };\n\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n\n      return config;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default['default'](this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n\n      if (tabClass !== null && tabClass.length) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {\n      this.tip = popperData.instance.popper;\n\n      this._cleanTipClass();\n\n      this.addAttachmentClass(this._getAttachment(popperData.placement));\n    };\n\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n\n      $__default['default'](tip).removeClass(CLASS_NAME_FADE$2);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    } // Static\n    ;\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$6);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $element.data(DATA_KEY$6, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$6;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$4;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$6;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY$6;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY$6;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$4;\n      }\n    }]);\n\n    return Tooltip;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'].fn[NAME$6] = Tooltip._jQueryInterface;\n  $__default['default'].fn[NAME$6].Constructor = Tooltip;\n\n  $__default['default'].fn[NAME$6].noConflict = function () {\n    $__default['default'].fn[NAME$6] = JQUERY_NO_CONFLICT$6;\n    return Tooltip._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$7 = 'popover';\n  var VERSION$7 = '4.6.0';\n  var DATA_KEY$7 = 'bs.popover';\n  var EVENT_KEY$7 = \".\" + DATA_KEY$7;\n  var JQUERY_NO_CONFLICT$7 = $__default['default'].fn[NAME$7];\n  var CLASS_PREFIX$1 = 'bs-popover';\n  var BSCLS_PREFIX_REGEX$1 = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX$1 + \"\\\\S+\", 'g');\n\n  var Default$5 = _extends({}, Tooltip.Default, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div></div>'\n  });\n\n  var DefaultType$5 = _extends({}, Tooltip.DefaultType, {\n    content: '(string|element|function)'\n  });\n\n  var CLASS_NAME_FADE$3 = 'fade';\n  var CLASS_NAME_SHOW$5 = 'show';\n  var SELECTOR_TITLE = '.popover-header';\n  var SELECTOR_CONTENT = '.popover-body';\n  var Event$1 = {\n    HIDE: \"hide\" + EVENT_KEY$7,\n    HIDDEN: \"hidden\" + EVENT_KEY$7,\n    SHOW: \"show\" + EVENT_KEY$7,\n    SHOWN: \"shown\" + EVENT_KEY$7,\n    INSERTED: \"inserted\" + EVENT_KEY$7,\n    CLICK: \"click\" + EVENT_KEY$7,\n    FOCUSIN: \"focusin\" + EVENT_KEY$7,\n    FOCUSOUT: \"focusout\" + EVENT_KEY$7,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY$7,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY$7\n  };\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inheritsLoose(Popover, _Tooltip);\n\n    function Popover() {\n      return _Tooltip.apply(this, arguments) || this;\n    }\n\n    var _proto = Popover.prototype;\n\n    // Overrides\n    _proto.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default['default'](this.getTipElement()).addClass(CLASS_PREFIX$1 + \"-\" + attachment);\n    };\n\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default['default'](this.config.template)[0];\n      return this.tip;\n    };\n\n    _proto.setContent = function setContent() {\n      var $tip = $__default['default'](this.getTipElement()); // We use append for html objects to maintain js events\n\n      this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());\n\n      var content = this._getContent();\n\n      if (typeof content === 'function') {\n        content = content.call(this.element);\n      }\n\n      this.setElementContent($tip.find(SELECTOR_CONTENT), content);\n      $tip.removeClass(CLASS_NAME_FADE$3 + \" \" + CLASS_NAME_SHOW$5);\n    } // Private\n    ;\n\n    _proto._getContent = function _getContent() {\n      return this.element.getAttribute('data-content') || this.config.content;\n    };\n\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default['default'](this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);\n\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    } // Static\n    ;\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$7);\n\n        var _config = typeof config === 'object' ? config : null;\n\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n\n        if (!data) {\n          data = new Popover(this, _config);\n          $__default['default'](this).data(DATA_KEY$7, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Popover, null, [{\n      key: \"VERSION\",\n      // Getters\n      get: function get() {\n        return VERSION$7;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$7;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY$7;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event$1;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY$7;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$5;\n      }\n    }]);\n\n    return Popover;\n  }(Tooltip);\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'].fn[NAME$7] = Popover._jQueryInterface;\n  $__default['default'].fn[NAME$7].Constructor = Popover;\n\n  $__default['default'].fn[NAME$7].noConflict = function () {\n    $__default['default'].fn[NAME$7] = JQUERY_NO_CONFLICT$7;\n    return Popover._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$8 = 'scrollspy';\n  var VERSION$8 = '4.6.0';\n  var DATA_KEY$8 = 'bs.scrollspy';\n  var EVENT_KEY$8 = \".\" + DATA_KEY$8;\n  var DATA_API_KEY$6 = '.data-api';\n  var JQUERY_NO_CONFLICT$8 = $__default['default'].fn[NAME$8];\n  var Default$6 = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n  var DefaultType$6 = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n  var EVENT_ACTIVATE = \"activate\" + EVENT_KEY$8;\n  var EVENT_SCROLL = \"scroll\" + EVENT_KEY$8;\n  var EVENT_LOAD_DATA_API$2 = \"load\" + EVENT_KEY$8 + DATA_API_KEY$6;\n  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  var CLASS_NAME_ACTIVE$2 = 'active';\n  var SELECTOR_DATA_SPY = '[data-spy=\"scroll\"]';\n  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  var SELECTOR_NAV_LINKS = '.nav-link';\n  var SELECTOR_NAV_ITEMS = '.nav-item';\n  var SELECTOR_LIST_ITEMS = '.list-group-item';\n  var SELECTOR_DROPDOWN = '.dropdown';\n  var SELECTOR_DROPDOWN_ITEMS = '.dropdown-item';\n  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  var METHOD_OFFSET = 'offset';\n  var METHOD_POSITION = 'position';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var ScrollSpy = /*#__PURE__*/function () {\n    function ScrollSpy(element, config) {\n      var _this = this;\n\n      this._element = element;\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + \" \" + SELECTOR_NAV_LINKS + \",\" + (this._config.target + \" \" + SELECTOR_LIST_ITEMS + \",\") + (this._config.target + \" \" + SELECTOR_DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n      $__default['default'](this._scrollElement).on(EVENT_SCROLL, function (event) {\n        return _this._process(event);\n      });\n      this.refresh();\n\n      this._process();\n    } // Getters\n\n\n    var _proto = ScrollSpy.prototype;\n\n    // Public\n    _proto.refresh = function refresh() {\n      var _this2 = this;\n\n      var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n      var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n      this._offsets = [];\n      this._targets = [];\n      this._scrollHeight = this._getScrollHeight();\n      var targets = [].slice.call(document.querySelectorAll(this._selector));\n      targets.map(function (element) {\n        var target;\n        var targetSelector = Util.getSelectorFromElement(element);\n\n        if (targetSelector) {\n          target = document.querySelector(targetSelector);\n        }\n\n        if (target) {\n          var targetBCR = target.getBoundingClientRect();\n\n          if (targetBCR.width || targetBCR.height) {\n            // TODO (fat): remove sketch reliance on jQuery position/offset\n            return [$__default['default'](target)[offsetMethod]().top + offsetBase, targetSelector];\n          }\n        }\n\n        return null;\n      }).filter(function (item) {\n        return item;\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this2._offsets.push(item[0]);\n\n        _this2._targets.push(item[1]);\n      });\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$8);\n      $__default['default'](this._scrollElement).off(EVENT_KEY$8);\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$6, typeof config === 'object' && config ? config : {});\n\n      if (typeof config.target !== 'string' && Util.isElement(config.target)) {\n        var id = $__default['default'](config.target).attr('id');\n\n        if (!id) {\n          id = Util.getUID(NAME$8);\n          $__default['default'](config.target).attr('id', id);\n        }\n\n        config.target = \"#\" + id;\n      }\n\n      Util.typeCheckConfig(NAME$8, config, DefaultType$6);\n      return config;\n    };\n\n    _proto._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n\n    _proto._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n\n    _proto._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    };\n\n    _proto._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n\n      var scrollHeight = this._getScrollHeight();\n\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n\n        return;\n      }\n\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n\n        this._clear();\n\n        return;\n      }\n\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n\n    _proto._activate = function _activate(target) {\n      this._activeTarget = target;\n\n      this._clear();\n\n      var queries = this._selector.split(',').map(function (selector) {\n        return selector + \"[data-target=\\\"\" + target + \"\\\"],\" + selector + \"[href=\\\"\" + target + \"\\\"]\";\n      });\n\n      var $link = $__default['default']([].slice.call(document.querySelectorAll(queries.join(','))));\n\n      if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {\n        $link.closest(SELECTOR_DROPDOWN).find(SELECTOR_DROPDOWN_TOGGLE).addClass(CLASS_NAME_ACTIVE$2);\n        $link.addClass(CLASS_NAME_ACTIVE$2);\n      } else {\n        // Set triggered link as active\n        $link.addClass(CLASS_NAME_ACTIVE$2); // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_LINKS + \", \" + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$2); // Handle special case when .nav-link is inside .nav-item\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$2);\n      }\n\n      $__default['default'](this._scrollElement).trigger(EVENT_ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n\n    _proto._clear = function _clear() {\n      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {\n        return node.classList.contains(CLASS_NAME_ACTIVE$2);\n      }).forEach(function (node) {\n        return node.classList.remove(CLASS_NAME_ACTIVE$2);\n      });\n    } // Static\n    ;\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default['default'](this).data(DATA_KEY$8);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $__default['default'](this).data(DATA_KEY$8, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(ScrollSpy, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$8;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$6;\n      }\n    }]);\n\n    return ScrollSpy;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](window).on(EVENT_LOAD_DATA_API$2, function () {\n    var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));\n    var scrollSpysLength = scrollSpys.length;\n\n    for (var i = scrollSpysLength; i--;) {\n      var $spy = $__default['default'](scrollSpys[i]);\n\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$8] = ScrollSpy._jQueryInterface;\n  $__default['default'].fn[NAME$8].Constructor = ScrollSpy;\n\n  $__default['default'].fn[NAME$8].noConflict = function () {\n    $__default['default'].fn[NAME$8] = JQUERY_NO_CONFLICT$8;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$9 = 'tab';\n  var VERSION$9 = '4.6.0';\n  var DATA_KEY$9 = 'bs.tab';\n  var EVENT_KEY$9 = \".\" + DATA_KEY$9;\n  var DATA_API_KEY$7 = '.data-api';\n  var JQUERY_NO_CONFLICT$9 = $__default['default'].fn[NAME$9];\n  var EVENT_HIDE$3 = \"hide\" + EVENT_KEY$9;\n  var EVENT_HIDDEN$3 = \"hidden\" + EVENT_KEY$9;\n  var EVENT_SHOW$3 = \"show\" + EVENT_KEY$9;\n  var EVENT_SHOWN$3 = \"shown\" + EVENT_KEY$9;\n  var EVENT_CLICK_DATA_API$6 = \"click\" + EVENT_KEY$9 + DATA_API_KEY$7;\n  var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\n  var CLASS_NAME_ACTIVE$3 = 'active';\n  var CLASS_NAME_DISABLED$1 = 'disabled';\n  var CLASS_NAME_FADE$4 = 'fade';\n  var CLASS_NAME_SHOW$6 = 'show';\n  var SELECTOR_DROPDOWN$1 = '.dropdown';\n  var SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\n  var SELECTOR_ACTIVE$2 = '.active';\n  var SELECTOR_ACTIVE_UL = '> li > .active';\n  var SELECTOR_DATA_TOGGLE$4 = '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  var SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Tab = /*#__PURE__*/function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n\n    var _proto = Tab.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default['default'](this._element).hasClass(CLASS_NAME_ACTIVE$3) || $__default['default'](this._element).hasClass(CLASS_NAME_DISABLED$1)) {\n        return;\n      }\n\n      var target;\n      var previous;\n      var listElement = $__default['default'](this._element).closest(SELECTOR_NAV_LIST_GROUP$1)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE$2;\n        previous = $__default['default'].makeArray($__default['default'](listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$3, {\n        relatedTarget: this._element\n      });\n      var showEvent = $__default['default'].Event(EVENT_SHOW$3, {\n        relatedTarget: previous\n      });\n\n      if (previous) {\n        $__default['default'](previous).trigger(hideEvent);\n      }\n\n      $__default['default'](this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      if (selector) {\n        target = document.querySelector(selector);\n      }\n\n      this._activate(this._element, listElement);\n\n      var complete = function complete() {\n        var hiddenEvent = $__default['default'].Event(EVENT_HIDDEN$3, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $__default['default'].Event(EVENT_SHOWN$3, {\n          relatedTarget: previous\n        });\n        $__default['default'](previous).trigger(hiddenEvent);\n        $__default['default'](_this._element).trigger(shownEvent);\n      };\n\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.dispose = function dispose() {\n      $__default['default'].removeData(this._element, DATA_KEY$9);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n\n      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $__default['default'](container).find(SELECTOR_ACTIVE_UL) : $__default['default'](container).children(SELECTOR_ACTIVE$2);\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $__default['default'](active).hasClass(CLASS_NAME_FADE$4);\n\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $__default['default'](active).removeClass(CLASS_NAME_SHOW$6).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $__default['default'](active).removeClass(CLASS_NAME_ACTIVE$3);\n        var dropdownChild = $__default['default'](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];\n\n        if (dropdownChild) {\n          $__default['default'](dropdownChild).removeClass(CLASS_NAME_ACTIVE$3);\n        }\n\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n\n      $__default['default'](element).addClass(CLASS_NAME_ACTIVE$3);\n\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n\n      Util.reflow(element);\n\n      if (element.classList.contains(CLASS_NAME_FADE$4)) {\n        element.classList.add(CLASS_NAME_SHOW$6);\n      }\n\n      if (element.parentNode && $__default['default'](element.parentNode).hasClass(CLASS_NAME_DROPDOWN_MENU)) {\n        var dropdownElement = $__default['default'](element).closest(SELECTOR_DROPDOWN$1)[0];\n\n        if (dropdownElement) {\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE$1));\n          $__default['default'](dropdownToggleList).addClass(CLASS_NAME_ACTIVE$3);\n        }\n\n        element.setAttribute('aria-expanded', true);\n      }\n\n      if (callback) {\n        callback();\n      }\n    } // Static\n    ;\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $__default['default'](this);\n        var data = $this.data(DATA_KEY$9);\n\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY$9, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config]();\n        }\n      });\n    };\n\n    _createClass(Tab, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$9;\n      }\n    }]);\n\n    return Tab;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * Data Api implementation\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$4, function (event) {\n    event.preventDefault();\n\n    Tab._jQueryInterface.call($__default['default'](this), 'show');\n  });\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n  $__default['default'].fn[NAME$9] = Tab._jQueryInterface;\n  $__default['default'].fn[NAME$9].Constructor = Tab;\n\n  $__default['default'].fn[NAME$9].noConflict = function () {\n    $__default['default'].fn[NAME$9] = JQUERY_NO_CONFLICT$9;\n    return Tab._jQueryInterface;\n  };\n\n  /**\n   * ------------------------------------------------------------------------\n   * Constants\n   * ------------------------------------------------------------------------\n   */\n\n  var NAME$a = 'toast';\n  var VERSION$a = '4.6.0';\n  var DATA_KEY$a = 'bs.toast';\n  var EVENT_KEY$a = \".\" + DATA_KEY$a;\n  var JQUERY_NO_CONFLICT$a = $__default['default'].fn[NAME$a];\n  var EVENT_CLICK_DISMISS$1 = \"click.dismiss\" + EVENT_KEY$a;\n  var EVENT_HIDE$4 = \"hide\" + EVENT_KEY$a;\n  var EVENT_HIDDEN$4 = \"hidden\" + EVENT_KEY$a;\n  var EVENT_SHOW$4 = \"show\" + EVENT_KEY$a;\n  var EVENT_SHOWN$4 = \"shown\" + EVENT_KEY$a;\n  var CLASS_NAME_FADE$5 = 'fade';\n  var CLASS_NAME_HIDE = 'hide';\n  var CLASS_NAME_SHOW$7 = 'show';\n  var CLASS_NAME_SHOWING = 'showing';\n  var DefaultType$7 = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  var Default$7 = {\n    animation: true,\n    autohide: true,\n    delay: 500\n  };\n  var SELECTOR_DATA_DISMISS$1 = '[data-dismiss=\"toast\"]';\n  /**\n   * ------------------------------------------------------------------------\n   * Class Definition\n   * ------------------------------------------------------------------------\n   */\n\n  var Toast = /*#__PURE__*/function () {\n    function Toast(element, config) {\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._timeout = null;\n\n      this._setListeners();\n    } // Getters\n\n\n    var _proto = Toast.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n\n      var showEvent = $__default['default'].Event(EVENT_SHOW$4);\n      $__default['default'](this._element).trigger(showEvent);\n\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._clearTimeout();\n\n      if (this._config.animation) {\n        this._element.classList.add(CLASS_NAME_FADE$5);\n      }\n\n      var complete = function complete() {\n        _this._element.classList.remove(CLASS_NAME_SHOWING);\n\n        _this._element.classList.add(CLASS_NAME_SHOW$7);\n\n        $__default['default'](_this._element).trigger(EVENT_SHOWN$4);\n\n        if (_this._config.autohide) {\n          _this._timeout = setTimeout(function () {\n            _this.hide();\n          }, _this._config.delay);\n        }\n      };\n\n      this._element.classList.remove(CLASS_NAME_HIDE);\n\n      Util.reflow(this._element);\n\n      this._element.classList.add(CLASS_NAME_SHOWING);\n\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto.hide = function hide() {\n      if (!this._element.classList.contains(CLASS_NAME_SHOW$7)) {\n        return;\n      }\n\n      var hideEvent = $__default['default'].Event(EVENT_HIDE$4);\n      $__default['default'](this._element).trigger(hideEvent);\n\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n\n      this._close();\n    };\n\n    _proto.dispose = function dispose() {\n      this._clearTimeout();\n\n      if (this._element.classList.contains(CLASS_NAME_SHOW$7)) {\n        this._element.classList.remove(CLASS_NAME_SHOW$7);\n      }\n\n      $__default['default'](this._element).off(EVENT_CLICK_DISMISS$1);\n      $__default['default'].removeData(this._element, DATA_KEY$a);\n      this._element = null;\n      this._config = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends({}, Default$7, $__default['default'](this._element).data(), typeof config === 'object' && config ? config : {});\n      Util.typeCheckConfig(NAME$a, config, this.constructor.DefaultType);\n      return config;\n    };\n\n    _proto._setListeners = function _setListeners() {\n      var _this2 = this;\n\n      $__default['default'](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function () {\n        return _this2.hide();\n      });\n    };\n\n    _proto._close = function _close() {\n      var _this3 = this;\n\n      var complete = function complete() {\n        _this3._element.classList.add(CLASS_NAME_HIDE);\n\n        $__default['default'](_this3._element).trigger(EVENT_HIDDEN$4);\n      };\n\n      this._element.classList.remove(CLASS_NAME_SHOW$7);\n\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default['default'](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n\n    _proto._clearTimeout = function _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    } // Static\n    ;\n\n    Toast._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default['default'](this);\n        var data = $element.data(DATA_KEY$a);\n\n        var _config = typeof config === 'object' && config;\n\n        if (!data) {\n          data = new Toast(this, _config);\n          $element.data(DATA_KEY$a, data);\n        }\n\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n\n          data[config](this);\n        }\n      });\n    };\n\n    _createClass(Toast, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$a;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$7;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$7;\n      }\n    }]);\n\n    return Toast;\n  }();\n  /**\n   * ------------------------------------------------------------------------\n   * jQuery\n   * ------------------------------------------------------------------------\n   */\n\n\n  $__default['default'].fn[NAME$a] = Toast._jQueryInterface;\n  $__default['default'].fn[NAME$a].Constructor = Toast;\n\n  $__default['default'].fn[NAME$a].noConflict = function () {\n    $__default['default'].fn[NAME$a] = JQUERY_NO_CONFLICT$a;\n    return Toast._jQueryInterface;\n  };\n\n  exports.Alert = Alert;\n  exports.Button = Button;\n  exports.Carousel = Carousel;\n  exports.Collapse = Collapse;\n  exports.Dropdown = Dropdown;\n  exports.Modal = Modal;\n  exports.Popover = Popover;\n  exports.Scrollspy = ScrollSpy;\n  exports.Tab = Tab;\n  exports.Toast = Toast;\n  exports.Tooltip = Tooltip;\n  exports.Util = Util;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=bootstrap.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmpzPzQ5ODkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxLQUE0RCxvQkFBb0IsbUJBQU8sQ0FBQyxvREFBUSxHQUFHLG1CQUFPLENBQUMsOERBQVc7QUFDeEgsRUFBRSxDQUN3STtBQUMxSSxDQUFDLHVDQUF1Qzs7QUFFeEMsc0NBQXNDLDREQUE0RCxnQkFBZ0I7O0FBRWxIO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixzQkFBc0I7QUFDM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QixLQUFLO0FBQ0w7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBLDJDQUEyQyxXQUFXO0FBQ3REOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsK0JBQStCOztBQUUvQixtQ0FBbUM7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7QUFDQSwrQkFBK0I7QUFDL0I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFNBQVM7QUFDcEQ7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGOztBQUU5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsRUFBRTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxFQUFFOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEVBQUU7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1HQUFtRzs7QUFFcEk7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdGQUF3Rjs7QUFFeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVJQUF1STs7QUFFdkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEVBQUU7O0FBRVAsd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnRUFBZ0U7QUFDaEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQyx3RUFBd0U7QUFDNUc7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsMEJBQTBCLDhGQUE4Rjs7QUFFeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGlDQUFpQztBQUNqQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDs7QUFFN0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsMEJBQTBCLCtEQUErRDs7QUFFekY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsS0FBSztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBLG1JQUFtSTs7QUFFbkk7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxLQUFLO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7OztBQUdMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSwwQkFBMEIsNEdBQTRHO0FBQ3RJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnREFBZ0QsY0FBYzs7QUFFOUQsQ0FBQztBQUNEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2pzL2Jvb3RzdHJhcC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICAqIEJvb3RzdHJhcCB2NC42LjAgKGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS8pXG4gICogQ29weXJpZ2h0IDIwMTEtMjAyMSBUaGUgQm9vdHN0cmFwIEF1dGhvcnMgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ncmFwaHMvY29udHJpYnV0b3JzKVxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzLCByZXF1aXJlKCdqcXVlcnknKSwgcmVxdWlyZSgncG9wcGVyLmpzJykpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cycsICdqcXVlcnknLCAncG9wcGVyLmpzJ10sIGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuYm9vdHN0cmFwID0ge30sIGdsb2JhbC5qUXVlcnksIGdsb2JhbC5Qb3BwZXIpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzLCAkLCBQb3BwZXIpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdExlZ2FjeSAoZSkgeyByZXR1cm4gZSAmJiB0eXBlb2YgZSA9PT0gJ29iamVjdCcgJiYgJ2RlZmF1bHQnIGluIGUgPyBlIDogeyAnZGVmYXVsdCc6IGUgfTsgfVxuXG4gIHZhciAkX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdExlZ2FjeSgkKTtcbiAgdmFyIFBvcHBlcl9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koUG9wcGVyKTtcblxuICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH1cblxuICBmdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCAodjQuNi4wKTogdXRpbC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBUUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJztcbiAgdmFyIE1BWF9VSUQgPSAxMDAwMDAwO1xuICB2YXIgTUlMTElTRUNPTkRTX01VTFRJUExJRVIgPSAxMDAwOyAvLyBTaG91dG91dCBBbmd1c0Nyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG5cbiAgZnVuY3Rpb24gdG9UeXBlKG9iaikge1xuICAgIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBcIlwiICsgb2JqO1xuICAgIH1cblxuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTcGVjaWFsVHJhbnNpdGlvbkVuZEV2ZW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICBiaW5kVHlwZTogVFJBTlNJVElPTl9FTkQsXG4gICAgICBkZWxlZ2F0ZVR5cGU6IFRSQU5TSVRJT05fRU5ELFxuICAgICAgaGFuZGxlOiBmdW5jdGlvbiBoYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXShldmVudC50YXJnZXQpLmlzKHRoaXMpKSB7XG4gICAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uRW5kRW11bGF0b3IoZHVyYXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIFV0aWwudHJpZ2dlclRyYW5zaXRpb25FbmQoX3RoaXMpO1xuICAgICAgfVxuICAgIH0sIGR1cmF0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYW5zaXRpb25FbmRTdXBwb3J0KCkge1xuICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbi5lbXVsYXRlVHJhbnNpdGlvbkVuZCA9IHRyYW5zaXRpb25FbmRFbXVsYXRvcjtcbiAgICAkX19kZWZhdWx0WydkZWZhdWx0J10uZXZlbnQuc3BlY2lhbFtVdGlsLlRSQU5TSVRJT05fRU5EXSA9IGdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQoKTtcbiAgfVxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogUHVibGljIFV0aWwgQXBpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgdmFyIFV0aWwgPSB7XG4gICAgVFJBTlNJVElPTl9FTkQ6ICdic1RyYW5zaXRpb25FbmQnLFxuICAgIGdldFVJRDogZnVuY3Rpb24gZ2V0VUlEKHByZWZpeCkge1xuICAgICAgZG8ge1xuICAgICAgICBwcmVmaXggKz0gfn4oTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpOyAvLyBcIn5+XCIgYWN0cyBsaWtlIGEgZmFzdGVyIE1hdGguZmxvb3IoKSBoZXJlXG4gICAgICB9IHdoaWxlIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwcmVmaXgpKTtcblxuICAgICAgcmV0dXJuIHByZWZpeDtcbiAgICB9LFxuICAgIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQ6IGZ1bmN0aW9uIGdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0Jyk7XG5cbiAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09ICcjJykge1xuICAgICAgICB2YXIgaHJlZkF0dHIgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xuICAgICAgICBzZWxlY3RvciA9IGhyZWZBdHRyICYmIGhyZWZBdHRyICE9PSAnIycgPyBocmVmQXR0ci50cmltKCkgOiAnJztcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50OiBmdW5jdGlvbiBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IC8vIEdldCB0cmFuc2l0aW9uLWR1cmF0aW9uIG9mIHRoZSBlbGVtZW50XG5cblxuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nKTtcbiAgICAgIHZhciB0cmFuc2l0aW9uRGVsYXkgPSAkX19kZWZhdWx0WydkZWZhdWx0J10oZWxlbWVudCkuY3NzKCd0cmFuc2l0aW9uLWRlbGF5Jyk7XG4gICAgICB2YXIgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB2YXIgZmxvYXRUcmFuc2l0aW9uRGVsYXkgPSBwYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSk7IC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcblxuICAgICAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9IC8vIElmIG11bHRpcGxlIGR1cmF0aW9ucyBhcmUgZGVmaW5lZCwgdGFrZSB0aGUgZmlyc3RcblxuXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcbiAgICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xuICAgICAgcmV0dXJuIChwYXJzZUZsb2F0KHRyYW5zaXRpb25EdXJhdGlvbikgKyBwYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XG4gICAgfSxcbiAgICByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgfSxcbiAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gdHJpZ2dlclRyYW5zaXRpb25FbmQoZWxlbWVudCkge1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLnRyaWdnZXIoVFJBTlNJVElPTl9FTkQpO1xuICAgIH0sXG4gICAgc3VwcG9ydHNUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiBzdXBwb3J0c1RyYW5zaXRpb25FbmQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihUUkFOU0lUSU9OX0VORCk7XG4gICAgfSxcbiAgICBpc0VsZW1lbnQ6IGZ1bmN0aW9uIGlzRWxlbWVudChvYmopIHtcbiAgICAgIHJldHVybiAob2JqWzBdIHx8IG9iaikubm9kZVR5cGU7XG4gICAgfSxcbiAgICB0eXBlQ2hlY2tDb25maWc6IGZ1bmN0aW9uIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSB7XG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb25maWdUeXBlcykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZ1R5cGVzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IGNvbmZpZ1R5cGVzW3Byb3BlcnR5XTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xuICAgICAgICAgIHZhciB2YWx1ZVR5cGUgPSB2YWx1ZSAmJiBVdGlsLmlzRWxlbWVudCh2YWx1ZSkgPyAnZWxlbWVudCcgOiB0b1R5cGUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXBvbmVudE5hbWUudG9VcHBlckNhc2UoKSArIFwiOiBcIiArIChcIk9wdGlvbiBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIiBwcm92aWRlZCB0eXBlIFxcXCJcIiArIHZhbHVlVHlwZSArIFwiXFxcIiBcIikgKyAoXCJidXQgZXhwZWN0ZWQgdHlwZSBcXFwiXCIgKyBleHBlY3RlZFR5cGVzICsgXCJcXFwiLlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBmaW5kU2hhZG93Um9vdDogZnVuY3Rpb24gZmluZFNoYWRvd1Jvb3QoZWxlbWVudCkge1xuICAgICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyBDYW4gZmluZCB0aGUgc2hhZG93IHJvb3Qgb3RoZXJ3aXNlIGl0J2xsIHJldHVybiB0aGUgZG9jdW1lbnRcblxuXG4gICAgICBpZiAodHlwZW9mIGVsZW1lbnQuZ2V0Um9vdE5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XG4gICAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9IC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG5cblxuICAgICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBVdGlsLmZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSk7XG4gICAgfSxcbiAgICBqUXVlcnlEZXRlY3Rpb246IGZ1bmN0aW9uIGpRdWVyeURldGVjdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2YgJF9fZGVmYXVsdFsnZGVmYXVsdCddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5LiBqUXVlcnkgbXVzdCBiZSBpbmNsdWRlZCBiZWZvcmUgQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0LicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmVyc2lvbiA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbi5qcXVlcnkuc3BsaXQoJyAnKVswXS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG1pbk1ham9yID0gMTtcbiAgICAgIHZhciBsdE1ham9yID0gMjtcbiAgICAgIHZhciBtaW5NaW5vciA9IDk7XG4gICAgICB2YXIgbWluUGF0Y2ggPSAxO1xuICAgICAgdmFyIG1heE1ham9yID0gNDtcblxuICAgICAgaWYgKHZlcnNpb25bMF0gPCBsdE1ham9yICYmIHZlcnNpb25bMV0gPCBtaW5NaW5vciB8fCB2ZXJzaW9uWzBdID09PSBtaW5NYWpvciAmJiB2ZXJzaW9uWzFdID09PSBtaW5NaW5vciAmJiB2ZXJzaW9uWzJdIDwgbWluUGF0Y2ggfHwgdmVyc2lvblswXSA+PSBtYXhNYWpvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdCByZXF1aXJlcyBhdCBsZWFzdCBqUXVlcnkgdjEuOS4xIGJ1dCBsZXNzIHRoYW4gdjQuMC4wJyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBVdGlsLmpRdWVyeURldGVjdGlvbigpO1xuICBzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCgpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSA9ICdhbGVydCc7XG4gIHZhciBWRVJTSU9OID0gJzQuNi4wJztcbiAgdmFyIERBVEFfS0VZID0gJ2JzLmFsZXJ0JztcbiAgdmFyIEVWRU5UX0tFWSA9IFwiLlwiICsgREFUQV9LRVk7XG4gIHZhciBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FXTtcbiAgdmFyIFNFTEVDVE9SX0RJU01JU1MgPSAnW2RhdGEtZGlzbWlzcz1cImFsZXJ0XCJdJztcbiAgdmFyIEVWRU5UX0NMT1NFID0gXCJjbG9zZVwiICsgRVZFTlRfS0VZO1xuICB2YXIgRVZFTlRfQ0xPU0VEID0gXCJjbG9zZWRcIiArIEVWRU5UX0tFWTtcbiAgdmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gXCJjbGlja1wiICsgRVZFTlRfS0VZICsgREFUQV9BUElfS0VZO1xuICB2YXIgQ0xBU1NfTkFNRV9BTEVSVCA9ICdhbGVydCc7XG4gIHZhciBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG4gIHZhciBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdyc7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIEFsZXJ0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBbGVydChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IEFsZXJ0LnByb3RvdHlwZTtcblxuICAgIC8vIFB1YmxpY1xuICAgIF9wcm90by5jbG9zZSA9IGZ1bmN0aW9uIGNsb3NlKGVsZW1lbnQpIHtcbiAgICAgIHZhciByb290RWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXN0b21FdmVudCA9IHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KHJvb3RFbGVtZW50KTtcblxuICAgICAgaWYgKGN1c3RvbUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudChyb290RWxlbWVudCk7XG4gICAgfTtcblxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH0gLy8gUHJpdmF0ZVxuICAgIDtcblxuICAgIF9wcm90by5fZ2V0Um9vdEVsZW1lbnQgPSBmdW5jdGlvbiBfZ2V0Um9vdEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpO1xuICAgICAgdmFyIHBhcmVudCA9IGZhbHNlO1xuXG4gICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgIHBhcmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5jbG9zZXN0KFwiLlwiICsgQ0xBU1NfTkFNRV9BTEVSVClbMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfTtcblxuICAgIF9wcm90by5fdHJpZ2dlckNsb3NlRXZlbnQgPSBmdW5jdGlvbiBfdHJpZ2dlckNsb3NlRXZlbnQoZWxlbWVudCkge1xuICAgICAgdmFyIGNsb3NlRXZlbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfQ0xPU0UpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLnRyaWdnZXIoY2xvc2VFdmVudCk7XG4gICAgICByZXR1cm4gY2xvc2VFdmVudDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gX3JlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyk7XG5cbiAgICAgIGlmICghJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlbGVtZW50KTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fZGVzdHJveUVsZW1lbnQoZWxlbWVudCwgZXZlbnQpO1xuICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9kZXN0cm95RWxlbWVudCA9IGZ1bmN0aW9uIF9kZXN0cm95RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZWxlbWVudCkuZGV0YWNoKCkudHJpZ2dlcihFVkVOVF9DTE9TRUQpLnJlbW92ZSgpO1xuICAgIH0gLy8gU3RhdGljXG4gICAgO1xuXG4gICAgQWxlcnQuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICRlbGVtZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQWxlcnQodGhpcyk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uZmlnID09PSAnY2xvc2UnKSB7XG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgQWxlcnQuX2hhbmRsZURpc21pc3MgPSBmdW5jdGlvbiBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBhbGVydEluc3RhbmNlLmNsb3NlKHRoaXMpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEFsZXJ0LCBudWxsLCBbe1xuICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQWxlcnQ7XG4gIH0oKTtcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9ESVNNSVNTLCBBbGVydC5faGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSkpO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUVdID0gQWxlcnQuX2pRdWVyeUludGVyZmFjZTtcbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQWxlcnQ7XG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUO1xuICAgIHJldHVybiBBbGVydC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSQxID0gJ2J1dHRvbic7XG4gIHZhciBWRVJTSU9OJDEgPSAnNC42LjAnO1xuICB2YXIgREFUQV9LRVkkMSA9ICdicy5idXR0b24nO1xuICB2YXIgRVZFTlRfS0VZJDEgPSBcIi5cIiArIERBVEFfS0VZJDE7XG4gIHZhciBEQVRBX0FQSV9LRVkkMSA9ICcuZGF0YS1hcGknO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUJDEgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQxXTtcbiAgdmFyIENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSc7XG4gIHZhciBDTEFTU19OQU1FX0JVVFRPTiA9ICdidG4nO1xuICB2YXIgQ0xBU1NfTkFNRV9GT0NVUyA9ICdmb2N1cyc7XG4gIHZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9DQVJST1QgPSAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXSc7XG4gIHZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRVMgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXSc7XG4gIHZhciBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJidXR0b25cIl0nO1xuICB2YXIgU0VMRUNUT1JfREFUQV9UT0dHTEVTX0JVVFRPTlMgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXSAuYnRuJztcbiAgdmFyIFNFTEVDVE9SX0lOUFVUID0gJ2lucHV0Om5vdChbdHlwZT1cImhpZGRlblwiXSknO1xuICB2YXIgU0VMRUNUT1JfQUNUSVZFID0gJy5hY3RpdmUnO1xuICB2YXIgU0VMRUNUT1JfQlVUVE9OID0gJy5idG4nO1xuICB2YXIgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMSA9IFwiY2xpY2tcIiArIEVWRU5UX0tFWSQxICsgREFUQV9BUElfS0VZJDE7XG4gIHZhciBFVkVOVF9GT0NVU19CTFVSX0RBVEFfQVBJID0gXCJmb2N1c1wiICsgRVZFTlRfS0VZJDEgKyBEQVRBX0FQSV9LRVkkMSArIFwiIFwiICsgKFwiYmx1clwiICsgRVZFTlRfS0VZJDEgKyBEQVRBX0FQSV9LRVkkMSk7XG4gIHZhciBFVkVOVF9MT0FEX0RBVEFfQVBJID0gXCJsb2FkXCIgKyBFVkVOVF9LRVkkMSArIERBVEFfQVBJX0tFWSQxO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBCdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1dHRvbihlbGVtZW50KSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuc2hvdWxkQXZvaWRUcmlnZ2VyQ2hhbmdlID0gZmFsc2U7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHZhciBfcHJvdG8gPSBCdXR0b24ucHJvdG90eXBlO1xuXG4gICAgLy8gUHVibGljXG4gICAgX3Byb3RvLnRvZ2dsZSA9IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcbiAgICAgIHZhciB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlO1xuICAgICAgdmFyIGFkZEFyaWFQcmVzc2VkID0gdHJ1ZTtcbiAgICAgIHZhciByb290RWxlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFUylbMF07XG5cbiAgICAgIGlmIChyb290RWxlbWVudCkge1xuICAgICAgICB2YXIgaW5wdXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfSU5QVVQpO1xuXG4gICAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAncmFkaW8nKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAmJiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSkpIHtcbiAgICAgICAgICAgICAgdHJpZ2dlckNoYW5nZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfQUNUSVZFKTtcblxuICAgICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJpZ2dlckNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIHJhZGlvIGJ1dHRvbiBvciBjaGVja2JveCBkb24ndCBhZGQgYSBwb2ludGxlc3MvaW52YWxpZCBjaGVja2VkIHByb3BlcnR5IHRvIHRoZSBpbnB1dFxuICAgICAgICAgICAgaWYgKGlucHV0LnR5cGUgPT09ICdjaGVja2JveCcgfHwgaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICBpbnB1dC5jaGVja2VkID0gIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oaW5wdXQpLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgYWRkQXJpYVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoISh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkpIHtcbiAgICAgICAgaWYgKGFkZEFyaWFQcmVzc2VkKSB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtcHJlc3NlZCcsICF0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0FDVElWRSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS50b2dnbGVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkkMSk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICB9IC8vIFN0YXRpY1xuICAgIDtcblxuICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcsIGF2b2lkVHJpZ2dlckNoYW5nZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZJDEpO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgQnV0dG9uKHRoaXMpO1xuICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVkkMSwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSA9IGF2b2lkVHJpZ2dlckNoYW5nZTtcblxuICAgICAgICBpZiAoY29uZmlnID09PSAndG9nZ2xlJykge1xuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKEJ1dHRvbiwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kMTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQnV0dG9uO1xuICB9KCk7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9DQVJST1QsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBidXR0b24gPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIGluaXRpYWxCdXR0b24gPSBidXR0b247XG5cbiAgICBpZiAoISRfX2RlZmF1bHRbJ2RlZmF1bHQnXShidXR0b24pLmhhc0NsYXNzKENMQVNTX05BTUVfQlVUVE9OKSkge1xuICAgICAgYnV0dG9uID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGJ1dHRvbikuY2xvc2VzdChTRUxFQ1RPUl9CVVRUT04pWzBdO1xuICAgIH1cblxuICAgIGlmICghYnV0dG9uIHx8IGJ1dHRvbi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgYnV0dG9uLmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gd29yayBhcm91bmQgRmlyZWZveCBidWcgIzE1NDA5OTVcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlucHV0QnRuID0gYnV0dG9uLnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfSU5QVVQpO1xuXG4gICAgICBpZiAoaW5wdXRCdG4gJiYgKGlucHV0QnRuLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCBpbnB1dEJ0bi5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIHdvcmsgYXJvdW5kIEZpcmVmb3ggYnVnICMxNTQwOTk1XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdGlhbEJ1dHRvbi50YWdOYW1lID09PSAnSU5QVVQnIHx8IGJ1dHRvbi50YWdOYW1lICE9PSAnTEFCRUwnKSB7XG4gICAgICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJF9fZGVmYXVsdFsnZGVmYXVsdCddKGJ1dHRvbiksICd0b2dnbGUnLCBpbml0aWFsQnV0dG9uLnRhZ05hbWUgPT09ICdJTlBVVCcpO1xuICAgICAgfVxuICAgIH1cbiAgfSkub24oRVZFTlRfRk9DVVNfQkxVUl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEVfQ0FSUk9ULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgYnV0dG9uID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGV2ZW50LnRhcmdldCkuY2xvc2VzdChTRUxFQ1RPUl9CVVRUT04pWzBdO1xuICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShidXR0b24pLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfRk9DVVMsIC9eZm9jdXMoaW4pPyQvLnRlc3QoZXZlbnQudHlwZSkpO1xuICB9KTtcbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHdpbmRvdykub24oRVZFTlRfTE9BRF9EQVRBX0FQSSwgZnVuY3Rpb24gKCkge1xuICAgIC8vIGVuc3VyZSBjb3JyZWN0IGFjdGl2ZSBjbGFzcyBpcyBzZXQgdG8gbWF0Y2ggdGhlIGNvbnRyb2xzJyBhY3R1YWwgdmFsdWVzL3N0YXRlc1xuICAgIC8vIGZpbmQgYWxsIGNoZWNrYm94ZXMvcmVhZGlvIGJ1dHRvbnMgaW5zaWRlIGRhdGEtdG9nZ2xlIGdyb3Vwc1xuICAgIHZhciBidXR0b25zID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TKSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG4gICAgICB2YXIgaW5wdXQgPSBidXR0b24ucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTlBVVCk7XG5cbiAgICAgIGlmIChpbnB1dC5jaGVja2VkIHx8IGlucHV0Lmhhc0F0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIH1cbiAgICB9IC8vIGZpbmQgYWxsIGJ1dHRvbiB0b2dnbGVzXG5cblxuICAgIGJ1dHRvbnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfREFUQV9UT0dHTEUpKTtcblxuICAgIGZvciAodmFyIF9pID0gMCwgX2xlbiA9IGJ1dHRvbnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHZhciBfYnV0dG9uID0gYnV0dG9uc1tfaV07XG5cbiAgICAgIGlmIChfYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJykgPT09ICd0cnVlJykge1xuICAgICAgICBfYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2J1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkMV0gPSBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkMV0uQ29uc3RydWN0b3IgPSBCdXR0b247XG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkMV0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQxXSA9IEpRVUVSWV9OT19DT05GTElDVCQxO1xuICAgIHJldHVybiBCdXR0b24uX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUkMiA9ICdjYXJvdXNlbCc7XG4gIHZhciBWRVJTSU9OJDIgPSAnNC42LjAnO1xuICB2YXIgREFUQV9LRVkkMiA9ICdicy5jYXJvdXNlbCc7XG4gIHZhciBFVkVOVF9LRVkkMiA9IFwiLlwiICsgREFUQV9LRVkkMjtcbiAgdmFyIERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkMiA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDJdO1xuICB2YXIgQVJST1dfTEVGVF9LRVlDT0RFID0gMzc7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGxlZnQgYXJyb3cga2V5XG5cbiAgdmFyIEFSUk9XX1JJR0hUX0tFWUNPREUgPSAzOTsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XG5cbiAgdmFyIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuXG4gIHZhciBTV0lQRV9USFJFU0hPTEQgPSA0MDtcbiAgdmFyIERlZmF1bHQgPSB7XG4gICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgc2xpZGU6IGZhbHNlLFxuICAgIHBhdXNlOiAnaG92ZXInLFxuICAgIHdyYXA6IHRydWUsXG4gICAgdG91Y2g6IHRydWVcbiAgfTtcbiAgdmFyIERlZmF1bHRUeXBlID0ge1xuICAgIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICBzbGlkZTogJyhib29sZWFufHN0cmluZyknLFxuICAgIHBhdXNlOiAnKHN0cmluZ3xib29sZWFuKScsXG4gICAgd3JhcDogJ2Jvb2xlYW4nLFxuICAgIHRvdWNoOiAnYm9vbGVhbidcbiAgfTtcbiAgdmFyIERJUkVDVElPTl9ORVhUID0gJ25leHQnO1xuICB2YXIgRElSRUNUSU9OX1BSRVYgPSAncHJldic7XG4gIHZhciBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0JztcbiAgdmFyIERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XG4gIHZhciBFVkVOVF9TTElERSA9IFwic2xpZGVcIiArIEVWRU5UX0tFWSQyO1xuICB2YXIgRVZFTlRfU0xJRCA9IFwic2xpZFwiICsgRVZFTlRfS0VZJDI7XG4gIHZhciBFVkVOVF9LRVlET1dOID0gXCJrZXlkb3duXCIgKyBFVkVOVF9LRVkkMjtcbiAgdmFyIEVWRU5UX01PVVNFRU5URVIgPSBcIm1vdXNlZW50ZXJcIiArIEVWRU5UX0tFWSQyO1xuICB2YXIgRVZFTlRfTU9VU0VMRUFWRSA9IFwibW91c2VsZWF2ZVwiICsgRVZFTlRfS0VZJDI7XG4gIHZhciBFVkVOVF9UT1VDSFNUQVJUID0gXCJ0b3VjaHN0YXJ0XCIgKyBFVkVOVF9LRVkkMjtcbiAgdmFyIEVWRU5UX1RPVUNITU9WRSA9IFwidG91Y2htb3ZlXCIgKyBFVkVOVF9LRVkkMjtcbiAgdmFyIEVWRU5UX1RPVUNIRU5EID0gXCJ0b3VjaGVuZFwiICsgRVZFTlRfS0VZJDI7XG4gIHZhciBFVkVOVF9QT0lOVEVSRE9XTiA9IFwicG9pbnRlcmRvd25cIiArIEVWRU5UX0tFWSQyO1xuICB2YXIgRVZFTlRfUE9JTlRFUlVQID0gXCJwb2ludGVydXBcIiArIEVWRU5UX0tFWSQyO1xuICB2YXIgRVZFTlRfRFJBR19TVEFSVCA9IFwiZHJhZ3N0YXJ0XCIgKyBFVkVOVF9LRVkkMjtcbiAgdmFyIEVWRU5UX0xPQURfREFUQV9BUEkkMSA9IFwibG9hZFwiICsgRVZFTlRfS0VZJDIgKyBEQVRBX0FQSV9LRVkkMjtcbiAgdmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIgPSBcImNsaWNrXCIgKyBFVkVOVF9LRVkkMiArIERBVEFfQVBJX0tFWSQyO1xuICB2YXIgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCc7XG4gIHZhciBDTEFTU19OQU1FX0FDVElWRSQxID0gJ2FjdGl2ZSc7XG4gIHZhciBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbiAgdmFyIENMQVNTX05BTUVfUklHSFQgPSAnY2Fyb3VzZWwtaXRlbS1yaWdodCc7XG4gIHZhciBDTEFTU19OQU1FX0xFRlQgPSAnY2Fyb3VzZWwtaXRlbS1sZWZ0JztcbiAgdmFyIENMQVNTX05BTUVfTkVYVCA9ICdjYXJvdXNlbC1pdGVtLW5leHQnO1xuICB2YXIgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XG4gIHZhciBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCc7XG4gIHZhciBTRUxFQ1RPUl9BQ1RJVkUkMSA9ICcuYWN0aXZlJztcbiAgdmFyIFNFTEVDVE9SX0FDVElWRV9JVEVNID0gJy5hY3RpdmUuY2Fyb3VzZWwtaXRlbSc7XG4gIHZhciBTRUxFQ1RPUl9JVEVNID0gJy5jYXJvdXNlbC1pdGVtJztcbiAgdmFyIFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZyc7XG4gIHZhciBTRUxFQ1RPUl9ORVhUX1BSRVYgPSAnLmNhcm91c2VsLWl0ZW0tbmV4dCwgLmNhcm91c2VsLWl0ZW0tcHJldic7XG4gIHZhciBTRUxFQ1RPUl9JTkRJQ0FUT1JTID0gJy5jYXJvdXNlbC1pbmRpY2F0b3JzJztcbiAgdmFyIFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b10nO1xuICB2YXIgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLXJpZGU9XCJjYXJvdXNlbFwiXSc7XG4gIHZhciBQb2ludGVyVHlwZSA9IHtcbiAgICBUT1VDSDogJ3RvdWNoJyxcbiAgICBQRU46ICdwZW4nXG4gIH07XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIENhcm91c2VsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDYXJvdXNlbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgdGhpcy50b3VjaFRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy50b3VjaFN0YXJ0WCA9IDA7XG4gICAgICB0aGlzLnRvdWNoRGVsdGFYID0gMDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTkRJQ0FUT1JTKTtcbiAgICAgIHRoaXMuX3RvdWNoU3VwcG9ydGVkID0gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XG4gICAgICB0aGlzLl9wb2ludGVyRXZlbnQgPSBCb29sZWFuKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50KTtcblxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IENhcm91c2VsLnByb3RvdHlwZTtcblxuICAgIC8vIFB1YmxpY1xuICAgIF9wcm90by5uZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlKERJUkVDVElPTl9ORVhUKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLm5leHRXaGVuVmlzaWJsZSA9IGZ1bmN0aW9uIG5leHRXaGVuVmlzaWJsZSgpIHtcbiAgICAgIHZhciAkZWxlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KTsgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgICAgLy8gb3IgdGhlIGNhcm91c2VsIG9yIGl0cyBwYXJlbnQgaXNuJ3QgdmlzaWJsZVxuXG4gICAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJiAkZWxlbWVudC5pcygnOnZpc2libGUnKSAmJiAkZWxlbWVudC5jc3MoJ3Zpc2liaWxpdHknKSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wcmV2ID0gZnVuY3Rpb24gcHJldigpIHtcbiAgICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIHRoaXMuX3NsaWRlKERJUkVDVElPTl9QUkVWKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnBhdXNlID0gZnVuY3Rpb24gcGF1c2UoZXZlbnQpIHtcbiAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX05FWFRfUFJFVikpIHtcbiAgICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgdGhpcy5jeWNsZSh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgfTtcblxuICAgIF9wcm90by5jeWNsZSA9IGZ1bmN0aW9uIGN5Y2xlKGV2ZW50KSB7XG4gICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcbiAgICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCkge1xuICAgICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xuXG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwoKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udG8gPSBmdW5jdGlvbiB0byhpbmRleCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9BQ1RJVkVfSVRFTSk7XG5cbiAgICAgIHZhciBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KTtcblxuICAgICAgaWYgKGluZGV4ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vbmUoRVZFTlRfU0xJRCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy50byhpbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGlvbiA9IGluZGV4ID4gYWN0aXZlSW5kZXggPyBESVJFQ1RJT05fTkVYVCA6IERJUkVDVElPTl9QUkVWO1xuXG4gICAgICB0aGlzLl9zbGlkZShkaXJlY3Rpb24sIHRoaXMuX2l0ZW1zW2luZGV4XSk7XG4gICAgfTtcblxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZJDIpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkkMik7XG4gICAgICB0aGlzLl9pdGVtcyA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCA9IG51bGw7XG4gICAgfSAvLyBQcml2YXRlXG4gICAgO1xuXG4gICAgX3Byb3RvLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gX2V4dGVuZHMoe30sIERlZmF1bHQsIGNvbmZpZyk7XG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FJDIsIGNvbmZpZywgRGVmYXVsdFR5cGUpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9oYW5kbGVTd2lwZSA9IGZ1bmN0aW9uIF9oYW5kbGVTd2lwZSgpIHtcbiAgICAgIHZhciBhYnNEZWx0YXggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKTtcblxuICAgICAgaWYgKGFic0RlbHRheCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGlyZWN0aW9uID0gYWJzRGVsdGF4IC8gdGhpcy50b3VjaERlbHRhWDtcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSAwOyAvLyBzd2lwZSBsZWZ0XG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPiAwKSB7XG4gICAgICAgIHRoaXMucHJldigpO1xuICAgICAgfSAvLyBzd2lwZSByaWdodFxuXG5cbiAgICAgIGlmIChkaXJlY3Rpb24gPCAwKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uX2FkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX0tFWURPV04sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX2tleWRvd24oZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub24oRVZFTlRfTU9VU0VFTlRFUiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5wYXVzZShldmVudCk7XG4gICAgICAgIH0pLm9uKEVWRU5UX01PVVNFTEVBVkUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuY3ljbGUoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCkge1xuICAgICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fYWRkVG91Y2hFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fdG91Y2hTdXBwb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnQgPSBmdW5jdGlvbiBzdGFydChldmVudCkge1xuICAgICAgICBpZiAoX3RoaXMzLl9wb2ludGVyRXZlbnQgJiYgUG9pbnRlclR5cGVbZXZlbnQub3JpZ2luYWxFdmVudC5wb2ludGVyVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICAgIF90aGlzMy50b3VjaFN0YXJ0WCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2xpZW50WDtcbiAgICAgICAgfSBlbHNlIGlmICghX3RoaXMzLl9wb2ludGVyRXZlbnQpIHtcbiAgICAgICAgICBfdGhpczMudG91Y2hTdGFydFggPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIG1vdmUgPSBmdW5jdGlvbiBtb3ZlKGV2ZW50KSB7XG4gICAgICAgIC8vIGVuc3VyZSBzd2lwaW5nIHdpdGggb25lIHRvdWNoIGFuZCBub3QgcGluY2hpbmdcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIF90aGlzMy50b3VjaERlbHRhWCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMzLnRvdWNoRGVsdGFYID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLmNsaWVudFggLSBfdGhpczMudG91Y2hTdGFydFg7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBlbmQgPSBmdW5jdGlvbiBlbmQoZXZlbnQpIHtcbiAgICAgICAgaWYgKF90aGlzMy5fcG9pbnRlckV2ZW50ICYmIFBvaW50ZXJUeXBlW2V2ZW50Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgICBfdGhpczMudG91Y2hEZWx0YVggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFggLSBfdGhpczMudG91Y2hTdGFydFg7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczMuX2hhbmRsZVN3aXBlKCk7XG5cbiAgICAgICAgaWYgKF90aGlzMy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAgIC8vIHdvdWxkIHN0b3AgY3ljbGluZyB1bnRpbCB1c2VyIHRhcHBlZCBvdXQgb2YgaXQ7XG4gICAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAgIC8vIGlzIE5PVCBmaXJlZCkgYW5kIGFmdGVyIGEgdGltZW91dCAodG8gYWxsb3cgZm9yIG1vdXNlIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcbiAgICAgICAgICBfdGhpczMucGF1c2UoKTtcblxuICAgICAgICAgIGlmIChfdGhpczMudG91Y2hUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMzLnRvdWNoVGltZW91dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLmN5Y2xlKGV2ZW50KTtcbiAgICAgICAgICB9LCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUICsgX3RoaXMzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0lURU1fSU1HKSkub24oRVZFTlRfRFJBR19TVEFSVCwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgcmV0dXJuIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50KSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9QT0lOVEVSRE9XTiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9QT0lOVEVSVVAsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBlbmQoZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9UT1VDSFNUQVJULCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gc3RhcnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX1RPVUNITU9WRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuIG1vdmUoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX1RPVUNIRU5ELCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZW5kKGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fa2V5ZG93biA9IGZ1bmN0aW9uIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGV2ZW50LndoaWNoKSB7XG4gICAgICAgIGNhc2UgQVJST1dfTEVGVF9LRVlDT0RFOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5wcmV2KCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBUlJPV19SSUdIVF9LRVlDT0RFOlxuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0SXRlbUluZGV4ID0gZnVuY3Rpb24gX2dldEl0ZW1JbmRleChlbGVtZW50KSB7XG4gICAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID8gW10uc2xpY2UuY2FsbChlbGVtZW50LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9JVEVNKSkgOiBbXTtcbiAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5pbmRleE9mKGVsZW1lbnQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldEl0ZW1CeURpcmVjdGlvbiA9IGZ1bmN0aW9uIF9nZXRJdGVtQnlEaXJlY3Rpb24oZGlyZWN0aW9uLCBhY3RpdmVFbGVtZW50KSB7XG4gICAgICB2YXIgaXNOZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTkVYVDtcbiAgICAgIHZhciBpc1ByZXZEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9QUkVWO1xuXG4gICAgICB2YXIgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgoYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgIHZhciBsYXN0SXRlbUluZGV4ID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBpc0dvaW5nVG9XcmFwID0gaXNQcmV2RGlyZWN0aW9uICYmIGFjdGl2ZUluZGV4ID09PSAwIHx8IGlzTmV4dERpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gbGFzdEl0ZW1JbmRleDtcblxuICAgICAgaWYgKGlzR29pbmdUb1dyYXAgJiYgIXRoaXMuX2NvbmZpZy53cmFwKSB7XG4gICAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBkaXJlY3Rpb24gPT09IERJUkVDVElPTl9QUkVWID8gLTEgOiAxO1xuICAgICAgdmFyIGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aDtcbiAgICAgIHJldHVybiBpdGVtSW5kZXggPT09IC0xID8gdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB0aGlzLl9pdGVtc1tpdGVtSW5kZXhdO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX3RyaWdnZXJTbGlkZUV2ZW50ID0gZnVuY3Rpb24gX3RyaWdnZXJTbGlkZUV2ZW50KHJlbGF0ZWRUYXJnZXQsIGV2ZW50RGlyZWN0aW9uTmFtZSkge1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHJlbGF0ZWRUYXJnZXQpO1xuXG4gICAgICB2YXIgZnJvbUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9BQ1RJVkVfSVRFTSkpO1xuXG4gICAgICB2YXIgc2xpZGVFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudChFVkVOVF9TTElERSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkVGFyZ2V0LFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50RGlyZWN0aW9uTmFtZSxcbiAgICAgICAgZnJvbTogZnJvbUluZGV4LFxuICAgICAgICB0bzogdGFyZ2V0SW5kZXhcbiAgICAgIH0pO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2xpZGVFdmVudCk7XG4gICAgICByZXR1cm4gc2xpZGVFdmVudDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50ID0gZnVuY3Rpb24gX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICAgIHZhciBpbmRpY2F0b3JzID0gW10uc2xpY2UuY2FsbCh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0FDVElWRSQxKSk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShpbmRpY2F0b3JzKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSQxKTtcblxuICAgICAgICB2YXIgbmV4dEluZGljYXRvciA9IHRoaXMuX2luZGljYXRvcnNFbGVtZW50LmNoaWxkcmVuW3RoaXMuX2dldEl0ZW1JbmRleChlbGVtZW50KV07XG5cbiAgICAgICAgaWYgKG5leHRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10obmV4dEluZGljYXRvcikuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLl91cGRhdGVJbnRlcnZhbCA9IGZ1bmN0aW9uIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfQUNUSVZFX0lURU0pO1xuXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudEludGVydmFsID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSwgMTApO1xuXG4gICAgICBpZiAoZWxlbWVudEludGVydmFsKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gZWxlbWVudEludGVydmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fc2xpZGUgPSBmdW5jdGlvbiBfc2xpZGUoZGlyZWN0aW9uLCBlbGVtZW50KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfQUNUSVZFX0lURU0pO1xuXG4gICAgICB2YXIgYWN0aXZlRWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBlbGVtZW50IHx8IGFjdGl2ZUVsZW1lbnQgJiYgdGhpcy5fZ2V0SXRlbUJ5RGlyZWN0aW9uKGRpcmVjdGlvbiwgYWN0aXZlRWxlbWVudCk7XG5cbiAgICAgIHZhciBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcblxuICAgICAgdmFyIGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO1xuICAgICAgdmFyIGRpcmVjdGlvbmFsQ2xhc3NOYW1lO1xuICAgICAgdmFyIG9yZGVyQ2xhc3NOYW1lO1xuICAgICAgdmFyIGV2ZW50RGlyZWN0aW9uTmFtZTtcblxuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX05FWFQpIHtcbiAgICAgICAgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBDTEFTU19OQU1FX0xFRlQ7XG4gICAgICAgIG9yZGVyQ2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9ORVhUO1xuICAgICAgICBldmVudERpcmVjdGlvbk5hbWUgPSBESVJFQ1RJT05fTEVGVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9SSUdIVDtcbiAgICAgICAgb3JkZXJDbGFzc05hbWUgPSBDTEFTU19OQU1FX1BSRVY7XG4gICAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERJUkVDVElPTl9SSUdIVDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRFbGVtZW50ICYmICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShuZXh0RWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMSkpIHtcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsaWRlRXZlbnQgPSB0aGlzLl90cmlnZ2VyU2xpZGVFdmVudChuZXh0RWxlbWVudCwgZXZlbnREaXJlY3Rpb25OYW1lKTtcblxuICAgICAgaWYgKHNsaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWFjdGl2ZUVsZW1lbnQgfHwgIW5leHRFbGVtZW50KSB7XG4gICAgICAgIC8vIFNvbWUgd2VpcmRuZXNzIGlzIGhhcHBlbmluZywgc28gd2UgYmFpbFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KTtcblxuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgICAgdmFyIHNsaWRFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudChFVkVOVF9TTElELCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG5leHRFbGVtZW50LFxuICAgICAgICBkaXJlY3Rpb246IGV2ZW50RGlyZWN0aW9uTmFtZSxcbiAgICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxuICAgICAgfSk7XG5cbiAgICAgIGlmICgkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TTElERSkpIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKG5leHRFbGVtZW50KS5hZGRDbGFzcyhvcmRlckNsYXNzTmFtZSk7XG4gICAgICAgIFV0aWwucmVmbG93KG5leHRFbGVtZW50KTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGFjdGl2ZUVsZW1lbnQpLmFkZENsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKG5leHRFbGVtZW50KS5hZGRDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oYWN0aXZlRWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10obmV4dEVsZW1lbnQpLnJlbW92ZUNsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lICsgXCIgXCIgKyBvcmRlckNsYXNzTmFtZSkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFJDEgKyBcIiBcIiArIG9yZGVyQ2xhc3NOYW1lICsgXCIgXCIgKyBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICAgICAgX3RoaXM0Ll9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXM0Ll9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShuZXh0RWxlbWVudCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIFN0YXRpY1xuICAgIDtcblxuICAgIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpLmRhdGEoREFUQV9LRVkkMik7XG5cbiAgICAgICAgdmFyIF9jb25maWcgPSBfZXh0ZW5kcyh7fSwgRGVmYXVsdCwgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpLmRhdGEoKSk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgX2NvbmZpZyA9IF9leHRlbmRzKHt9LCBfY29uZmlnLCBjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbiA9IHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnID8gY29uZmlnIDogX2NvbmZpZy5zbGlkZTtcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IENhcm91c2VsKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS5kYXRhKERBVEFfS0VZJDIsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgZGF0YS50byhjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2FjdGlvbl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIiArIGFjdGlvbiArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhW2FjdGlvbl0oKTtcbiAgICAgICAgfSBlbHNlIGlmIChfY29uZmlnLmludGVydmFsICYmIF9jb25maWcucmlkZSkge1xuICAgICAgICAgIGRhdGEucGF1c2UoKTtcbiAgICAgICAgICBkYXRhLmN5Y2xlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcyk7XG5cbiAgICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFyZ2V0ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHNlbGVjdG9yKVswXTtcblxuICAgICAgaWYgKCF0YXJnZXQgfHwgISRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0YXJnZXQpLmhhc0NsYXNzKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbmZpZyA9IF9leHRlbmRzKHt9LCAkX19kZWZhdWx0WydkZWZhdWx0J10odGFyZ2V0KS5kYXRhKCksICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS5kYXRhKCkpO1xuXG4gICAgICB2YXIgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJyk7XG5cbiAgICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICAgIGNvbmZpZy5pbnRlcnZhbCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRhcmdldCksIGNvbmZpZyk7XG5cbiAgICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0YXJnZXQpLmRhdGEoREFUQV9LRVkkMikudG8oc2xpZGVJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhDYXJvdXNlbCwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kMjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRGVmYXVsdFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDYXJvdXNlbDtcbiAgfSgpO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShkb2N1bWVudCkub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiwgU0VMRUNUT1JfREFUQV9TTElERSwgQ2Fyb3VzZWwuX2RhdGFBcGlDbGlja0hhbmRsZXIpO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10od2luZG93KS5vbihFVkVOVF9MT0FEX0RBVEFfQVBJJDEsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2Fyb3VzZWxzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfUklERSkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhcm91c2Vscy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyICRjYXJvdXNlbCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShjYXJvdXNlbHNbaV0pO1xuXG4gICAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkMl0gPSBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQyXS5Db25zdHJ1Y3RvciA9IENhcm91c2VsO1xuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDJdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkMl0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkMjtcbiAgICByZXR1cm4gQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUkMyA9ICdjb2xsYXBzZSc7XG4gIHZhciBWRVJTSU9OJDMgPSAnNC42LjAnO1xuICB2YXIgREFUQV9LRVkkMyA9ICdicy5jb2xsYXBzZSc7XG4gIHZhciBFVkVOVF9LRVkkMyA9IFwiLlwiICsgREFUQV9LRVkkMztcbiAgdmFyIERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkMyA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDNdO1xuICB2YXIgRGVmYXVsdCQxID0ge1xuICAgIHRvZ2dsZTogdHJ1ZSxcbiAgICBwYXJlbnQ6ICcnXG4gIH07XG4gIHZhciBEZWZhdWx0VHlwZSQxID0ge1xuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nLFxuICAgIHBhcmVudDogJyhzdHJpbmd8ZWxlbWVudCknXG4gIH07XG4gIHZhciBFVkVOVF9TSE9XID0gXCJzaG93XCIgKyBFVkVOVF9LRVkkMztcbiAgdmFyIEVWRU5UX1NIT1dOID0gXCJzaG93blwiICsgRVZFTlRfS0VZJDM7XG4gIHZhciBFVkVOVF9ISURFID0gXCJoaWRlXCIgKyBFVkVOVF9LRVkkMztcbiAgdmFyIEVWRU5UX0hJRERFTiA9IFwiaGlkZGVuXCIgKyBFVkVOVF9LRVkkMztcbiAgdmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMgPSBcImNsaWNrXCIgKyBFVkVOVF9LRVkkMyArIERBVEFfQVBJX0tFWSQzO1xuICB2YXIgQ0xBU1NfTkFNRV9TSE9XJDEgPSAnc2hvdyc7XG4gIHZhciBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcbiAgdmFyIENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcbiAgdmFyIENMQVNTX05BTUVfQ09MTEFQU0VEID0gJ2NvbGxhcHNlZCc7XG4gIHZhciBESU1FTlNJT05fV0lEVEggPSAnd2lkdGgnO1xuICB2YXIgRElNRU5TSU9OX0hFSUdIVCA9ICdoZWlnaHQnO1xuICB2YXIgU0VMRUNUT1JfQUNUSVZFUyA9ICcuc2hvdywgLmNvbGxhcHNpbmcnO1xuICB2YXIgU0VMRUNUT1JfREFUQV9UT0dHTEUkMSA9ICdbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIENvbGxhcHNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2xsYXBzZShlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtocmVmPVxcXCIjXCIgKyBlbGVtZW50LmlkICsgXCJcXFwiXSxcIiArIChcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtkYXRhLXRhcmdldD1cXFwiI1wiICsgZWxlbWVudC5pZCArIFwiXFxcIl1cIikpKTtcbiAgICAgIHZhciB0b2dnbGVMaXN0ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvZ2dsZUxpc3QubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGVsZW0gPSB0b2dnbGVMaXN0W2ldO1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XG4gICAgICAgIHZhciBmaWx0ZXJFbGVtZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkuZmlsdGVyKGZ1bmN0aW9uIChmb3VuZEVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRFbGVtID09PSBlbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2NvbmZpZy5wYXJlbnQgPyB0aGlzLl9nZXRQYXJlbnQoKSA6IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fdHJpZ2dlckFycmF5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IENvbGxhcHNlLnByb3RvdHlwZTtcblxuICAgIC8vIFB1YmxpY1xuICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBpZiAoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVyQxKSkge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1ckMSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWN0aXZlcztcbiAgICAgIHZhciBhY3RpdmVzRGF0YTtcblxuICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgICBhY3RpdmVzID0gW10uc2xpY2UuY2FsbCh0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9BQ1RJVkVTKSkuZmlsdGVyKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBfdGhpcy5fY29uZmlnLnBhcmVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXJlbnQnKSA9PT0gX3RoaXMuX2NvbmZpZy5wYXJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQ09MTEFQU0UpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBhY3RpdmVzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICBhY3RpdmVzRGF0YSA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShhY3RpdmVzKS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoREFUQV9LRVkkMyk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZXNEYXRhICYmIGFjdGl2ZXNEYXRhLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0RXZlbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfU0hPVyk7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KTtcblxuICAgICAgaWYgKHN0YXJ0RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0aXZlcykge1xuICAgICAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJF9fZGVmYXVsdFsnZGVmYXVsdCddKGFjdGl2ZXMpLm5vdCh0aGlzLl9zZWxlY3RvciksICdoaWRlJyk7XG5cbiAgICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShhY3RpdmVzKS5kYXRhKERBVEFfS0VZJDMsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0UpLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xuXG4gICAgICBpZiAodGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fdHJpZ2dlckFycmF5KS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNFRCkuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFRyYW5zaXRpb25pbmcodHJ1ZSk7XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORykuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTRSArIFwiIFwiICsgQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICBfdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gJyc7XG5cbiAgICAgICAgX3RoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSk7XG5cbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX1NIT1dOKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjYXBpdGFsaXplZERpbWVuc2lvbiA9IGRpbWVuc2lvblswXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKDEpO1xuICAgICAgdmFyIHNjcm9sbFNpemUgPSBcInNjcm9sbFwiICsgY2FwaXRhbGl6ZWREaW1lbnNpb247XG4gICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSB0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdICsgXCJweFwiO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fCAhJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVyQxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydEV2ZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX0hJREUpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc3RhcnRFdmVudCk7XG5cbiAgICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl0gKyBcInB4XCI7XG4gICAgICBVdGlsLnJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNJTkcpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0UgKyBcIiBcIiArIENMQVNTX05BTUVfU0hPVyQxKTtcbiAgICAgIHZhciB0cmlnZ2VyQXJyYXlMZW5ndGggPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoO1xuXG4gICAgICBpZiAodHJpZ2dlckFycmF5TGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWdnZXJBcnJheUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHRyaWdnZXIgPSB0aGlzLl90cmlnZ2VyQXJyYXlbaV07XG4gICAgICAgICAgdmFyIHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRyaWdnZXIpO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkX19kZWZhdWx0WydkZWZhdWx0J10oW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSkpO1xuXG4gICAgICAgICAgICBpZiAoISRlbGVtLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVyQxKSkge1xuICAgICAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odHJpZ2dlcikuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyh0cnVlKTtcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIF90aGlzMi5zZXRUcmFuc2l0aW9uaW5nKGZhbHNlKTtcblxuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXMyLl9lbGVtZW50KS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNJTkcpLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0UpLnRyaWdnZXIoRVZFTlRfSElEREVOKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xuICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc2V0VHJhbnNpdGlvbmluZyA9IGZ1bmN0aW9uIHNldFRyYW5zaXRpb25pbmcoaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBpc1RyYW5zaXRpb25pbmc7XG4gICAgfTtcblxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJDMpO1xuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IG51bGw7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsO1xuICAgIH0gLy8gUHJpdmF0ZVxuICAgIDtcblxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IF9leHRlbmRzKHt9LCBEZWZhdWx0JDEsIGNvbmZpZyk7XG4gICAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcblxuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSQzLCBjb25maWcsIERlZmF1bHRUeXBlJDEpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBfZ2V0RGltZW5zaW9uKCkge1xuICAgICAgdmFyIGhhc1dpZHRoID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKERJTUVOU0lPTl9XSURUSCk7XG4gICAgICByZXR1cm4gaGFzV2lkdGggPyBESU1FTlNJT05fV0lEVEggOiBESU1FTlNJT05fSEVJR0hUO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldFBhcmVudCA9IGZ1bmN0aW9uIF9nZXRQYXJlbnQoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHBhcmVudDtcblxuICAgICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5wYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudCA9IHRoaXMuX2NvbmZpZy5wYXJlbnQ7IC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XG5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcucGFyZW50LmpxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50WzBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuX2NvbmZpZy5wYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZWN0b3IgPSBcIltkYXRhLXRvZ2dsZT1cXFwiY29sbGFwc2VcXFwiXVtkYXRhLXBhcmVudD1cXFwiXCIgKyB0aGlzLl9jb25maWcucGFyZW50ICsgXCJcXFwiXVwiO1xuICAgICAgdmFyIGNoaWxkcmVuID0gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGNoaWxkcmVuKS5lYWNoKGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XG4gICAgICAgIF90aGlzMy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSwgW2VsZW1lbnRdKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MgPSBmdW5jdGlvbiBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKGVsZW1lbnQsIHRyaWdnZXJBcnJheSkge1xuICAgICAgdmFyIGlzT3BlbiA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1ckMSk7XG5cbiAgICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0cmlnZ2VyQXJyYXkpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgaXNPcGVuKTtcbiAgICAgIH1cbiAgICB9IC8vIFN0YXRpY1xuICAgIDtcblxuICAgIENvbGxhcHNlLl9nZXRUYXJnZXRGcm9tRWxlbWVudCA9IGZ1bmN0aW9uIF9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG51bGw7XG4gICAgfTtcblxuICAgIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZJDMpO1xuXG4gICAgICAgIHZhciBfY29uZmlnID0gX2V4dGVuZHMoe30sIERlZmF1bHQkMSwgJGVsZW1lbnQuZGF0YSgpLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XG5cbiAgICAgICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVkkMywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgY29uZmlnICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKENvbGxhcHNlLCBudWxsLCBbe1xuICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTiQzO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQkMTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gQ29sbGFwc2U7XG4gIH0oKTtcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJJDMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgICBpZiAoZXZlbnQuY3VycmVudFRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdmFyICR0cmlnZ2VyID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpO1xuICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcbiAgICB2YXIgc2VsZWN0b3JzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHNlbGVjdG9ycykuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHRhcmdldCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKTtcbiAgICAgIHZhciBkYXRhID0gJHRhcmdldC5kYXRhKERBVEFfS0VZJDMpO1xuICAgICAgdmFyIGNvbmZpZyA9IGRhdGEgPyAndG9nZ2xlJyA6ICR0cmlnZ2VyLmRhdGEoKTtcblxuICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCR0YXJnZXQsIGNvbmZpZyk7XG4gICAgfSk7XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkM10gPSBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQzXS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlO1xuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDNdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkM10gPSBKUVVFUllfTk9fQ09ORkxJQ1QkMztcbiAgICByZXR1cm4gQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUkNCA9ICdkcm9wZG93bic7XG4gIHZhciBWRVJTSU9OJDQgPSAnNC42LjAnO1xuICB2YXIgREFUQV9LRVkkNCA9ICdicy5kcm9wZG93bic7XG4gIHZhciBFVkVOVF9LRVkkNCA9IFwiLlwiICsgREFUQV9LRVkkNDtcbiAgdmFyIERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkNCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDRdO1xuICB2YXIgRVNDQVBFX0tFWUNPREUgPSAyNzsgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuXG4gIHZhciBTUEFDRV9LRVlDT0RFID0gMzI7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHNwYWNlIGtleVxuXG4gIHZhciBUQUJfS0VZQ09ERSA9IDk7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRhYiBrZXlcblxuICB2YXIgQVJST1dfVVBfS0VZQ09ERSA9IDM4OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciB1cCBhcnJvdyBrZXlcblxuICB2YXIgQVJST1dfRE9XTl9LRVlDT0RFID0gNDA7IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGRvd24gYXJyb3cga2V5XG5cbiAgdmFyIFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCA9IDM7IC8vIE1vdXNlRXZlbnQud2hpY2ggdmFsdWUgZm9yIHRoZSByaWdodCBidXR0b24gKGFzc3VtaW5nIGEgcmlnaHQtaGFuZGVkIG1vdXNlKVxuXG4gIHZhciBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoQVJST1dfVVBfS0VZQ09ERSArIFwifFwiICsgQVJST1dfRE9XTl9LRVlDT0RFICsgXCJ8XCIgKyBFU0NBUEVfS0VZQ09ERSk7XG4gIHZhciBFVkVOVF9ISURFJDEgPSBcImhpZGVcIiArIEVWRU5UX0tFWSQ0O1xuICB2YXIgRVZFTlRfSElEREVOJDEgPSBcImhpZGRlblwiICsgRVZFTlRfS0VZJDQ7XG4gIHZhciBFVkVOVF9TSE9XJDEgPSBcInNob3dcIiArIEVWRU5UX0tFWSQ0O1xuICB2YXIgRVZFTlRfU0hPV04kMSA9IFwic2hvd25cIiArIEVWRU5UX0tFWSQ0O1xuICB2YXIgRVZFTlRfQ0xJQ0sgPSBcImNsaWNrXCIgKyBFVkVOVF9LRVkkNDtcbiAgdmFyIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQgPSBcImNsaWNrXCIgKyBFVkVOVF9LRVkkNCArIERBVEFfQVBJX0tFWSQ0O1xuICB2YXIgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IFwia2V5ZG93blwiICsgRVZFTlRfS0VZJDQgKyBEQVRBX0FQSV9LRVkkNDtcbiAgdmFyIEVWRU5UX0tFWVVQX0RBVEFfQVBJID0gXCJrZXl1cFwiICsgRVZFTlRfS0VZJDQgKyBEQVRBX0FQSV9LRVkkNDtcbiAgdmFyIENMQVNTX05BTUVfRElTQUJMRUQgPSAnZGlzYWJsZWQnO1xuICB2YXIgQ0xBU1NfTkFNRV9TSE9XJDIgPSAnc2hvdyc7XG4gIHZhciBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xuICB2YXIgQ0xBU1NfTkFNRV9EUk9QUklHSFQgPSAnZHJvcHJpZ2h0JztcbiAgdmFyIENMQVNTX05BTUVfRFJPUExFRlQgPSAnZHJvcGxlZnQnO1xuICB2YXIgQ0xBU1NfTkFNRV9NRU5VUklHSFQgPSAnZHJvcGRvd24tbWVudS1yaWdodCc7XG4gIHZhciBDTEFTU19OQU1FX1BPU0lUSU9OX1NUQVRJQyA9ICdwb3NpdGlvbi1zdGF0aWMnO1xuICB2YXIgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiA9ICdbZGF0YS10b2dnbGU9XCJkcm9wZG93blwiXSc7XG4gIHZhciBTRUxFQ1RPUl9GT1JNX0NISUxEID0gJy5kcm9wZG93biBmb3JtJztcbiAgdmFyIFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuICB2YXIgU0VMRUNUT1JfTkFWQkFSX05BViA9ICcubmF2YmFyLW5hdic7XG4gIHZhciBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbiAgdmFyIFBMQUNFTUVOVF9UT1AgPSAndG9wLXN0YXJ0JztcbiAgdmFyIFBMQUNFTUVOVF9UT1BFTkQgPSAndG9wLWVuZCc7XG4gIHZhciBQTEFDRU1FTlRfQk9UVE9NID0gJ2JvdHRvbS1zdGFydCc7XG4gIHZhciBQTEFDRU1FTlRfQk9UVE9NRU5EID0gJ2JvdHRvbS1lbmQnO1xuICB2YXIgUExBQ0VNRU5UX1JJR0hUID0gJ3JpZ2h0LXN0YXJ0JztcbiAgdmFyIFBMQUNFTUVOVF9MRUZUID0gJ2xlZnQtc3RhcnQnO1xuICB2YXIgRGVmYXVsdCQyID0ge1xuICAgIG9mZnNldDogMCxcbiAgICBmbGlwOiB0cnVlLFxuICAgIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgICByZWZlcmVuY2U6ICd0b2dnbGUnLFxuICAgIGRpc3BsYXk6ICdkeW5hbWljJyxcbiAgICBwb3BwZXJDb25maWc6IG51bGxcbiAgfTtcbiAgdmFyIERlZmF1bHRUeXBlJDIgPSB7XG4gICAgb2Zmc2V0OiAnKG51bWJlcnxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBmbGlwOiAnYm9vbGVhbicsXG4gICAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3QpJ1xuICB9O1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBEcm9wZG93biA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJvcGRvd24oZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpO1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcblxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IERyb3Bkb3duLnByb3RvdHlwZTtcblxuICAgIC8vIFB1YmxpY1xuICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUoKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNBY3RpdmUgPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fbWVudSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuXG4gICAgICBEcm9wZG93bi5fY2xlYXJNZW51cygpO1xuXG4gICAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNob3codHJ1ZSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdyh1c2VQb3BwZXIpIHtcbiAgICAgIGlmICh1c2VQb3BwZXIgPT09IHZvaWQgMCkge1xuICAgICAgICB1c2VQb3BwZXIgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRElTQUJMRUQpIHx8ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9tZW51KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1ckMikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgICAgfTtcbiAgICAgIHZhciBzaG93RXZlbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfU0hPVyQxLCByZWxhdGVkVGFyZ2V0KTtcblxuICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHBhcmVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gVG90YWxseSBkaXNhYmxlIFBvcHBlciBmb3IgRHJvcGRvd25zIGluIE5hdmJhclxuXG5cbiAgICAgIGlmICghdGhpcy5faW5OYXZiYXIgJiYgdXNlUG9wcGVyKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVjayBmb3IgUG9wcGVyIGRlcGVuZGVuY3lcbiAgICAgICAgICogUG9wcGVyIC0gaHR0cHM6Ly9wb3BwZXIuanMub3JnXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIFBvcHBlcl9fZGVmYXVsdFsnZGVmYXVsdCddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHBhcmVudDtcbiAgICAgICAgfSBlbHNlIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLl9jb25maWcucmVmZXJlbmNlKSkge1xuICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9jb25maWcucmVmZXJlbmNlOyAvLyBDaGVjayBpZiBpdCdzIGpRdWVyeSBlbGVtZW50XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2VbMF07XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIElmIGJvdW5kYXJ5IGlzIG5vdCBgc2Nyb2xsUGFyZW50YCwgdGhlbiBzZXQgcG9zaXRpb24gdG8gYHN0YXRpY2BcbiAgICAgICAgLy8gdG8gYWxsb3cgdGhlIG1lbnUgdG8gXCJlc2NhcGVcIiB0aGUgc2Nyb2xsIHBhcmVudCdzIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8yNDI1MVxuXG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5ib3VuZGFyeSAhPT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10ocGFyZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX1BPU0lUSU9OX1NUQVRJQyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBuZXcgUG9wcGVyX19kZWZhdWx0WydkZWZhdWx0J10ocmVmZXJlbmNlRWxlbWVudCwgdGhpcy5fbWVudSwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCkpO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuXG5cbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHBhcmVudCkuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5ub29wKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIHRydWUpO1xuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHBhcmVudCkudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDIpLnRyaWdnZXIoJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX1NIT1dOJDEsIHJlbGF0ZWRUYXJnZXQpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRElTQUJMRUQpIHx8ICEkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fbWVudSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDIpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX0hJREUkMSwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgIHZhciBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG5cbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfU0hPVyQyKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShwYXJlbnQpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfU0hPVyQyKS50cmlnZ2VyKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudChFVkVOVF9ISURERU4kMSwgcmVsYXRlZFRhcmdldCkpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10ucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSQ0KTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZJDQpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9tZW51ID0gbnVsbDtcblxuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuXG4gICAgICBpZiAodGhpcy5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpO1xuICAgICAgfVxuICAgIH0gLy8gUHJpdmF0ZVxuICAgIDtcblxuICAgIF9wcm90by5fYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub24oRVZFTlRfQ0xJQ0ssIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICBfdGhpcy50b2dnbGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldENvbmZpZyA9IGZ1bmN0aW9uIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25maWcgPSBfZXh0ZW5kcyh7fSwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LCAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkuZGF0YSgpLCBjb25maWcpO1xuICAgICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSQ0LCBjb25maWcsIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGUpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9nZXRNZW51RWxlbWVudCA9IGZ1bmN0aW9uIF9nZXRNZW51RWxlbWVudCgpIHtcbiAgICAgIGlmICghdGhpcy5fbWVudSkge1xuICAgICAgICB2YXIgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuXG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLl9tZW51ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfTUVOVSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX21lbnU7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0UGxhY2VtZW50ID0gZnVuY3Rpb24gX2dldFBsYWNlbWVudCgpIHtcbiAgICAgIHZhciAkcGFyZW50RHJvcGRvd24gPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICAgIHZhciBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfQk9UVE9NOyAvLyBIYW5kbGUgZHJvcHVwXG5cbiAgICAgIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICAgIHBsYWNlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9tZW51KS5oYXNDbGFzcyhDTEFTU19OQU1FX01FTlVSSUdIVCkgPyBQTEFDRU1FTlRfVE9QRU5EIDogUExBQ0VNRU5UX1RPUDtcbiAgICAgIH0gZWxzZSBpZiAoJHBhcmVudERyb3Bkb3duLmhhc0NsYXNzKENMQVNTX05BTUVfRFJPUFJJR0hUKSkge1xuICAgICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfUklHSFQ7XG4gICAgICB9IGVsc2UgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDTEFTU19OQU1FX0RST1BMRUZUKSkge1xuICAgICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfTEVGVDtcbiAgICAgIH0gZWxzZSBpZiAoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfTUVOVVJJR0hUKSkge1xuICAgICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfQk9UVE9NRU5EO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGxhY2VtZW50O1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2RldGVjdE5hdmJhciA9IGZ1bmN0aW9uIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgICByZXR1cm4gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmNsb3Nlc3QoJy5uYXZiYXInKS5sZW5ndGggPiAwO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldE9mZnNldCA9IGZ1bmN0aW9uIF9nZXRPZmZzZXQoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIG9mZnNldCA9IHt9O1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0LmZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLm9mZnNldHMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLCBfdGhpczIuX2NvbmZpZy5vZmZzZXQoZGF0YS5vZmZzZXRzLCBfdGhpczIuX2VsZW1lbnQpIHx8IHt9KTtcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9mZnNldC5vZmZzZXQgPSB0aGlzLl9jb25maWcub2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldFBvcHBlckNvbmZpZyA9IGZ1bmN0aW9uIF9nZXRQb3BwZXJDb25maWcoKSB7XG4gICAgICB2YXIgcG9wcGVyQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpLFxuICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgIGVuYWJsZWQ6IHRoaXMuX2NvbmZpZy5mbGlwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07IC8vIERpc2FibGUgUG9wcGVyIGlmIHdlIGhhdmUgYSBzdGF0aWMgZGlzcGxheVxuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIHBvcHBlckNvbmZpZy5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIHBvcHBlckNvbmZpZywgdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyk7XG4gICAgfSAvLyBTdGF0aWNcbiAgICA7XG5cbiAgICBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS5kYXRhKERBVEFfS0VZJDQpO1xuXG4gICAgICAgIHZhciBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgPyBjb25maWcgOiBudWxsO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpLmRhdGEoREFUQV9LRVkkNCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgY29uZmlnICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2NsZWFyTWVudXMgPSBmdW5jdGlvbiBfY2xlYXJNZW51cyhldmVudCkge1xuICAgICAgaWYgKGV2ZW50ICYmIChldmVudC53aGljaCA9PT0gUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQud2hpY2ggIT09IFRBQl9LRVlDT0RFKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2dnbGVzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFJDIpKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRvZ2dsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0b2dnbGVzW2ldKTtcblxuICAgICAgICB2YXIgY29udGV4dCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0b2dnbGVzW2ldKS5kYXRhKERBVEFfS0VZJDQpO1xuICAgICAgICB2YXIgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiB0b2dnbGVzW2ldXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0LmNsaWNrRXZlbnQgPSBldmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyb3Bkb3duTWVudSA9IGNvbnRleHQuX21lbnU7XG5cbiAgICAgICAgaWYgKCEkX19kZWZhdWx0WydkZWZhdWx0J10ocGFyZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX1NIT1ckMikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudCAmJiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJyAmJiAvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LndoaWNoID09PSBUQUJfS0VZQ09ERSkgJiYgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmNvbnRhaW5zKHBhcmVudCwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhpZGVFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudChFVkVOVF9ISURFJDEsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10ocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudCk7XG5cbiAgICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG5cblxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub2ZmKCdtb3VzZW92ZXInLCBudWxsLCAkX19kZWZhdWx0WydkZWZhdWx0J10ubm9vcCk7XG4gICAgICAgIH1cblxuICAgICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Ll9wb3BwZXIpIHtcbiAgICAgICAgICBjb250ZXh0Ll9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRyb3Bkb3duTWVudSkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10ocGFyZW50KS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1ckMikudHJpZ2dlcigkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfSElEREVOJDEsIHJlbGF0ZWRUYXJnZXQpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50ID0gZnVuY3Rpb24gX2dldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciBwYXJlbnQ7XG4gICAgICB2YXIgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmVudCB8fCBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIDtcblxuICAgIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIgPSBmdW5jdGlvbiBfZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgICAvLyBJZiBub3QgaW5wdXQvdGV4dGFyZWE6XG4gICAgICAvLyAgLSBBbmQgbm90IGEga2V5IGluIFJFR0VYUF9LRVlET1dOID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAgIC8vIElmIGlucHV0L3RleHRhcmVhOlxuICAgICAgLy8gIC0gSWYgc3BhY2Uga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAgIC8vICAtIElmIGtleSBpcyBvdGhlciB0aGFuIGVzY2FwZVxuICAgICAgLy8gICAgLSBJZiBrZXkgaXMgbm90IHVwIG9yIGRvd24gPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuICAgICAgLy8gICAgLSBJZiB0cmlnZ2VyIGluc2lkZSB0aGUgbWVudSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkgPyBldmVudC53aGljaCA9PT0gU1BBQ0VfS0VZQ09ERSB8fCBldmVudC53aGljaCAhPT0gRVNDQVBFX0tFWUNPREUgJiYgKGV2ZW50LndoaWNoICE9PSBBUlJPV19ET1dOX0tFWUNPREUgJiYgZXZlbnQud2hpY2ggIT09IEFSUk9XX1VQX0tFWUNPREUgfHwgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGV2ZW50LnRhcmdldCkuY2xvc2VzdChTRUxFQ1RPUl9NRU5VKS5sZW5ndGgpIDogIVJFR0VYUF9LRVlET1dOLnRlc3QoZXZlbnQud2hpY2gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpLmhhc0NsYXNzKENMQVNTX05BTUVfRElTQUJMRUQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzKTtcblxuICAgICAgdmFyIGlzQWN0aXZlID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHBhcmVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuXG4gICAgICBpZiAoIWlzQWN0aXZlICYmIGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgaWYgKCFpc0FjdGl2ZSB8fCBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUgfHwgZXZlbnQud2hpY2ggPT09IFNQQUNFX0tFWUNPREUpIHtcbiAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShwYXJlbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyKSkudHJpZ2dlcignZm9jdXMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS50cmlnZ2VyKCdjbGljaycpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtcyA9IFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfVklTSUJMRV9JVEVNUykpLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGl0ZW0pLmlzKCc6dmlzaWJsZScpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5kZXggPSBpdGVtcy5pbmRleE9mKGV2ZW50LnRhcmdldCk7XG5cbiAgICAgIGlmIChldmVudC53aGljaCA9PT0gQVJST1dfVVBfS0VZQ09ERSAmJiBpbmRleCA+IDApIHtcbiAgICAgICAgLy8gVXBcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19ET1dOX0tFWUNPREUgJiYgaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIERvd25cbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1zW2luZGV4XS5mb2N1cygpO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoRHJvcGRvd24sIG51bGwsIFt7XG4gICAgICBrZXk6IFwiVkVSU0lPTlwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OJDQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdCQyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0VHlwZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQyO1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBEcm9wZG93bjtcbiAgfSgpO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIERhdGEgQXBpIGltcGxlbWVudGF0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShkb2N1bWVudCkub24oRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uX2RhdGFBcGlLZXlkb3duSGFuZGxlcikub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCArIFwiIFwiICsgRVZFTlRfS0VZVVBfREFUQV9BUEksIERyb3Bkb3duLl9jbGVhck1lbnVzKS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZS5jYWxsKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKSwgJ3RvZ2dsZScpO1xuICB9KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSQ0LCBTRUxFQ1RPUl9GT1JNX0NISUxELCBmdW5jdGlvbiAoZSkge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNF0gPSBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ0XS5Db25zdHJ1Y3RvciA9IERyb3Bkb3duO1xuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDRdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNF0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkNDtcbiAgICByZXR1cm4gRHJvcGRvd24uX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUkNSA9ICdtb2RhbCc7XG4gIHZhciBWRVJTSU9OJDUgPSAnNC42LjAnO1xuICB2YXIgREFUQV9LRVkkNSA9ICdicy5tb2RhbCc7XG4gIHZhciBFVkVOVF9LRVkkNSA9IFwiLlwiICsgREFUQV9LRVkkNTtcbiAgdmFyIERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XG4gIHZhciBKUVVFUllfTk9fQ09ORkxJQ1QkNSA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDVdO1xuICB2YXIgRVNDQVBFX0tFWUNPREUkMSA9IDI3OyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XG5cbiAgdmFyIERlZmF1bHQkMyA9IHtcbiAgICBiYWNrZHJvcDogdHJ1ZSxcbiAgICBrZXlib2FyZDogdHJ1ZSxcbiAgICBmb2N1czogdHJ1ZSxcbiAgICBzaG93OiB0cnVlXG4gIH07XG4gIHZhciBEZWZhdWx0VHlwZSQzID0ge1xuICAgIGJhY2tkcm9wOiAnKGJvb2xlYW58c3RyaW5nKScsXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICBmb2N1czogJ2Jvb2xlYW4nLFxuICAgIHNob3c6ICdib29sZWFuJ1xuICB9O1xuICB2YXIgRVZFTlRfSElERSQyID0gXCJoaWRlXCIgKyBFVkVOVF9LRVkkNTtcbiAgdmFyIEVWRU5UX0hJREVfUFJFVkVOVEVEID0gXCJoaWRlUHJldmVudGVkXCIgKyBFVkVOVF9LRVkkNTtcbiAgdmFyIEVWRU5UX0hJRERFTiQyID0gXCJoaWRkZW5cIiArIEVWRU5UX0tFWSQ1O1xuICB2YXIgRVZFTlRfU0hPVyQyID0gXCJzaG93XCIgKyBFVkVOVF9LRVkkNTtcbiAgdmFyIEVWRU5UX1NIT1dOJDIgPSBcInNob3duXCIgKyBFVkVOVF9LRVkkNTtcbiAgdmFyIEVWRU5UX0ZPQ1VTSU4gPSBcImZvY3VzaW5cIiArIEVWRU5UX0tFWSQ1O1xuICB2YXIgRVZFTlRfUkVTSVpFID0gXCJyZXNpemVcIiArIEVWRU5UX0tFWSQ1O1xuICB2YXIgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IFwiY2xpY2suZGlzbWlzc1wiICsgRVZFTlRfS0VZJDU7XG4gIHZhciBFVkVOVF9LRVlET1dOX0RJU01JU1MgPSBcImtleWRvd24uZGlzbWlzc1wiICsgRVZFTlRfS0VZJDU7XG4gIHZhciBFVkVOVF9NT1VTRVVQX0RJU01JU1MgPSBcIm1vdXNldXAuZGlzbWlzc1wiICsgRVZFTlRfS0VZJDU7XG4gIHZhciBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IFwibW91c2Vkb3duLmRpc21pc3NcIiArIEVWRU5UX0tFWSQ1O1xuICB2YXIgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IFwiY2xpY2tcIiArIEVWRU5UX0tFWSQ1ICsgREFUQV9BUElfS0VZJDU7XG4gIHZhciBDTEFTU19OQU1FX1NDUk9MTEFCTEUgPSAnbW9kYWwtZGlhbG9nLXNjcm9sbGFibGUnO1xuICB2YXIgQ0xBU1NfTkFNRV9TQ1JPTExCQVJfTUVBU1VSRVIgPSAnbW9kYWwtc2Nyb2xsYmFyLW1lYXN1cmUnO1xuICB2YXIgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdtb2RhbC1iYWNrZHJvcCc7XG4gIHZhciBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XG4gIHZhciBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcbiAgdmFyIENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xuICB2YXIgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcbiAgdmFyIFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcbiAgdmFyIFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xuICB2YXIgU0VMRUNUT1JfREFUQV9UT0dHTEUkMyA9ICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXSc7XG4gIHZhciBTRUxFQ1RPUl9EQVRBX0RJU01JU1MgPSAnW2RhdGEtZGlzbWlzcz1cIm1vZGFsXCJdJztcbiAgdmFyIFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XG4gIHZhciBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCc7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ2xhc3MgRGVmaW5pdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE1vZGFsID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNb2RhbChlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9kaWFsb2cgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfRElBTE9HKTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gMDtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IE1vZGFsLnByb3RvdHlwZTtcblxuICAgIC8vIFB1YmxpY1xuICAgIF9wcm90by50b2dnbGUgPSBmdW5jdGlvbiB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IHRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICgkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFJDEpKSB7XG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfU0hPVyQyLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNTaG93biA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2NoZWNrU2Nyb2xsYmFyKCk7XG5cbiAgICAgIHRoaXMuX3NldFNjcm9sbGJhcigpO1xuXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcblxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcblxuICAgICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RJU01JU1MsIFNFTEVDVE9SX0RBVEFfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5oaWRlKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2RpYWxvZykub24oRVZFTlRfTU9VU0VET1dOX0RJU01JU1MsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKF90aGlzLl9lbGVtZW50KS5vbmUoRVZFTlRfTU9VU0VVUF9ESVNNSVNTLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICBpZiAoJF9fZGVmYXVsdFsnZGVmYXVsdCddKGV2ZW50LnRhcmdldCkuaXMoX3RoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgICAgICBfdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zaG93QmFja2Ryb3AoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZShldmVudCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhpZGVFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudChFVkVOVF9ISURFJDIpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSQxKTtcblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKTtcblxuICAgICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKTtcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50KS5vZmYoRVZFTlRfRk9DVVNJTik7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDMpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9DTElDS19ESVNNSVNTKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9kaWFsb2cpLm9mZihFVkVOVF9NT1VTRURPV05fRElTTUlTUyk7XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX2hpZGVNb2RhbChldmVudCk7XG4gICAgICAgIH0pLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9oaWRlTW9kYWwoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgW3dpbmRvdywgdGhpcy5fZWxlbWVudCwgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKGZ1bmN0aW9uIChodG1sRWxlbWVudCkge1xuICAgICAgICByZXR1cm4gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGh0bWxFbGVtZW50KS5vZmYoRVZFTlRfS0VZJDUpO1xuICAgICAgfSk7XG4gICAgICAvKipcbiAgICAgICAqIGBkb2N1bWVudGAgaGFzIDIgZXZlbnRzIGBFVkVOVF9GT0NVU0lOYCBhbmQgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYFxuICAgICAgICogRG8gbm90IG1vdmUgYGRvY3VtZW50YCBpbiBgaHRtbEVsZW1lbnRzYCBhcnJheVxuICAgICAgICogSXQgd2lsbCByZW1vdmUgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYCBldmVudCB0aGF0IHNob3VsZCByZW1haW5cbiAgICAgICAqL1xuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQpLm9mZihFVkVOVF9GT0NVU0lOKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJDUpO1xuICAgICAgdGhpcy5fY29uZmlnID0gbnVsbDtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgICAgdGhpcy5fZGlhbG9nID0gbnVsbDtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbDtcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBudWxsO1xuICAgICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBudWxsO1xuICAgICAgdGhpcy5faWdub3JlQmFja2Ryb3BDbGljayA9IG51bGw7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsO1xuICAgICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSBudWxsO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaGFuZGxlVXBkYXRlID0gZnVuY3Rpb24gaGFuZGxlVXBkYXRlKCkge1xuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gICAgfSAvLyBQcml2YXRlXG4gICAgO1xuXG4gICAgX3Byb3RvLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gX2V4dGVuZHMoe30sIERlZmF1bHQkMywgY29uZmlnKTtcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkNSwgY29uZmlnLCBEZWZhdWx0VHlwZSQzKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIF9wcm90by5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBoaWRlRXZlbnRQcmV2ZW50ZWQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfSElERV9QUkVWRU5URUQpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50UHJldmVudGVkKTtcblxuICAgICAgaWYgKGhpZGVFdmVudFByZXZlbnRlZC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG5cbiAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NUQVRJQyk7XG5cbiAgICAgIHZhciBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZGlhbG9nKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vZmYoVXRpbC5UUkFOU0lUSU9OX0VORCk7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuXG4gICAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKF90aGlzMy5fZWxlbWVudCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnJztcbiAgICAgICAgICB9KS5lbXVsYXRlVHJhbnNpdGlvbkVuZChfdGhpczMuX2VsZW1lbnQsIG1vZGFsVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSkuZW11bGF0ZVRyYW5zaXRpb25FbmQobW9kYWxUcmFuc2l0aW9uRHVyYXRpb24pO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5fc2hvd0VsZW1lbnQgPSBmdW5jdGlvbiBfc2hvd0VsZW1lbnQocmVsYXRlZFRhcmdldCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSQxKTtcbiAgICAgIHZhciBtb2RhbEJvZHkgPSB0aGlzLl9kaWFsb2cgPyB0aGlzLl9kaWFsb2cucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9NT0RBTF9CT0RZKSA6IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgLy8gRG9uJ3QgbW92ZSBtb2RhbCdzIERPTSBwb3NpdGlvblxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XG5cbiAgICAgIGlmICgkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZGlhbG9nKS5oYXNDbGFzcyhDTEFTU19OQU1FX1NDUk9MTEFCTEUpICYmIG1vZGFsQm9keSkge1xuICAgICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX1NIT1ckMyk7XG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZW5mb3JjZUZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG93bkV2ZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX1NIT1dOJDIsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZFRhcmdldFxuICAgICAgfSk7XG5cbiAgICAgIHZhciB0cmFuc2l0aW9uQ29tcGxldGUgPSBmdW5jdGlvbiB0cmFuc2l0aW9uQ29tcGxldGUoKSB7XG4gICAgICAgIGlmIChfdGhpczQuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICAgIF90aGlzNC5fZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM0Ll9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKF90aGlzNC5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KTtcbiAgICAgIH07XG5cbiAgICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZyk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9kaWFsb2cpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCB0cmFuc2l0aW9uQ29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uQ29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLl9lbmZvcmNlRm9jdXMgPSBmdW5jdGlvbiBfZW5mb3JjZUZvY3VzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShkb2N1bWVudCkub2ZmKEVWRU5UX0ZPQ1VTSU4pIC8vIEd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgLm9uKEVWRU5UX0ZPQ1VTSU4sIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiBfdGhpczUuX2VsZW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJiAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXM1Ll9lbGVtZW50KS5oYXMoZXZlbnQudGFyZ2V0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBfdGhpczUuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fc2V0RXNjYXBlRXZlbnQgPSBmdW5jdGlvbiBfc2V0RXNjYXBlRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX0tFWURPV05fRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzNi5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSQxKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBfdGhpczYuaGlkZSgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzNi5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSQxKSB7XG4gICAgICAgICAgICBfdGhpczYuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0tFWURPV05fRElTTUlTUyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fc2V0UmVzaXplRXZlbnQgPSBmdW5jdGlvbiBfc2V0UmVzaXplRXZlbnQoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHdpbmRvdykub24oRVZFTlRfUkVTSVpFLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM3LmhhbmRsZVVwZGF0ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHdpbmRvdykub2ZmKEVWRU5UX1JFU0laRSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5faGlkZU1vZGFsID0gZnVuY3Rpb24gX2hpZGVNb2RhbCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuXG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcblxuICAgICAgdGhpcy5fc2hvd0JhY2tkcm9wKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfT1BFTik7XG5cbiAgICAgICAgX3RoaXM4Ll9yZXNldEFkanVzdG1lbnRzKCk7XG5cbiAgICAgICAgX3RoaXM4Ll9yZXNldFNjcm9sbGJhcigpO1xuXG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShfdGhpczguX2VsZW1lbnQpLnRyaWdnZXIoRVZFTlRfSElEREVOJDIpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fcmVtb3ZlQmFja2Ryb3AgPSBmdW5jdGlvbiBfcmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgICBpZiAodGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uX3Nob3dCYWNrZHJvcCA9IGZ1bmN0aW9uIF9zaG93QmFja2Ryb3AoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICB2YXIgYW5pbWF0ZSA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUkMSkgPyBDTEFTU19OQU1FX0ZBREUkMSA6ICcnO1xuXG4gICAgICBpZiAodGhpcy5faXNTaG93biAmJiB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9CQUNLRFJPUDtcblxuICAgICAgICBpZiAoYW5pbWF0ZSkge1xuICAgICAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTGlzdC5hZGQoYW5pbWF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fYmFja2Ryb3ApLmFwcGVuZFRvKGRvY3VtZW50LmJvZHkpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub24oRVZFTlRfQ0xJQ0tfRElTTUlTUywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgaWYgKF90aGlzOS5faWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICAgICAgX3RoaXM5Ll9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfdGhpczkuX2NvbmZpZy5iYWNrZHJvcCA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIF90aGlzOS5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczkuaGlkZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgICBVdGlsLnJlZmxvdyh0aGlzLl9iYWNrZHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKENMQVNTX05BTUVfU0hPVyQzKTtcblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2JhY2tkcm9wKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY2FsbGJhY2spLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2JhY2tkcm9wKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1ckMyk7XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrUmVtb3ZlID0gZnVuY3Rpb24gY2FsbGJhY2tSZW1vdmUoKSB7XG4gICAgICAgICAgX3RoaXM5Ll9yZW1vdmVCYWNrZHJvcCgpO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSQxKSkge1xuICAgICAgICAgIHZhciBfYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKTtcblxuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9iYWNrZHJvcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNhbGxiYWNrUmVtb3ZlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZChfYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrUmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyB0aGUgZm9sbG93aW5nIG1ldGhvZHMgYXJlIHVzZWQgdG8gaGFuZGxlIG92ZXJmbG93aW5nIG1vZGFsc1xuICAgIC8vIHRvZG8gKGZhdCk6IHRoZXNlIHNob3VsZCBwcm9iYWJseSBiZSByZWZhY3RvcmVkIG91dCBvZiBtb2RhbC5qc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICA7XG5cbiAgICBfcHJvdG8uX2FkanVzdERpYWxvZyA9IGZ1bmN0aW9uIF9hZGp1c3REaWFsb2coKSB7XG4gICAgICB2YXIgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuXG4gICAgICBpZiAoIXRoaXMuX2lzQm9keU92ZXJmbG93aW5nICYmIGlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyBcInB4XCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fcmVzZXRBZGp1c3RtZW50cyA9IGZ1bmN0aW9uIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSAnJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uIF9jaGVja1Njcm9sbGJhcigpIHtcbiAgICAgIHZhciByZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gTWF0aC5yb3VuZChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSA8IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9nZXRTY3JvbGxiYXJXaWR0aCgpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX3NldFNjcm9sbGJhciA9IGZ1bmN0aW9uIF9zZXRTY3JvbGxiYXIoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9pc0JvZHlPdmVyZmxvd2luZykge1xuICAgICAgICAvLyBOb3RlOiBET01Ob2RlLnN0eWxlLnBhZGRpbmdSaWdodCByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUgb3IgJycgaWYgbm90IHNldFxuICAgICAgICAvLyAgIHdoaWxlICQoRE9NTm9kZSkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgcmV0dXJucyB0aGUgY2FsY3VsYXRlZCB2YWx1ZSBvciAwIGlmIG5vdCBzZXRcbiAgICAgICAgdmFyIGZpeGVkQ29udGVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9GSVhFRF9DT05URU5UKSk7XG4gICAgICAgIHZhciBzdGlja3lDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1NUSUNLWV9DT05URU5UKSk7IC8vIEFkanVzdCBmaXhlZCBjb250ZW50IHBhZGRpbmdcblxuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZml4ZWRDb250ZW50KS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICAgIHZhciBhY3R1YWxQYWRkaW5nID0gZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQ7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYWRkaW5nID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLmNzcygncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5kYXRhKCdwYWRkaW5nLXJpZ2h0JywgYWN0dWFsUGFkZGluZykuY3NzKCdwYWRkaW5nLXJpZ2h0JywgcGFyc2VGbG9hdChjYWxjdWxhdGVkUGFkZGluZykgKyBfdGhpczEwLl9zY3JvbGxiYXJXaWR0aCArIFwicHhcIik7XG4gICAgICAgIH0pOyAvLyBBZGp1c3Qgc3RpY2t5IGNvbnRlbnQgbWFyZ2luXG5cbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHN0aWNreUNvbnRlbnQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGFjdHVhbE1hcmdpbiA9IGVsZW1lbnQuc3R5bGUubWFyZ2luUmlnaHQ7XG4gICAgICAgICAgdmFyIGNhbGN1bGF0ZWRNYXJnaW4gPSAkX19kZWZhdWx0WydkZWZhdWx0J10oZWxlbWVudCkuY3NzKCdtYXJnaW4tcmlnaHQnKTtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZWxlbWVudCkuZGF0YSgnbWFyZ2luLXJpZ2h0JywgYWN0dWFsTWFyZ2luKS5jc3MoJ21hcmdpbi1yaWdodCcsIHBhcnNlRmxvYXQoY2FsY3VsYXRlZE1hcmdpbikgLSBfdGhpczEwLl9zY3JvbGxiYXJXaWR0aCArIFwicHhcIik7XG4gICAgICAgIH0pOyAvLyBBZGp1c3QgYm9keSBwYWRkaW5nXG5cbiAgICAgICAgdmFyIGFjdHVhbFBhZGRpbmcgPSBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodDtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZWRQYWRkaW5nID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50LmJvZHkpLmNzcygncGFkZGluZy1yaWdodCcpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQuYm9keSkuZGF0YSgncGFkZGluZy1yaWdodCcsIGFjdHVhbFBhZGRpbmcpLmNzcygncGFkZGluZy1yaWdodCcsIHBhcnNlRmxvYXQoY2FsY3VsYXRlZFBhZGRpbmcpICsgdGhpcy5fc2Nyb2xsYmFyV2lkdGggKyBcInB4XCIpO1xuICAgICAgfVxuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9yZXNldFNjcm9sbGJhciA9IGZ1bmN0aW9uIF9yZXNldFNjcm9sbGJhcigpIHtcbiAgICAgIC8vIFJlc3RvcmUgZml4ZWQgY29udGVudCBwYWRkaW5nXG4gICAgICB2YXIgZml4ZWRDb250ZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQpKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShmaXhlZENvbnRlbnQpLmVhY2goZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XG4gICAgICAgIHZhciBwYWRkaW5nID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLnJlbW92ZURhdGEoJ3BhZGRpbmctcmlnaHQnKTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nID8gcGFkZGluZyA6ICcnO1xuICAgICAgfSk7IC8vIFJlc3RvcmUgc3RpY2t5IGNvbnRlbnRcblxuICAgICAgdmFyIGVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiXCIgKyBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCkpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnRzKS5lYWNoKGZ1bmN0aW9uIChpbmRleCwgZWxlbWVudCkge1xuICAgICAgICB2YXIgbWFyZ2luID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGVsZW1lbnQpLmRhdGEoJ21hcmdpbi1yaWdodCcpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5jc3MoJ21hcmdpbi1yaWdodCcsIG1hcmdpbikucmVtb3ZlRGF0YSgnbWFyZ2luLXJpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBSZXN0b3JlIGJvZHkgcGFkZGluZ1xuXG4gICAgICB2YXIgcGFkZGluZyA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShkb2N1bWVudC5ib2R5KS5kYXRhKCdwYWRkaW5nLXJpZ2h0Jyk7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQuYm9keSkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpO1xuICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nID8gcGFkZGluZyA6ICcnO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldFNjcm9sbGJhcldpZHRoID0gZnVuY3Rpb24gX2dldFNjcm9sbGJhcldpZHRoKCkge1xuICAgICAgLy8gdGh4IGQud2Fsc2hcbiAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHNjcm9sbERpdi5jbGFzc05hbWUgPSBDTEFTU19OQU1FX1NDUk9MTEJBUl9NRUFTVVJFUjtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aDtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KTtcbiAgICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aDtcbiAgICB9IC8vIFN0YXRpY1xuICAgIDtcblxuICAgIE1vZGFsLl9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpLmRhdGEoREFUQV9LRVkkNSk7XG5cbiAgICAgICAgdmFyIF9jb25maWcgPSBfZXh0ZW5kcyh7fSwgRGVmYXVsdCQzLCAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcykuZGF0YSgpLCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSk7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcykuZGF0YShEQVRBX0tFWSQ1LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICB9IGVsc2UgaWYgKF9jb25maWcuc2hvdykge1xuICAgICAgICAgIGRhdGEuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhNb2RhbCwgbnVsbCwgW3tcbiAgICAgIGtleTogXCJWRVJTSU9OXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIFZFUlNJT04kNTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRGVmYXVsdFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0JDM7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1vZGFsO1xuICB9KCk7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50KS5vbihFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG5cbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzKTtcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgdmFyIGNvbmZpZyA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0YXJnZXQpLmRhdGEoREFUQV9LRVkkNSkgPyAndG9nZ2xlJyA6IF9leHRlbmRzKHt9LCAkX19kZWZhdWx0WydkZWZhdWx0J10odGFyZ2V0KS5kYXRhKCksICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS5kYXRhKCkpO1xuXG4gICAgaWYgKHRoaXMudGFnTmFtZSA9PT0gJ0EnIHx8IHRoaXMudGFnTmFtZSA9PT0gJ0FSRUEnKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHZhciAkdGFyZ2V0ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRhcmdldCkub25lKEVWRU5UX1NIT1ckMiwgZnVuY3Rpb24gKHNob3dFdmVudCkge1xuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJHRhcmdldC5vbmUoRVZFTlRfSElEREVOJDIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXShfdGhpczExKS5pcygnOnZpc2libGUnKSkge1xuICAgICAgICAgIF90aGlzMTEuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRhcmdldCksIGNvbmZpZywgdGhpcyk7XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNV0gPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ1XS5Db25zdHJ1Y3RvciA9IE1vZGFsO1xuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDVdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNV0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkNTtcbiAgICByZXR1cm4gTW9kYWwuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwICh2NC42LjApOiB0b29scy9zYW5pdGl6ZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuICB2YXIgdXJpQXR0cnMgPSBbJ2JhY2tncm91bmQnLCAnY2l0ZScsICdocmVmJywgJ2l0ZW10eXBlJywgJ2xvbmdkZXNjJywgJ3Bvc3RlcicsICdzcmMnLCAneGxpbms6aHJlZiddO1xuICB2YXIgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pO1xuICB2YXIgRGVmYXVsdFdoaXRlbGlzdCA9IHtcbiAgICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICAgICcqJzogWydjbGFzcycsICdkaXInLCAnaWQnLCAnbGFuZycsICdyb2xlJywgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTl0sXG4gICAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcbiAgICBhcmVhOiBbXSxcbiAgICBiOiBbXSxcbiAgICBicjogW10sXG4gICAgY29sOiBbXSxcbiAgICBjb2RlOiBbXSxcbiAgICBkaXY6IFtdLFxuICAgIGVtOiBbXSxcbiAgICBocjogW10sXG4gICAgaDE6IFtdLFxuICAgIGgyOiBbXSxcbiAgICBoMzogW10sXG4gICAgaDQ6IFtdLFxuICAgIGg1OiBbXSxcbiAgICBoNjogW10sXG4gICAgaTogW10sXG4gICAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICAgIGxpOiBbXSxcbiAgICBvbDogW10sXG4gICAgcDogW10sXG4gICAgcHJlOiBbXSxcbiAgICBzOiBbXSxcbiAgICBzbWFsbDogW10sXG4gICAgc3BhbjogW10sXG4gICAgc3ViOiBbXSxcbiAgICBzdXA6IFtdLFxuICAgIHN0cm9uZzogW10sXG4gICAgdTogW10sXG4gICAgdWw6IFtdXG4gIH07XG4gIC8qKlxuICAgKiBBIHBhdHRlcm4gdGhhdCByZWNvZ25pemVzIGEgY29tbW9ubHkgdXNlZnVsIHN1YnNldCBvZiBVUkxzIHRoYXQgYXJlIHNhZmUuXG4gICAqXG4gICAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAgICovXG5cbiAgdmFyIFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlKTp8W14jJi86P10qKD86WyMvP118JCkpL2dpO1xuICAvKipcbiAgICogQSBwYXR0ZXJuIHRoYXQgbWF0Y2hlcyBzYWZlIGRhdGEgVVJMcy4gT25seSBtYXRjaGVzIGltYWdlLCB2aWRlbyBhbmQgYXVkaW8gdHlwZXMuXG4gICAqXG4gICAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgNyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvNy4yLjQvcGFja2FnZXMvY29yZS9zcmMvc2FuaXRpemF0aW9uL3VybF9zYW5pdGl6ZXIudHNcbiAgICovXG5cbiAgdmFyIERBVEFfVVJMX1BBVFRFUk4gPSAvXmRhdGE6KD86aW1hZ2VcXC8oPzpibXB8Z2lmfGpwZWd8anBnfHBuZ3x0aWZmfHdlYnApfHZpZGVvXFwvKD86bXBlZ3xtcDR8b2dnfHdlYm0pfGF1ZGlvXFwvKD86bXAzfG9nYXxvZ2d8b3B1cykpO2Jhc2U2NCxbXFxkKy9hLXpdKz0qJC9pO1xuXG4gIGZ1bmN0aW9uIGFsbG93ZWRBdHRyaWJ1dGUoYXR0ciwgYWxsb3dlZEF0dHJpYnV0ZUxpc3QpIHtcbiAgICB2YXIgYXR0ck5hbWUgPSBhdHRyLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZUxpc3QuaW5kZXhPZihhdHRyTmFtZSkgIT09IC0xKSB7XG4gICAgICBpZiAodXJpQXR0cnMuaW5kZXhPZihhdHRyTmFtZSkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKGF0dHIubm9kZVZhbHVlLm1hdGNoKFNBRkVfVVJMX1BBVFRFUk4pIHx8IGF0dHIubm9kZVZhbHVlLm1hdGNoKERBVEFfVVJMX1BBVFRFUk4pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHJlZ0V4cCA9IGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihmdW5jdGlvbiAoYXR0clJlZ2V4KSB7XG4gICAgICByZXR1cm4gYXR0clJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwO1xuICAgIH0pOyAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByZWdFeHAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChhdHRyTmFtZS5tYXRjaChyZWdFeHBbaV0pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNhbml0aXplSHRtbCh1bnNhZmVIdG1sLCB3aGl0ZUxpc3QsIHNhbml0aXplRm4pIHtcbiAgICBpZiAodW5zYWZlSHRtbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB1bnNhZmVIdG1sO1xuICAgIH1cblxuICAgIGlmIChzYW5pdGl6ZUZuICYmIHR5cGVvZiBzYW5pdGl6ZUZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gc2FuaXRpemVGbih1bnNhZmVIdG1sKTtcbiAgICB9XG5cbiAgICB2YXIgZG9tUGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKTtcbiAgICB2YXIgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XG4gICAgdmFyIHdoaXRlbGlzdEtleXMgPSBPYmplY3Qua2V5cyh3aGl0ZUxpc3QpO1xuICAgIHZhciBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGksIGxlbikge1xuICAgICAgdmFyIGVsID0gZWxlbWVudHNbaV07XG4gICAgICB2YXIgZWxOYW1lID0gZWwubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgaWYgKHdoaXRlbGlzdEtleXMuaW5kZXhPZihlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVMaXN0ID0gW10uc2xpY2UuY2FsbChlbC5hdHRyaWJ1dGVzKTtcbiAgICAgIHZhciB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQod2hpdGVMaXN0WycqJ10gfHwgW10sIHdoaXRlTGlzdFtlbE5hbWVdIHx8IFtdKTtcbiAgICAgIGF0dHJpYnV0ZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICBpZiAoIWFsbG93ZWRBdHRyaWJ1dGUoYXR0ciwgd2hpdGVsaXN0ZWRBdHRyaWJ1dGVzKSkge1xuICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShhdHRyLm5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChpKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiY29udGludWVcIikgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZWREb2N1bWVudC5ib2R5LmlubmVySFRNTDtcbiAgfVxuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSQ2ID0gJ3Rvb2x0aXAnO1xuICB2YXIgVkVSU0lPTiQ2ID0gJzQuNi4wJztcbiAgdmFyIERBVEFfS0VZJDYgPSAnYnMudG9vbHRpcCc7XG4gIHZhciBFVkVOVF9LRVkkNiA9IFwiLlwiICsgREFUQV9LRVkkNjtcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQ2ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNl07XG4gIHZhciBDTEFTU19QUkVGSVggPSAnYnMtdG9vbHRpcCc7XG4gIHZhciBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBDTEFTU19QUkVGSVggKyBcIlxcXFxTK1wiLCAnZycpO1xuICB2YXIgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gWydzYW5pdGl6ZScsICd3aGl0ZUxpc3QnLCAnc2FuaXRpemVGbiddO1xuICB2YXIgRGVmYXVsdFR5cGUkNCA9IHtcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZycsXG4gICAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgICB0cmlnZ2VyOiAnc3RyaW5nJyxcbiAgICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXG4gICAgaHRtbDogJ2Jvb2xlYW4nLFxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXG4gICAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIG9mZnNldDogJyhudW1iZXJ8c3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgY29udGFpbmVyOiAnKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pJyxcbiAgICBmYWxsYmFja1BsYWNlbWVudDogJyhzdHJpbmd8YXJyYXkpJyxcbiAgICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICAgIGN1c3RvbUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXG4gICAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gICAgd2hpdGVMaXN0OiAnb2JqZWN0JyxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3QpJ1xuICB9O1xuICB2YXIgQXR0YWNobWVudE1hcCA9IHtcbiAgICBBVVRPOiAnYXV0bycsXG4gICAgVE9QOiAndG9wJyxcbiAgICBSSUdIVDogJ3JpZ2h0JyxcbiAgICBCT1RUT006ICdib3R0b20nLFxuICAgIExFRlQ6ICdsZWZ0J1xuICB9O1xuICB2YXIgRGVmYXVsdCQ0ID0ge1xuICAgIGFuaW1hdGlvbjogdHJ1ZSxcbiAgICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICsgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cycsXG4gICAgdGl0bGU6ICcnLFxuICAgIGRlbGF5OiAwLFxuICAgIGh0bWw6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiBmYWxzZSxcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIG9mZnNldDogMCxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIGZhbGxiYWNrUGxhY2VtZW50OiAnZmxpcCcsXG4gICAgYm91bmRhcnk6ICdzY3JvbGxQYXJlbnQnLFxuICAgIGN1c3RvbUNsYXNzOiAnJyxcbiAgICBzYW5pdGl6ZTogdHJ1ZSxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxuICAgIHdoaXRlTGlzdDogRGVmYXVsdFdoaXRlbGlzdCxcbiAgICBwb3BwZXJDb25maWc6IG51bGxcbiAgfTtcbiAgdmFyIEhPVkVSX1NUQVRFX1NIT1cgPSAnc2hvdyc7XG4gIHZhciBIT1ZFUl9TVEFURV9PVVQgPSAnb3V0JztcbiAgdmFyIEV2ZW50ID0ge1xuICAgIEhJREU6IFwiaGlkZVwiICsgRVZFTlRfS0VZJDYsXG4gICAgSElEREVOOiBcImhpZGRlblwiICsgRVZFTlRfS0VZJDYsXG4gICAgU0hPVzogXCJzaG93XCIgKyBFVkVOVF9LRVkkNixcbiAgICBTSE9XTjogXCJzaG93blwiICsgRVZFTlRfS0VZJDYsXG4gICAgSU5TRVJURUQ6IFwiaW5zZXJ0ZWRcIiArIEVWRU5UX0tFWSQ2LFxuICAgIENMSUNLOiBcImNsaWNrXCIgKyBFVkVOVF9LRVkkNixcbiAgICBGT0NVU0lOOiBcImZvY3VzaW5cIiArIEVWRU5UX0tFWSQ2LFxuICAgIEZPQ1VTT1VUOiBcImZvY3Vzb3V0XCIgKyBFVkVOVF9LRVkkNixcbiAgICBNT1VTRUVOVEVSOiBcIm1vdXNlZW50ZXJcIiArIEVWRU5UX0tFWSQ2LFxuICAgIE1PVVNFTEVBVkU6IFwibW91c2VsZWF2ZVwiICsgRVZFTlRfS0VZJDZcbiAgfTtcbiAgdmFyIENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xuICB2YXIgQ0xBU1NfTkFNRV9TSE9XJDQgPSAnc2hvdyc7XG4gIHZhciBTRUxFQ1RPUl9UT09MVElQX0lOTkVSID0gJy50b29sdGlwLWlubmVyJztcbiAgdmFyIFNFTEVDVE9SX0FSUk9XID0gJy5hcnJvdyc7XG4gIHZhciBUUklHR0VSX0hPVkVSID0gJ2hvdmVyJztcbiAgdmFyIFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnO1xuICB2YXIgVFJJR0dFUl9DTElDSyA9ICdjbGljayc7XG4gIHZhciBUUklHR0VSX01BTlVBTCA9ICdtYW51YWwnO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBUb29sdGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb29sdGlwKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgaWYgKHR5cGVvZiBQb3BwZXJfX2RlZmF1bHRbJ2RlZmF1bHQnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyB0b29sdGlwcyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgICAgfSAvLyBwcml2YXRlXG5cblxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSAwO1xuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9O1xuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDsgLy8gUHJvdGVjdGVkXG5cbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy50aXAgPSBudWxsO1xuXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IFRvb2x0aXAucHJvdG90eXBlO1xuXG4gICAgLy8gUHVibGljXG4gICAgX3Byb3RvLmVuYWJsZSA9IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIF9wcm90by5kaXNhYmxlID0gZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBfcHJvdG8udG9nZ2xlRW5hYmxlZCA9IGZ1bmN0aW9uIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xuICAgIH07XG5cbiAgICBfcHJvdG8udG9nZ2xlID0gZnVuY3Rpb24gdG9nZ2xlKGV2ZW50KSB7XG4gICAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChldmVudCkge1xuICAgICAgICB2YXIgZGF0YUtleSA9IHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG5cbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrO1xuXG4gICAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0Ll9sZWF2ZShudWxsLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDQpKSB7XG4gICAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbnRlcihudWxsLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmRpc3Bvc2UgPSBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLnJlbW92ZURhdGEodGhpcy5lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmVsZW1lbnQpLm9mZih0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSk7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vZmYoJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcblxuICAgICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLnRpcCkucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLmNvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLnRpcCA9IG51bGw7XG4gICAgfTtcblxuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICgkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5lbGVtZW50KS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNob3dFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LlNIT1cpO1xuXG4gICAgICBpZiAodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmVsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KTtcbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSBVdGlsLmZpbmRTaGFkb3dSb290KHRoaXMuZWxlbWVudCk7XG4gICAgICAgIHZhciBpc0luVGhlRG9tID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLmNvbnRhaW5zKHNoYWRvd1Jvb3QgIT09IG51bGwgPyBzaGFkb3dSb290IDogdGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLmVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG4gICAgICAgIHZhciB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSk7XG4gICAgICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5JywgdGlwSWQpO1xuICAgICAgICB0aGlzLnNldENvbnRlbnQoKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRpcCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IHR5cGVvZiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy5wbGFjZW1lbnQuY2FsbCh0aGlzLCB0aXAsIHRoaXMuZWxlbWVudCkgOiB0aGlzLmNvbmZpZy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgdmFyIGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudCk7XG5cbiAgICAgICAgdGhpcy5hZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCk7XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2dldENvbnRhaW5lcigpO1xuXG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aXApLmRhdGEodGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKCEkX19kZWZhdWx0WydkZWZhdWx0J10uY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnRpcCkpIHtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGlwKS5hcHBlbmRUbyhjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LklOU0VSVEVEKTtcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcl9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuZWxlbWVudCwgdGlwLCB0aGlzLl9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGlwKS5hZGRDbGFzcyhDTEFTU19OQU1FX1NIT1ckNCk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aXApLmFkZENsYXNzKHRoaXMuY29uZmlnLmN1c3RvbUNsYXNzKTsgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxuICAgICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xuICAgICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcblxuICAgICAgICBpZiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5ub29wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBfdGhpcy5fZml4VHJhbnNpdGlvbigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcmV2SG92ZXJTdGF0ZSA9IF90aGlzLl9ob3ZlclN0YXRlO1xuICAgICAgICAgIF90aGlzLl9ob3ZlclN0YXRlID0gbnVsbDtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXMuZWxlbWVudCkudHJpZ2dlcihfdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5TSE9XTik7XG5cbiAgICAgICAgICBpZiAocHJldkhvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX09VVCkge1xuICAgICAgICAgICAgX3RoaXMuX2xlYXZlKG51bGwsIF90aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLnRpcCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFJDIpKSB7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy50aXApO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLnRpcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdmFyIGhpZGVFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgaWYgKF90aGlzMi5faG92ZXJTdGF0ZSAhPT0gSE9WRVJfU1RBVEVfU0hPVyAmJiB0aXAucGFyZW50Tm9kZSkge1xuICAgICAgICAgIHRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRpcCk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuX2NsZWFuVGlwQ2xhc3MoKTtcblxuICAgICAgICBfdGhpczIuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcblxuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXMyLmVsZW1lbnQpLnRyaWdnZXIoX3RoaXMyLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTik7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fcG9wcGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgX3RoaXMyLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuZWxlbWVudCkudHJpZ2dlcihoaWRlRXZlbnQpO1xuXG4gICAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRpcCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDQpOyAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcblxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vZmYoJ21vdXNlb3ZlcicsIG51bGwsICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5ub29wKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0ZPQ1VTXSA9IGZhbHNlO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0hPVkVSXSA9IGZhbHNlO1xuXG4gICAgICBpZiAoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMudGlwKS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUkMikpIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGlwKTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRpcCkub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKS5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faG92ZXJTdGF0ZSA9ICcnO1xuICAgIH07XG5cbiAgICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlciAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIuc2NoZWR1bGVVcGRhdGUoKTtcbiAgICAgIH1cbiAgICB9IC8vIFByb3RlY3RlZFxuICAgIDtcblxuICAgIF9wcm90by5pc1dpdGhDb250ZW50ID0gZnVuY3Rpb24gaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0VGl0bGUoKSk7XG4gICAgfTtcblxuICAgIF9wcm90by5hZGRBdHRhY2htZW50Q2xhc3MgPSBmdW5jdGlvbiBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhDTEFTU19QUkVGSVggKyBcIi1cIiArIGF0dGFjaG1lbnQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF07XG4gICAgICByZXR1cm4gdGhpcy50aXA7XG4gICAgfTtcblxuICAgIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCgpIHtcbiAgICAgIHZhciB0aXAgPSB0aGlzLmdldFRpcEVsZW1lbnQoKTtcbiAgICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRpcC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIpKSwgdGhpcy5nZXRUaXRsZSgpKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aXApLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfRkFERSQyICsgXCIgXCIgKyBDTEFTU19OQU1FX1NIT1ckNCk7XG4gICAgfTtcblxuICAgIF9wcm90by5zZXRFbGVtZW50Q29udGVudCA9IGZ1bmN0aW9uIHNldEVsZW1lbnRDb250ZW50KCRlbGVtZW50LCBjb250ZW50KSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIChjb250ZW50Lm5vZGVUeXBlIHx8IGNvbnRlbnQuanF1ZXJ5KSkge1xuICAgICAgICAvLyBDb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmh0bWwpIHtcbiAgICAgICAgICBpZiAoISRfX2RlZmF1bHRbJ2RlZmF1bHQnXShjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAgICRlbGVtZW50LmVtcHR5KCkuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxlbWVudC50ZXh0KCRfX2RlZmF1bHRbJ2RlZmF1bHQnXShjb250ZW50KS50ZXh0KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5jb25maWcuc2FuaXRpemUpIHtcbiAgICAgICAgICBjb250ZW50ID0gc2FuaXRpemVIdG1sKGNvbnRlbnQsIHRoaXMuY29uZmlnLndoaXRlTGlzdCwgdGhpcy5jb25maWcuc2FuaXRpemVGbik7XG4gICAgICAgIH1cblxuICAgICAgICAkZWxlbWVudC5odG1sKGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsZW1lbnQudGV4dChjb250ZW50KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmdldFRpdGxlID0gZnVuY3Rpb24gZ2V0VGl0bGUoKSB7XG4gICAgICB2YXIgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG5cbiAgICAgIGlmICghdGl0bGUpIHtcbiAgICAgICAgdGl0bGUgPSB0eXBlb2YgdGhpcy5jb25maWcudGl0bGUgPT09ICdmdW5jdGlvbicgPyB0aGlzLmNvbmZpZy50aXRsZS5jYWxsKHRoaXMuZWxlbWVudCkgOiB0aGlzLmNvbmZpZy50aXRsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRpdGxlO1xuICAgIH0gLy8gUHJpdmF0ZVxuICAgIDtcblxuICAgIF9wcm90by5fZ2V0UG9wcGVyQ29uZmlnID0gZnVuY3Rpb24gX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGRlZmF1bHRCc0NvbmZpZyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpLFxuICAgICAgICAgIGZsaXA6IHtcbiAgICAgICAgICAgIGJlaGF2aW9yOiB0aGlzLmNvbmZpZy5mYWxsYmFja1BsYWNlbWVudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IFNFTEVDVE9SX0FSUk9XXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICAgIGJvdW5kYXJpZXNFbGVtZW50OiB0aGlzLmNvbmZpZy5ib3VuZGFyeVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKGRhdGEpIHtcbiAgICAgICAgICBpZiAoZGF0YS5vcmlnaW5hbFBsYWNlbWVudCAhPT0gZGF0YS5wbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIF90aGlzMy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRCc0NvbmZpZywgdGhpcy5jb25maWcucG9wcGVyQ29uZmlnKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9nZXRPZmZzZXQgPSBmdW5jdGlvbiBfZ2V0T2Zmc2V0KCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBvZmZzZXQgPSB7fTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb2Zmc2V0LmZuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLm9mZnNldHMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLCBfdGhpczQuY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIF90aGlzNC5lbGVtZW50KSB8fCB7fSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQub2Zmc2V0ID0gdGhpcy5jb25maWcub2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldENvbnRhaW5lciA9IGZ1bmN0aW9uIF9nZXRDb250YWluZXIoKSB7XG4gICAgICBpZiAodGhpcy5jb25maWcuY29udGFpbmVyID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICAgIH1cblxuICAgICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuY29uZmlnLmNvbnRhaW5lcikpIHtcbiAgICAgICAgcmV0dXJuICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmNvbmZpZy5jb250YWluZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJF9fZGVmYXVsdFsnZGVmYXVsdCddKGRvY3VtZW50KS5maW5kKHRoaXMuY29uZmlnLmNvbnRhaW5lcik7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0QXR0YWNobWVudCA9IGZ1bmN0aW9uIF9nZXRBdHRhY2htZW50KHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX3NldExpc3RlbmVycyA9IGZ1bmN0aW9uIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblxuICAgICAgdmFyIHRyaWdnZXJzID0gdGhpcy5jb25maWcudHJpZ2dlci5zcGxpdCgnICcpO1xuICAgICAgdHJpZ2dlcnMuZm9yRWFjaChmdW5jdGlvbiAodHJpZ2dlcikge1xuICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ2NsaWNrJykge1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShfdGhpczUuZWxlbWVudCkub24oX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkNMSUNLLCBfdGhpczUuY29uZmlnLnNlbGVjdG9yLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczUudG9nZ2xlKGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xuICAgICAgICAgIHZhciBldmVudEluID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IF90aGlzNS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUVOVEVSIDogX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTSU47XG4gICAgICAgICAgdmFyIGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/IF90aGlzNS5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDogX3RoaXM1LmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShfdGhpczUuZWxlbWVudCkub24oZXZlbnRJbiwgX3RoaXM1LmNvbmZpZy5zZWxlY3RvciwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM1Ll9lbnRlcihldmVudCk7XG4gICAgICAgICAgfSkub24oZXZlbnRPdXQsIF90aGlzNS5jb25maWcuc2VsZWN0b3IsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzNS5fbGVhdmUoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKF90aGlzNS5lbGVtZW50KSB7XG4gICAgICAgICAgX3RoaXM1LmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuZWxlbWVudCkuY2xvc2VzdCgnLm1vZGFsJykub24oJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuY29uZmlnID0gX2V4dGVuZHMoe30sIHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgc2VsZWN0b3I6ICcnXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZml4VGl0bGUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLl9maXhUaXRsZSA9IGZ1bmN0aW9uIF9maXhUaXRsZSgpIHtcbiAgICAgIHZhciB0aXRsZVR5cGUgPSB0eXBlb2YgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuXG4gICAgICBpZiAodGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCB0aXRsZVR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8ICcnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fZW50ZXIgPSBmdW5jdGlvbiBfZW50ZXIoZXZlbnQsIGNvbnRleHQpIHtcbiAgICAgIHZhciBkYXRhS2V5ID0gdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWTtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpO1xuXG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGV2ZW50LmN1cnJlbnRUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXShjb250ZXh0LmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XJDQpIHx8IGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX1NIT1cpIHtcbiAgICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpO1xuICAgICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX1NIT1c7XG5cbiAgICAgIGlmICghY29udGV4dC5jb25maWcuZGVsYXkgfHwgIWNvbnRleHQuY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgICAgY29udGV4dC5zaG93KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY29udGV4dC5faG92ZXJTdGF0ZSA9PT0gSE9WRVJfU1RBVEVfU0hPVykge1xuICAgICAgICAgIGNvbnRleHQuc2hvdygpO1xuICAgICAgICB9XG4gICAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5zaG93KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9sZWF2ZSA9IGZ1bmN0aW9uIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xuICAgICAgdmFyIGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZO1xuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGV2ZW50LmN1cnJlbnRUYXJnZXQpLmRhdGEoZGF0YUtleSk7XG5cbiAgICAgIGlmICghY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoZXZlbnQuY3VycmVudFRhcmdldCwgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKSk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbGVhclRpbWVvdXQoY29udGV4dC5fdGltZW91dCk7XG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfT1VUO1xuXG4gICAgICBpZiAoIWNvbnRleHQuY29uZmlnLmRlbGF5IHx8ICFjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKSB7XG4gICAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuX2hvdmVyU3RhdGUgPT09IEhPVkVSX1NUQVRFX09VVCkge1xuICAgICAgICAgIGNvbnRleHQuaGlkZSgpO1xuICAgICAgICB9XG4gICAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9pc1dpdGhBY3RpdmVUcmlnZ2VyID0gZnVuY3Rpb24gX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgICBmb3IgKHZhciB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRyaWdnZXJbdHJpZ2dlcl0pIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIHZhciBkYXRhQXR0cmlidXRlcyA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmVsZW1lbnQpLmRhdGEoKTtcbiAgICAgIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhQXR0cikge1xuICAgICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmluZGV4T2YoZGF0YUF0dHIpICE9PSAtMSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cl07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uZmlnID0gX2V4dGVuZHMoe30sIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCwgZGF0YUF0dHJpYnV0ZXMsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KTtcblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5kZWxheSA9IHtcbiAgICAgICAgICBzaG93OiBjb25maWcuZGVsYXksXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRpdGxlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuY29udGVudCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlnLmNvbnRlbnQgPSBjb25maWcuY29udGVudC50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FJDYsIGNvbmZpZywgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSk7XG5cbiAgICAgIGlmIChjb25maWcuc2FuaXRpemUpIHtcbiAgICAgICAgY29uZmlnLnRlbXBsYXRlID0gc2FuaXRpemVIdG1sKGNvbmZpZy50ZW1wbGF0ZSwgY29uZmlnLndoaXRlTGlzdCwgY29uZmlnLnNhbml0aXplRm4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dldERlbGVnYXRlQ29uZmlnID0gZnVuY3Rpb24gX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgICAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gICAgICBpZiAodGhpcy5jb25maWcpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuY29uZmlnKSB7XG4gICAgICAgICAgaWYgKHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtrZXldICE9PSB0aGlzLmNvbmZpZ1trZXldKSB7XG4gICAgICAgICAgICBjb25maWdba2V5XSA9IHRoaXMuY29uZmlnW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIF9wcm90by5fY2xlYW5UaXBDbGFzcyA9IGZ1bmN0aW9uIF9jbGVhblRpcENsYXNzKCkge1xuICAgICAgdmFyICR0aXAgPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5nZXRUaXBFbGVtZW50KCkpO1xuICAgICAgdmFyIHRhYkNsYXNzID0gJHRpcC5hdHRyKCdjbGFzcycpLm1hdGNoKEJTQ0xTX1BSRUZJWF9SRUdFWCk7XG5cbiAgICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGgpIHtcbiAgICAgICAgJHRpcC5yZW1vdmVDbGFzcyh0YWJDbGFzcy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlID0gZnVuY3Rpb24gX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShwb3BwZXJEYXRhKSB7XG4gICAgICB0aGlzLnRpcCA9IHBvcHBlckRhdGEuaW5zdGFuY2UucG9wcGVyO1xuXG4gICAgICB0aGlzLl9jbGVhblRpcENsYXNzKCk7XG5cbiAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQocG9wcGVyRGF0YS5wbGFjZW1lbnQpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9maXhUcmFuc2l0aW9uID0gZnVuY3Rpb24gX2ZpeFRyYW5zaXRpb24oKSB7XG4gICAgICB2YXIgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KCk7XG4gICAgICB2YXIgaW5pdENvbmZpZ0FuaW1hdGlvbiA9IHRoaXMuY29uZmlnLmFuaW1hdGlvbjtcblxuICAgICAgaWYgKHRpcC5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGlwKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0ZBREUkMik7XG4gICAgICB0aGlzLmNvbmZpZy5hbmltYXRpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgdGhpcy5zaG93KCk7XG4gICAgICB0aGlzLmNvbmZpZy5hbmltYXRpb24gPSBpbml0Q29uZmlnQW5pbWF0aW9uO1xuICAgIH0gLy8gU3RhdGljXG4gICAgO1xuXG4gICAgVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlID0gZnVuY3Rpb24gX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgJGVsZW1lbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcyk7XG4gICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSQ2KTtcblxuICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcblxuICAgICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBUb29sdGlwKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVkkNiwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyBtZXRob2QgbmFtZWQgXFxcIlwiICsgY29uZmlnICsgXCJcXFwiXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFRvb2x0aXAsIG51bGwsIFt7XG4gICAgICBrZXk6IFwiVkVSU0lPTlwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBWRVJTSU9OJDY7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkRlZmF1bHRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdCQ0O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJOQU1FXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIE5BTUUkNjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiREFUQV9LRVlcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gREFUQV9LRVkkNjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRXZlbnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRXZlbnQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkVWRU5UX0tFWVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVF9LRVkkNjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRGVmYXVsdFR5cGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNDtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVG9vbHRpcDtcbiAgfSgpO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ2XSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZTtcbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNl0uQ29uc3RydWN0b3IgPSBUb29sdGlwO1xuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDZdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkNl0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkNjtcbiAgICByZXR1cm4gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSQ3ID0gJ3BvcG92ZXInO1xuICB2YXIgVkVSU0lPTiQ3ID0gJzQuNi4wJztcbiAgdmFyIERBVEFfS0VZJDcgPSAnYnMucG9wb3Zlcic7XG4gIHZhciBFVkVOVF9LRVkkNyA9IFwiLlwiICsgREFUQV9LRVkkNztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQ3ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkN107XG4gIHZhciBDTEFTU19QUkVGSVgkMSA9ICdicy1wb3BvdmVyJztcbiAgdmFyIEJTQ0xTX1BSRUZJWF9SRUdFWCQxID0gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgQ0xBU1NfUFJFRklYJDEgKyBcIlxcXFxTK1wiLCAnZycpO1xuXG4gIHZhciBEZWZhdWx0JDUgPSBfZXh0ZW5kcyh7fSwgVG9vbHRpcC5EZWZhdWx0LCB7XG4gICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgIHRyaWdnZXI6ICdjbGljaycsXG4gICAgY29udGVudDogJycsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwiYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj48L2Rpdj4nXG4gIH0pO1xuXG4gIHZhciBEZWZhdWx0VHlwZSQ1ID0gX2V4dGVuZHMoe30sIFRvb2x0aXAuRGVmYXVsdFR5cGUsIHtcbiAgICBjb250ZW50OiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKSdcbiAgfSk7XG5cbiAgdmFyIENMQVNTX05BTUVfRkFERSQzID0gJ2ZhZGUnO1xuICB2YXIgQ0xBU1NfTkFNRV9TSE9XJDUgPSAnc2hvdyc7XG4gIHZhciBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xuICB2YXIgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcbiAgdmFyIEV2ZW50JDEgPSB7XG4gICAgSElERTogXCJoaWRlXCIgKyBFVkVOVF9LRVkkNyxcbiAgICBISURERU46IFwiaGlkZGVuXCIgKyBFVkVOVF9LRVkkNyxcbiAgICBTSE9XOiBcInNob3dcIiArIEVWRU5UX0tFWSQ3LFxuICAgIFNIT1dOOiBcInNob3duXCIgKyBFVkVOVF9LRVkkNyxcbiAgICBJTlNFUlRFRDogXCJpbnNlcnRlZFwiICsgRVZFTlRfS0VZJDcsXG4gICAgQ0xJQ0s6IFwiY2xpY2tcIiArIEVWRU5UX0tFWSQ3LFxuICAgIEZPQ1VTSU46IFwiZm9jdXNpblwiICsgRVZFTlRfS0VZJDcsXG4gICAgRk9DVVNPVVQ6IFwiZm9jdXNvdXRcIiArIEVWRU5UX0tFWSQ3LFxuICAgIE1PVVNFRU5URVI6IFwibW91c2VlbnRlclwiICsgRVZFTlRfS0VZJDcsXG4gICAgTU9VU0VMRUFWRTogXCJtb3VzZWxlYXZlXCIgKyBFVkVOVF9LRVkkN1xuICB9O1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBQb3BvdmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVG9vbHRpcCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFBvcG92ZXIsIF9Ub29sdGlwKTtcblxuICAgIGZ1bmN0aW9uIFBvcG92ZXIoKSB7XG4gICAgICByZXR1cm4gX1Rvb2x0aXAuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBQb3BvdmVyLnByb3RvdHlwZTtcblxuICAgIC8vIE92ZXJyaWRlc1xuICAgIF9wcm90by5pc1dpdGhDb250ZW50ID0gZnVuY3Rpb24gaXNXaXRoQ29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYWRkQXR0YWNobWVudENsYXNzID0gZnVuY3Rpb24gYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmdldFRpcEVsZW1lbnQoKSkuYWRkQ2xhc3MoQ0xBU1NfUFJFRklYJDEgKyBcIi1cIiArIGF0dGFjaG1lbnQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZ2V0VGlwRWxlbWVudCA9IGZ1bmN0aW9uIGdldFRpcEVsZW1lbnQoKSB7XG4gICAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF07XG4gICAgICByZXR1cm4gdGhpcy50aXA7XG4gICAgfTtcblxuICAgIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCgpIHtcbiAgICAgIHZhciAkdGlwID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuZ2V0VGlwRWxlbWVudCgpKTsgLy8gV2UgdXNlIGFwcGVuZCBmb3IgaHRtbCBvYmplY3RzIHRvIG1haW50YWluIGpzIGV2ZW50c1xuXG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTRUxFQ1RPUl9USVRMRSksIHRoaXMuZ2V0VGl0bGUoKSk7XG5cbiAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fZ2V0Q29udGVudCgpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29udGVudCA9IGNvbnRlbnQuY2FsbCh0aGlzLmVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldEVsZW1lbnRDb250ZW50KCR0aXAuZmluZChTRUxFQ1RPUl9DT05URU5UKSwgY29udGVudCk7XG4gICAgICAkdGlwLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfRkFERSQzICsgXCIgXCIgKyBDTEFTU19OQU1FX1NIT1ckNSk7XG4gICAgfSAvLyBQcml2YXRlXG4gICAgO1xuXG4gICAgX3Byb3RvLl9nZXRDb250ZW50ID0gZnVuY3Rpb24gX2dldENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1jb250ZW50JykgfHwgdGhpcy5jb25maWcuY29udGVudDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9jbGVhblRpcENsYXNzID0gZnVuY3Rpb24gX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgICB2YXIgJHRpcCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLmdldFRpcEVsZW1lbnQoKSk7XG4gICAgICB2YXIgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYJDEpO1xuXG4gICAgICBpZiAodGFiQ2xhc3MgIT09IG51bGwgJiYgdGFiQ2xhc3MubGVuZ3RoID4gMCkge1xuICAgICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICB9IC8vIFN0YXRpY1xuICAgIDtcblxuICAgIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcykuZGF0YShEQVRBX0tFWSQ3KTtcblxuICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbDtcblxuICAgICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKS5kYXRhKERBVEFfS0VZJDcsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm8gbWV0aG9kIG5hbWVkIFxcXCJcIiArIGNvbmZpZyArIFwiXFxcIlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9jcmVhdGVDbGFzcyhQb3BvdmVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgIC8vIEdldHRlcnNcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTiQ3O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQkNTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiTkFNRVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBOQU1FJDc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkRBVEFfS0VZXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERBVEFfS0VZJDc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkV2ZW50XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50JDE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIkVWRU5UX0tFWVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBFVkVOVF9LRVkkNztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiRGVmYXVsdFR5cGVcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUG9wb3ZlcjtcbiAgfShUb29sdGlwKTtcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkN10gPSBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2U7XG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDddLkNvbnN0cnVjdG9yID0gUG9wb3ZlcjtcblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ3XS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDddID0gSlFVRVJZX05PX0NPTkZMSUNUJDc7XG4gICAgcmV0dXJuIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUkOCA9ICdzY3JvbGxzcHknO1xuICB2YXIgVkVSU0lPTiQ4ID0gJzQuNi4wJztcbiAgdmFyIERBVEFfS0VZJDggPSAnYnMuc2Nyb2xsc3B5JztcbiAgdmFyIEVWRU5UX0tFWSQ4ID0gXCIuXCIgKyBEQVRBX0tFWSQ4O1xuICB2YXIgREFUQV9BUElfS0VZJDYgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQ4ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkOF07XG4gIHZhciBEZWZhdWx0JDYgPSB7XG4gICAgb2Zmc2V0OiAxMCxcbiAgICBtZXRob2Q6ICdhdXRvJyxcbiAgICB0YXJnZXQ6ICcnXG4gIH07XG4gIHZhciBEZWZhdWx0VHlwZSQ2ID0ge1xuICAgIG9mZnNldDogJ251bWJlcicsXG4gICAgbWV0aG9kOiAnc3RyaW5nJyxcbiAgICB0YXJnZXQ6ICcoc3RyaW5nfGVsZW1lbnQpJ1xuICB9O1xuICB2YXIgRVZFTlRfQUNUSVZBVEUgPSBcImFjdGl2YXRlXCIgKyBFVkVOVF9LRVkkODtcbiAgdmFyIEVWRU5UX1NDUk9MTCA9IFwic2Nyb2xsXCIgKyBFVkVOVF9LRVkkODtcbiAgdmFyIEVWRU5UX0xPQURfREFUQV9BUEkkMiA9IFwibG9hZFwiICsgRVZFTlRfS0VZJDggKyBEQVRBX0FQSV9LRVkkNjtcbiAgdmFyIENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJztcbiAgdmFyIENMQVNTX05BTUVfQUNUSVZFJDIgPSAnYWN0aXZlJztcbiAgdmFyIFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLXNweT1cInNjcm9sbFwiXSc7XG4gIHZhciBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCc7XG4gIHZhciBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJztcbiAgdmFyIFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nO1xuICB2YXIgU0VMRUNUT1JfTElTVF9JVEVNUyA9ICcubGlzdC1ncm91cC1pdGVtJztcbiAgdmFyIFNFTEVDVE9SX0RST1BET1dOID0gJy5kcm9wZG93bic7XG4gIHZhciBTRUxFQ1RPUl9EUk9QRE9XTl9JVEVNUyA9ICcuZHJvcGRvd24taXRlbSc7XG4gIHZhciBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIHZhciBNRVRIT0RfT0ZGU0VUID0gJ29mZnNldCc7XG4gIHZhciBNRVRIT0RfUE9TSVRJT04gPSAncG9zaXRpb24nO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENsYXNzIERlZmluaXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIHZhciBTY3JvbGxTcHkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjcm9sbFNweShlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JPRFknID8gd2luZG93IDogZWxlbWVudDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5fc2VsZWN0b3IgPSB0aGlzLl9jb25maWcudGFyZ2V0ICsgXCIgXCIgKyBTRUxFQ1RPUl9OQVZfTElOS1MgKyBcIixcIiArICh0aGlzLl9jb25maWcudGFyZ2V0ICsgXCIgXCIgKyBTRUxFQ1RPUl9MSVNUX0lURU1TICsgXCIsXCIpICsgKHRoaXMuX2NvbmZpZy50YXJnZXQgKyBcIiBcIiArIFNFTEVDVE9SX0RST1BET1dOX0lURU1TKTtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxIZWlnaHQgPSAwO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX3Njcm9sbEVsZW1lbnQpLm9uKEVWRU5UX1NDUk9MTCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5fcHJvY2VzcyhldmVudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzKCk7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHZhciBfcHJvdG8gPSBTY3JvbGxTcHkucHJvdG90eXBlO1xuXG4gICAgLy8gUHVibGljXG4gICAgX3Byb3RvLnJlZnJlc2ggPSBmdW5jdGlvbiByZWZyZXNoKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBNRVRIT0RfT0ZGU0VUIDogTUVUSE9EX1BPU0lUSU9OO1xuICAgICAgdmFyIG9mZnNldE1ldGhvZCA9IHRoaXMuX2NvbmZpZy5tZXRob2QgPT09ICdhdXRvJyA/IGF1dG9NZXRob2QgOiB0aGlzLl9jb25maWcubWV0aG9kO1xuICAgICAgdmFyIG9mZnNldEJhc2UgPSBvZmZzZXRNZXRob2QgPT09IE1FVEhPRF9QT1NJVElPTiA/IHRoaXMuX2dldFNjcm9sbFRvcCgpIDogMDtcbiAgICAgIHRoaXMuX29mZnNldHMgPSBbXTtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBbXTtcbiAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpO1xuICAgICAgdmFyIHRhcmdldHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKTtcbiAgICAgIHRhcmdldHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciB0YXJnZXQ7XG4gICAgICAgIHZhciB0YXJnZXRTZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0b3IpIHtcbiAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldFNlbGVjdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICB2YXIgdGFyZ2V0QkNSID0gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRhcmdldEJDUi53aWR0aCB8fCB0YXJnZXRCQ1IuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBUT0RPIChmYXQpOiByZW1vdmUgc2tldGNoIHJlbGlhbmNlIG9uIGpRdWVyeSBwb3NpdGlvbi9vZmZzZXRcbiAgICAgICAgICAgIHJldHVybiBbJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRhcmdldClbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsIHRhcmdldFNlbGVjdG9yXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBfdGhpczIuX29mZnNldHMucHVzaChpdGVtWzBdKTtcblxuICAgICAgICBfdGhpczIuX3RhcmdldHMucHVzaChpdGVtWzFdKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10ucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSQ4KTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoRVZFTlRfS0VZJDgpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IG51bGw7XG4gICAgICB0aGlzLl9zZWxlY3RvciA9IG51bGw7XG4gICAgICB0aGlzLl9vZmZzZXRzID0gbnVsbDtcbiAgICAgIHRoaXMuX3RhcmdldHMgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IG51bGw7XG4gICAgfSAvLyBQcml2YXRlXG4gICAgO1xuXG4gICAgX3Byb3RvLl9nZXRDb25maWcgPSBmdW5jdGlvbiBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gX2V4dGVuZHMoe30sIERlZmF1bHQkNiwgdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50YXJnZXQgIT09ICdzdHJpbmcnICYmIFV0aWwuaXNFbGVtZW50KGNvbmZpZy50YXJnZXQpKSB7XG4gICAgICAgIHZhciBpZCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShjb25maWcudGFyZ2V0KS5hdHRyKCdpZCcpO1xuXG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICBpZCA9IFV0aWwuZ2V0VUlEKE5BTUUkOCk7XG4gICAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKGNvbmZpZy50YXJnZXQpLmF0dHIoJ2lkJywgaWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLnRhcmdldCA9IFwiI1wiICsgaWQ7XG4gICAgICB9XG5cbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkOCwgY29uZmlnLCBEZWZhdWx0VHlwZSQ2KTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gX2dldFNjcm9sbFRvcCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBNYXRoLm1heChkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCk7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2V0T2Zmc2V0SGVpZ2h0ID0gZnVuY3Rpb24gX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB3aW5kb3cuaW5uZXJIZWlnaHQgOiB0aGlzLl9zY3JvbGxFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9wcm9jZXNzID0gZnVuY3Rpb24gX3Byb2Nlc3MoKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgKyB0aGlzLl9jb25maWcub2Zmc2V0O1xuXG4gICAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5fZ2V0U2Nyb2xsSGVpZ2h0KCk7XG5cbiAgICAgIHZhciBtYXhTY3JvbGwgPSB0aGlzLl9jb25maWcub2Zmc2V0ICsgc2Nyb2xsSGVpZ2h0IC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XG5cbiAgICAgIGlmICh0aGlzLl9zY3JvbGxIZWlnaHQgIT09IHNjcm9sbEhlaWdodCkge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbFRvcCA+PSBtYXhTY3JvbGwpIHtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMuX3RhcmdldHNbdGhpcy5fdGFyZ2V0cy5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHNjcm9sbFRvcCA8IHRoaXMuX29mZnNldHNbMF0gJiYgdGhpcy5fb2Zmc2V0c1swXSA+IDApIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9jbGVhcigpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMuX29mZnNldHMubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIHZhciBpc0FjdGl2ZVRhcmdldCA9IHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGhpcy5fdGFyZ2V0c1tpXSAmJiBzY3JvbGxUb3AgPj0gdGhpcy5fb2Zmc2V0c1tpXSAmJiAodHlwZW9mIHRoaXMuX29mZnNldHNbaSArIDFdID09PSAndW5kZWZpbmVkJyB8fCBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzW2kgKyAxXSk7XG5cbiAgICAgICAgaWYgKGlzQWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fdGFyZ2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLl9hY3RpdmF0ZSA9IGZ1bmN0aW9uIF9hY3RpdmF0ZSh0YXJnZXQpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcblxuICAgICAgdGhpcy5fY2xlYXIoKTtcblxuICAgICAgdmFyIHF1ZXJpZXMgPSB0aGlzLl9zZWxlY3Rvci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdG9yICsgXCJbZGF0YS10YXJnZXQ9XFxcIlwiICsgdGFyZ2V0ICsgXCJcXFwiXSxcIiArIHNlbGVjdG9yICsgXCJbaHJlZj1cXFwiXCIgKyB0YXJnZXQgKyBcIlxcXCJdXCI7XG4gICAgICB9KTtcblxuICAgICAgdmFyICRsaW5rID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChxdWVyaWVzLmpvaW4oJywnKSkpKTtcblxuICAgICAgaWYgKCRsaW5rLmhhc0NsYXNzKENMQVNTX05BTUVfRFJPUERPV05fSVRFTSkpIHtcbiAgICAgICAgJGxpbmsuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTikuZmluZChTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUpLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgICAkbGluay5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGluayBhcyBhY3RpdmVcbiAgICAgICAgJGxpbmsuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7IC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcbiAgICAgICAgLy8gV2l0aCBib3RoIDx1bD4gYW5kIDxuYXY+IG1hcmt1cCBhIHBhcmVudCBpcyB0aGUgcHJldmlvdXMgc2libGluZyBvZiBhbnkgbmF2IGFuY2VzdG9yXG5cbiAgICAgICAgJGxpbmsucGFyZW50cyhTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkucHJldihTRUxFQ1RPUl9OQVZfTElOS1MgKyBcIiwgXCIgKyBTRUxFQ1RPUl9MSVNUX0lURU1TKS5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSQyKTsgLy8gSGFuZGxlIHNwZWNpYWwgY2FzZSB3aGVuIC5uYXYtbGluayBpcyBpbnNpZGUgLm5hdi1pdGVtXG5cbiAgICAgICAgJGxpbmsucGFyZW50cyhTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCkucHJldihTRUxFQ1RPUl9OQVZfSVRFTVMpLmNoaWxkcmVuKFNFTEVDVE9SX05BVl9MSU5LUykuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICB9XG5cbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9zY3JvbGxFbGVtZW50KS50cmlnZ2VyKEVWRU5UX0FDVElWQVRFLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fY2xlYXIgPSBmdW5jdGlvbiBfY2xlYXIoKSB7XG4gICAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKS5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIpO1xuICAgICAgfSk7XG4gICAgfSAvLyBTdGF0aWNcbiAgICA7XG5cbiAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcykuZGF0YShEQVRBX0tFWSQ4KTtcblxuICAgICAgICB2YXIgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZztcblxuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICBkYXRhID0gbmV3IFNjcm9sbFNweSh0aGlzLCBfY29uZmlnKTtcbiAgICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcykuZGF0YShEQVRBX0tFWSQ4LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoU2Nyb2xsU3B5LCBudWxsLCBbe1xuICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTiQ4O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQkNjtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU2Nyb2xsU3B5O1xuICB9KCk7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogRGF0YSBBcGkgaW1wbGVtZW50YXRpb25cbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHdpbmRvdykub24oRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNjcm9sbFNweXMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfREFUQV9TUFkpKTtcbiAgICB2YXIgc2Nyb2xsU3B5c0xlbmd0aCA9IHNjcm9sbFNweXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IHNjcm9sbFNweXNMZW5ndGg7IGktLTspIHtcbiAgICAgIHZhciAkc3B5ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHNjcm9sbFNweXNbaV0pO1xuXG4gICAgICBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRzcHksICRzcHkuZGF0YSgpKTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIGpRdWVyeVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkOF0gPSBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZTtcbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkOF0uQ29uc3RydWN0b3IgPSBTY3JvbGxTcHk7XG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkOF0ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ4XSA9IEpRVUVSWV9OT19DT05GTElDVCQ4O1xuICAgIHJldHVybiBTY3JvbGxTcHkuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIENvbnN0YW50c1xuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgdmFyIE5BTUUkOSA9ICd0YWInO1xuICB2YXIgVkVSU0lPTiQ5ID0gJzQuNi4wJztcbiAgdmFyIERBVEFfS0VZJDkgPSAnYnMudGFiJztcbiAgdmFyIEVWRU5UX0tFWSQ5ID0gXCIuXCIgKyBEQVRBX0tFWSQ5O1xuICB2YXIgREFUQV9BUElfS0VZJDcgPSAnLmRhdGEtYXBpJztcbiAgdmFyIEpRVUVSWV9OT19DT05GTElDVCQ5ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkOV07XG4gIHZhciBFVkVOVF9ISURFJDMgPSBcImhpZGVcIiArIEVWRU5UX0tFWSQ5O1xuICB2YXIgRVZFTlRfSElEREVOJDMgPSBcImhpZGRlblwiICsgRVZFTlRfS0VZJDk7XG4gIHZhciBFVkVOVF9TSE9XJDMgPSBcInNob3dcIiArIEVWRU5UX0tFWSQ5O1xuICB2YXIgRVZFTlRfU0hPV04kMyA9IFwic2hvd25cIiArIEVWRU5UX0tFWSQ5O1xuICB2YXIgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IFwiY2xpY2tcIiArIEVWRU5UX0tFWSQ5ICsgREFUQV9BUElfS0VZJDc7XG4gIHZhciBDTEFTU19OQU1FX0RST1BET1dOX01FTlUgPSAnZHJvcGRvd24tbWVudSc7XG4gIHZhciBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XG4gIHZhciBDTEFTU19OQU1FX0RJU0FCTEVEJDEgPSAnZGlzYWJsZWQnO1xuICB2YXIgQ0xBU1NfTkFNRV9GQURFJDQgPSAnZmFkZSc7XG4gIHZhciBDTEFTU19OQU1FX1NIT1ckNiA9ICdzaG93JztcbiAgdmFyIFNFTEVDVE9SX0RST1BET1dOJDEgPSAnLmRyb3Bkb3duJztcbiAgdmFyIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQJDEgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xuICB2YXIgU0VMRUNUT1JfQUNUSVZFJDIgPSAnLmFjdGl2ZSc7XG4gIHZhciBTRUxFQ1RPUl9BQ1RJVkVfVUwgPSAnPiBsaSA+IC5hY3RpdmUnO1xuICB2YXIgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLXRvZ2dsZT1cImxpc3RcIl0nO1xuICB2YXIgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XG4gIHZhciBTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQgPSAnPiAuZHJvcGRvd24tbWVudSAuYWN0aXZlJztcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgVGFiID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWIoZWxlbWVudCkge1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgfSAvLyBHZXR0ZXJzXG5cblxuICAgIHZhciBfcHJvdG8gPSBUYWIucHJvdG90eXBlO1xuXG4gICAgLy8gUHVibGljXG4gICAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSAmJiB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0FDVElWRSQzKSB8fCAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9ESVNBQkxFRCQxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB2YXIgcHJldmlvdXM7XG4gICAgICB2YXIgbGlzdEVsZW1lbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkuY2xvc2VzdChTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCQxKVswXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcblxuICAgICAgaWYgKGxpc3RFbGVtZW50KSB7XG4gICAgICAgIHZhciBpdGVtU2VsZWN0b3IgPSBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ1VMJyB8fCBsaXN0RWxlbWVudC5ub2RlTmFtZSA9PT0gJ09MJyA/IFNFTEVDVE9SX0FDVElWRV9VTCA6IFNFTEVDVE9SX0FDVElWRSQyO1xuICAgICAgICBwcmV2aW91cyA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5tYWtlQXJyYXkoJF9fZGVmYXVsdFsnZGVmYXVsdCddKGxpc3RFbGVtZW50KS5maW5kKGl0ZW1TZWxlY3RvcikpO1xuICAgICAgICBwcmV2aW91cyA9IHByZXZpb3VzW3ByZXZpb3VzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGlkZUV2ZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX0hJREUkMywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcbiAgICAgIHZhciBzaG93RXZlbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfU0hPVyQzLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHByZXZpb3VzXG4gICAgICB9KTtcblxuICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShwcmV2aW91cykudHJpZ2dlcihoaWRlRXZlbnQpO1xuICAgICAgfVxuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpO1xuXG4gICAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWN0aXZhdGUodGhpcy5fZWxlbWVudCwgbGlzdEVsZW1lbnQpO1xuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgdmFyIGhpZGRlbkV2ZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX0hJRERFTiQzLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogX3RoaXMuX2VsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzaG93bkV2ZW50ID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddLkV2ZW50KEVWRU5UX1NIT1dOJDMsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgICAgICB9KTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKF90aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICB0aGlzLl9hY3RpdmF0ZSh0YXJnZXQsIHRhcmdldC5wYXJlbnROb2RlLCBjb21wbGV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10ucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSQ5KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICAgIH0gLy8gUHJpdmF0ZVxuICAgIDtcblxuICAgIF9wcm90by5fYWN0aXZhdGUgPSBmdW5jdGlvbiBfYWN0aXZhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBhY3RpdmVFbGVtZW50cyA9IGNvbnRhaW5lciAmJiAoY29udGFpbmVyLm5vZGVOYW1lID09PSAnVUwnIHx8IGNvbnRhaW5lci5ub2RlTmFtZSA9PT0gJ09MJykgPyAkX19kZWZhdWx0WydkZWZhdWx0J10oY29udGFpbmVyKS5maW5kKFNFTEVDVE9SX0FDVElWRV9VTCkgOiAkX19kZWZhdWx0WydkZWZhdWx0J10oY29udGFpbmVyKS5jaGlsZHJlbihTRUxFQ1RPUl9BQ1RJVkUkMik7XG4gICAgICB2YXIgYWN0aXZlID0gYWN0aXZlRWxlbWVudHNbMF07XG4gICAgICB2YXIgaXNUcmFuc2l0aW9uaW5nID0gY2FsbGJhY2sgJiYgYWN0aXZlICYmICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShhY3RpdmUpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSQ0KTtcblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGNhbGxiYWNrKTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChhY3RpdmUgJiYgaXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZSk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShhY3RpdmUpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVyQ2KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uX3RyYW5zaXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uIF90cmFuc2l0aW9uQ29tcGxldGUoZWxlbWVudCwgYWN0aXZlLCBjYWxsYmFjaykge1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oYWN0aXZlKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSQzKTtcbiAgICAgICAgdmFyIGRyb3Bkb3duQ2hpbGQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10oYWN0aXZlLnBhcmVudE5vZGUpLmZpbmQoU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEKVswXTtcblxuICAgICAgICBpZiAoZHJvcGRvd25DaGlsZCkge1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShkcm9wZG93bkNoaWxkKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0FDVElWRSQzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3RpdmUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICAgICAgYWN0aXZlLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oZWxlbWVudCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUkMyk7XG5cbiAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAndGFiJykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBVdGlsLnJlZmxvdyhlbGVtZW50KTtcblxuICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQ0KSkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudC5wYXJlbnROb2RlICYmICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50LnBhcmVudE5vZGUpLmhhc0NsYXNzKENMQVNTX05BTUVfRFJPUERPV05fTUVOVSkpIHtcbiAgICAgICAgdmFyIGRyb3Bkb3duRWxlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShlbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOJDEpWzBdO1xuXG4gICAgICAgIGlmIChkcm9wZG93bkVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgZHJvcGRvd25Ub2dnbGVMaXN0ID0gW10uc2xpY2UuY2FsbChkcm9wZG93bkVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSkpO1xuICAgICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShkcm9wZG93blRvZ2dsZUxpc3QpLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFJDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBTdGF0aWNcbiAgICA7XG5cbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZSA9IGZ1bmN0aW9uIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyICR0aGlzID0gJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMpO1xuICAgICAgICB2YXIgZGF0YSA9ICR0aGlzLmRhdGEoREFUQV9LRVkkOSk7XG5cbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBUYWIodGhpcyk7XG4gICAgICAgICAgJHRoaXMuZGF0YShEQVRBX0tFWSQ5LCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGFiLCBudWxsLCBbe1xuICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTiQ5O1xuICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBUYWI7XG4gIH0oKTtcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBEYXRhIEFwaSBpbXBsZW1lbnRhdGlvblxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10oZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJJDYsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZS5jYWxsKCRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKSwgJ3Nob3cnKTtcbiAgfSk7XG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogalF1ZXJ5XG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ5XSA9IFRhYi5falF1ZXJ5SW50ZXJmYWNlO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ5XS5Db25zdHJ1Y3RvciA9IFRhYjtcblxuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSQ5XS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJDldID0gSlFVRVJZX05PX0NPTkZMSUNUJDk7XG4gICAgcmV0dXJuIFRhYi5falF1ZXJ5SW50ZXJmYWNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQ29uc3RhbnRzXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgTkFNRSRhID0gJ3RvYXN0JztcbiAgdmFyIFZFUlNJT04kYSA9ICc0LjYuMCc7XG4gIHZhciBEQVRBX0tFWSRhID0gJ2JzLnRvYXN0JztcbiAgdmFyIEVWRU5UX0tFWSRhID0gXCIuXCIgKyBEQVRBX0tFWSRhO1xuICB2YXIgSlFVRVJZX05PX0NPTkZMSUNUJGEgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSRhXTtcbiAgdmFyIEVWRU5UX0NMSUNLX0RJU01JU1MkMSA9IFwiY2xpY2suZGlzbWlzc1wiICsgRVZFTlRfS0VZJGE7XG4gIHZhciBFVkVOVF9ISURFJDQgPSBcImhpZGVcIiArIEVWRU5UX0tFWSRhO1xuICB2YXIgRVZFTlRfSElEREVOJDQgPSBcImhpZGRlblwiICsgRVZFTlRfS0VZJGE7XG4gIHZhciBFVkVOVF9TSE9XJDQgPSBcInNob3dcIiArIEVWRU5UX0tFWSRhO1xuICB2YXIgRVZFTlRfU0hPV04kNCA9IFwic2hvd25cIiArIEVWRU5UX0tFWSRhO1xuICB2YXIgQ0xBU1NfTkFNRV9GQURFJDUgPSAnZmFkZSc7XG4gIHZhciBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7XG4gIHZhciBDTEFTU19OQU1FX1NIT1ckNyA9ICdzaG93JztcbiAgdmFyIENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcbiAgdmFyIERlZmF1bHRUeXBlJDcgPSB7XG4gICAgYW5pbWF0aW9uOiAnYm9vbGVhbicsXG4gICAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgICBkZWxheTogJ251bWJlcidcbiAgfTtcbiAgdmFyIERlZmF1bHQkNyA9IHtcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgYXV0b2hpZGU6IHRydWUsXG4gICAgZGVsYXk6IDUwMFxuICB9O1xuICB2YXIgU0VMRUNUT1JfREFUQV9ESVNNSVNTJDEgPSAnW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJztcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBDbGFzcyBEZWZpbml0aW9uXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICB2YXIgVG9hc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRvYXN0KGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICB9IC8vIEdldHRlcnNcblxuXG4gICAgdmFyIF9wcm90byA9IFRvYXN0LnByb3RvdHlwZTtcblxuICAgIC8vIFB1YmxpY1xuICAgIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzaG93RXZlbnQgPSAkX19kZWZhdWx0WydkZWZhdWx0J10uRXZlbnQoRVZFTlRfU0hPVyQ0KTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3dFdmVudCk7XG5cbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSQ1KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBsZXRlID0gZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIF90aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HKTtcblxuICAgICAgICBfdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ3KTtcblxuICAgICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10oX3RoaXMuX2VsZW1lbnQpLnRyaWdnZXIoRVZFTlRfU0hPV04kNCk7XG5cbiAgICAgICAgaWYgKF90aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcbiAgICAgICAgICBfdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaGlkZSgpO1xuICAgICAgICAgIH0sIF90aGlzLl9jb25maWcuZGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKTtcblxuICAgICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudCk7XG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xuXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSkuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhpZGVFdmVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5FdmVudChFVkVOVF9ISURFJDQpO1xuICAgICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KTtcblxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfTtcblxuICAgIF9wcm90by5kaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNyk7XG4gICAgICB9XG5cbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfQ0xJQ0tfRElTTUlTUyQxKTtcbiAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZJGEpO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9jb25maWcgPSBudWxsO1xuICAgIH0gLy8gUHJpdmF0ZVxuICAgIDtcblxuICAgIF9wcm90by5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IF9leHRlbmRzKHt9LCBEZWZhdWx0JDcsICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5kYXRhKCksIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KTtcbiAgICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUkYSwgY29uZmlnLCB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfTtcblxuICAgIF9wcm90by5fc2V0TGlzdGVuZXJzID0gZnVuY3Rpb24gX3NldExpc3RlbmVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAkX19kZWZhdWx0WydkZWZhdWx0J10odGhpcy5fZWxlbWVudCkub24oRVZFTlRfQ0xJQ0tfRElTTUlTUyQxLCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2Nsb3NlID0gZnVuY3Rpb24gX2Nsb3NlKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBfdGhpczMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpO1xuXG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXShfdGhpczMuX2VsZW1lbnQpLnRyaWdnZXIoRVZFTlRfSElEREVOJDQpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ3KTtcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudCk7XG4gICAgICAgICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzLl9lbGVtZW50KS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uX2NsZWFyVGltZW91dCA9IGZ1bmN0aW9uIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICB9IC8vIFN0YXRpY1xuICAgIDtcblxuICAgIFRvYXN0Ll9qUXVlcnlJbnRlcmZhY2UgPSBmdW5jdGlvbiBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciAkZWxlbWVudCA9ICRfX2RlZmF1bHRbJ2RlZmF1bHQnXSh0aGlzKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZJGEpO1xuXG4gICAgICAgIHZhciBfY29uZmlnID0gdHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnO1xuXG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgIGRhdGEgPSBuZXcgVG9hc3QodGhpcywgX2NvbmZpZyk7XG4gICAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSRhLCBkYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk5vIG1ldGhvZCBuYW1lZCBcXFwiXCIgKyBjb25maWcgKyBcIlxcXCJcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGF0YVtjb25maWddKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKFRvYXN0LCBudWxsLCBbe1xuICAgICAga2V5OiBcIlZFUlNJT05cIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTiRhO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0VHlwZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ3O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJEZWZhdWx0XCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIERlZmF1bHQkNztcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVG9hc3Q7XG4gIH0oKTtcbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBqUXVlcnlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkYV0gPSBUb2FzdC5falF1ZXJ5SW50ZXJmYWNlO1xuICAkX19kZWZhdWx0WydkZWZhdWx0J10uZm5bTkFNRSRhXS5Db25zdHJ1Y3RvciA9IFRvYXN0O1xuXG4gICRfX2RlZmF1bHRbJ2RlZmF1bHQnXS5mbltOQU1FJGFdLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgJF9fZGVmYXVsdFsnZGVmYXVsdCddLmZuW05BTUUkYV0gPSBKUVVFUllfTk9fQ09ORkxJQ1QkYTtcbiAgICByZXR1cm4gVG9hc3QuX2pRdWVyeUludGVyZmFjZTtcbiAgfTtcblxuICBleHBvcnRzLkFsZXJ0ID0gQWxlcnQ7XG4gIGV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xuICBleHBvcnRzLkNhcm91c2VsID0gQ2Fyb3VzZWw7XG4gIGV4cG9ydHMuQ29sbGFwc2UgPSBDb2xsYXBzZTtcbiAgZXhwb3J0cy5Ecm9wZG93biA9IERyb3Bkb3duO1xuICBleHBvcnRzLk1vZGFsID0gTW9kYWw7XG4gIGV4cG9ydHMuUG9wb3ZlciA9IFBvcG92ZXI7XG4gIGV4cG9ydHMuU2Nyb2xsc3B5ID0gU2Nyb2xsU3B5O1xuICBleHBvcnRzLlRhYiA9IFRhYjtcbiAgZXhwb3J0cy5Ub2FzdCA9IFRvYXN0O1xuICBleHBvcnRzLlRvb2x0aXAgPSBUb29sdGlwO1xuICBleHBvcnRzLlV0aWwgPSBVdGlsO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/bootstrap/dist/js/bootstrap.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js":
/*!*********************************************************************!*\
  !*** ./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables Bootstrap 4 integration\n * 2011-2017 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * DataTables integration for Bootstrap 4. This requires Bootstrap 4 and\n * DataTables 1.10 or newer.\n *\n * This file sets the defaults and adds options to DataTables to style its\n * controls using Bootstrap. See http://datatables.net/manual/styling/bootstrap\n * for further information.\n */\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! datatables.net */ \"./node_modules/datatables.net/js/jquery.dataTables.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n/* Set the defaults for DataTables initialisation */\n$.extend( true, DataTable.defaults, {\n\tdom:\n\t\t\"<'row'<'col-sm-12 col-md-6'l><'col-sm-12 col-md-6'f>>\" +\n\t\t\"<'row'<'col-sm-12'tr>>\" +\n\t\t\"<'row'<'col-sm-12 col-md-5'i><'col-sm-12 col-md-7'p>>\",\n\trenderer: 'bootstrap'\n} );\n\n\n/* Default class modification */\n$.extend( DataTable.ext.classes, {\n\tsWrapper:      \"dataTables_wrapper dt-bootstrap4\",\n\tsFilterInput:  \"form-control form-control-sm\",\n\tsLengthSelect: \"custom-select custom-select-sm form-control form-control-sm\",\n\tsProcessing:   \"dataTables_processing card\",\n\tsPageButton:   \"paginate_button page-item\"\n} );\n\n\n/* Bootstrap paging button renderer */\nDataTable.ext.renderer.pageButton.bootstrap = function ( settings, host, idx, buttons, page, pages ) {\n\tvar api     = new DataTable.Api( settings );\n\tvar classes = settings.oClasses;\n\tvar lang    = settings.oLanguage.oPaginate;\n\tvar aria = settings.oLanguage.oAria.paginate || {};\n\tvar btnDisplay, btnClass, counter=0;\n\n\tvar attach = function( container, buttons ) {\n\t\tvar i, ien, node, button;\n\t\tvar clickHandler = function ( e ) {\n\t\t\te.preventDefault();\n\t\t\tif ( !$(e.currentTarget).hasClass('disabled') && api.page() != e.data.action ) {\n\t\t\t\tapi.page( e.data.action ).draw( 'page' );\n\t\t\t}\n\t\t};\n\n\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tbutton = buttons[i];\n\n\t\t\tif ( Array.isArray( button ) ) {\n\t\t\t\tattach( container, button );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbtnDisplay = '';\n\t\t\t\tbtnClass = '';\n\n\t\t\t\tswitch ( button ) {\n\t\t\t\t\tcase 'ellipsis':\n\t\t\t\t\t\tbtnDisplay = '&#x2026;';\n\t\t\t\t\t\tbtnClass = 'disabled';\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'first':\n\t\t\t\t\t\tbtnDisplay = lang.sFirst;\n\t\t\t\t\t\tbtnClass = button + (page > 0 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'previous':\n\t\t\t\t\t\tbtnDisplay = lang.sPrevious;\n\t\t\t\t\t\tbtnClass = button + (page > 0 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'next':\n\t\t\t\t\t\tbtnDisplay = lang.sNext;\n\t\t\t\t\t\tbtnClass = button + (page < pages-1 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'last':\n\t\t\t\t\t\tbtnDisplay = lang.sLast;\n\t\t\t\t\t\tbtnClass = button + (page < pages-1 ?\n\t\t\t\t\t\t\t'' : ' disabled');\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbtnDisplay = button + 1;\n\t\t\t\t\t\tbtnClass = page === button ?\n\t\t\t\t\t\t\t'active' : '';\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif ( btnDisplay ) {\n\t\t\t\t\tnode = $('<li>', {\n\t\t\t\t\t\t\t'class': classes.sPageButton+' '+btnClass,\n\t\t\t\t\t\t\t'id': idx === 0 && typeof button === 'string' ?\n\t\t\t\t\t\t\t\tsettings.sTableId +'_'+ button :\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t} )\n\t\t\t\t\t\t.append( $('<a>', {\n\t\t\t\t\t\t\t\t'href': '#',\n\t\t\t\t\t\t\t\t'aria-controls': settings.sTableId,\n\t\t\t\t\t\t\t\t'aria-label': aria[ button ],\n\t\t\t\t\t\t\t\t'data-dt-idx': counter,\n\t\t\t\t\t\t\t\t'tabindex': settings.iTabIndex,\n\t\t\t\t\t\t\t\t'class': 'page-link'\n\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t.html( btnDisplay )\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.appendTo( container );\n\n\t\t\t\t\tsettings.oApi._fnBindAction(\n\t\t\t\t\t\tnode, {action: button}, clickHandler\n\t\t\t\t\t);\n\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// IE9 throws an 'unknown error' if document.activeElement is used\n\t// inside an iframe or frame. \n\tvar activeEl;\n\n\ttry {\n\t\t// Because this approach is destroying and recreating the paging\n\t\t// elements, focus is lost on the select button which is bad for\n\t\t// accessibility. So we want to restore focus once the draw has\n\t\t// completed\n\t\tactiveEl = $(host).find(document.activeElement).data('dt-idx');\n\t}\n\tcatch (e) {}\n\n\tattach(\n\t\t$(host).empty().html('<ul class=\"pagination\"/>').children('ul'),\n\t\tbuttons\n\t);\n\n\tif ( activeEl !== undefined ) {\n\t\t$(host).find( '[data-dt-idx='+activeEl+']' ).trigger('focus');\n\t}\n};\n\n\nreturn DataTable;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnM0L2pzL2RhdGFUYWJsZXMuYm9vdHN0cmFwNC5qcz83YjUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsa0dBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFvQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLFFBQVE7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1iczQvanMvZGF0YVRhYmxlcy5ib290c3RyYXA0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIERhdGFUYWJsZXMgQm9vdHN0cmFwIDQgaW50ZWdyYXRpb25cbiAqIMKpMjAxMS0yMDE3IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuLyoqXG4gKiBEYXRhVGFibGVzIGludGVncmF0aW9uIGZvciBCb290c3RyYXAgNC4gVGhpcyByZXF1aXJlcyBCb290c3RyYXAgNCBhbmRcbiAqIERhdGFUYWJsZXMgMS4xMCBvciBuZXdlci5cbiAqXG4gKiBUaGlzIGZpbGUgc2V0cyB0aGUgZGVmYXVsdHMgYW5kIGFkZHMgb3B0aW9ucyB0byBEYXRhVGFibGVzIHRvIHN0eWxlIGl0c1xuICogY29udHJvbHMgdXNpbmcgQm9vdHN0cmFwLiBTZWUgaHR0cDovL2RhdGF0YWJsZXMubmV0L21hbnVhbC9zdHlsaW5nL2Jvb3RzdHJhcFxuICogZm9yIGZ1cnRoZXIgaW5mb3JtYXRpb24uXG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApe1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0J10sIGZ1bmN0aW9uICggJCApIHtcblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdFx0fSApO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG5cdFx0XHRpZiAoICEgcm9vdCApIHtcblx0XHRcdFx0cm9vdCA9IHdpbmRvdztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhICQgfHwgISAkLmZuLmRhdGFUYWJsZSApIHtcblx0XHRcdFx0Ly8gUmVxdWlyZSBEYXRhVGFibGVzLCB3aGljaCBhdHRhY2hlcyB0byBqUXVlcnksIGluY2x1ZGluZ1xuXHRcdFx0XHQvLyBqUXVlcnkgaWYgbmVlZGVkIGFuZCBoYXZlIGEgJCBwcm9wZXJ0eSBzbyB3ZSBjYW4gYWNjZXNzIHRoZVxuXHRcdFx0XHQvLyBqUXVlcnkgb2JqZWN0IHRoYXQgaXMgdXNlZFxuXHRcdFx0XHQkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQnKShyb290LCAkKS4kO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG4ndXNlIHN0cmljdCc7XG52YXIgRGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XG5cblxuLyogU2V0IHRoZSBkZWZhdWx0cyBmb3IgRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiAqL1xuJC5leHRlbmQoIHRydWUsIERhdGFUYWJsZS5kZWZhdWx0cywge1xuXHRkb206XG5cdFx0XCI8J3Jvdyc8J2NvbC1zbS0xMiBjb2wtbWQtNidsPjwnY29sLXNtLTEyIGNvbC1tZC02J2Y+PlwiICtcblx0XHRcIjwncm93JzwnY29sLXNtLTEyJ3RyPj5cIiArXG5cdFx0XCI8J3Jvdyc8J2NvbC1zbS0xMiBjb2wtbWQtNSdpPjwnY29sLXNtLTEyIGNvbC1tZC03J3A+PlwiLFxuXHRyZW5kZXJlcjogJ2Jvb3RzdHJhcCdcbn0gKTtcblxuXG4vKiBEZWZhdWx0IGNsYXNzIG1vZGlmaWNhdGlvbiAqL1xuJC5leHRlbmQoIERhdGFUYWJsZS5leHQuY2xhc3Nlcywge1xuXHRzV3JhcHBlcjogICAgICBcImRhdGFUYWJsZXNfd3JhcHBlciBkdC1ib290c3RyYXA0XCIsXG5cdHNGaWx0ZXJJbnB1dDogIFwiZm9ybS1jb250cm9sIGZvcm0tY29udHJvbC1zbVwiLFxuXHRzTGVuZ3RoU2VsZWN0OiBcImN1c3RvbS1zZWxlY3QgY3VzdG9tLXNlbGVjdC1zbSBmb3JtLWNvbnRyb2wgZm9ybS1jb250cm9sLXNtXCIsXG5cdHNQcm9jZXNzaW5nOiAgIFwiZGF0YVRhYmxlc19wcm9jZXNzaW5nIGNhcmRcIixcblx0c1BhZ2VCdXR0b246ICAgXCJwYWdpbmF0ZV9idXR0b24gcGFnZS1pdGVtXCJcbn0gKTtcblxuXG4vKiBCb290c3RyYXAgcGFnaW5nIGJ1dHRvbiByZW5kZXJlciAqL1xuRGF0YVRhYmxlLmV4dC5yZW5kZXJlci5wYWdlQnV0dG9uLmJvb3RzdHJhcCA9IGZ1bmN0aW9uICggc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMgKSB7XG5cdHZhciBhcGkgICAgID0gbmV3IERhdGFUYWJsZS5BcGkoIHNldHRpbmdzICk7XG5cdHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG5cdHZhciBsYW5nICAgID0gc2V0dGluZ3Mub0xhbmd1YWdlLm9QYWdpbmF0ZTtcblx0dmFyIGFyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWEucGFnaW5hdGUgfHwge307XG5cdHZhciBidG5EaXNwbGF5LCBidG5DbGFzcywgY291bnRlcj0wO1xuXG5cdHZhciBhdHRhY2ggPSBmdW5jdGlvbiggY29udGFpbmVyLCBidXR0b25zICkge1xuXHRcdHZhciBpLCBpZW4sIG5vZGUsIGJ1dHRvbjtcblx0XHR2YXIgY2xpY2tIYW5kbGVyID0gZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0aWYgKCAhJChlLmN1cnJlbnRUYXJnZXQpLmhhc0NsYXNzKCdkaXNhYmxlZCcpICYmIGFwaS5wYWdlKCkgIT0gZS5kYXRhLmFjdGlvbiApIHtcblx0XHRcdFx0YXBpLnBhZ2UoIGUuZGF0YS5hY3Rpb24gKS5kcmF3KCAncGFnZScgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0Zm9yICggaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggYnV0dG9uICkgKSB7XG5cdFx0XHRcdGF0dGFjaCggY29udGFpbmVyLCBidXR0b24gKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRidG5EaXNwbGF5ID0gJyc7XG5cdFx0XHRcdGJ0bkNsYXNzID0gJyc7XG5cblx0XHRcdFx0c3dpdGNoICggYnV0dG9uICkge1xuXHRcdFx0XHRcdGNhc2UgJ2VsbGlwc2lzJzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSAnJiN4MjAyNjsnO1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSAnZGlzYWJsZWQnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdmaXJzdCc6XG5cdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zRmlyc3Q7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XG5cdFx0XHRcdFx0XHRcdCcnIDogJyBkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICdwcmV2aW91cyc6XG5cdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zUHJldmlvdXM7XG5cdFx0XHRcdFx0XHRidG5DbGFzcyA9IGJ1dHRvbiArIChwYWdlID4gMCA/XG5cdFx0XHRcdFx0XHRcdCcnIDogJyBkaXNhYmxlZCcpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0XHRjYXNlICduZXh0Jzpcblx0XHRcdFx0XHRcdGJ0bkRpc3BsYXkgPSBsYW5nLnNOZXh0O1xuXHRcdFx0XHRcdFx0YnRuQ2xhc3MgPSBidXR0b24gKyAocGFnZSA8IHBhZ2VzLTEgP1xuXHRcdFx0XHRcdFx0XHQnJyA6ICcgZGlzYWJsZWQnKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0Y2FzZSAnbGFzdCc6XG5cdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gbGFuZy5zTGFzdDtcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gYnV0dG9uICsgKHBhZ2UgPCBwYWdlcy0xID9cblx0XHRcdFx0XHRcdFx0JycgOiAnIGRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRidG5EaXNwbGF5ID0gYnV0dG9uICsgMTtcblx0XHRcdFx0XHRcdGJ0bkNsYXNzID0gcGFnZSA9PT0gYnV0dG9uID9cblx0XHRcdFx0XHRcdFx0J2FjdGl2ZScgOiAnJztcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBidG5EaXNwbGF5ICkge1xuXHRcdFx0XHRcdG5vZGUgPSAkKCc8bGk+Jywge1xuXHRcdFx0XHRcdFx0XHQnY2xhc3MnOiBjbGFzc2VzLnNQYWdlQnV0dG9uKycgJytidG5DbGFzcyxcblx0XHRcdFx0XHRcdFx0J2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cblx0XHRcdFx0XHRcdFx0XHRzZXR0aW5ncy5zVGFibGVJZCArJ18nKyBidXR0b24gOlxuXHRcdFx0XHRcdFx0XHRcdG51bGxcblx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0LmFwcGVuZCggJCgnPGE+Jywge1xuXHRcdFx0XHRcdFx0XHRcdCdocmVmJzogJyMnLFxuXHRcdFx0XHRcdFx0XHRcdCdhcmlhLWNvbnRyb2xzJzogc2V0dGluZ3Muc1RhYmxlSWQsXG5cdFx0XHRcdFx0XHRcdFx0J2FyaWEtbGFiZWwnOiBhcmlhWyBidXR0b24gXSxcblx0XHRcdFx0XHRcdFx0XHQnZGF0YS1kdC1pZHgnOiBjb3VudGVyLFxuXHRcdFx0XHRcdFx0XHRcdCd0YWJpbmRleCc6IHNldHRpbmdzLmlUYWJJbmRleCxcblx0XHRcdFx0XHRcdFx0XHQnY2xhc3MnOiAncGFnZS1saW5rJ1xuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdFx0Lmh0bWwoIGJ0bkRpc3BsYXkgKVxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0LmFwcGVuZFRvKCBjb250YWluZXIgKTtcblxuXHRcdFx0XHRcdHNldHRpbmdzLm9BcGkuX2ZuQmluZEFjdGlvbihcblx0XHRcdFx0XHRcdG5vZGUsIHthY3Rpb246IGJ1dHRvbn0sIGNsaWNrSGFuZGxlclxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRjb3VudGVyKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Ly8gSUU5IHRocm93cyBhbiAndW5rbm93biBlcnJvcicgaWYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpcyB1c2VkXG5cdC8vIGluc2lkZSBhbiBpZnJhbWUgb3IgZnJhbWUuIFxuXHR2YXIgYWN0aXZlRWw7XG5cblx0dHJ5IHtcblx0XHQvLyBCZWNhdXNlIHRoaXMgYXBwcm9hY2ggaXMgZGVzdHJveWluZyBhbmQgcmVjcmVhdGluZyB0aGUgcGFnaW5nXG5cdFx0Ly8gZWxlbWVudHMsIGZvY3VzIGlzIGxvc3Qgb24gdGhlIHNlbGVjdCBidXR0b24gd2hpY2ggaXMgYmFkIGZvclxuXHRcdC8vIGFjY2Vzc2liaWxpdHkuIFNvIHdlIHdhbnQgdG8gcmVzdG9yZSBmb2N1cyBvbmNlIHRoZSBkcmF3IGhhc1xuXHRcdC8vIGNvbXBsZXRlZFxuXHRcdGFjdGl2ZUVsID0gJChob3N0KS5maW5kKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmRhdGEoJ2R0LWlkeCcpO1xuXHR9XG5cdGNhdGNoIChlKSB7fVxuXG5cdGF0dGFjaChcblx0XHQkKGhvc3QpLmVtcHR5KCkuaHRtbCgnPHVsIGNsYXNzPVwicGFnaW5hdGlvblwiLz4nKS5jaGlsZHJlbigndWwnKSxcblx0XHRidXR0b25zXG5cdCk7XG5cblx0aWYgKCBhY3RpdmVFbCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdCQoaG9zdCkuZmluZCggJ1tkYXRhLWR0LWlkeD0nK2FjdGl2ZUVsKyddJyApLnRyaWdnZXIoJ2ZvY3VzJyk7XG5cdH1cbn07XG5cblxucmV0dXJuIERhdGFUYWJsZTtcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-buttons-bs4/js/buttons.bootstrap4.js":
/*!**************************************************************************!*\
  !*** ./node_modules/datatables.net-buttons-bs4/js/buttons.bootstrap4.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Bootstrap integration for DataTables' Buttons\n * 2016 SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! datatables.net-bs4 */ \"./node_modules/datatables.net-bs4/js/dataTables.bootstrap4.js\"), __webpack_require__(/*! datatables.net-buttons */ \"./node_modules/datatables.net-buttons/js/dataTables.buttons.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n$.extend( true, DataTable.Buttons.defaults, {\n\tdom: {\n\t\tcontainer: {\n\t\t\tclassName: 'dt-buttons btn-group flex-wrap'\n\t\t},\n\t\tbutton: {\n\t\t\tclassName: 'btn btn-secondary'\n\t\t},\n\t\tcollection: {\n\t\t\ttag: 'div',\n\t\t\tclassName: 'dropdown-menu',\n\t\t\tbutton: {\n\t\t\t\ttag: 'a',\n\t\t\t\tclassName: 'dt-button dropdown-item',\n\t\t\t\tactive: 'active',\n\t\t\t\tdisabled: 'disabled'\n\t\t\t}\n\t\t}\n\t},\n\tbuttonCreated: function ( config, button ) {\n\t\treturn config.buttons ?\n\t\t\t$('<div class=\"btn-group\"/>').append(button) :\n\t\t\tbutton;\n\t}\n} );\n\nDataTable.ext.buttons.collection.className += ' dropdown-toggle';\nDataTable.ext.buttons.collection.rightAlignClassName = 'dropdown-menu-right';\n\nreturn DataTable.Buttons;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy1iczQvanMvYnV0dG9ucy5ib290c3RyYXA0LmpzPzA4YmUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLEVBQUUsaUNBQVEsQ0FBQyx5RUFBUSxFQUFFLDhHQUFvQixFQUFFLG1IQUF3QixDQUFDLG1DQUFFO0FBQ3RFO0FBQ0EsR0FBRztBQUFBLGtHQUFFO0FBQ0w7QUFDQSxNQUFNLEVBcUJKO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1idXR0b25zLWJzNC9qcy9idXR0b25zLmJvb3RzdHJhcDQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQm9vdHN0cmFwIGludGVncmF0aW9uIGZvciBEYXRhVGFibGVzJyBCdXR0b25zXG4gKiDCqTIwMTYgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldC1iczQnLCAnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucyddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldC1iczQnKShyb290LCAkKS4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJC5mbi5kYXRhVGFibGUuQnV0dG9ucyApIHtcblx0XHRcdFx0cmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucycpKHJvb3QsICQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG4ndXNlIHN0cmljdCc7XG52YXIgRGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XG5cbiQuZXh0ZW5kKCB0cnVlLCBEYXRhVGFibGUuQnV0dG9ucy5kZWZhdWx0cywge1xuXHRkb206IHtcblx0XHRjb250YWluZXI6IHtcblx0XHRcdGNsYXNzTmFtZTogJ2R0LWJ1dHRvbnMgYnRuLWdyb3VwIGZsZXgtd3JhcCdcblx0XHR9LFxuXHRcdGJ1dHRvbjoge1xuXHRcdFx0Y2xhc3NOYW1lOiAnYnRuIGJ0bi1zZWNvbmRhcnknXG5cdFx0fSxcblx0XHRjb2xsZWN0aW9uOiB7XG5cdFx0XHR0YWc6ICdkaXYnLFxuXHRcdFx0Y2xhc3NOYW1lOiAnZHJvcGRvd24tbWVudScsXG5cdFx0XHRidXR0b246IHtcblx0XHRcdFx0dGFnOiAnYScsXG5cdFx0XHRcdGNsYXNzTmFtZTogJ2R0LWJ1dHRvbiBkcm9wZG93bi1pdGVtJyxcblx0XHRcdFx0YWN0aXZlOiAnYWN0aXZlJyxcblx0XHRcdFx0ZGlzYWJsZWQ6ICdkaXNhYmxlZCdcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGJ1dHRvbkNyZWF0ZWQ6IGZ1bmN0aW9uICggY29uZmlnLCBidXR0b24gKSB7XG5cdFx0cmV0dXJuIGNvbmZpZy5idXR0b25zID9cblx0XHRcdCQoJzxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIi8+JykuYXBwZW5kKGJ1dHRvbikgOlxuXHRcdFx0YnV0dG9uO1xuXHR9XG59ICk7XG5cbkRhdGFUYWJsZS5leHQuYnV0dG9ucy5jb2xsZWN0aW9uLmNsYXNzTmFtZSArPSAnIGRyb3Bkb3duLXRvZ2dsZSc7XG5EYXRhVGFibGUuZXh0LmJ1dHRvbnMuY29sbGVjdGlvbi5yaWdodEFsaWduQ2xhc3NOYW1lID0gJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnO1xuXG5yZXR1cm4gRGF0YVRhYmxlLkJ1dHRvbnM7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-buttons-bs4/js/buttons.bootstrap4.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-buttons/js/buttons.colVis.js":
/*!******************************************************************!*\
  !*** ./node_modules/datatables.net-buttons/js/buttons.colVis.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Column visibility buttons for Buttons and DataTables.\n * 2016 SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! datatables.net */ \"./node_modules/datatables.net/js/jquery.dataTables.js\"), __webpack_require__(/*! datatables.net-buttons */ \"./node_modules/datatables.net-buttons/js/dataTables.buttons.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n$.extend( DataTable.ext.buttons, {\n\t// A collection of column visibility buttons\n\tcolvis: function ( dt, conf ) {\n\t\treturn {\n\t\t\textend: 'collection',\n\t\t\ttext: function ( dt ) {\n\t\t\t\treturn dt.i18n( 'buttons.colvis', 'Column visibility' );\n\t\t\t},\n\t\t\tclassName: 'buttons-colvis',\n\t\t\tbuttons: [ {\n\t\t\t\textend: 'columnsToggle',\n\t\t\t\tcolumns: conf.columns,\n\t\t\t\tcolumnText: conf.columnText\n\t\t\t} ]\n\t\t};\n\t},\n\n\t// Selected columns with individual buttons - toggle column visibility\n\tcolumnsToggle: function ( dt, conf ) {\n\t\tvar columns = dt.columns( conf.columns ).indexes().map( function ( idx ) {\n\t\t\treturn {\n\t\t\t\textend: 'columnToggle',\n\t\t\t\tcolumns: idx,\n\t\t\t\tcolumnText: conf.columnText\n\t\t\t};\n\t\t} ).toArray();\n\n\t\treturn columns;\n\t},\n\n\t// Single button to toggle column visibility\n\tcolumnToggle: function ( dt, conf ) {\n\t\treturn {\n\t\t\textend: 'columnVisibility',\n\t\t\tcolumns: conf.columns,\n\t\t\tcolumnText: conf.columnText\n\t\t};\n\t},\n\n\t// Selected columns with individual buttons - set column visibility\n\tcolumnsVisibility: function ( dt, conf ) {\n\t\tvar columns = dt.columns( conf.columns ).indexes().map( function ( idx ) {\n\t\t\treturn {\n\t\t\t\textend: 'columnVisibility',\n\t\t\t\tcolumns: idx,\n\t\t\t\tvisibility: conf.visibility,\n\t\t\t\tcolumnText: conf.columnText\n\t\t\t};\n\t\t} ).toArray();\n\n\t\treturn columns;\n\t},\n\n\t// Single button to set column visibility\n\tcolumnVisibility: {\n\t\tcolumns: undefined, // column selector\n\t\ttext: function ( dt, button, conf ) {\n\t\t\treturn conf._columnText( dt, conf );\n\t\t},\n\t\tclassName: 'buttons-columnVisibility',\n\t\taction: function ( e, dt, button, conf ) {\n\t\t\tvar col = dt.columns( conf.columns );\n\t\t\tvar curr = col.visible();\n\n\t\t\tcol.visible( conf.visibility !== undefined ?\n\t\t\t\tconf.visibility :\n\t\t\t\t! (curr.length ? curr[0] : false )\n\t\t\t);\n\t\t},\n\t\tinit: function ( dt, button, conf ) {\n\t\t\tvar that = this;\n\t\t\tbutton.attr( 'data-cv-idx', conf.columns );\n\n\t\t\tdt\n\t\t\t\t.on( 'column-visibility.dt'+conf.namespace, function (e, settings) {\n\t\t\t\t\tif ( ! settings.bDestroying && settings.nTable == dt.settings()[0].nTable ) {\n\t\t\t\t\t\tthat.active( dt.column( conf.columns ).visible() );\n\t\t\t\t\t}\n\t\t\t\t} )\n\t\t\t\t.on( 'column-reorder.dt'+conf.namespace, function (e, settings, details) {\n\t\t\t\t\tif ( dt.columns( conf.columns ).count() !== 1 ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// This button controls the same column index but the text for the column has\n\t\t\t\t\t// changed\n\t\t\t\t\tthat.text( conf._columnText( dt, conf ) );\n\n\t\t\t\t\t// Since its a different column, we need to check its visibility\n\t\t\t\t\tthat.active( dt.column( conf.columns ).visible() );\n\t\t\t\t} );\n\n\t\t\tthis.active( dt.column( conf.columns ).visible() );\n\t\t},\n\t\tdestroy: function ( dt, button, conf ) {\n\t\t\tdt\n\t\t\t\t.off( 'column-visibility.dt'+conf.namespace )\n\t\t\t\t.off( 'column-reorder.dt'+conf.namespace );\n\t\t},\n\n\t\t_columnText: function ( dt, conf ) {\n\t\t\t// Use DataTables' internal data structure until this is presented\n\t\t\t// is a public API. The other option is to use\n\t\t\t// `$( column(col).node() ).text()` but the node might not have been\n\t\t\t// populated when Buttons is constructed.\n\t\t\tvar idx = dt.column( conf.columns ).index();\n\t\t\tvar title = dt.settings()[0].aoColumns[ idx ].sTitle;\n\n\t\t\tif (! title) {\n\t\t\t\ttitle = dt.column(idx).header().innerHTML;\n\t\t\t}\n\n\t\t\ttitle = title\n\t\t\t\t.replace(/\\n/g,\" \")        // remove new lines\n\t\t\t\t.replace(/<br\\s*\\/?>/gi, \" \")  // replace line breaks with spaces\n\t\t\t\t.replace(/<select(.*?)<\\/select>/g, \"\") // remove select tags, including options text\n\t\t\t\t.replace(/<!\\-\\-.*?\\-\\->/g, \"\") // strip HTML comments\n\t\t\t\t.replace(/<.*?>/g, \"\")   // strip HTML\n\t\t\t\t.replace(/^\\s+|\\s+$/g,\"\"); // trim\n\n\t\t\treturn conf.columnText ?\n\t\t\t\tconf.columnText( dt, idx, title ) :\n\t\t\t\ttitle;\n\t\t}\n\t},\n\n\n\tcolvisRestore: {\n\t\tclassName: 'buttons-colvisRestore',\n\n\t\ttext: function ( dt ) {\n\t\t\treturn dt.i18n( 'buttons.colvisRestore', 'Restore visibility' );\n\t\t},\n\n\t\tinit: function ( dt, button, conf ) {\n\t\t\tconf._visOriginal = dt.columns().indexes().map( function ( idx ) {\n\t\t\t\treturn dt.column( idx ).visible();\n\t\t\t} ).toArray();\n\t\t},\n\n\t\taction: function ( e, dt, button, conf ) {\n\t\t\tdt.columns().every( function ( i ) {\n\t\t\t\t// Take into account that ColReorder might have disrupted our\n\t\t\t\t// indexes\n\t\t\t\tvar idx = dt.colReorder && dt.colReorder.transpose ?\n\t\t\t\t\tdt.colReorder.transpose( i, 'toOriginal' ) :\n\t\t\t\t\ti;\n\n\t\t\t\tthis.visible( conf._visOriginal[ idx ] );\n\t\t\t} );\n\t\t}\n\t},\n\n\n\tcolvisGroup: {\n\t\tclassName: 'buttons-colvisGroup',\n\n\t\taction: function ( e, dt, button, conf ) {\n\t\t\tdt.columns( conf.show ).visible( true, false );\n\t\t\tdt.columns( conf.hide ).visible( false, false );\n\n\t\t\tdt.columns.adjust();\n\t\t},\n\n\t\tshow: [],\n\n\t\thide: []\n\t}\n} );\n\n\nreturn DataTable.Buttons;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9idXR0b25zLmNvbFZpcy5qcz8zMjAzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUEwQztBQUNoRDtBQUNBLEVBQUUsaUNBQVEsQ0FBQyx5RUFBUSxFQUFFLGtHQUFnQixFQUFFLG1IQUF3QixDQUFDLG1DQUFFO0FBQ2xFO0FBQ0EsR0FBRztBQUFBLGtHQUFFO0FBQ0w7QUFDQSxNQUFNLEVBcUJKO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LWJ1dHRvbnMvanMvYnV0dG9ucy5jb2xWaXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIENvbHVtbiB2aXNpYmlsaXR5IGJ1dHRvbnMgZm9yIEJ1dHRvbnMgYW5kIERhdGFUYWJsZXMuXG4gKiAyMDE2IFNwcnlNZWRpYSBMdGQgLSBkYXRhdGFibGVzLm5ldC9saWNlbnNlXG4gKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICl7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnLCAnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucyddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkLmZuLmRhdGFUYWJsZS5CdXR0b25zICkge1xuXHRcdFx0XHRyZXF1aXJlKCdkYXRhdGFibGVzLm5ldC1idXR0b25zJykocm9vdCwgJCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4kLmV4dGVuZCggRGF0YVRhYmxlLmV4dC5idXR0b25zLCB7XG5cdC8vIEEgY29sbGVjdGlvbiBvZiBjb2x1bW4gdmlzaWJpbGl0eSBidXR0b25zXG5cdGNvbHZpczogZnVuY3Rpb24gKCBkdCwgY29uZiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXh0ZW5kOiAnY29sbGVjdGlvbicsXG5cdFx0XHR0ZXh0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdFx0XHRyZXR1cm4gZHQuaTE4biggJ2J1dHRvbnMuY29sdmlzJywgJ0NvbHVtbiB2aXNpYmlsaXR5JyApO1xuXHRcdFx0fSxcblx0XHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtY29sdmlzJyxcblx0XHRcdGJ1dHRvbnM6IFsge1xuXHRcdFx0XHRleHRlbmQ6ICdjb2x1bW5zVG9nZ2xlJyxcblx0XHRcdFx0Y29sdW1uczogY29uZi5jb2x1bW5zLFxuXHRcdFx0XHRjb2x1bW5UZXh0OiBjb25mLmNvbHVtblRleHRcblx0XHRcdH0gXVxuXHRcdH07XG5cdH0sXG5cblx0Ly8gU2VsZWN0ZWQgY29sdW1ucyB3aXRoIGluZGl2aWR1YWwgYnV0dG9ucyAtIHRvZ2dsZSBjb2x1bW4gdmlzaWJpbGl0eVxuXHRjb2x1bW5zVG9nZ2xlOiBmdW5jdGlvbiAoIGR0LCBjb25mICkge1xuXHRcdHZhciBjb2x1bW5zID0gZHQuY29sdW1ucyggY29uZi5jb2x1bW5zICkuaW5kZXhlcygpLm1hcCggZnVuY3Rpb24gKCBpZHggKSB7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRleHRlbmQ6ICdjb2x1bW5Ub2dnbGUnLFxuXHRcdFx0XHRjb2x1bW5zOiBpZHgsXG5cdFx0XHRcdGNvbHVtblRleHQ6IGNvbmYuY29sdW1uVGV4dFxuXHRcdFx0fTtcblx0XHR9ICkudG9BcnJheSgpO1xuXG5cdFx0cmV0dXJuIGNvbHVtbnM7XG5cdH0sXG5cblx0Ly8gU2luZ2xlIGJ1dHRvbiB0byB0b2dnbGUgY29sdW1uIHZpc2liaWxpdHlcblx0Y29sdW1uVG9nZ2xlOiBmdW5jdGlvbiAoIGR0LCBjb25mICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRleHRlbmQ6ICdjb2x1bW5WaXNpYmlsaXR5Jyxcblx0XHRcdGNvbHVtbnM6IGNvbmYuY29sdW1ucyxcblx0XHRcdGNvbHVtblRleHQ6IGNvbmYuY29sdW1uVGV4dFxuXHRcdH07XG5cdH0sXG5cblx0Ly8gU2VsZWN0ZWQgY29sdW1ucyB3aXRoIGluZGl2aWR1YWwgYnV0dG9ucyAtIHNldCBjb2x1bW4gdmlzaWJpbGl0eVxuXHRjb2x1bW5zVmlzaWJpbGl0eTogZnVuY3Rpb24gKCBkdCwgY29uZiApIHtcblx0XHR2YXIgY29sdW1ucyA9IGR0LmNvbHVtbnMoIGNvbmYuY29sdW1ucyApLmluZGV4ZXMoKS5tYXAoIGZ1bmN0aW9uICggaWR4ICkge1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0ZXh0ZW5kOiAnY29sdW1uVmlzaWJpbGl0eScsXG5cdFx0XHRcdGNvbHVtbnM6IGlkeCxcblx0XHRcdFx0dmlzaWJpbGl0eTogY29uZi52aXNpYmlsaXR5LFxuXHRcdFx0XHRjb2x1bW5UZXh0OiBjb25mLmNvbHVtblRleHRcblx0XHRcdH07XG5cdFx0fSApLnRvQXJyYXkoKTtcblxuXHRcdHJldHVybiBjb2x1bW5zO1xuXHR9LFxuXG5cdC8vIFNpbmdsZSBidXR0b24gdG8gc2V0IGNvbHVtbiB2aXNpYmlsaXR5XG5cdGNvbHVtblZpc2liaWxpdHk6IHtcblx0XHRjb2x1bW5zOiB1bmRlZmluZWQsIC8vIGNvbHVtbiBzZWxlY3RvclxuXHRcdHRleHQ6IGZ1bmN0aW9uICggZHQsIGJ1dHRvbiwgY29uZiApIHtcblx0XHRcdHJldHVybiBjb25mLl9jb2x1bW5UZXh0KCBkdCwgY29uZiApO1xuXHRcdH0sXG5cdFx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1jb2x1bW5WaXNpYmlsaXR5Jyxcblx0XHRhY3Rpb246IGZ1bmN0aW9uICggZSwgZHQsIGJ1dHRvbiwgY29uZiApIHtcblx0XHRcdHZhciBjb2wgPSBkdC5jb2x1bW5zKCBjb25mLmNvbHVtbnMgKTtcblx0XHRcdHZhciBjdXJyID0gY29sLnZpc2libGUoKTtcblxuXHRcdFx0Y29sLnZpc2libGUoIGNvbmYudmlzaWJpbGl0eSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0Y29uZi52aXNpYmlsaXR5IDpcblx0XHRcdFx0ISAoY3Vyci5sZW5ndGggPyBjdXJyWzBdIDogZmFsc2UgKVxuXHRcdFx0KTtcblx0XHR9LFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIGJ1dHRvbiwgY29uZiApIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdGJ1dHRvbi5hdHRyKCAnZGF0YS1jdi1pZHgnLCBjb25mLmNvbHVtbnMgKTtcblxuXHRcdFx0ZHRcblx0XHRcdFx0Lm9uKCAnY29sdW1uLXZpc2liaWxpdHkuZHQnK2NvbmYubmFtZXNwYWNlLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MpIHtcblx0XHRcdFx0XHRpZiAoICEgc2V0dGluZ3MuYkRlc3Ryb3lpbmcgJiYgc2V0dGluZ3MublRhYmxlID09IGR0LnNldHRpbmdzKClbMF0ublRhYmxlICkge1xuXHRcdFx0XHRcdFx0dGhhdC5hY3RpdmUoIGR0LmNvbHVtbiggY29uZi5jb2x1bW5zICkudmlzaWJsZSgpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IClcblx0XHRcdFx0Lm9uKCAnY29sdW1uLXJlb3JkZXIuZHQnK2NvbmYubmFtZXNwYWNlLCBmdW5jdGlvbiAoZSwgc2V0dGluZ3MsIGRldGFpbHMpIHtcblx0XHRcdFx0XHRpZiAoIGR0LmNvbHVtbnMoIGNvbmYuY29sdW1ucyApLmNvdW50KCkgIT09IDEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gVGhpcyBidXR0b24gY29udHJvbHMgdGhlIHNhbWUgY29sdW1uIGluZGV4IGJ1dCB0aGUgdGV4dCBmb3IgdGhlIGNvbHVtbiBoYXNcblx0XHRcdFx0XHQvLyBjaGFuZ2VkXG5cdFx0XHRcdFx0dGhhdC50ZXh0KCBjb25mLl9jb2x1bW5UZXh0KCBkdCwgY29uZiApICk7XG5cblx0XHRcdFx0XHQvLyBTaW5jZSBpdHMgYSBkaWZmZXJlbnQgY29sdW1uLCB3ZSBuZWVkIHRvIGNoZWNrIGl0cyB2aXNpYmlsaXR5XG5cdFx0XHRcdFx0dGhhdC5hY3RpdmUoIGR0LmNvbHVtbiggY29uZi5jb2x1bW5zICkudmlzaWJsZSgpICk7XG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0dGhpcy5hY3RpdmUoIGR0LmNvbHVtbiggY29uZi5jb2x1bW5zICkudmlzaWJsZSgpICk7XG5cdFx0fSxcblx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBidXR0b24sIGNvbmYgKSB7XG5cdFx0XHRkdFxuXHRcdFx0XHQub2ZmKCAnY29sdW1uLXZpc2liaWxpdHkuZHQnK2NvbmYubmFtZXNwYWNlIClcblx0XHRcdFx0Lm9mZiggJ2NvbHVtbi1yZW9yZGVyLmR0Jytjb25mLm5hbWVzcGFjZSApO1xuXHRcdH0sXG5cblx0XHRfY29sdW1uVGV4dDogZnVuY3Rpb24gKCBkdCwgY29uZiApIHtcblx0XHRcdC8vIFVzZSBEYXRhVGFibGVzJyBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB1bnRpbCB0aGlzIGlzIHByZXNlbnRlZFxuXHRcdFx0Ly8gaXMgYSBwdWJsaWMgQVBJLiBUaGUgb3RoZXIgb3B0aW9uIGlzIHRvIHVzZVxuXHRcdFx0Ly8gYCQoIGNvbHVtbihjb2wpLm5vZGUoKSApLnRleHQoKWAgYnV0IHRoZSBub2RlIG1pZ2h0IG5vdCBoYXZlIGJlZW5cblx0XHRcdC8vIHBvcHVsYXRlZCB3aGVuIEJ1dHRvbnMgaXMgY29uc3RydWN0ZWQuXG5cdFx0XHR2YXIgaWR4ID0gZHQuY29sdW1uKCBjb25mLmNvbHVtbnMgKS5pbmRleCgpO1xuXHRcdFx0dmFyIHRpdGxlID0gZHQuc2V0dGluZ3MoKVswXS5hb0NvbHVtbnNbIGlkeCBdLnNUaXRsZTtcblxuXHRcdFx0aWYgKCEgdGl0bGUpIHtcblx0XHRcdFx0dGl0bGUgPSBkdC5jb2x1bW4oaWR4KS5oZWFkZXIoKS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdHRpdGxlID0gdGl0bGVcblx0XHRcdFx0LnJlcGxhY2UoL1xcbi9nLFwiIFwiKSAgICAgICAgLy8gcmVtb3ZlIG5ldyBsaW5lc1xuXHRcdFx0XHQucmVwbGFjZSgvPGJyXFxzKlxcLz8+L2dpLCBcIiBcIikgIC8vIHJlcGxhY2UgbGluZSBicmVha3Mgd2l0aCBzcGFjZXNcblx0XHRcdFx0LnJlcGxhY2UoLzxzZWxlY3QoLio/KTxcXC9zZWxlY3Q+L2csIFwiXCIpIC8vIHJlbW92ZSBzZWxlY3QgdGFncywgaW5jbHVkaW5nIG9wdGlvbnMgdGV4dFxuXHRcdFx0XHQucmVwbGFjZSgvPCFcXC1cXC0uKj9cXC1cXC0+L2csIFwiXCIpIC8vIHN0cmlwIEhUTUwgY29tbWVudHNcblx0XHRcdFx0LnJlcGxhY2UoLzwuKj8+L2csIFwiXCIpICAgLy8gc3RyaXAgSFRNTFxuXHRcdFx0XHQucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKTsgLy8gdHJpbVxuXG5cdFx0XHRyZXR1cm4gY29uZi5jb2x1bW5UZXh0ID9cblx0XHRcdFx0Y29uZi5jb2x1bW5UZXh0KCBkdCwgaWR4LCB0aXRsZSApIDpcblx0XHRcdFx0dGl0bGU7XG5cdFx0fVxuXHR9LFxuXG5cblx0Y29sdmlzUmVzdG9yZToge1xuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtY29sdmlzUmVzdG9yZScsXG5cblx0XHR0ZXh0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdFx0cmV0dXJuIGR0LmkxOG4oICdidXR0b25zLmNvbHZpc1Jlc3RvcmUnLCAnUmVzdG9yZSB2aXNpYmlsaXR5JyApO1xuXHRcdH0sXG5cblx0XHRpbml0OiBmdW5jdGlvbiAoIGR0LCBidXR0b24sIGNvbmYgKSB7XG5cdFx0XHRjb25mLl92aXNPcmlnaW5hbCA9IGR0LmNvbHVtbnMoKS5pbmRleGVzKCkubWFwKCBmdW5jdGlvbiAoIGlkeCApIHtcblx0XHRcdFx0cmV0dXJuIGR0LmNvbHVtbiggaWR4ICkudmlzaWJsZSgpO1xuXHRcdFx0fSApLnRvQXJyYXkoKTtcblx0XHR9LFxuXG5cdFx0YWN0aW9uOiBmdW5jdGlvbiAoIGUsIGR0LCBidXR0b24sIGNvbmYgKSB7XG5cdFx0XHRkdC5jb2x1bW5zKCkuZXZlcnkoIGZ1bmN0aW9uICggaSApIHtcblx0XHRcdFx0Ly8gVGFrZSBpbnRvIGFjY291bnQgdGhhdCBDb2xSZW9yZGVyIG1pZ2h0IGhhdmUgZGlzcnVwdGVkIG91clxuXHRcdFx0XHQvLyBpbmRleGVzXG5cdFx0XHRcdHZhciBpZHggPSBkdC5jb2xSZW9yZGVyICYmIGR0LmNvbFJlb3JkZXIudHJhbnNwb3NlID9cblx0XHRcdFx0XHRkdC5jb2xSZW9yZGVyLnRyYW5zcG9zZSggaSwgJ3RvT3JpZ2luYWwnICkgOlxuXHRcdFx0XHRcdGk7XG5cblx0XHRcdFx0dGhpcy52aXNpYmxlKCBjb25mLl92aXNPcmlnaW5hbFsgaWR4IF0gKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0sXG5cblxuXHRjb2x2aXNHcm91cDoge1xuXHRcdGNsYXNzTmFtZTogJ2J1dHRvbnMtY29sdmlzR3JvdXAnLFxuXG5cdFx0YWN0aW9uOiBmdW5jdGlvbiAoIGUsIGR0LCBidXR0b24sIGNvbmYgKSB7XG5cdFx0XHRkdC5jb2x1bW5zKCBjb25mLnNob3cgKS52aXNpYmxlKCB0cnVlLCBmYWxzZSApO1xuXHRcdFx0ZHQuY29sdW1ucyggY29uZi5oaWRlICkudmlzaWJsZSggZmFsc2UsIGZhbHNlICk7XG5cblx0XHRcdGR0LmNvbHVtbnMuYWRqdXN0KCk7XG5cdFx0fSxcblxuXHRcdHNob3c6IFtdLFxuXG5cdFx0aGlkZTogW11cblx0fVxufSApO1xuXG5cbnJldHVybiBEYXRhVGFibGUuQnV0dG9ucztcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-buttons/js/buttons.colVis.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-buttons/js/buttons.html5.js":
/*!*****************************************************************!*\
  !*** ./node_modules/datatables.net-buttons/js/buttons.html5.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * HTML5 export buttons for Buttons and DataTables.\n * 2016 SpryMedia Ltd - datatables.net/license\n *\n * FileSaver.js (1.3.3) - MIT license\n * Copyright  2016 Eli Grey - http://eligrey.com\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! datatables.net */ \"./node_modules/datatables.net/js/jquery.dataTables.js\"), __webpack_require__(/*! datatables.net-buttons */ \"./node_modules/datatables.net-buttons/js/dataTables.buttons.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, jszip, pdfmake, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n// Allow the constructor to pass in JSZip and PDFMake from external requires.\n// Otherwise, use globally defined variables, if they are available.\nfunction _jsZip () {\n\treturn jszip || window.JSZip;\n}\nfunction _pdfMake () {\n\treturn pdfmake || window.pdfMake;\n}\n\nDataTable.Buttons.pdfMake = function (_) {\n\tif ( ! _ ) {\n\t\treturn _pdfMake();\n\t}\n\tpdfmake = _;\n}\n\nDataTable.Buttons.jszip = function (_) {\n\tif ( ! _ ) {\n\t\treturn _jsZip();\n\t}\n\tjszip = _;\n}\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * FileSaver.js dependency\n */\n\n/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */\n\nvar _saveAs = (function(view) {\n\t\"use strict\";\n\t// IE <10 is explicitly unsupported\n\tif (typeof view === \"undefined\" || typeof navigator !== \"undefined\" && /MSIE [1-9]\\./.test(navigator.userAgent)) {\n\t\treturn;\n\t}\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case Blob.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = new MouseEvent(\"click\");\n\t\t\tnode.dispatchEvent(event);\n\t\t}\n\t\t, is_safari = /constructor/i.test(view.HTMLElement) || view.safari\n\t\t, is_chrome_ios =/CriOS\\/[\\d]+/.test(navigator.userAgent)\n\t\t, throw_outside = function(ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t// the Blob API is fundamentally broken as there is no \"downloadfinished\" event to subscribe to\n\t\t, arbitrary_revoke_timeout = 1000 * 40 // in ms\n\t\t, revoke = function(file) {\n\t\t\tvar revoker = function() {\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tget_URL().revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\tsetTimeout(revoker, arbitrary_revoke_timeout);\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, auto_bom = function(blob) {\n\t\t\t// prepend BOM for UTF-8 XML and text/* types (including HTML)\n\t\t\t// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n\t\t\tif (/^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n\t\t\t\treturn new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});\n\t\t\t}\n\t\t\treturn blob;\n\t\t}\n\t\t, FileSaver = function(blob, name, no_auto_bom) {\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, force = type === force_saveable_type\n\t\t\t\t, object_url\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\tif ((is_chrome_ios || (force && is_safari)) && view.FileReader) {\n\t\t\t\t\t\t// Safari doesn't allow downloading of blob urls\n\t\t\t\t\t\tvar reader = new FileReader();\n\t\t\t\t\t\treader.onloadend = function() {\n\t\t\t\t\t\t\tvar url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');\n\t\t\t\t\t\t\tvar popup = view.open(url, '_blank');\n\t\t\t\t\t\t\tif(!popup) view.location.href = url;\n\t\t\t\t\t\t\turl=undefined; // release reference before dispatching\n\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\tdispatch_all();\n\t\t\t\t\t\t};\n\t\t\t\t\t\treader.readAsDataURL(blob);\n\t\t\t\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (!object_url) {\n\t\t\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\t\t}\n\t\t\t\t\tif (force) {\n\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar opened = view.open(object_url, \"_blank\");\n\t\t\t\t\t\tif (!opened) {\n\t\t\t\t\t\t\t// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html\n\t\t\t\t\t\t\tview.location.href = object_url;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t}\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_URL().createObjectURL(blob);\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tsave_link.href = object_url;\n\t\t\t\t\tsave_link.download = name;\n\t\t\t\t\tclick(save_link);\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\trevoke(object_url);\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfs_error();\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name, no_auto_bom) {\n\t\t\treturn new FileSaver(blob, name || blob.name || \"download\", no_auto_bom);\n\t\t}\n\t;\n\t// IE 10+ (native saveAs)\n\tif (typeof navigator !== \"undefined\" && navigator.msSaveOrOpenBlob) {\n\t\treturn function(blob, name, no_auto_bom) {\n\t\t\tname = name || blob.name || \"download\";\n\n\t\t\tif (!no_auto_bom) {\n\t\t\t\tblob = auto_bom(blob);\n\t\t\t}\n\t\t\treturn navigator.msSaveOrOpenBlob(blob, name);\n\t\t};\n\t}\n\n\tFS_proto.abort = function(){};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n\treturn saveAs;\n}(\n\t   typeof self !== \"undefined\" && self\n\t|| typeof window !== \"undefined\" && window\n\t|| this.content\n));\n\n\n// Expose file saver on the DataTables API. Can't attach to `DataTables.Buttons`\n// since this file can be loaded before Button's core!\nDataTable.fileSave = _saveAs;\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Local (private) functions\n */\n\n/**\n * Get the sheet name for Excel exports.\n *\n * @param {object}\tconfig Button configuration\n */\nvar _sheetname = function ( config )\n{\n\tvar sheetName = 'Sheet1';\n\n\tif ( config.sheetName ) {\n\t\tsheetName = config.sheetName.replace(/[\\[\\]\\*\\/\\\\\\?\\:]/g, '');\n\t}\n\n\treturn sheetName;\n};\n\n/**\n * Get the newline character(s)\n *\n * @param {object}\tconfig Button configuration\n * @return {string}\t\t\t\tNewline character\n */\nvar _newLine = function ( config )\n{\n\treturn config.newline ?\n\t\tconfig.newline :\n\t\tnavigator.userAgent.match(/Windows/) ?\n\t\t\t'\\r\\n' :\n\t\t\t'\\n';\n};\n\n/**\n * Combine the data from the `buttons.exportData` method into a string that\n * will be used in the export file.\n *\n * @param\t{DataTable.Api} dt\t\t DataTables API instance\n * @param\t{object}\t\t\t\tconfig Button configuration\n * @return {object}\t\t\t\t\t\t\t The data to export\n */\nvar _exportData = function ( dt, config )\n{\n\tvar newLine = _newLine( config );\n\tvar data = dt.buttons.exportData( config.exportOptions );\n\tvar boundary = config.fieldBoundary;\n\tvar separator = config.fieldSeparator;\n\tvar reBoundary = new RegExp( boundary, 'g' );\n\tvar escapeChar = config.escapeChar !== undefined ?\n\t\tconfig.escapeChar :\n\t\t'\\\\';\n\tvar join = function ( a ) {\n\t\tvar s = '';\n\n\t\t// If there is a field boundary, then we might need to escape it in\n\t\t// the source data\n\t\tfor ( var i=0, ien=a.length ; i<ien ; i++ ) {\n\t\t\tif ( i > 0 ) {\n\t\t\t\ts += separator;\n\t\t\t}\n\n\t\t\ts += boundary ?\n\t\t\t\tboundary + ('' + a[i]).replace( reBoundary, escapeChar+boundary ) + boundary :\n\t\t\t\ta[i];\n\t\t}\n\n\t\treturn s;\n\t};\n\n\tvar header = config.header ? join( data.header )+newLine : '';\n\tvar footer = config.footer && data.footer ? newLine+join( data.footer ) : '';\n\tvar body = [];\n\n\tfor ( var i=0, ien=data.body.length ; i<ien ; i++ ) {\n\t\tbody.push( join( data.body[i] ) );\n\t}\n\n\treturn {\n\t\tstr: header + body.join( newLine ) + footer,\n\t\trows: body.length\n\t};\n};\n\n/**\n * Older versions of Safari (prior to tech preview 18) don't support the\n * download option required.\n *\n * @return {Boolean} `true` if old Safari\n */\nvar _isDuffSafari = function ()\n{\n\tvar safari = navigator.userAgent.indexOf('Safari') !== -1 &&\n\t\tnavigator.userAgent.indexOf('Chrome') === -1 &&\n\t\tnavigator.userAgent.indexOf('Opera') === -1;\n\n\tif ( ! safari ) {\n\t\treturn false;\n\t}\n\n\tvar version = navigator.userAgent.match( /AppleWebKit\\/(\\d+\\.\\d+)/ );\n\tif ( version && version.length > 1 && version[1]*1 < 603.1 ) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\n/**\n * Convert from numeric position to letter for column names in Excel\n * @param  {int} n Column number\n * @return {string} Column letter(s) name\n */\nfunction createCellPos( n ){\n\tvar ordA = 'A'.charCodeAt(0);\n\tvar ordZ = 'Z'.charCodeAt(0);\n\tvar len = ordZ - ordA + 1;\n\tvar s = \"\";\n\n\twhile( n >= 0 ) {\n\t\ts = String.fromCharCode(n % len + ordA) + s;\n\t\tn = Math.floor(n / len) - 1;\n\t}\n\n\treturn s;\n}\n\ntry {\n\tvar _serialiser = new XMLSerializer();\n\tvar _ieExcel;\n}\ncatch (t) {}\n\n/**\n * Recursively add XML files from an object's structure to a ZIP file. This\n * allows the XSLX file to be easily defined with an object's structure matching\n * the files structure.\n *\n * @param {JSZip} zip ZIP package\n * @param {object} obj Object to add (recursive)\n */\nfunction _addToZip( zip, obj ) {\n\tif ( _ieExcel === undefined ) {\n\t\t// Detect if we are dealing with IE's _awful_ serialiser by seeing if it\n\t\t// drop attributes\n\t\t_ieExcel = _serialiser\n\t\t\t.serializeToString(\n\t\t\t\t( new window.DOMParser() ).parseFromString( excelStrings['xl/worksheets/sheet1.xml'], 'text/xml' )\n\t\t\t)\n\t\t\t.indexOf( 'xmlns:r' ) === -1;\n\t}\n\n\t$.each( obj, function ( name, val ) {\n\t\tif ( $.isPlainObject( val ) ) {\n\t\t\tvar newDir = zip.folder( name );\n\t\t\t_addToZip( newDir, val );\n\t\t}\n\t\telse {\n\t\t\tif ( _ieExcel ) {\n\t\t\t\t// IE's XML serialiser will drop some name space attributes from\n\t\t\t\t// from the root node, so we need to save them. Do this by\n\t\t\t\t// replacing the namespace nodes with a regular attribute that\n\t\t\t\t// we convert back when serialised. Edge does not have this\n\t\t\t\t// issue\n\t\t\t\tvar worksheet = val.childNodes[0];\n\t\t\t\tvar i, ien;\n\t\t\t\tvar attrs = [];\n\n\t\t\t\tfor ( i=worksheet.attributes.length-1 ; i>=0 ; i-- ) {\n\t\t\t\t\tvar attrName = worksheet.attributes[i].nodeName;\n\t\t\t\t\tvar attrValue = worksheet.attributes[i].nodeValue;\n\n\t\t\t\t\tif ( attrName.indexOf( ':' ) !== -1 ) {\n\t\t\t\t\t\tattrs.push( { name: attrName, value: attrValue } );\n\n\t\t\t\t\t\tworksheet.removeAttribute( attrName );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor ( i=0, ien=attrs.length ; i<ien ; i++ ) {\n\t\t\t\t\tvar attr = val.createAttribute( attrs[i].name.replace( ':', '_dt_b_namespace_token_' ) );\n\t\t\t\t\tattr.value = attrs[i].value;\n\t\t\t\t\tworksheet.setAttributeNode( attr );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar str = _serialiser.serializeToString(val);\n\n\t\t\t// Fix IE's XML\n\t\t\tif ( _ieExcel ) {\n\t\t\t\t// IE doesn't include the XML declaration\n\t\t\t\tif ( str.indexOf( '<?xml' ) === -1 ) {\n\t\t\t\t\tstr = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'+str;\n\t\t\t\t}\n\n\t\t\t\t// Return namespace attributes to being as such\n\t\t\t\tstr = str.replace( /_dt_b_namespace_token_/g, ':' );\n\n\t\t\t\t// Remove testing name space that IE puts into the space preserve attr\n\t\t\t\tstr = str.replace( /xmlns:NS[\\d]+=\"\" NS[\\d]+:/g, '' );\n\t\t\t}\n\n\t\t\t// Safari, IE and Edge will put empty name space attributes onto\n\t\t\t// various elements making them useless. This strips them out\n\t\t\tstr = str.replace( /<([^<>]*?) xmlns=\"\"([^<>]*?)>/g, '<$1 $2>' );\n\n\t\t\tzip.file( name, str );\n\t\t}\n\t} );\n}\n\n/**\n * Create an XML node and add any children, attributes, etc without needing to\n * be verbose in the DOM.\n *\n * @param  {object} doc      XML document\n * @param  {string} nodeName Node name\n * @param  {object} opts     Options - can be `attr` (attributes), `children`\n *   (child nodes) and `text` (text content)\n * @return {node}            Created node\n */\nfunction _createNode( doc, nodeName, opts ) {\n\tvar tempNode = doc.createElement( nodeName );\n\n\tif ( opts ) {\n\t\tif ( opts.attr ) {\n\t\t\t$(tempNode).attr( opts.attr );\n\t\t}\n\n\t\tif ( opts.children ) {\n\t\t\t$.each( opts.children, function ( key, value ) {\n\t\t\t\ttempNode.appendChild( value );\n\t\t\t} );\n\t\t}\n\n\t\tif ( opts.text !== null && opts.text !== undefined ) {\n\t\t\ttempNode.appendChild( doc.createTextNode( opts.text ) );\n\t\t}\n\t}\n\n\treturn tempNode;\n}\n\n/**\n * Get the width for an Excel column based on the contents of that column\n * @param  {object} data Data for export\n * @param  {int}    col  Column index\n * @return {int}         Column width\n */\nfunction _excelColWidth( data, col ) {\n\tvar max = data.header[col].length;\n\tvar len, lineSplit, str;\n\n\tif ( data.footer && data.footer[col].length > max ) {\n\t\tmax = data.footer[col].length;\n\t}\n\n\tfor ( var i=0, ien=data.body.length ; i<ien ; i++ ) {\n\t\tvar point = data.body[i][col];\n\t\tstr = point !== null && point !== undefined ?\n\t\t\tpoint.toString() :\n\t\t\t'';\n\n\t\t// If there is a newline character, workout the width of the column\n\t\t// based on the longest line in the string\n\t\tif ( str.indexOf('\\n') !== -1 ) {\n\t\t\tlineSplit = str.split('\\n');\n\t\t\tlineSplit.sort( function (a, b) {\n\t\t\t\treturn b.length - a.length;\n\t\t\t} );\n\n\t\t\tlen = lineSplit[0].length;\n\t\t}\n\t\telse {\n\t\t\tlen = str.length;\n\t\t}\n\n\t\tif ( len > max ) {\n\t\t\tmax = len;\n\t\t}\n\n\t\t// Max width rather than having potentially massive column widths\n\t\tif ( max > 40 ) {\n\t\t\treturn 54; // 40 * 1.35\n\t\t}\n\t}\n\n\tmax *= 1.35;\n\n\t// And a min width\n\treturn max > 6 ? max : 6;\n}\n\n// Excel - Pre-defined strings to build a basic XLSX file\nvar excelStrings = {\n\t\"_rels/.rels\":\n\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'+\n\t\t'<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">'+\n\t\t\t'<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" Target=\"xl/workbook.xml\"/>'+\n\t\t'</Relationships>',\n\n\t\"xl/_rels/workbook.xml.rels\":\n\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'+\n\t\t'<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">'+\n\t\t\t'<Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet\" Target=\"worksheets/sheet1.xml\"/>'+\n\t\t\t'<Relationship Id=\"rId2\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles\" Target=\"styles.xml\"/>'+\n\t\t'</Relationships>',\n\n\t\"[Content_Types].xml\":\n\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'+\n\t\t'<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">'+\n\t\t\t'<Default Extension=\"xml\" ContentType=\"application/xml\" />'+\n\t\t\t'<Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\" />'+\n\t\t\t'<Default Extension=\"jpeg\" ContentType=\"image/jpeg\" />'+\n\t\t\t'<Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\" />'+\n\t\t\t'<Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\" />'+\n\t\t\t'<Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\" />'+\n\t\t'</Types>',\n\n\t\"xl/workbook.xml\":\n\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'+\n\t\t'<workbook xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\">'+\n\t\t\t'<fileVersion appName=\"xl\" lastEdited=\"5\" lowestEdited=\"5\" rupBuild=\"24816\"/>'+\n\t\t\t'<workbookPr showInkAnnotation=\"0\" autoCompressPictures=\"0\"/>'+\n\t\t\t'<bookViews>'+\n\t\t\t\t'<workbookView xWindow=\"0\" yWindow=\"0\" windowWidth=\"25600\" windowHeight=\"19020\" tabRatio=\"500\"/>'+\n\t\t\t'</bookViews>'+\n\t\t\t'<sheets>'+\n\t\t\t\t'<sheet name=\"Sheet1\" sheetId=\"1\" r:id=\"rId1\"/>'+\n\t\t\t'</sheets>'+\n\t\t\t'<definedNames/>'+\n\t\t'</workbook>',\n\n\t\"xl/worksheets/sheet1.xml\":\n\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>'+\n\t\t'<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">'+\n\t\t\t'<sheetData/>'+\n\t\t\t'<mergeCells count=\"0\"/>'+\n\t\t'</worksheet>',\n\n\t\"xl/styles.xml\":\n\t\t'<?xml version=\"1.0\" encoding=\"UTF-8\"?>'+\n\t\t'<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">'+\n\t\t\t'<numFmts count=\"6\">'+\n\t\t\t\t'<numFmt numFmtId=\"164\" formatCode=\"#,##0.00_-\\ [$$-45C]\"/>'+\n\t\t\t\t'<numFmt numFmtId=\"165\" formatCode=\"&quot;&quot;#,##0.00\"/>'+\n\t\t\t\t'<numFmt numFmtId=\"166\" formatCode=\"[$-2]\\ #,##0.00\"/>'+\n\t\t\t\t'<numFmt numFmtId=\"167\" formatCode=\"0.0%\"/>'+\n\t\t\t\t'<numFmt numFmtId=\"168\" formatCode=\"#,##0;(#,##0)\"/>'+\n\t\t\t\t'<numFmt numFmtId=\"169\" formatCode=\"#,##0.00;(#,##0.00)\"/>'+\n\t\t\t'</numFmts>'+\n\t\t\t'<fonts count=\"5\" x14ac:knownFonts=\"1\">'+\n\t\t\t\t'<font>'+\n\t\t\t\t\t'<sz val=\"11\" />'+\n\t\t\t\t\t'<name val=\"Calibri\" />'+\n\t\t\t\t'</font>'+\n\t\t\t\t'<font>'+\n\t\t\t\t\t'<sz val=\"11\" />'+\n\t\t\t\t\t'<name val=\"Calibri\" />'+\n\t\t\t\t\t'<color rgb=\"FFFFFFFF\" />'+\n\t\t\t\t'</font>'+\n\t\t\t\t'<font>'+\n\t\t\t\t\t'<sz val=\"11\" />'+\n\t\t\t\t\t'<name val=\"Calibri\" />'+\n\t\t\t\t\t'<b />'+\n\t\t\t\t'</font>'+\n\t\t\t\t'<font>'+\n\t\t\t\t\t'<sz val=\"11\" />'+\n\t\t\t\t\t'<name val=\"Calibri\" />'+\n\t\t\t\t\t'<i />'+\n\t\t\t\t'</font>'+\n\t\t\t\t'<font>'+\n\t\t\t\t\t'<sz val=\"11\" />'+\n\t\t\t\t\t'<name val=\"Calibri\" />'+\n\t\t\t\t\t'<u />'+\n\t\t\t\t'</font>'+\n\t\t\t'</fonts>'+\n\t\t\t'<fills count=\"6\">'+\n\t\t\t\t'<fill>'+\n\t\t\t\t\t'<patternFill patternType=\"none\" />'+\n\t\t\t\t'</fill>'+\n\t\t\t\t'<fill>'+ // Excel appears to use this as a dotted background regardless of values but\n\t\t\t\t\t'<patternFill patternType=\"none\" />'+ // to be valid to the schema, use a patternFill\n\t\t\t\t'</fill>'+\n\t\t\t\t'<fill>'+\n\t\t\t\t\t'<patternFill patternType=\"solid\">'+\n\t\t\t\t\t\t'<fgColor rgb=\"FFD9D9D9\" />'+\n\t\t\t\t\t\t'<bgColor indexed=\"64\" />'+\n\t\t\t\t\t'</patternFill>'+\n\t\t\t\t'</fill>'+\n\t\t\t\t'<fill>'+\n\t\t\t\t\t'<patternFill patternType=\"solid\">'+\n\t\t\t\t\t\t'<fgColor rgb=\"FFD99795\" />'+\n\t\t\t\t\t\t'<bgColor indexed=\"64\" />'+\n\t\t\t\t\t'</patternFill>'+\n\t\t\t\t'</fill>'+\n\t\t\t\t'<fill>'+\n\t\t\t\t\t'<patternFill patternType=\"solid\">'+\n\t\t\t\t\t\t'<fgColor rgb=\"ffc6efce\" />'+\n\t\t\t\t\t\t'<bgColor indexed=\"64\" />'+\n\t\t\t\t\t'</patternFill>'+\n\t\t\t\t'</fill>'+\n\t\t\t\t'<fill>'+\n\t\t\t\t\t'<patternFill patternType=\"solid\">'+\n\t\t\t\t\t\t'<fgColor rgb=\"ffc6cfef\" />'+\n\t\t\t\t\t\t'<bgColor indexed=\"64\" />'+\n\t\t\t\t\t'</patternFill>'+\n\t\t\t\t'</fill>'+\n\t\t\t'</fills>'+\n\t\t\t'<borders count=\"2\">'+\n\t\t\t\t'<border>'+\n\t\t\t\t\t'<left />'+\n\t\t\t\t\t'<right />'+\n\t\t\t\t\t'<top />'+\n\t\t\t\t\t'<bottom />'+\n\t\t\t\t\t'<diagonal />'+\n\t\t\t\t'</border>'+\n\t\t\t\t'<border diagonalUp=\"false\" diagonalDown=\"false\">'+\n\t\t\t\t\t'<left style=\"thin\">'+\n\t\t\t\t\t\t'<color auto=\"1\" />'+\n\t\t\t\t\t'</left>'+\n\t\t\t\t\t'<right style=\"thin\">'+\n\t\t\t\t\t\t'<color auto=\"1\" />'+\n\t\t\t\t\t'</right>'+\n\t\t\t\t\t'<top style=\"thin\">'+\n\t\t\t\t\t\t'<color auto=\"1\" />'+\n\t\t\t\t\t'</top>'+\n\t\t\t\t\t'<bottom style=\"thin\">'+\n\t\t\t\t\t\t'<color auto=\"1\" />'+\n\t\t\t\t\t'</bottom>'+\n\t\t\t\t\t'<diagonal />'+\n\t\t\t\t'</border>'+\n\t\t\t'</borders>'+\n\t\t\t'<cellStyleXfs count=\"1\">'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" />'+\n\t\t\t'</cellStyleXfs>'+\n\t\t\t'<cellXfs count=\"68\">'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"2\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"2\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"2\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"2\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"2\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"3\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"3\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"3\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"3\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"3\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"4\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"4\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"4\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"4\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"4\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"5\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"5\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"5\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"5\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"5\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"0\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"0\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"0\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"0\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"2\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"2\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"2\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"2\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"2\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"3\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"3\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"3\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"3\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"3\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"4\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"4\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"4\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"4\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"4\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"5\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"1\" fillId=\"5\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"2\" fillId=\"5\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"3\" fillId=\"5\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"4\" fillId=\"5\" borderId=\"1\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyAlignment=\"1\">'+\n\t\t\t\t\t'<alignment horizontal=\"left\"/>'+\n\t\t\t\t'</xf>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyAlignment=\"1\">'+\n\t\t\t\t\t'<alignment horizontal=\"center\"/>'+\n\t\t\t\t'</xf>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyAlignment=\"1\">'+\n\t\t\t\t\t'<alignment horizontal=\"right\"/>'+\n\t\t\t\t'</xf>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyAlignment=\"1\">'+\n\t\t\t\t\t'<alignment horizontal=\"fill\"/>'+\n\t\t\t\t'</xf>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyAlignment=\"1\">'+\n\t\t\t\t\t'<alignment textRotation=\"90\"/>'+\n\t\t\t\t'</xf>'+\n\t\t\t\t'<xf numFmtId=\"0\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyAlignment=\"1\">'+\n\t\t\t\t\t'<alignment wrapText=\"1\"/>'+\n\t\t\t\t'</xf>'+\n\t\t\t\t'<xf numFmtId=\"9\"   fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"164\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"165\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"166\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"167\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"168\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"169\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"3\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"4\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"1\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"2\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t\t'<xf numFmtId=\"14\" fontId=\"0\" fillId=\"0\" borderId=\"0\" applyFont=\"1\" applyFill=\"1\" applyBorder=\"1\" xfId=\"0\" applyNumberFormat=\"1\"/>'+\n\t\t\t'</cellXfs>'+\n\t\t\t'<cellStyles count=\"1\">'+\n\t\t\t\t'<cellStyle name=\"Normal\" xfId=\"0\" builtinId=\"0\" />'+\n\t\t\t'</cellStyles>'+\n\t\t\t'<dxfs count=\"0\" />'+\n\t\t\t'<tableStyles count=\"0\" defaultTableStyle=\"TableStyleMedium9\" defaultPivotStyle=\"PivotStyleMedium4\" />'+\n\t\t'</styleSheet>'\n};\n// Note we could use 3 `for` loops for the styles, but when gzipped there is\n// virtually no difference in size, since the above can be easily compressed\n\n// Pattern matching for special number formats. Perhaps this should be exposed\n// via an API in future?\n// Ref: section 3.8.30 - built in formatters in open spreadsheet\n//   https://www.ecma-international.org/news/TC45_current_work/Office%20Open%20XML%20Part%204%20-%20Markup%20Language%20Reference.pdf\nvar _excelSpecials = [\n\t{ match: /^\\-?\\d+\\.\\d%$/,               style: 60, fmt: function (d) { return d/100; } }, // Precent with d.p.\n\t{ match: /^\\-?\\d+\\.?\\d*%$/,             style: 56, fmt: function (d) { return d/100; } }, // Percent\n\t{ match: /^\\-?\\$[\\d,]+.?\\d*$/,          style: 57 }, // Dollars\n\t{ match: /^\\-?[\\d,]+.?\\d*$/,           style: 58 }, // Pounds\n\t{ match: /^\\-?[\\d,]+.?\\d*$/,           style: 59 }, // Euros\n\t{ match: /^\\-?\\d+$/,                    style: 65 }, // Numbers without thousand separators\n\t{ match: /^\\-?\\d+\\.\\d{2}$/,             style: 66 }, // Numbers 2 d.p. without thousands separators\n\t{ match: /^\\([\\d,]+\\)$/,                style: 61, fmt: function (d) { return -1 * d.replace(/[\\(\\)]/g, ''); } },  // Negative numbers indicated by brackets\n\t{ match: /^\\([\\d,]+\\.\\d{2}\\)$/,         style: 62, fmt: function (d) { return -1 * d.replace(/[\\(\\)]/g, ''); } },  // Negative numbers indicated by brackets - 2d.p.\n\t{ match: /^\\-?[\\d,]+$/,                 style: 63 }, // Numbers with thousand separators\n\t{ match: /^\\-?[\\d,]+\\.\\d{2}$/,          style: 64 },\n\t{ match: /^[\\d]{4}\\-[\\d]{2}\\-[\\d]{2}$/, style: 67, fmt: function (d) {return Math.round(25569 + (Date.parse(d) / (86400 * 1000)));}} //Date yyyy-mm-dd\n];\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Buttons\n */\n\n//\n// Copy to clipboard\n//\nDataTable.ext.buttons.copyHtml5 = {\n\tclassName: 'buttons-copy buttons-html5',\n\n\ttext: function ( dt ) {\n\t\treturn dt.i18n( 'buttons.copy', 'Copy' );\n\t},\n\n\taction: function ( e, dt, button, config ) {\n\t\tthis.processing( true );\n\n\t\tvar that = this;\n\t\tvar exportData = _exportData( dt, config );\n\t\tvar info = dt.buttons.exportInfo( config );\n\t\tvar newline = _newLine(config);\n\t\tvar output = exportData.str;\n\t\tvar hiddenDiv = $('<div/>')\n\t\t\t.css( {\n\t\t\t\theight: 1,\n\t\t\t\twidth: 1,\n\t\t\t\toverflow: 'hidden',\n\t\t\t\tposition: 'fixed',\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t} );\n\n\t\tif ( info.title ) {\n\t\t\toutput = info.title + newline + newline + output;\n\t\t}\n\n\t\tif ( info.messageTop ) {\n\t\t\toutput = info.messageTop + newline + newline + output;\n\t\t}\n\n\t\tif ( info.messageBottom ) {\n\t\t\toutput = output + newline + newline + info.messageBottom;\n\t\t}\n\n\t\tif ( config.customize ) {\n\t\t\toutput = config.customize( output, config, dt );\n\t\t}\n\n\t\tvar textarea = $('<textarea readonly/>')\n\t\t\t.val( output )\n\t\t\t.appendTo( hiddenDiv );\n\n\t\t// For browsers that support the copy execCommand, try to use it\n\t\tif ( document.queryCommandSupported('copy') ) {\n\t\t\thiddenDiv.appendTo( dt.table().container() );\n\t\t\ttextarea[0].focus();\n\t\t\ttextarea[0].select();\n\n\t\t\ttry {\n\t\t\t\tvar successful = document.execCommand( 'copy' );\n\t\t\t\thiddenDiv.remove();\n\n\t\t\t\tif (successful) {\n\t\t\t\t\tdt.buttons.info(\n\t\t\t\t\t\tdt.i18n( 'buttons.copyTitle', 'Copy to clipboard' ),\n\t\t\t\t\t\tdt.i18n( 'buttons.copySuccess', {\n\t\t\t\t\t\t\t1: 'Copied one row to clipboard',\n\t\t\t\t\t\t\t_: 'Copied %d rows to clipboard'\n\t\t\t\t\t\t}, exportData.rows ),\n\t\t\t\t\t\t2000\n\t\t\t\t\t);\n\n\t\t\t\t\tthis.processing( false );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (t) {}\n\t\t}\n\n\t\t// Otherwise we show the text box and instruct the user to use it\n\t\tvar message = $('<span>'+dt.i18n( 'buttons.copyKeys',\n\t\t\t\t'Press <i>ctrl</i> or <i>\\u2318</i> + <i>C</i> to copy the table data<br>to your system clipboard.<br><br>'+\n\t\t\t\t'To cancel, click this message or press escape.' )+'</span>'\n\t\t\t)\n\t\t\t.append( hiddenDiv );\n\n\t\tdt.buttons.info( dt.i18n( 'buttons.copyTitle', 'Copy to clipboard' ), message, 0 );\n\n\t\t// Select the text so when the user activates their system clipboard\n\t\t// it will copy that text\n\t\ttextarea[0].focus();\n\t\ttextarea[0].select();\n\n\t\t// Event to hide the message when the user is done\n\t\tvar container = $(message).closest('.dt-button-info');\n\t\tvar close = function () {\n\t\t\tcontainer.off( 'click.buttons-copy' );\n\t\t\t$(document).off( '.buttons-copy' );\n\t\t\tdt.buttons.info( false );\n\t\t};\n\n\t\tcontainer.on( 'click.buttons-copy', close );\n\t\t$(document)\n\t\t\t.on( 'keydown.buttons-copy', function (e) {\n\t\t\t\tif ( e.keyCode === 27 ) { // esc\n\t\t\t\t\tclose();\n\t\t\t\t\tthat.processing( false );\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.on( 'copy.buttons-copy cut.buttons-copy', function () {\n\t\t\t\tclose();\n\t\t\t\tthat.processing( false );\n\t\t\t} );\n\t},\n\n\texportOptions: {},\n\n\tfieldSeparator: '\\t',\n\n\tfieldBoundary: '',\n\n\theader: true,\n\n\tfooter: false,\n\n\ttitle: '*',\n\n\tmessageTop: '*',\n\n\tmessageBottom: '*'\n};\n\n//\n// CSV export\n//\nDataTable.ext.buttons.csvHtml5 = {\n\tbom: false,\n\n\tclassName: 'buttons-csv buttons-html5',\n\n\tavailable: function () {\n\t\treturn window.FileReader !== undefined && window.Blob;\n\t},\n\n\ttext: function ( dt ) {\n\t\treturn dt.i18n( 'buttons.csv', 'CSV' );\n\t},\n\n\taction: function ( e, dt, button, config ) {\n\t\tthis.processing( true );\n\n\t\t// Set the text\n\t\tvar output = _exportData( dt, config ).str;\n\t\tvar info = dt.buttons.exportInfo(config);\n\t\tvar charset = config.charset;\n\n\t\tif ( config.customize ) {\n\t\t\toutput = config.customize( output, config, dt );\n\t\t}\n\n\t\tif ( charset !== false ) {\n\t\t\tif ( ! charset ) {\n\t\t\t\tcharset = document.characterSet || document.charset;\n\t\t\t}\n\n\t\t\tif ( charset ) {\n\t\t\t\tcharset = ';charset='+charset;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tcharset = '';\n\t\t}\n\n\t\tif ( config.bom ) {\n\t\t\toutput = '\\ufeff' + output;\n\t\t}\n\n\t\t_saveAs(\n\t\t\tnew Blob( [output], {type: 'text/csv'+charset} ),\n\t\t\tinfo.filename,\n\t\t\ttrue\n\t\t);\n\n\t\tthis.processing( false );\n\t},\n\n\tfilename: '*',\n\n\textension: '.csv',\n\n\texportOptions: {},\n\n\tfieldSeparator: ',',\n\n\tfieldBoundary: '\"',\n\n\tescapeChar: '\"',\n\n\tcharset: null,\n\n\theader: true,\n\n\tfooter: false\n};\n\n//\n// Excel (xlsx) export\n//\nDataTable.ext.buttons.excelHtml5 = {\n\tclassName: 'buttons-excel buttons-html5',\n\n\tavailable: function () {\n\t\treturn window.FileReader !== undefined && _jsZip() !== undefined && ! _isDuffSafari() && _serialiser;\n\t},\n\n\ttext: function ( dt ) {\n\t\treturn dt.i18n( 'buttons.excel', 'Excel' );\n\t},\n\n\taction: function ( e, dt, button, config ) {\n\t\tthis.processing( true );\n\n\t\tvar that = this;\n\t\tvar rowPos = 0;\n\t\tvar dataStartRow, dataEndRow;\n\t\tvar getXml = function ( type ) {\n\t\t\tvar str = excelStrings[ type ];\n\n\t\t\t//str = str.replace( /xmlns:/g, 'xmlns_' ).replace( /mc:/g, 'mc_' );\n\n\t\t\treturn $.parseXML( str );\n\t\t};\n\t\tvar rels = getXml('xl/worksheets/sheet1.xml');\n\t\tvar relsGet = rels.getElementsByTagName( \"sheetData\" )[0];\n\n\t\tvar xlsx = {\n\t\t\t_rels: {\n\t\t\t\t\".rels\": getXml('_rels/.rels')\n\t\t\t},\n\t\t\txl: {\n\t\t\t\t_rels: {\n\t\t\t\t\t\"workbook.xml.rels\": getXml('xl/_rels/workbook.xml.rels')\n\t\t\t\t},\n\t\t\t\t\"workbook.xml\": getXml('xl/workbook.xml'),\n\t\t\t\t\"styles.xml\": getXml('xl/styles.xml'),\n\t\t\t\t\"worksheets\": {\n\t\t\t\t\t\"sheet1.xml\": rels\n\t\t\t\t}\n\n\t\t\t},\n\t\t\t\"[Content_Types].xml\": getXml('[Content_Types].xml')\n\t\t};\n\n\t\tvar data = dt.buttons.exportData( config.exportOptions );\n\t\tvar currentRow, rowNode;\n\t\tvar addRow = function ( row ) {\n\t\t\tcurrentRow = rowPos+1;\n\t\t\trowNode = _createNode( rels, \"row\", { attr: {r:currentRow} } );\n\n\t\t\tfor ( var i=0, ien=row.length ; i<ien ; i++ ) {\n\t\t\t\t// Concat both the Cell Columns as a letter and the Row of the cell.\n\t\t\t\tvar cellId = createCellPos(i) + '' + currentRow;\n\t\t\t\tvar cell = null;\n\n\t\t\t\t// For null, undefined of blank cell, continue so it doesn't create the _createNode\n\t\t\t\tif ( row[i] === null || row[i] === undefined || row[i] === '' ) {\n\t\t\t\t\tif ( config.createEmptyCells === true ) {\n\t\t\t\t\t\trow[i] = '';\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar originalContent = row[i];\n\t\t\t\trow[i] = typeof row[i].trim === 'function'\n\t\t\t\t\t? row[i].trim()\n\t\t\t\t\t: row[i];\n\n\t\t\t\t// Special number formatting options\n\t\t\t\tfor ( var j=0, jen=_excelSpecials.length ; j<jen ; j++ ) {\n\t\t\t\t\tvar special = _excelSpecials[j];\n\n\t\t\t\t\t// TODO Need to provide the ability for the specials to say\n\t\t\t\t\t// if they are returning a string, since at the moment it is\n\t\t\t\t\t// assumed to be a number\n\t\t\t\t\tif ( row[i].match && ! row[i].match(/^0\\d+/) && row[i].match( special.match ) ) {\n\t\t\t\t\t\tvar val = row[i].replace(/[^\\d\\.\\-]/g, '');\n\n\t\t\t\t\t\tif ( special.fmt ) {\n\t\t\t\t\t\t\tval = special.fmt( val );\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcell = _createNode( rels, 'c', {\n\t\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\t\tr: cellId,\n\t\t\t\t\t\t\t\ts: special.style\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tchildren: [\n\t\t\t\t\t\t\t\t_createNode( rels, 'v', { text: val } )\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t} );\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( ! cell ) {\n\t\t\t\t\tif ( typeof row[i] === 'number' || (\n\t\t\t\t\t\trow[i].match &&\n\t\t\t\t\t\trow[i].match(/^-?\\d+(\\.\\d+)?$/) &&\n\t\t\t\t\t\t! row[i].match(/^0\\d+/) )\n\t\t\t\t\t) {\n\t\t\t\t\t\t// Detect numbers - don't match numbers with leading zeros\n\t\t\t\t\t\t// or a negative anywhere but the start\n\t\t\t\t\t\tcell = _createNode( rels, 'c', {\n\t\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\t\tt: 'n',\n\t\t\t\t\t\t\t\tr: cellId\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tchildren: [\n\t\t\t\t\t\t\t\t_createNode( rels, 'v', { text: row[i] } )\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// String output - replace non standard characters for text output\n\t\t\t\t\t\tvar text = ! originalContent.replace ?\n\t\t\t\t\t\t\toriginalContent :\n\t\t\t\t\t\t\toriginalContent.replace(/[\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x9F]/g, '');\n\n\t\t\t\t\t\tcell = _createNode( rels, 'c', {\n\t\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\t\tt: 'inlineStr',\n\t\t\t\t\t\t\t\tr: cellId\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tchildren:{\n\t\t\t\t\t\t\t\trow: _createNode( rels, 'is', {\n\t\t\t\t\t\t\t\t\tchildren: {\n\t\t\t\t\t\t\t\t\t\trow: _createNode( rels, 't', {\n\t\t\t\t\t\t\t\t\t\t\ttext: text,\n\t\t\t\t\t\t\t\t\t\t\tattr: {\n\t\t\t\t\t\t\t\t\t\t\t\t'xml:space': 'preserve'\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} )\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\trowNode.appendChild( cell );\n\t\t\t}\n\n\t\t\trelsGet.appendChild(rowNode);\n\t\t\trowPos++;\n\t\t};\n\n\t\tif ( config.customizeData ) {\n\t\t\tconfig.customizeData( data );\n\t\t}\n\n\t\tvar mergeCells = function ( row, colspan ) {\n\t\t\tvar mergeCells = $('mergeCells', rels);\n\n\t\t\tmergeCells[0].appendChild( _createNode( rels, 'mergeCell', {\n\t\t\t\tattr: {\n\t\t\t\t\tref: 'A'+row+':'+createCellPos(colspan)+row\n\t\t\t\t}\n\t\t\t} ) );\n\t\t\tmergeCells.attr( 'count', parseFloat(mergeCells.attr( 'count' ))+1 );\n\t\t\t$('row:eq('+(row-1)+') c', rels).attr( 's', '51' ); // centre\n\t\t};\n\n\t\t// Title and top messages\n\t\tvar exportInfo = dt.buttons.exportInfo( config );\n\t\tif ( exportInfo.title ) {\n\t\t\taddRow( [exportInfo.title], rowPos );\n\t\t\tmergeCells( rowPos, data.header.length-1 );\n\t\t}\n\n\t\tif ( exportInfo.messageTop ) {\n\t\t\taddRow( [exportInfo.messageTop], rowPos );\n\t\t\tmergeCells( rowPos, data.header.length-1 );\n\t\t}\n\n\n\t\t// Table itself\n\t\tif ( config.header ) {\n\t\t\taddRow( data.header, rowPos );\n\t\t\t$('row:last c', rels).attr( 's', '2' ); // bold\n\t\t}\n\t\n\t\tdataStartRow = rowPos;\n\n\t\tfor ( var n=0, ie=data.body.length ; n<ie ; n++ ) {\n\t\t\taddRow( data.body[n], rowPos );\n\t\t}\n\t\n\t\tdataEndRow = rowPos;\n\n\t\tif ( config.footer && data.footer ) {\n\t\t\taddRow( data.footer, rowPos);\n\t\t\t$('row:last c', rels).attr( 's', '2' ); // bold\n\t\t}\n\n\t\t// Below the table\n\t\tif ( exportInfo.messageBottom ) {\n\t\t\taddRow( [exportInfo.messageBottom], rowPos );\n\t\t\tmergeCells( rowPos, data.header.length-1 );\n\t\t}\n\n\t\t// Set column widths\n\t\tvar cols = _createNode( rels, 'cols' );\n\t\t$('worksheet', rels).prepend( cols );\n\n\t\tfor ( var i=0, ien=data.header.length ; i<ien ; i++ ) {\n\t\t\tcols.appendChild( _createNode( rels, 'col', {\n\t\t\t\tattr: {\n\t\t\t\t\tmin: i+1,\n\t\t\t\t\tmax: i+1,\n\t\t\t\t\twidth: _excelColWidth( data, i ),\n\t\t\t\t\tcustomWidth: 1\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\t// Workbook modifications\n\t\tvar workbook = xlsx.xl['workbook.xml'];\n\n\t\t$( 'sheets sheet', workbook ).attr( 'name', _sheetname( config ) );\n\n\t\t// Auto filter for columns\n\t\tif ( config.autoFilter ) {\n\t\t\t$('mergeCells', rels).before( _createNode( rels, 'autoFilter', {\n\t\t\t\tattr: {\n\t\t\t\t\tref: 'A'+dataStartRow+':'+createCellPos(data.header.length-1)+dataEndRow\n\t\t\t\t}\n\t\t\t} ) );\n\n\t\t\t$('definedNames', workbook).append( _createNode( workbook, 'definedName', {\n\t\t\t\tattr: {\n\t\t\t\t\tname: '_xlnm._FilterDatabase',\n\t\t\t\t\tlocalSheetId: '0',\n\t\t\t\t\thidden: 1\n\t\t\t\t},\n\t\t\t\ttext: _sheetname(config)+'!$A$'+dataStartRow+':'+createCellPos(data.header.length-1)+dataEndRow\n\t\t\t} ) );\n\t\t}\n\n\t\t// Let the developer customise the document if they want to\n\t\tif ( config.customize ) {\n\t\t\tconfig.customize( xlsx, config, dt );\n\t\t}\n\n\t\t// Excel doesn't like an empty mergeCells tag\n\t\tif ( $('mergeCells', rels).children().length === 0 ) {\n\t\t\t$('mergeCells', rels).remove();\n\t\t}\n\n\t\tvar jszip = _jsZip();\n\t\tvar zip = new jszip();\n\t\tvar zipConfig = {\n\t\t\ttype: 'blob',\n\t\t\tmimeType: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\n\t\t};\n\n\t\t_addToZip( zip, xlsx );\n\n\t\tif ( zip.generateAsync ) {\n\t\t\t// JSZip 3+\n\t\t\tzip\n\t\t\t\t.generateAsync( zipConfig )\n\t\t\t\t.then( function ( blob ) {\n\t\t\t\t\t_saveAs( blob, exportInfo.filename );\n\t\t\t\t\tthat.processing( false );\n\t\t\t\t} );\n\t\t}\n\t\telse {\n\t\t\t// JSZip 2.5\n\t\t\t_saveAs(\n\t\t\t\tzip.generate( zipConfig ),\n\t\t\t\texportInfo.filename\n\t\t\t);\n\t\t\tthis.processing( false );\n\t\t}\n\t},\n\n\tfilename: '*',\n\n\textension: '.xlsx',\n\n\texportOptions: {},\n\n\theader: true,\n\n\tfooter: false,\n\n\ttitle: '*',\n\n\tmessageTop: '*',\n\n\tmessageBottom: '*',\n\n\tcreateEmptyCells: false,\n\n\tautoFilter: false,\n\n\tsheetName: ''\n};\n\n//\n// PDF export - using pdfMake - http://pdfmake.org\n//\nDataTable.ext.buttons.pdfHtml5 = {\n\tclassName: 'buttons-pdf buttons-html5',\n\n\tavailable: function () {\n\t\treturn window.FileReader !== undefined && _pdfMake();\n\t},\n\n\ttext: function ( dt ) {\n\t\treturn dt.i18n( 'buttons.pdf', 'PDF' );\n\t},\n\n\taction: function ( e, dt, button, config ) {\n\t\tthis.processing( true );\n\n\t\tvar that = this;\n\t\tvar data = dt.buttons.exportData( config.exportOptions );\n\t\tvar info = dt.buttons.exportInfo( config );\n\t\tvar rows = [];\n\n\t\tif ( config.header ) {\n\t\t\trows.push( $.map( data.header, function ( d ) {\n\t\t\t\treturn {\n\t\t\t\t\ttext: typeof d === 'string' ? d : d+'',\n\t\t\t\t\tstyle: 'tableHeader'\n\t\t\t\t};\n\t\t\t} ) );\n\t\t}\n\n\t\tfor ( var i=0, ien=data.body.length ; i<ien ; i++ ) {\n\t\t\trows.push( $.map( data.body[i], function ( d ) {\n\t\t\t\tif ( d === null || d === undefined ) {\n\t\t\t\t\td = '';\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\ttext: typeof d === 'string' ? d : d+'',\n\t\t\t\t\tstyle: i % 2 ? 'tableBodyEven' : 'tableBodyOdd'\n\t\t\t\t};\n\t\t\t} ) );\n\t\t}\n\n\t\tif ( config.footer && data.footer) {\n\t\t\trows.push( $.map( data.footer, function ( d ) {\n\t\t\t\treturn {\n\t\t\t\t\ttext: typeof d === 'string' ? d : d+'',\n\t\t\t\t\tstyle: 'tableFooter'\n\t\t\t\t};\n\t\t\t} ) );\n\t\t}\n\n\t\tvar doc = {\n\t\t\tpageSize: config.pageSize,\n\t\t\tpageOrientation: config.orientation,\n\t\t\tcontent: [\n\t\t\t\t{\n\t\t\t\t\ttable: {\n\t\t\t\t\t\theaderRows: 1,\n\t\t\t\t\t\tbody: rows\n\t\t\t\t\t},\n\t\t\t\t\tlayout: 'noBorders'\n\t\t\t\t}\n\t\t\t],\n\t\t\tstyles: {\n\t\t\t\ttableHeader: {\n\t\t\t\t\tbold: true,\n\t\t\t\t\tfontSize: 11,\n\t\t\t\t\tcolor: 'white',\n\t\t\t\t\tfillColor: '#2d4154',\n\t\t\t\t\talignment: 'center'\n\t\t\t\t},\n\t\t\t\ttableBodyEven: {},\n\t\t\t\ttableBodyOdd: {\n\t\t\t\t\tfillColor: '#f3f3f3'\n\t\t\t\t},\n\t\t\t\ttableFooter: {\n\t\t\t\t\tbold: true,\n\t\t\t\t\tfontSize: 11,\n\t\t\t\t\tcolor: 'white',\n\t\t\t\t\tfillColor: '#2d4154'\n\t\t\t\t},\n\t\t\t\ttitle: {\n\t\t\t\t\talignment: 'center',\n\t\t\t\t\tfontSize: 15\n\t\t\t\t},\n\t\t\t\tmessage: {}\n\t\t\t},\n\t\t\tdefaultStyle: {\n\t\t\t\tfontSize: 10\n\t\t\t}\n\t\t};\n\n\t\tif ( info.messageTop ) {\n\t\t\tdoc.content.unshift( {\n\t\t\t\ttext: info.messageTop,\n\t\t\t\tstyle: 'message',\n\t\t\t\tmargin: [ 0, 0, 0, 12 ]\n\t\t\t} );\n\t\t}\n\n\t\tif ( info.messageBottom ) {\n\t\t\tdoc.content.push( {\n\t\t\t\ttext: info.messageBottom,\n\t\t\t\tstyle: 'message',\n\t\t\t\tmargin: [ 0, 0, 0, 12 ]\n\t\t\t} );\n\t\t}\n\n\t\tif ( info.title ) {\n\t\t\tdoc.content.unshift( {\n\t\t\t\ttext: info.title,\n\t\t\t\tstyle: 'title',\n\t\t\t\tmargin: [ 0, 0, 0, 12 ]\n\t\t\t} );\n\t\t}\n\n\t\tif ( config.customize ) {\n\t\t\tconfig.customize( doc, config, dt );\n\t\t}\n\n\t\tvar pdf = _pdfMake().createPdf( doc );\n\n\t\tif ( config.download === 'open' && ! _isDuffSafari() ) {\n\t\t\tpdf.open();\n\t\t}\n\t\telse {\n\t\t\tpdf.download( info.filename );\n\t\t}\n\n\t\tthis.processing( false );\n\t},\n\n\ttitle: '*',\n\n\tfilename: '*',\n\n\textension: '.pdf',\n\n\texportOptions: {},\n\n\torientation: 'portrait',\n\n\tpageSize: 'A4',\n\n\theader: true,\n\n\tfooter: false,\n\n\tmessageTop: '*',\n\n\tmessageBottom: '*',\n\n\tcustomize: null,\n\n\tdownload: 'download'\n};\n\n\nreturn DataTable.Buttons;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9idXR0b25zLmh0bWw1LmpzPzljMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsa0dBQWdCLEVBQUUsbUhBQXdCLENBQUMsbUNBQUU7QUFDbEU7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFxQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsMERBQTBELGdCQUFnQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFp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SjtBQUNBLHNEQUFzRDtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQzs7QUFFQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7O0FBRUEsa0JBQWtCOztBQUVsQjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTs7QUFFQSxrQkFBa0I7O0FBRWxCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kYXRhdGFibGVzLm5ldC1idXR0b25zL2pzL2J1dHRvbnMuaHRtbDUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEhUTUw1IGV4cG9ydCBidXR0b25zIGZvciBCdXR0b25zIGFuZCBEYXRhVGFibGVzLlxuICogMjAxNiBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICpcbiAqIEZpbGVTYXZlci5qcyAoMS4zLjMpIC0gTUlUIGxpY2Vuc2VcbiAqIENvcHlyaWdodCDCqSAyMDE2IEVsaSBHcmV5IC0gaHR0cDovL2VsaWdyZXkuY29tXG4gKi9cblxuKGZ1bmN0aW9uKCBmYWN0b3J5ICl7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRFxuXHRcdGRlZmluZSggWydqcXVlcnknLCAnZGF0YXRhYmxlcy5uZXQnLCAnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucyddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCwganN6aXAsIHBkZm1ha2UpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQnKShyb290LCAkKS4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJC5mbi5kYXRhVGFibGUuQnV0dG9ucyApIHtcblx0XHRcdFx0cmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucycpKHJvb3QsICQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCwganN6aXAsIHBkZm1ha2UgKTtcblx0XHR9O1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIEJyb3dzZXJcblx0XHRmYWN0b3J5KCBqUXVlcnksIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0fVxufShmdW5jdGlvbiggJCwgd2luZG93LCBkb2N1bWVudCwganN6aXAsIHBkZm1ha2UsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuLy8gQWxsb3cgdGhlIGNvbnN0cnVjdG9yIHRvIHBhc3MgaW4gSlNaaXAgYW5kIFBERk1ha2UgZnJvbSBleHRlcm5hbCByZXF1aXJlcy5cbi8vIE90aGVyd2lzZSwgdXNlIGdsb2JhbGx5IGRlZmluZWQgdmFyaWFibGVzLCBpZiB0aGV5IGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiBfanNaaXAgKCkge1xuXHRyZXR1cm4ganN6aXAgfHwgd2luZG93LkpTWmlwO1xufVxuZnVuY3Rpb24gX3BkZk1ha2UgKCkge1xuXHRyZXR1cm4gcGRmbWFrZSB8fCB3aW5kb3cucGRmTWFrZTtcbn1cblxuRGF0YVRhYmxlLkJ1dHRvbnMucGRmTWFrZSA9IGZ1bmN0aW9uIChfKSB7XG5cdGlmICggISBfICkge1xuXHRcdHJldHVybiBfcGRmTWFrZSgpO1xuXHR9XG5cdHBkZm1ha2UgPSBfO1xufVxuXG5EYXRhVGFibGUuQnV0dG9ucy5qc3ppcCA9IGZ1bmN0aW9uIChfKSB7XG5cdGlmICggISBfICkge1xuXHRcdHJldHVybiBfanNaaXAoKTtcblx0fVxuXHRqc3ppcCA9IF87XG59XG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBGaWxlU2F2ZXIuanMgZGVwZW5kZW5jeVxuICovXG5cbi8qanNsaW50IGJpdHdpc2U6IHRydWUsIGluZGVudDogNCwgbGF4YnJlYWs6IHRydWUsIGxheGNvbW1hOiB0cnVlLCBzbWFydHRhYnM6IHRydWUsIHBsdXNwbHVzOiB0cnVlICovXG5cbnZhciBfc2F2ZUFzID0gKGZ1bmN0aW9uKHZpZXcpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdC8vIElFIDwxMCBpcyBleHBsaWNpdGx5IHVuc3VwcG9ydGVkXG5cdGlmICh0eXBlb2YgdmlldyA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9NU0lFIFsxLTldXFwuLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cdHZhclxuXHRcdCAgZG9jID0gdmlldy5kb2N1bWVudFxuXHRcdCAgLy8gb25seSBnZXQgVVJMIHdoZW4gbmVjZXNzYXJ5IGluIGNhc2UgQmxvYi5qcyBoYXNuJ3Qgb3ZlcnJpZGRlbiBpdCB5ZXRcblx0XHQsIGdldF9VUkwgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB2aWV3LlVSTCB8fCB2aWV3LndlYmtpdFVSTCB8fCB2aWV3O1xuXHRcdH1cblx0XHQsIHNhdmVfbGluayA9IGRvYy5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsIFwiYVwiKVxuXHRcdCwgY2FuX3VzZV9zYXZlX2xpbmsgPSBcImRvd25sb2FkXCIgaW4gc2F2ZV9saW5rXG5cdFx0LCBjbGljayA9IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBldmVudCA9IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIik7XG5cdFx0XHRub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXHRcdH1cblx0XHQsIGlzX3NhZmFyaSA9IC9jb25zdHJ1Y3Rvci9pLnRlc3Qodmlldy5IVE1MRWxlbWVudCkgfHwgdmlldy5zYWZhcmlcblx0XHQsIGlzX2Nocm9tZV9pb3MgPS9DcmlPU1xcL1tcXGRdKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KVxuXHRcdCwgdGhyb3dfb3V0c2lkZSA9IGZ1bmN0aW9uKGV4KSB7XG5cdFx0XHQodmlldy5zZXRJbW1lZGlhdGUgfHwgdmlldy5zZXRUaW1lb3V0KShmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhyb3cgZXg7XG5cdFx0XHR9LCAwKTtcblx0XHR9XG5cdFx0LCBmb3JjZV9zYXZlYWJsZV90eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIlxuXHRcdC8vIHRoZSBCbG9iIEFQSSBpcyBmdW5kYW1lbnRhbGx5IGJyb2tlbiBhcyB0aGVyZSBpcyBubyBcImRvd25sb2FkZmluaXNoZWRcIiBldmVudCB0byBzdWJzY3JpYmUgdG9cblx0XHQsIGFyYml0cmFyeV9yZXZva2VfdGltZW91dCA9IDEwMDAgKiA0MCAvLyBpbiBtc1xuXHRcdCwgcmV2b2tlID0gZnVuY3Rpb24oZmlsZSkge1xuXHRcdFx0dmFyIHJldm9rZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBmaWxlID09PSBcInN0cmluZ1wiKSB7IC8vIGZpbGUgaXMgYW4gb2JqZWN0IFVSTFxuXHRcdFx0XHRcdGdldF9VUkwoKS5yZXZva2VPYmplY3RVUkwoZmlsZSk7XG5cdFx0XHRcdH0gZWxzZSB7IC8vIGZpbGUgaXMgYSBGaWxlXG5cdFx0XHRcdFx0ZmlsZS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHNldFRpbWVvdXQocmV2b2tlciwgYXJiaXRyYXJ5X3Jldm9rZV90aW1lb3V0KTtcblx0XHR9XG5cdFx0LCBkaXNwYXRjaCA9IGZ1bmN0aW9uKGZpbGVzYXZlciwgZXZlbnRfdHlwZXMsIGV2ZW50KSB7XG5cdFx0XHRldmVudF90eXBlcyA9IFtdLmNvbmNhdChldmVudF90eXBlcyk7XG5cdFx0XHR2YXIgaSA9IGV2ZW50X3R5cGVzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gZmlsZXNhdmVyW1wib25cIiArIGV2ZW50X3R5cGVzW2ldXTtcblx0XHRcdFx0aWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbGwoZmlsZXNhdmVyLCBldmVudCB8fCBmaWxlc2F2ZXIpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGV4KSB7XG5cdFx0XHRcdFx0XHR0aHJvd19vdXRzaWRlKGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0LCBhdXRvX2JvbSA9IGZ1bmN0aW9uKGJsb2IpIHtcblx0XHRcdC8vIHByZXBlbmQgQk9NIGZvciBVVEYtOCBYTUwgYW5kIHRleHQvKiB0eXBlcyAoaW5jbHVkaW5nIEhUTUwpXG5cdFx0XHQvLyBub3RlOiB5b3VyIGJyb3dzZXIgd2lsbCBhdXRvbWF0aWNhbGx5IGNvbnZlcnQgVVRGLTE2IFUrRkVGRiB0byBFRiBCQiBCRlxuXHRcdFx0aWYgKC9eXFxzKig/OnRleHRcXC9cXFMqfGFwcGxpY2F0aW9uXFwveG1sfFxcUypcXC9cXFMqXFwreG1sKVxccyo7LipjaGFyc2V0XFxzKj1cXHMqdXRmLTgvaS50ZXN0KGJsb2IudHlwZSkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCbG9iKFtTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkVGRiksIGJsb2JdLCB7dHlwZTogYmxvYi50eXBlfSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmxvYjtcblx0XHR9XG5cdFx0LCBGaWxlU2F2ZXIgPSBmdW5jdGlvbihibG9iLCBuYW1lLCBub19hdXRvX2JvbSkge1xuXHRcdFx0aWYgKCFub19hdXRvX2JvbSkge1xuXHRcdFx0XHRibG9iID0gYXV0b19ib20oYmxvYik7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaXJzdCB0cnkgYS5kb3dubG9hZCwgdGhlbiB3ZWIgZmlsZXN5c3RlbSwgdGhlbiBvYmplY3QgVVJMc1xuXHRcdFx0dmFyXG5cdFx0XHRcdCAgZmlsZXNhdmVyID0gdGhpc1xuXHRcdFx0XHQsIHR5cGUgPSBibG9iLnR5cGVcblx0XHRcdFx0LCBmb3JjZSA9IHR5cGUgPT09IGZvcmNlX3NhdmVhYmxlX3R5cGVcblx0XHRcdFx0LCBvYmplY3RfdXJsXG5cdFx0XHRcdCwgZGlzcGF0Y2hfYWxsID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGlzcGF0Y2goZmlsZXNhdmVyLCBcIndyaXRlc3RhcnQgcHJvZ3Jlc3Mgd3JpdGUgd3JpdGVlbmRcIi5zcGxpdChcIiBcIikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9uIGFueSBmaWxlc3lzIGVycm9ycyByZXZlcnQgdG8gc2F2aW5nIHdpdGggb2JqZWN0IFVSTHNcblx0XHRcdFx0LCBmc19lcnJvciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICgoaXNfY2hyb21lX2lvcyB8fCAoZm9yY2UgJiYgaXNfc2FmYXJpKSkgJiYgdmlldy5GaWxlUmVhZGVyKSB7XG5cdFx0XHRcdFx0XHQvLyBTYWZhcmkgZG9lc24ndCBhbGxvdyBkb3dubG9hZGluZyBvZiBibG9iIHVybHNcblx0XHRcdFx0XHRcdHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXHRcdFx0XHRcdFx0cmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgdXJsID0gaXNfY2hyb21lX2lvcyA/IHJlYWRlci5yZXN1bHQgOiByZWFkZXIucmVzdWx0LnJlcGxhY2UoL15kYXRhOlteO10qOy8sICdkYXRhOmF0dGFjaG1lbnQvZmlsZTsnKTtcblx0XHRcdFx0XHRcdFx0dmFyIHBvcHVwID0gdmlldy5vcGVuKHVybCwgJ19ibGFuaycpO1xuXHRcdFx0XHRcdFx0XHRpZighcG9wdXApIHZpZXcubG9jYXRpb24uaHJlZiA9IHVybDtcblx0XHRcdFx0XHRcdFx0dXJsPXVuZGVmaW5lZDsgLy8gcmVsZWFzZSByZWZlcmVuY2UgYmVmb3JlIGRpc3BhdGNoaW5nXG5cdFx0XHRcdFx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLkRPTkU7XG5cdFx0XHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuXHRcdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuSU5JVDtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgY3JlYXRlIG1vcmUgb2JqZWN0IFVSTHMgdGhhbiBuZWVkZWRcblx0XHRcdFx0XHRpZiAoIW9iamVjdF91cmwpIHtcblx0XHRcdFx0XHRcdG9iamVjdF91cmwgPSBnZXRfVVJMKCkuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoZm9yY2UpIHtcblx0XHRcdFx0XHRcdHZpZXcubG9jYXRpb24uaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHZhciBvcGVuZWQgPSB2aWV3Lm9wZW4ob2JqZWN0X3VybCwgXCJfYmxhbmtcIik7XG5cdFx0XHRcdFx0XHRpZiAoIW9wZW5lZCkge1xuXHRcdFx0XHRcdFx0XHQvLyBBcHBsZSBkb2VzIG5vdCBhbGxvdyB3aW5kb3cub3Blbiwgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS9saWJyYXJ5L3NhZmFyaS9kb2N1bWVudGF0aW9uL1Rvb2xzL0NvbmNlcHR1YWwvU2FmYXJpRXh0ZW5zaW9uR3VpZGUvV29ya2luZ3dpdGhXaW5kb3dzYW5kVGFicy9Xb3JraW5nd2l0aFdpbmRvd3NhbmRUYWJzLmh0bWxcblx0XHRcdFx0XHRcdFx0dmlldy5sb2NhdGlvbi5ocmVmID0gb2JqZWN0X3VybDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZmlsZXNhdmVyLnJlYWR5U3RhdGUgPSBmaWxlc2F2ZXIuRE9ORTtcblx0XHRcdFx0XHRkaXNwYXRjaF9hbGwoKTtcblx0XHRcdFx0XHRyZXZva2Uob2JqZWN0X3VybCk7XG5cdFx0XHRcdH1cblx0XHRcdDtcblx0XHRcdGZpbGVzYXZlci5yZWFkeVN0YXRlID0gZmlsZXNhdmVyLklOSVQ7XG5cblx0XHRcdGlmIChjYW5fdXNlX3NhdmVfbGluaykge1xuXHRcdFx0XHRvYmplY3RfdXJsID0gZ2V0X1VSTCgpLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzYXZlX2xpbmsuaHJlZiA9IG9iamVjdF91cmw7XG5cdFx0XHRcdFx0c2F2ZV9saW5rLmRvd25sb2FkID0gbmFtZTtcblx0XHRcdFx0XHRjbGljayhzYXZlX2xpbmspO1xuXHRcdFx0XHRcdGRpc3BhdGNoX2FsbCgpO1xuXHRcdFx0XHRcdHJldm9rZShvYmplY3RfdXJsKTtcblx0XHRcdFx0XHRmaWxlc2F2ZXIucmVhZHlTdGF0ZSA9IGZpbGVzYXZlci5ET05FO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRmc19lcnJvcigpO1xuXHRcdH1cblx0XHQsIEZTX3Byb3RvID0gRmlsZVNhdmVyLnByb3RvdHlwZVxuXHRcdCwgc2F2ZUFzID0gZnVuY3Rpb24oYmxvYiwgbmFtZSwgbm9fYXV0b19ib20pIHtcblx0XHRcdHJldHVybiBuZXcgRmlsZVNhdmVyKGJsb2IsIG5hbWUgfHwgYmxvYi5uYW1lIHx8IFwiZG93bmxvYWRcIiwgbm9fYXV0b19ib20pO1xuXHRcdH1cblx0O1xuXHQvLyBJRSAxMCsgKG5hdGl2ZSBzYXZlQXMpXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGJsb2IsIG5hbWUsIG5vX2F1dG9fYm9tKSB7XG5cdFx0XHRuYW1lID0gbmFtZSB8fCBibG9iLm5hbWUgfHwgXCJkb3dubG9hZFwiO1xuXG5cdFx0XHRpZiAoIW5vX2F1dG9fYm9tKSB7XG5cdFx0XHRcdGJsb2IgPSBhdXRvX2JvbShibG9iKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYihibG9iLCBuYW1lKTtcblx0XHR9O1xuXHR9XG5cblx0RlNfcHJvdG8uYWJvcnQgPSBmdW5jdGlvbigpe307XG5cdEZTX3Byb3RvLnJlYWR5U3RhdGUgPSBGU19wcm90by5JTklUID0gMDtcblx0RlNfcHJvdG8uV1JJVElORyA9IDE7XG5cdEZTX3Byb3RvLkRPTkUgPSAyO1xuXG5cdEZTX3Byb3RvLmVycm9yID1cblx0RlNfcHJvdG8ub253cml0ZXN0YXJ0ID1cblx0RlNfcHJvdG8ub25wcm9ncmVzcyA9XG5cdEZTX3Byb3RvLm9ud3JpdGUgPVxuXHRGU19wcm90by5vbmFib3J0ID1cblx0RlNfcHJvdG8ub25lcnJvciA9XG5cdEZTX3Byb3RvLm9ud3JpdGVlbmQgPVxuXHRcdG51bGw7XG5cblx0cmV0dXJuIHNhdmVBcztcbn0oXG5cdCAgIHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcblx0fHwgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3dcblx0fHwgdGhpcy5jb250ZW50XG4pKTtcblxuXG4vLyBFeHBvc2UgZmlsZSBzYXZlciBvbiB0aGUgRGF0YVRhYmxlcyBBUEkuIENhbid0IGF0dGFjaCB0byBgRGF0YVRhYmxlcy5CdXR0b25zYFxuLy8gc2luY2UgdGhpcyBmaWxlIGNhbiBiZSBsb2FkZWQgYmVmb3JlIEJ1dHRvbidzIGNvcmUhXG5EYXRhVGFibGUuZmlsZVNhdmUgPSBfc2F2ZUFzO1xuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogTG9jYWwgKHByaXZhdGUpIGZ1bmN0aW9uc1xuICovXG5cbi8qKlxuICogR2V0IHRoZSBzaGVldCBuYW1lIGZvciBFeGNlbCBleHBvcnRzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fVx0Y29uZmlnIEJ1dHRvbiBjb25maWd1cmF0aW9uXG4gKi9cbnZhciBfc2hlZXRuYW1lID0gZnVuY3Rpb24gKCBjb25maWcgKVxue1xuXHR2YXIgc2hlZXROYW1lID0gJ1NoZWV0MSc7XG5cblx0aWYgKCBjb25maWcuc2hlZXROYW1lICkge1xuXHRcdHNoZWV0TmFtZSA9IGNvbmZpZy5zaGVldE5hbWUucmVwbGFjZSgvW1xcW1xcXVxcKlxcL1xcXFxcXD9cXDpdL2csICcnKTtcblx0fVxuXG5cdHJldHVybiBzaGVldE5hbWU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbmV3bGluZSBjaGFyYWN0ZXIocylcbiAqXG4gKiBAcGFyYW0ge29iamVjdH1cdGNvbmZpZyBCdXR0b24gY29uZmlndXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfVx0XHRcdFx0TmV3bGluZSBjaGFyYWN0ZXJcbiAqL1xudmFyIF9uZXdMaW5lID0gZnVuY3Rpb24gKCBjb25maWcgKVxue1xuXHRyZXR1cm4gY29uZmlnLm5ld2xpbmUgP1xuXHRcdGNvbmZpZy5uZXdsaW5lIDpcblx0XHRuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9XaW5kb3dzLykgP1xuXHRcdFx0J1xcclxcbicgOlxuXHRcdFx0J1xcbic7XG59O1xuXG4vKipcbiAqIENvbWJpbmUgdGhlIGRhdGEgZnJvbSB0aGUgYGJ1dHRvbnMuZXhwb3J0RGF0YWAgbWV0aG9kIGludG8gYSBzdHJpbmcgdGhhdFxuICogd2lsbCBiZSB1c2VkIGluIHRoZSBleHBvcnQgZmlsZS5cbiAqXG4gKiBAcGFyYW1cdHtEYXRhVGFibGUuQXBpfSBkdFx0XHQgRGF0YVRhYmxlcyBBUEkgaW5zdGFuY2VcbiAqIEBwYXJhbVx0e29iamVjdH1cdFx0XHRcdGNvbmZpZyBCdXR0b24gY29uZmlndXJhdGlvblxuICogQHJldHVybiB7b2JqZWN0fVx0XHRcdFx0XHRcdFx0IFRoZSBkYXRhIHRvIGV4cG9ydFxuICovXG52YXIgX2V4cG9ydERhdGEgPSBmdW5jdGlvbiAoIGR0LCBjb25maWcgKVxue1xuXHR2YXIgbmV3TGluZSA9IF9uZXdMaW5lKCBjb25maWcgKTtcblx0dmFyIGRhdGEgPSBkdC5idXR0b25zLmV4cG9ydERhdGEoIGNvbmZpZy5leHBvcnRPcHRpb25zICk7XG5cdHZhciBib3VuZGFyeSA9IGNvbmZpZy5maWVsZEJvdW5kYXJ5O1xuXHR2YXIgc2VwYXJhdG9yID0gY29uZmlnLmZpZWxkU2VwYXJhdG9yO1xuXHR2YXIgcmVCb3VuZGFyeSA9IG5ldyBSZWdFeHAoIGJvdW5kYXJ5LCAnZycgKTtcblx0dmFyIGVzY2FwZUNoYXIgPSBjb25maWcuZXNjYXBlQ2hhciAhPT0gdW5kZWZpbmVkID9cblx0XHRjb25maWcuZXNjYXBlQ2hhciA6XG5cdFx0J1xcXFwnO1xuXHR2YXIgam9pbiA9IGZ1bmN0aW9uICggYSApIHtcblx0XHR2YXIgcyA9ICcnO1xuXG5cdFx0Ly8gSWYgdGhlcmUgaXMgYSBmaWVsZCBib3VuZGFyeSwgdGhlbiB3ZSBtaWdodCBuZWVkIHRvIGVzY2FwZSBpdCBpblxuXHRcdC8vIHRoZSBzb3VyY2UgZGF0YVxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1hLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aWYgKCBpID4gMCApIHtcblx0XHRcdFx0cyArPSBzZXBhcmF0b3I7XG5cdFx0XHR9XG5cblx0XHRcdHMgKz0gYm91bmRhcnkgP1xuXHRcdFx0XHRib3VuZGFyeSArICgnJyArIGFbaV0pLnJlcGxhY2UoIHJlQm91bmRhcnksIGVzY2FwZUNoYXIrYm91bmRhcnkgKSArIGJvdW5kYXJ5IDpcblx0XHRcdFx0YVtpXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcztcblx0fTtcblxuXHR2YXIgaGVhZGVyID0gY29uZmlnLmhlYWRlciA/IGpvaW4oIGRhdGEuaGVhZGVyICkrbmV3TGluZSA6ICcnO1xuXHR2YXIgZm9vdGVyID0gY29uZmlnLmZvb3RlciAmJiBkYXRhLmZvb3RlciA/IG5ld0xpbmUram9pbiggZGF0YS5mb290ZXIgKSA6ICcnO1xuXHR2YXIgYm9keSA9IFtdO1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmJvZHkubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0Ym9keS5wdXNoKCBqb2luKCBkYXRhLmJvZHlbaV0gKSApO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzdHI6IGhlYWRlciArIGJvZHkuam9pbiggbmV3TGluZSApICsgZm9vdGVyLFxuXHRcdHJvd3M6IGJvZHkubGVuZ3RoXG5cdH07XG59O1xuXG4vKipcbiAqIE9sZGVyIHZlcnNpb25zIG9mIFNhZmFyaSAocHJpb3IgdG8gdGVjaCBwcmV2aWV3IDE4KSBkb24ndCBzdXBwb3J0IHRoZVxuICogZG93bmxvYWQgb3B0aW9uIHJlcXVpcmVkLlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiBvbGQgU2FmYXJpXG4gKi9cbnZhciBfaXNEdWZmU2FmYXJpID0gZnVuY3Rpb24gKClcbntcblx0dmFyIHNhZmFyaSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignU2FmYXJpJykgIT09IC0xICYmXG5cdFx0bmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdDaHJvbWUnKSA9PT0gLTEgJiZcblx0XHRuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ09wZXJhJykgPT09IC0xO1xuXG5cdGlmICggISBzYWZhcmkgKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0dmFyIHZlcnNpb24gPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCAvQXBwbGVXZWJLaXRcXC8oXFxkK1xcLlxcZCspLyApO1xuXHRpZiAoIHZlcnNpb24gJiYgdmVyc2lvbi5sZW5ndGggPiAxICYmIHZlcnNpb25bMV0qMSA8IDYwMy4xICkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGZyb20gbnVtZXJpYyBwb3NpdGlvbiB0byBsZXR0ZXIgZm9yIGNvbHVtbiBuYW1lcyBpbiBFeGNlbFxuICogQHBhcmFtICB7aW50fSBuIENvbHVtbiBudW1iZXJcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sdW1uIGxldHRlcihzKSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNlbGxQb3MoIG4gKXtcblx0dmFyIG9yZEEgPSAnQScuY2hhckNvZGVBdCgwKTtcblx0dmFyIG9yZFogPSAnWicuY2hhckNvZGVBdCgwKTtcblx0dmFyIGxlbiA9IG9yZFogLSBvcmRBICsgMTtcblx0dmFyIHMgPSBcIlwiO1xuXG5cdHdoaWxlKCBuID49IDAgKSB7XG5cdFx0cyA9IFN0cmluZy5mcm9tQ2hhckNvZGUobiAlIGxlbiArIG9yZEEpICsgcztcblx0XHRuID0gTWF0aC5mbG9vcihuIC8gbGVuKSAtIDE7XG5cdH1cblxuXHRyZXR1cm4gcztcbn1cblxudHJ5IHtcblx0dmFyIF9zZXJpYWxpc2VyID0gbmV3IFhNTFNlcmlhbGl6ZXIoKTtcblx0dmFyIF9pZUV4Y2VsO1xufVxuY2F0Y2ggKHQpIHt9XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgYWRkIFhNTCBmaWxlcyBmcm9tIGFuIG9iamVjdCdzIHN0cnVjdHVyZSB0byBhIFpJUCBmaWxlLiBUaGlzXG4gKiBhbGxvd3MgdGhlIFhTTFggZmlsZSB0byBiZSBlYXNpbHkgZGVmaW5lZCB3aXRoIGFuIG9iamVjdCdzIHN0cnVjdHVyZSBtYXRjaGluZ1xuICogdGhlIGZpbGVzIHN0cnVjdHVyZS5cbiAqXG4gKiBAcGFyYW0ge0pTWmlwfSB6aXAgWklQIHBhY2thZ2VcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmogT2JqZWN0IHRvIGFkZCAocmVjdXJzaXZlKVxuICovXG5mdW5jdGlvbiBfYWRkVG9aaXAoIHppcCwgb2JqICkge1xuXHRpZiAoIF9pZUV4Y2VsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0Ly8gRGV0ZWN0IGlmIHdlIGFyZSBkZWFsaW5nIHdpdGggSUUncyBfYXdmdWxfIHNlcmlhbGlzZXIgYnkgc2VlaW5nIGlmIGl0XG5cdFx0Ly8gZHJvcCBhdHRyaWJ1dGVzXG5cdFx0X2llRXhjZWwgPSBfc2VyaWFsaXNlclxuXHRcdFx0LnNlcmlhbGl6ZVRvU3RyaW5nKFxuXHRcdFx0XHQoIG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkgKS5wYXJzZUZyb21TdHJpbmcoIGV4Y2VsU3RyaW5nc1sneGwvd29ya3NoZWV0cy9zaGVldDEueG1sJ10sICd0ZXh0L3htbCcgKVxuXHRcdFx0KVxuXHRcdFx0LmluZGV4T2YoICd4bWxuczpyJyApID09PSAtMTtcblx0fVxuXG5cdCQuZWFjaCggb2JqLCBmdW5jdGlvbiAoIG5hbWUsIHZhbCApIHtcblx0XHRpZiAoICQuaXNQbGFpbk9iamVjdCggdmFsICkgKSB7XG5cdFx0XHR2YXIgbmV3RGlyID0gemlwLmZvbGRlciggbmFtZSApO1xuXHRcdFx0X2FkZFRvWmlwKCBuZXdEaXIsIHZhbCApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGlmICggX2llRXhjZWwgKSB7XG5cdFx0XHRcdC8vIElFJ3MgWE1MIHNlcmlhbGlzZXIgd2lsbCBkcm9wIHNvbWUgbmFtZSBzcGFjZSBhdHRyaWJ1dGVzIGZyb21cblx0XHRcdFx0Ly8gZnJvbSB0aGUgcm9vdCBub2RlLCBzbyB3ZSBuZWVkIHRvIHNhdmUgdGhlbS4gRG8gdGhpcyBieVxuXHRcdFx0XHQvLyByZXBsYWNpbmcgdGhlIG5hbWVzcGFjZSBub2RlcyB3aXRoIGEgcmVndWxhciBhdHRyaWJ1dGUgdGhhdFxuXHRcdFx0XHQvLyB3ZSBjb252ZXJ0IGJhY2sgd2hlbiBzZXJpYWxpc2VkLiBFZGdlIGRvZXMgbm90IGhhdmUgdGhpc1xuXHRcdFx0XHQvLyBpc3N1ZVxuXHRcdFx0XHR2YXIgd29ya3NoZWV0ID0gdmFsLmNoaWxkTm9kZXNbMF07XG5cdFx0XHRcdHZhciBpLCBpZW47XG5cdFx0XHRcdHZhciBhdHRycyA9IFtdO1xuXG5cdFx0XHRcdGZvciAoIGk9d29ya3NoZWV0LmF0dHJpYnV0ZXMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tICkge1xuXHRcdFx0XHRcdHZhciBhdHRyTmFtZSA9IHdvcmtzaGVldC5hdHRyaWJ1dGVzW2ldLm5vZGVOYW1lO1xuXHRcdFx0XHRcdHZhciBhdHRyVmFsdWUgPSB3b3Jrc2hlZXQuYXR0cmlidXRlc1tpXS5ub2RlVmFsdWU7XG5cblx0XHRcdFx0XHRpZiAoIGF0dHJOYW1lLmluZGV4T2YoICc6JyApICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdGF0dHJzLnB1c2goIHsgbmFtZTogYXR0ck5hbWUsIHZhbHVlOiBhdHRyVmFsdWUgfSApO1xuXG5cdFx0XHRcdFx0XHR3b3Jrc2hlZXQucmVtb3ZlQXR0cmlidXRlKCBhdHRyTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPWF0dHJzLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdHZhciBhdHRyID0gdmFsLmNyZWF0ZUF0dHJpYnV0ZSggYXR0cnNbaV0ubmFtZS5yZXBsYWNlKCAnOicsICdfZHRfYl9uYW1lc3BhY2VfdG9rZW5fJyApICk7XG5cdFx0XHRcdFx0YXR0ci52YWx1ZSA9IGF0dHJzW2ldLnZhbHVlO1xuXHRcdFx0XHRcdHdvcmtzaGVldC5zZXRBdHRyaWJ1dGVOb2RlKCBhdHRyICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0dmFyIHN0ciA9IF9zZXJpYWxpc2VyLnNlcmlhbGl6ZVRvU3RyaW5nKHZhbCk7XG5cblx0XHRcdC8vIEZpeCBJRSdzIFhNTFxuXHRcdFx0aWYgKCBfaWVFeGNlbCApIHtcblx0XHRcdFx0Ly8gSUUgZG9lc24ndCBpbmNsdWRlIHRoZSBYTUwgZGVjbGFyYXRpb25cblx0XHRcdFx0aWYgKCBzdHIuaW5kZXhPZiggJzw/eG1sJyApID09PSAtMSApIHtcblx0XHRcdFx0XHRzdHIgPSAnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/Picrc3RyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5hbWVzcGFjZSBhdHRyaWJ1dGVzIHRvIGJlaW5nIGFzIHN1Y2hcblx0XHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoIC9fZHRfYl9uYW1lc3BhY2VfdG9rZW5fL2csICc6JyApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSB0ZXN0aW5nIG5hbWUgc3BhY2UgdGhhdCBJRSBwdXRzIGludG8gdGhlIHNwYWNlIHByZXNlcnZlIGF0dHJcblx0XHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoIC94bWxuczpOU1tcXGRdKz1cIlwiIE5TW1xcZF0rOi9nLCAnJyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTYWZhcmksIElFIGFuZCBFZGdlIHdpbGwgcHV0IGVtcHR5IG5hbWUgc3BhY2UgYXR0cmlidXRlcyBvbnRvXG5cdFx0XHQvLyB2YXJpb3VzIGVsZW1lbnRzIG1ha2luZyB0aGVtIHVzZWxlc3MuIFRoaXMgc3RyaXBzIHRoZW0gb3V0XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggLzwoW148Pl0qPykgeG1sbnM9XCJcIihbXjw+XSo/KT4vZywgJzwkMSAkMj4nICk7XG5cblx0XHRcdHppcC5maWxlKCBuYW1lLCBzdHIgKTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gWE1MIG5vZGUgYW5kIGFkZCBhbnkgY2hpbGRyZW4sIGF0dHJpYnV0ZXMsIGV0YyB3aXRob3V0IG5lZWRpbmcgdG9cbiAqIGJlIHZlcmJvc2UgaW4gdGhlIERPTS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IGRvYyAgICAgIFhNTCBkb2N1bWVudFxuICogQHBhcmFtICB7c3RyaW5nfSBub2RlTmFtZSBOb2RlIG5hbWVcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0cyAgICAgT3B0aW9ucyAtIGNhbiBiZSBgYXR0cmAgKGF0dHJpYnV0ZXMpLCBgY2hpbGRyZW5gXG4gKiAgIChjaGlsZCBub2RlcykgYW5kIGB0ZXh0YCAodGV4dCBjb250ZW50KVxuICogQHJldHVybiB7bm9kZX0gICAgICAgICAgICBDcmVhdGVkIG5vZGVcbiAqL1xuZnVuY3Rpb24gX2NyZWF0ZU5vZGUoIGRvYywgbm9kZU5hbWUsIG9wdHMgKSB7XG5cdHZhciB0ZW1wTm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCBub2RlTmFtZSApO1xuXG5cdGlmICggb3B0cyApIHtcblx0XHRpZiAoIG9wdHMuYXR0ciApIHtcblx0XHRcdCQodGVtcE5vZGUpLmF0dHIoIG9wdHMuYXR0ciApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0cy5jaGlsZHJlbiApIHtcblx0XHRcdCQuZWFjaCggb3B0cy5jaGlsZHJlbiwgZnVuY3Rpb24gKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHR0ZW1wTm9kZS5hcHBlbmRDaGlsZCggdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIG9wdHMudGV4dCAhPT0gbnVsbCAmJiBvcHRzLnRleHQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRlbXBOb2RlLmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlVGV4dE5vZGUoIG9wdHMudGV4dCApICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRlbXBOb2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2lkdGggZm9yIGFuIEV4Y2VsIGNvbHVtbiBiYXNlZCBvbiB0aGUgY29udGVudHMgb2YgdGhhdCBjb2x1bW5cbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSBEYXRhIGZvciBleHBvcnRcbiAqIEBwYXJhbSAge2ludH0gICAgY29sICBDb2x1bW4gaW5kZXhcbiAqIEByZXR1cm4ge2ludH0gICAgICAgICBDb2x1bW4gd2lkdGhcbiAqL1xuZnVuY3Rpb24gX2V4Y2VsQ29sV2lkdGgoIGRhdGEsIGNvbCApIHtcblx0dmFyIG1heCA9IGRhdGEuaGVhZGVyW2NvbF0ubGVuZ3RoO1xuXHR2YXIgbGVuLCBsaW5lU3BsaXQsIHN0cjtcblxuXHRpZiAoIGRhdGEuZm9vdGVyICYmIGRhdGEuZm9vdGVyW2NvbF0ubGVuZ3RoID4gbWF4ICkge1xuXHRcdG1heCA9IGRhdGEuZm9vdGVyW2NvbF0ubGVuZ3RoO1xuXHR9XG5cblx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEuYm9keS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHR2YXIgcG9pbnQgPSBkYXRhLmJvZHlbaV1bY29sXTtcblx0XHRzdHIgPSBwb2ludCAhPT0gbnVsbCAmJiBwb2ludCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdHBvaW50LnRvU3RyaW5nKCkgOlxuXHRcdFx0Jyc7XG5cblx0XHQvLyBJZiB0aGVyZSBpcyBhIG5ld2xpbmUgY2hhcmFjdGVyLCB3b3Jrb3V0IHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uXG5cdFx0Ly8gYmFzZWQgb24gdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgc3RyaW5nXG5cdFx0aWYgKCBzdHIuaW5kZXhPZignXFxuJykgIT09IC0xICkge1xuXHRcdFx0bGluZVNwbGl0ID0gc3RyLnNwbGl0KCdcXG4nKTtcblx0XHRcdGxpbmVTcGxpdC5zb3J0KCBmdW5jdGlvbiAoYSwgYikge1xuXHRcdFx0XHRyZXR1cm4gYi5sZW5ndGggLSBhLmxlbmd0aDtcblx0XHRcdH0gKTtcblxuXHRcdFx0bGVuID0gbGluZVNwbGl0WzBdLmxlbmd0aDtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsZW4gPSBzdHIubGVuZ3RoO1xuXHRcdH1cblxuXHRcdGlmICggbGVuID4gbWF4ICkge1xuXHRcdFx0bWF4ID0gbGVuO1xuXHRcdH1cblxuXHRcdC8vIE1heCB3aWR0aCByYXRoZXIgdGhhbiBoYXZpbmcgcG90ZW50aWFsbHkgbWFzc2l2ZSBjb2x1bW4gd2lkdGhzXG5cdFx0aWYgKCBtYXggPiA0MCApIHtcblx0XHRcdHJldHVybiA1NDsgLy8gNDAgKiAxLjM1XG5cdFx0fVxuXHR9XG5cblx0bWF4ICo9IDEuMzU7XG5cblx0Ly8gQW5kIGEgbWluIHdpZHRoXG5cdHJldHVybiBtYXggPiA2ID8gbWF4IDogNjtcbn1cblxuLy8gRXhjZWwgLSBQcmUtZGVmaW5lZCBzdHJpbmdzIHRvIGJ1aWxkIGEgYmFzaWMgWExTWCBmaWxlXG52YXIgZXhjZWxTdHJpbmdzID0ge1xuXHRcIl9yZWxzLy5yZWxzXCI6XG5cdFx0Jzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nK1xuXHRcdCc8UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPicrXG5cdFx0XHQnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDFcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy9vZmZpY2VEb2N1bWVudFwiIFRhcmdldD1cInhsL3dvcmtib29rLnhtbFwiLz4nK1xuXHRcdCc8L1JlbGF0aW9uc2hpcHM+JyxcblxuXHRcInhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzXCI6XG5cdFx0Jzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nK1xuXHRcdCc8UmVsYXRpb25zaGlwcyB4bWxucz1cImh0dHA6Ly9zY2hlbWFzLm9wZW54bWxmb3JtYXRzLm9yZy9wYWNrYWdlLzIwMDYvcmVsYXRpb25zaGlwc1wiPicrXG5cdFx0XHQnPFJlbGF0aW9uc2hpcCBJZD1cInJJZDFcIiBUeXBlPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwcy93b3Jrc2hlZXRcIiBUYXJnZXQ9XCJ3b3Jrc2hlZXRzL3NoZWV0MS54bWxcIi8+Jytcblx0XHRcdCc8UmVsYXRpb25zaGlwIElkPVwicklkMlwiIFR5cGU9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvb2ZmaWNlRG9jdW1lbnQvMjAwNi9yZWxhdGlvbnNoaXBzL3N0eWxlc1wiIFRhcmdldD1cInN0eWxlcy54bWxcIi8+Jytcblx0XHQnPC9SZWxhdGlvbnNoaXBzPicsXG5cblx0XCJbQ29udGVudF9UeXBlc10ueG1sXCI6XG5cdFx0Jzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nK1xuXHRcdCc8VHlwZXMgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvcGFja2FnZS8yMDA2L2NvbnRlbnQtdHlwZXNcIj4nK1xuXHRcdFx0JzxEZWZhdWx0IEV4dGVuc2lvbj1cInhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24veG1sXCIgLz4nK1xuXHRcdFx0JzxEZWZhdWx0IEV4dGVuc2lvbj1cInJlbHNcIiBDb250ZW50VHlwZT1cImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1wYWNrYWdlLnJlbGF0aW9uc2hpcHMreG1sXCIgLz4nK1xuXHRcdFx0JzxEZWZhdWx0IEV4dGVuc2lvbj1cImpwZWdcIiBDb250ZW50VHlwZT1cImltYWdlL2pwZWdcIiAvPicrXG5cdFx0XHQnPE92ZXJyaWRlIFBhcnROYW1lPVwiL3hsL3dvcmtib29rLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQubWFpbit4bWxcIiAvPicrXG5cdFx0XHQnPE92ZXJyaWRlIFBhcnROYW1lPVwiL3hsL3dvcmtzaGVldHMvc2hlZXQxLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwud29ya3NoZWV0K3htbFwiIC8+Jytcblx0XHRcdCc8T3ZlcnJpZGUgUGFydE5hbWU9XCIveGwvc3R5bGVzLnhtbFwiIENvbnRlbnRUeXBlPVwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc3R5bGVzK3htbFwiIC8+Jytcblx0XHQnPC9UeXBlcz4nLFxuXG5cdFwieGwvd29ya2Jvb2sueG1sXCI6XG5cdFx0Jzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCIgc3RhbmRhbG9uZT1cInllc1wiPz4nK1xuXHRcdCc8d29ya2Jvb2sgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiPicrXG5cdFx0XHQnPGZpbGVWZXJzaW9uIGFwcE5hbWU9XCJ4bFwiIGxhc3RFZGl0ZWQ9XCI1XCIgbG93ZXN0RWRpdGVkPVwiNVwiIHJ1cEJ1aWxkPVwiMjQ4MTZcIi8+Jytcblx0XHRcdCc8d29ya2Jvb2tQciBzaG93SW5rQW5ub3RhdGlvbj1cIjBcIiBhdXRvQ29tcHJlc3NQaWN0dXJlcz1cIjBcIi8+Jytcblx0XHRcdCc8Ym9va1ZpZXdzPicrXG5cdFx0XHRcdCc8d29ya2Jvb2tWaWV3IHhXaW5kb3c9XCIwXCIgeVdpbmRvdz1cIjBcIiB3aW5kb3dXaWR0aD1cIjI1NjAwXCIgd2luZG93SGVpZ2h0PVwiMTkwMjBcIiB0YWJSYXRpbz1cIjUwMFwiLz4nK1xuXHRcdFx0JzwvYm9va1ZpZXdzPicrXG5cdFx0XHQnPHNoZWV0cz4nK1xuXHRcdFx0XHQnPHNoZWV0IG5hbWU9XCJTaGVldDFcIiBzaGVldElkPVwiMVwiIHI6aWQ9XCJySWQxXCIvPicrXG5cdFx0XHQnPC9zaGVldHM+Jytcblx0XHRcdCc8ZGVmaW5lZE5hbWVzLz4nK1xuXHRcdCc8L3dvcmtib29rPicsXG5cblx0XCJ4bC93b3Jrc2hlZXRzL3NoZWV0MS54bWxcIjpcblx0XHQnPD94bWwgdmVyc2lvbj1cIjEuMFwiIGVuY29kaW5nPVwiVVRGLThcIiBzdGFuZGFsb25lPVwieWVzXCI/PicrXG5cdFx0Jzx3b3Jrc2hlZXQgeG1sbnM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvc3ByZWFkc2hlZXRtbC8yMDA2L21haW5cIiB4bWxuczpyPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL29mZmljZURvY3VtZW50LzIwMDYvcmVsYXRpb25zaGlwc1wiIHhtbG5zOm1jPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL21hcmt1cC1jb21wYXRpYmlsaXR5LzIwMDZcIiBtYzpJZ25vcmFibGU9XCJ4MTRhY1wiIHhtbG5zOngxNGFjPVwiaHR0cDovL3NjaGVtYXMubWljcm9zb2Z0LmNvbS9vZmZpY2Uvc3ByZWFkc2hlZXRtbC8yMDA5LzkvYWNcIj4nK1xuXHRcdFx0JzxzaGVldERhdGEvPicrXG5cdFx0XHQnPG1lcmdlQ2VsbHMgY291bnQ9XCIwXCIvPicrXG5cdFx0Jzwvd29ya3NoZWV0PicsXG5cblx0XCJ4bC9zdHlsZXMueG1sXCI6XG5cdFx0Jzw/eG1sIHZlcnNpb249XCIxLjBcIiBlbmNvZGluZz1cIlVURi04XCI/PicrXG5cdFx0JzxzdHlsZVNoZWV0IHhtbG5zPVwiaHR0cDovL3NjaGVtYXMub3BlbnhtbGZvcm1hdHMub3JnL3NwcmVhZHNoZWV0bWwvMjAwNi9tYWluXCIgeG1sbnM6bWM9XCJodHRwOi8vc2NoZW1hcy5vcGVueG1sZm9ybWF0cy5vcmcvbWFya3VwLWNvbXBhdGliaWxpdHkvMjAwNlwiIG1jOklnbm9yYWJsZT1cIngxNGFjXCIgeG1sbnM6eDE0YWM9XCJodHRwOi8vc2NoZW1hcy5taWNyb3NvZnQuY29tL29mZmljZS9zcHJlYWRzaGVldG1sLzIwMDkvOS9hY1wiPicrXG5cdFx0XHQnPG51bUZtdHMgY291bnQ9XCI2XCI+Jytcblx0XHRcdFx0JzxudW1GbXQgbnVtRm10SWQ9XCIxNjRcIiBmb3JtYXRDb2RlPVwiIywjIzAuMDBfLVxcIFskJC00NUNdXCIvPicrXG5cdFx0XHRcdCc8bnVtRm10IG51bUZtdElkPVwiMTY1XCIgZm9ybWF0Q29kZT1cIiZxdW90O8KjJnF1b3Q7IywjIzAuMDBcIi8+Jytcblx0XHRcdFx0JzxudW1GbXQgbnVtRm10SWQ9XCIxNjZcIiBmb3JtYXRDb2RlPVwiWyTigqwtMl1cXCAjLCMjMC4wMFwiLz4nK1xuXHRcdFx0XHQnPG51bUZtdCBudW1GbXRJZD1cIjE2N1wiIGZvcm1hdENvZGU9XCIwLjAlXCIvPicrXG5cdFx0XHRcdCc8bnVtRm10IG51bUZtdElkPVwiMTY4XCIgZm9ybWF0Q29kZT1cIiMsIyMwOygjLCMjMClcIi8+Jytcblx0XHRcdFx0JzxudW1GbXQgbnVtRm10SWQ9XCIxNjlcIiBmb3JtYXRDb2RlPVwiIywjIzAuMDA7KCMsIyMwLjAwKVwiLz4nK1xuXHRcdFx0JzwvbnVtRm10cz4nK1xuXHRcdFx0Jzxmb250cyBjb3VudD1cIjVcIiB4MTRhYzprbm93bkZvbnRzPVwiMVwiPicrXG5cdFx0XHRcdCc8Zm9udD4nK1xuXHRcdFx0XHRcdCc8c3ogdmFsPVwiMTFcIiAvPicrXG5cdFx0XHRcdFx0JzxuYW1lIHZhbD1cIkNhbGlicmlcIiAvPicrXG5cdFx0XHRcdCc8L2ZvbnQ+Jytcblx0XHRcdFx0Jzxmb250PicrXG5cdFx0XHRcdFx0JzxzeiB2YWw9XCIxMVwiIC8+Jytcblx0XHRcdFx0XHQnPG5hbWUgdmFsPVwiQ2FsaWJyaVwiIC8+Jytcblx0XHRcdFx0XHQnPGNvbG9yIHJnYj1cIkZGRkZGRkZGXCIgLz4nK1xuXHRcdFx0XHQnPC9mb250PicrXG5cdFx0XHRcdCc8Zm9udD4nK1xuXHRcdFx0XHRcdCc8c3ogdmFsPVwiMTFcIiAvPicrXG5cdFx0XHRcdFx0JzxuYW1lIHZhbD1cIkNhbGlicmlcIiAvPicrXG5cdFx0XHRcdFx0JzxiIC8+Jytcblx0XHRcdFx0JzwvZm9udD4nK1xuXHRcdFx0XHQnPGZvbnQ+Jytcblx0XHRcdFx0XHQnPHN6IHZhbD1cIjExXCIgLz4nK1xuXHRcdFx0XHRcdCc8bmFtZSB2YWw9XCJDYWxpYnJpXCIgLz4nK1xuXHRcdFx0XHRcdCc8aSAvPicrXG5cdFx0XHRcdCc8L2ZvbnQ+Jytcblx0XHRcdFx0Jzxmb250PicrXG5cdFx0XHRcdFx0JzxzeiB2YWw9XCIxMVwiIC8+Jytcblx0XHRcdFx0XHQnPG5hbWUgdmFsPVwiQ2FsaWJyaVwiIC8+Jytcblx0XHRcdFx0XHQnPHUgLz4nK1xuXHRcdFx0XHQnPC9mb250PicrXG5cdFx0XHQnPC9mb250cz4nK1xuXHRcdFx0JzxmaWxscyBjb3VudD1cIjZcIj4nK1xuXHRcdFx0XHQnPGZpbGw+Jytcblx0XHRcdFx0XHQnPHBhdHRlcm5GaWxsIHBhdHRlcm5UeXBlPVwibm9uZVwiIC8+Jytcblx0XHRcdFx0JzwvZmlsbD4nK1xuXHRcdFx0XHQnPGZpbGw+JysgLy8gRXhjZWwgYXBwZWFycyB0byB1c2UgdGhpcyBhcyBhIGRvdHRlZCBiYWNrZ3JvdW5kIHJlZ2FyZGxlc3Mgb2YgdmFsdWVzIGJ1dFxuXHRcdFx0XHRcdCc8cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9XCJub25lXCIgLz4nKyAvLyB0byBiZSB2YWxpZCB0byB0aGUgc2NoZW1hLCB1c2UgYSBwYXR0ZXJuRmlsbFxuXHRcdFx0XHQnPC9maWxsPicrXG5cdFx0XHRcdCc8ZmlsbD4nK1xuXHRcdFx0XHRcdCc8cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9XCJzb2xpZFwiPicrXG5cdFx0XHRcdFx0XHQnPGZnQ29sb3IgcmdiPVwiRkZEOUQ5RDlcIiAvPicrXG5cdFx0XHRcdFx0XHQnPGJnQ29sb3IgaW5kZXhlZD1cIjY0XCIgLz4nK1xuXHRcdFx0XHRcdCc8L3BhdHRlcm5GaWxsPicrXG5cdFx0XHRcdCc8L2ZpbGw+Jytcblx0XHRcdFx0JzxmaWxsPicrXG5cdFx0XHRcdFx0JzxwYXR0ZXJuRmlsbCBwYXR0ZXJuVHlwZT1cInNvbGlkXCI+Jytcblx0XHRcdFx0XHRcdCc8ZmdDb2xvciByZ2I9XCJGRkQ5OTc5NVwiIC8+Jytcblx0XHRcdFx0XHRcdCc8YmdDb2xvciBpbmRleGVkPVwiNjRcIiAvPicrXG5cdFx0XHRcdFx0JzwvcGF0dGVybkZpbGw+Jytcblx0XHRcdFx0JzwvZmlsbD4nK1xuXHRcdFx0XHQnPGZpbGw+Jytcblx0XHRcdFx0XHQnPHBhdHRlcm5GaWxsIHBhdHRlcm5UeXBlPVwic29saWRcIj4nK1xuXHRcdFx0XHRcdFx0JzxmZ0NvbG9yIHJnYj1cImZmYzZlZmNlXCIgLz4nK1xuXHRcdFx0XHRcdFx0JzxiZ0NvbG9yIGluZGV4ZWQ9XCI2NFwiIC8+Jytcblx0XHRcdFx0XHQnPC9wYXR0ZXJuRmlsbD4nK1xuXHRcdFx0XHQnPC9maWxsPicrXG5cdFx0XHRcdCc8ZmlsbD4nK1xuXHRcdFx0XHRcdCc8cGF0dGVybkZpbGwgcGF0dGVyblR5cGU9XCJzb2xpZFwiPicrXG5cdFx0XHRcdFx0XHQnPGZnQ29sb3IgcmdiPVwiZmZjNmNmZWZcIiAvPicrXG5cdFx0XHRcdFx0XHQnPGJnQ29sb3IgaW5kZXhlZD1cIjY0XCIgLz4nK1xuXHRcdFx0XHRcdCc8L3BhdHRlcm5GaWxsPicrXG5cdFx0XHRcdCc8L2ZpbGw+Jytcblx0XHRcdCc8L2ZpbGxzPicrXG5cdFx0XHQnPGJvcmRlcnMgY291bnQ9XCIyXCI+Jytcblx0XHRcdFx0Jzxib3JkZXI+Jytcblx0XHRcdFx0XHQnPGxlZnQgLz4nK1xuXHRcdFx0XHRcdCc8cmlnaHQgLz4nK1xuXHRcdFx0XHRcdCc8dG9wIC8+Jytcblx0XHRcdFx0XHQnPGJvdHRvbSAvPicrXG5cdFx0XHRcdFx0JzxkaWFnb25hbCAvPicrXG5cdFx0XHRcdCc8L2JvcmRlcj4nK1xuXHRcdFx0XHQnPGJvcmRlciBkaWFnb25hbFVwPVwiZmFsc2VcIiBkaWFnb25hbERvd249XCJmYWxzZVwiPicrXG5cdFx0XHRcdFx0JzxsZWZ0IHN0eWxlPVwidGhpblwiPicrXG5cdFx0XHRcdFx0XHQnPGNvbG9yIGF1dG89XCIxXCIgLz4nK1xuXHRcdFx0XHRcdCc8L2xlZnQ+Jytcblx0XHRcdFx0XHQnPHJpZ2h0IHN0eWxlPVwidGhpblwiPicrXG5cdFx0XHRcdFx0XHQnPGNvbG9yIGF1dG89XCIxXCIgLz4nK1xuXHRcdFx0XHRcdCc8L3JpZ2h0PicrXG5cdFx0XHRcdFx0Jzx0b3Agc3R5bGU9XCJ0aGluXCI+Jytcblx0XHRcdFx0XHRcdCc8Y29sb3IgYXV0bz1cIjFcIiAvPicrXG5cdFx0XHRcdFx0JzwvdG9wPicrXG5cdFx0XHRcdFx0Jzxib3R0b20gc3R5bGU9XCJ0aGluXCI+Jytcblx0XHRcdFx0XHRcdCc8Y29sb3IgYXV0bz1cIjFcIiAvPicrXG5cdFx0XHRcdFx0JzwvYm90dG9tPicrXG5cdFx0XHRcdFx0JzxkaWFnb25hbCAvPicrXG5cdFx0XHRcdCc8L2JvcmRlcj4nK1xuXHRcdFx0JzwvYm9yZGVycz4nK1xuXHRcdFx0JzxjZWxsU3R5bGVYZnMgY291bnQ9XCIxXCI+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIC8+Jytcblx0XHRcdCc8L2NlbGxTdHlsZVhmcz4nK1xuXHRcdFx0JzxjZWxsWGZzIGNvdW50PVwiNjhcIj4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjFcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIyXCIgZmlsbElkPVwiMlwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjRcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiM1wiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMVwiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIzXCIgZmlsbElkPVwiM1wiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiNFwiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCI0XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjRcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCI0XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjFcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIyXCIgZmlsbElkPVwiNVwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjRcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMVwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIzXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiNFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiMlwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjJcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCIyXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiMlwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjFcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIyXCIgZmlsbElkPVwiM1wiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiM1wiIGZpbGxJZD1cIjNcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjRcIiBmaWxsSWQ9XCIzXCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMVwiIGZpbGxJZD1cIjRcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjJcIiBmaWxsSWQ9XCI0XCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIzXCIgZmlsbElkPVwiNFwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiNFwiIGZpbGxJZD1cIjRcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIxXCIgZmlsbElkPVwiNVwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMlwiIGZpbGxJZD1cIjVcIiBib3JkZXJJZD1cIjFcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjNcIiBmaWxsSWQ9XCI1XCIgYm9yZGVySWQ9XCIxXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCI0XCIgZmlsbElkPVwiNVwiIGJvcmRlcklkPVwiMVwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlBbGlnbm1lbnQ9XCIxXCI+Jytcblx0XHRcdFx0XHQnPGFsaWdubWVudCBob3Jpem9udGFsPVwibGVmdFwiLz4nK1xuXHRcdFx0XHQnPC94Zj4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5QWxpZ25tZW50PVwiMVwiPicrXG5cdFx0XHRcdFx0JzxhbGlnbm1lbnQgaG9yaXpvbnRhbD1cImNlbnRlclwiLz4nK1xuXHRcdFx0XHQnPC94Zj4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5QWxpZ25tZW50PVwiMVwiPicrXG5cdFx0XHRcdFx0JzxhbGlnbm1lbnQgaG9yaXpvbnRhbD1cInJpZ2h0XCIvPicrXG5cdFx0XHRcdCc8L3hmPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIwXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlBbGlnbm1lbnQ9XCIxXCI+Jytcblx0XHRcdFx0XHQnPGFsaWdubWVudCBob3Jpem9udGFsPVwiZmlsbFwiLz4nK1xuXHRcdFx0XHQnPC94Zj4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5QWxpZ25tZW50PVwiMVwiPicrXG5cdFx0XHRcdFx0JzxhbGlnbm1lbnQgdGV4dFJvdGF0aW9uPVwiOTBcIi8+Jytcblx0XHRcdFx0JzwveGY+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjBcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIgeGZJZD1cIjBcIiBhcHBseUFsaWdubWVudD1cIjFcIj4nK1xuXHRcdFx0XHRcdCc8YWxpZ25tZW50IHdyYXBUZXh0PVwiMVwiLz4nK1xuXHRcdFx0XHQnPC94Zj4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiOVwiICAgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIxNjRcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIgeGZJZD1cIjBcIiBhcHBseU51bWJlckZvcm1hdD1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjE2NVwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMTY2XCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIxNjdcIiBmb250SWQ9XCIwXCIgZmlsbElkPVwiMFwiIGJvcmRlcklkPVwiMFwiIGFwcGx5Rm9udD1cIjFcIiBhcHBseUZpbGw9XCIxXCIgYXBwbHlCb3JkZXI9XCIxXCIgeGZJZD1cIjBcIiBhcHBseU51bWJlckZvcm1hdD1cIjFcIi8+Jytcblx0XHRcdFx0Jzx4ZiBudW1GbXRJZD1cIjE2OFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nK1xuXHRcdFx0XHQnPHhmIG51bUZtdElkPVwiMTY5XCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIzXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCI0XCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIxXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIyXCIgZm9udElkPVwiMFwiIGZpbGxJZD1cIjBcIiBib3JkZXJJZD1cIjBcIiBhcHBseUZvbnQ9XCIxXCIgYXBwbHlGaWxsPVwiMVwiIGFwcGx5Qm9yZGVyPVwiMVwiIHhmSWQ9XCIwXCIgYXBwbHlOdW1iZXJGb3JtYXQ9XCIxXCIvPicrXG5cdFx0XHRcdCc8eGYgbnVtRm10SWQ9XCIxNFwiIGZvbnRJZD1cIjBcIiBmaWxsSWQ9XCIwXCIgYm9yZGVySWQ9XCIwXCIgYXBwbHlGb250PVwiMVwiIGFwcGx5RmlsbD1cIjFcIiBhcHBseUJvcmRlcj1cIjFcIiB4ZklkPVwiMFwiIGFwcGx5TnVtYmVyRm9ybWF0PVwiMVwiLz4nK1xuXHRcdFx0JzwvY2VsbFhmcz4nK1xuXHRcdFx0JzxjZWxsU3R5bGVzIGNvdW50PVwiMVwiPicrXG5cdFx0XHRcdCc8Y2VsbFN0eWxlIG5hbWU9XCJOb3JtYWxcIiB4ZklkPVwiMFwiIGJ1aWx0aW5JZD1cIjBcIiAvPicrXG5cdFx0XHQnPC9jZWxsU3R5bGVzPicrXG5cdFx0XHQnPGR4ZnMgY291bnQ9XCIwXCIgLz4nK1xuXHRcdFx0Jzx0YWJsZVN0eWxlcyBjb3VudD1cIjBcIiBkZWZhdWx0VGFibGVTdHlsZT1cIlRhYmxlU3R5bGVNZWRpdW05XCIgZGVmYXVsdFBpdm90U3R5bGU9XCJQaXZvdFN0eWxlTWVkaXVtNFwiIC8+Jytcblx0XHQnPC9zdHlsZVNoZWV0Pidcbn07XG4vLyBOb3RlIHdlIGNvdWxkIHVzZSAzIGBmb3JgIGxvb3BzIGZvciB0aGUgc3R5bGVzLCBidXQgd2hlbiBnemlwcGVkIHRoZXJlIGlzXG4vLyB2aXJ0dWFsbHkgbm8gZGlmZmVyZW5jZSBpbiBzaXplLCBzaW5jZSB0aGUgYWJvdmUgY2FuIGJlIGVhc2lseSBjb21wcmVzc2VkXG5cbi8vIFBhdHRlcm4gbWF0Y2hpbmcgZm9yIHNwZWNpYWwgbnVtYmVyIGZvcm1hdHMuIFBlcmhhcHMgdGhpcyBzaG91bGQgYmUgZXhwb3NlZFxuLy8gdmlhIGFuIEFQSSBpbiBmdXR1cmU/XG4vLyBSZWY6IHNlY3Rpb24gMy44LjMwIC0gYnVpbHQgaW4gZm9ybWF0dGVycyBpbiBvcGVuIHNwcmVhZHNoZWV0XG4vLyAgIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvbmV3cy9UQzQ1X2N1cnJlbnRfd29yay9PZmZpY2UlMjBPcGVuJTIwWE1MJTIwUGFydCUyMDQlMjAtJTIwTWFya3VwJTIwTGFuZ3VhZ2UlMjBSZWZlcmVuY2UucGRmXG52YXIgX2V4Y2VsU3BlY2lhbHMgPSBbXG5cdHsgbWF0Y2g6IC9eXFwtP1xcZCtcXC5cXGQlJC8sICAgICAgICAgICAgICAgc3R5bGU6IDYwLCBmbXQ6IGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLzEwMDsgfSB9LCAvLyBQcmVjZW50IHdpdGggZC5wLlxuXHR7IG1hdGNoOiAvXlxcLT9cXGQrXFwuP1xcZColJC8sICAgICAgICAgICAgIHN0eWxlOiA1NiwgZm10OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC8xMDA7IH0gfSwgLy8gUGVyY2VudFxuXHR7IG1hdGNoOiAvXlxcLT9cXCRbXFxkLF0rLj9cXGQqJC8sICAgICAgICAgIHN0eWxlOiA1NyB9LCAvLyBEb2xsYXJzXG5cdHsgbWF0Y2g6IC9eXFwtP8KjW1xcZCxdKy4/XFxkKiQvLCAgICAgICAgICAgc3R5bGU6IDU4IH0sIC8vIFBvdW5kc1xuXHR7IG1hdGNoOiAvXlxcLT/igqxbXFxkLF0rLj9cXGQqJC8sICAgICAgICAgICBzdHlsZTogNTkgfSwgLy8gRXVyb3Ncblx0eyBtYXRjaDogL15cXC0/XFxkKyQvLCAgICAgICAgICAgICAgICAgICAgc3R5bGU6IDY1IH0sIC8vIE51bWJlcnMgd2l0aG91dCB0aG91c2FuZCBzZXBhcmF0b3JzXG5cdHsgbWF0Y2g6IC9eXFwtP1xcZCtcXC5cXGR7Mn0kLywgICAgICAgICAgICAgc3R5bGU6IDY2IH0sIC8vIE51bWJlcnMgMiBkLnAuIHdpdGhvdXQgdGhvdXNhbmRzIHNlcGFyYXRvcnNcblx0eyBtYXRjaDogL15cXChbXFxkLF0rXFwpJC8sICAgICAgICAgICAgICAgIHN0eWxlOiA2MSwgZm10OiBmdW5jdGlvbiAoZCkgeyByZXR1cm4gLTEgKiBkLnJlcGxhY2UoL1tcXChcXCldL2csICcnKTsgfSB9LCAgLy8gTmVnYXRpdmUgbnVtYmVycyBpbmRpY2F0ZWQgYnkgYnJhY2tldHNcblx0eyBtYXRjaDogL15cXChbXFxkLF0rXFwuXFxkezJ9XFwpJC8sICAgICAgICAgc3R5bGU6IDYyLCBmbXQ6IGZ1bmN0aW9uIChkKSB7IHJldHVybiAtMSAqIGQucmVwbGFjZSgvW1xcKFxcKV0vZywgJycpOyB9IH0sICAvLyBOZWdhdGl2ZSBudW1iZXJzIGluZGljYXRlZCBieSBicmFja2V0cyAtIDJkLnAuXG5cdHsgbWF0Y2g6IC9eXFwtP1tcXGQsXSskLywgICAgICAgICAgICAgICAgIHN0eWxlOiA2MyB9LCAvLyBOdW1iZXJzIHdpdGggdGhvdXNhbmQgc2VwYXJhdG9yc1xuXHR7IG1hdGNoOiAvXlxcLT9bXFxkLF0rXFwuXFxkezJ9JC8sICAgICAgICAgIHN0eWxlOiA2NCB9LFxuXHR7IG1hdGNoOiAvXltcXGRdezR9XFwtW1xcZF17Mn1cXC1bXFxkXXsyfSQvLCBzdHlsZTogNjcsIGZtdDogZnVuY3Rpb24gKGQpIHtyZXR1cm4gTWF0aC5yb3VuZCgyNTU2OSArIChEYXRlLnBhcnNlKGQpIC8gKDg2NDAwICogMTAwMCkpKTt9fSAvL0RhdGUgeXl5eS1tbS1kZFxuXTtcblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKlxuICogQnV0dG9uc1xuICovXG5cbi8vXG4vLyBDb3B5IHRvIGNsaXBib2FyZFxuLy9cbkRhdGFUYWJsZS5leHQuYnV0dG9ucy5jb3B5SHRtbDUgPSB7XG5cdGNsYXNzTmFtZTogJ2J1dHRvbnMtY29weSBidXR0b25zLWh0bWw1JyxcblxuXHR0ZXh0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy5jb3B5JywgJ0NvcHknICk7XG5cdH0sXG5cblx0YWN0aW9uOiBmdW5jdGlvbiAoIGUsIGR0LCBidXR0b24sIGNvbmZpZyApIHtcblx0XHR0aGlzLnByb2Nlc3NpbmcoIHRydWUgKTtcblxuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZXhwb3J0RGF0YSA9IF9leHBvcnREYXRhKCBkdCwgY29uZmlnICk7XG5cdFx0dmFyIGluZm8gPSBkdC5idXR0b25zLmV4cG9ydEluZm8oIGNvbmZpZyApO1xuXHRcdHZhciBuZXdsaW5lID0gX25ld0xpbmUoY29uZmlnKTtcblx0XHR2YXIgb3V0cHV0ID0gZXhwb3J0RGF0YS5zdHI7XG5cdFx0dmFyIGhpZGRlbkRpdiA9ICQoJzxkaXYvPicpXG5cdFx0XHQuY3NzKCB7XG5cdFx0XHRcdGhlaWdodDogMSxcblx0XHRcdFx0d2lkdGg6IDEsXG5cdFx0XHRcdG92ZXJmbG93OiAnaGlkZGVuJyxcblx0XHRcdFx0cG9zaXRpb246ICdmaXhlZCcsXG5cdFx0XHRcdHRvcDogMCxcblx0XHRcdFx0bGVmdDogMFxuXHRcdFx0fSApO1xuXG5cdFx0aWYgKCBpbmZvLnRpdGxlICkge1xuXHRcdFx0b3V0cHV0ID0gaW5mby50aXRsZSArIG5ld2xpbmUgKyBuZXdsaW5lICsgb3V0cHV0O1xuXHRcdH1cblxuXHRcdGlmICggaW5mby5tZXNzYWdlVG9wICkge1xuXHRcdFx0b3V0cHV0ID0gaW5mby5tZXNzYWdlVG9wICsgbmV3bGluZSArIG5ld2xpbmUgKyBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmZvLm1lc3NhZ2VCb3R0b20gKSB7XG5cdFx0XHRvdXRwdXQgPSBvdXRwdXQgKyBuZXdsaW5lICsgbmV3bGluZSArIGluZm8ubWVzc2FnZUJvdHRvbTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy5jdXN0b21pemUgKSB7XG5cdFx0XHRvdXRwdXQgPSBjb25maWcuY3VzdG9taXplKCBvdXRwdXQsIGNvbmZpZywgZHQgKTtcblx0XHR9XG5cblx0XHR2YXIgdGV4dGFyZWEgPSAkKCc8dGV4dGFyZWEgcmVhZG9ubHkvPicpXG5cdFx0XHQudmFsKCBvdXRwdXQgKVxuXHRcdFx0LmFwcGVuZFRvKCBoaWRkZW5EaXYgKTtcblxuXHRcdC8vIEZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgdGhlIGNvcHkgZXhlY0NvbW1hbmQsIHRyeSB0byB1c2UgaXRcblx0XHRpZiAoIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZFN1cHBvcnRlZCgnY29weScpICkge1xuXHRcdFx0aGlkZGVuRGl2LmFwcGVuZFRvKCBkdC50YWJsZSgpLmNvbnRhaW5lcigpICk7XG5cdFx0XHR0ZXh0YXJlYVswXS5mb2N1cygpO1xuXHRcdFx0dGV4dGFyZWFbMF0uc2VsZWN0KCk7XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBzdWNjZXNzZnVsID0gZG9jdW1lbnQuZXhlY0NvbW1hbmQoICdjb3B5JyApO1xuXHRcdFx0XHRoaWRkZW5EaXYucmVtb3ZlKCk7XG5cblx0XHRcdFx0aWYgKHN1Y2Nlc3NmdWwpIHtcblx0XHRcdFx0XHRkdC5idXR0b25zLmluZm8oXG5cdFx0XHRcdFx0XHRkdC5pMThuKCAnYnV0dG9ucy5jb3B5VGl0bGUnLCAnQ29weSB0byBjbGlwYm9hcmQnICksXG5cdFx0XHRcdFx0XHRkdC5pMThuKCAnYnV0dG9ucy5jb3B5U3VjY2VzcycsIHtcblx0XHRcdFx0XHRcdFx0MTogJ0NvcGllZCBvbmUgcm93IHRvIGNsaXBib2FyZCcsXG5cdFx0XHRcdFx0XHRcdF86ICdDb3BpZWQgJWQgcm93cyB0byBjbGlwYm9hcmQnXG5cdFx0XHRcdFx0XHR9LCBleHBvcnREYXRhLnJvd3MgKSxcblx0XHRcdFx0XHRcdDIwMDBcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0dGhpcy5wcm9jZXNzaW5nKCBmYWxzZSApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKHQpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIHNob3cgdGhlIHRleHQgYm94IGFuZCBpbnN0cnVjdCB0aGUgdXNlciB0byB1c2UgaXRcblx0XHR2YXIgbWVzc2FnZSA9ICQoJzxzcGFuPicrZHQuaTE4biggJ2J1dHRvbnMuY29weUtleXMnLFxuXHRcdFx0XHQnUHJlc3MgPGk+Y3RybDwvaT4gb3IgPGk+XFx1MjMxODwvaT4gKyA8aT5DPC9pPiB0byBjb3B5IHRoZSB0YWJsZSBkYXRhPGJyPnRvIHlvdXIgc3lzdGVtIGNsaXBib2FyZC48YnI+PGJyPicrXG5cdFx0XHRcdCdUbyBjYW5jZWwsIGNsaWNrIHRoaXMgbWVzc2FnZSBvciBwcmVzcyBlc2NhcGUuJyApKyc8L3NwYW4+J1xuXHRcdFx0KVxuXHRcdFx0LmFwcGVuZCggaGlkZGVuRGl2ICk7XG5cblx0XHRkdC5idXR0b25zLmluZm8oIGR0LmkxOG4oICdidXR0b25zLmNvcHlUaXRsZScsICdDb3B5IHRvIGNsaXBib2FyZCcgKSwgbWVzc2FnZSwgMCApO1xuXG5cdFx0Ly8gU2VsZWN0IHRoZSB0ZXh0IHNvIHdoZW4gdGhlIHVzZXIgYWN0aXZhdGVzIHRoZWlyIHN5c3RlbSBjbGlwYm9hcmRcblx0XHQvLyBpdCB3aWxsIGNvcHkgdGhhdCB0ZXh0XG5cdFx0dGV4dGFyZWFbMF0uZm9jdXMoKTtcblx0XHR0ZXh0YXJlYVswXS5zZWxlY3QoKTtcblxuXHRcdC8vIEV2ZW50IHRvIGhpZGUgdGhlIG1lc3NhZ2Ugd2hlbiB0aGUgdXNlciBpcyBkb25lXG5cdFx0dmFyIGNvbnRhaW5lciA9ICQobWVzc2FnZSkuY2xvc2VzdCgnLmR0LWJ1dHRvbi1pbmZvJyk7XG5cdFx0dmFyIGNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0Y29udGFpbmVyLm9mZiggJ2NsaWNrLmJ1dHRvbnMtY29weScgKTtcblx0XHRcdCQoZG9jdW1lbnQpLm9mZiggJy5idXR0b25zLWNvcHknICk7XG5cdFx0XHRkdC5idXR0b25zLmluZm8oIGZhbHNlICk7XG5cdFx0fTtcblxuXHRcdGNvbnRhaW5lci5vbiggJ2NsaWNrLmJ1dHRvbnMtY29weScsIGNsb3NlICk7XG5cdFx0JChkb2N1bWVudClcblx0XHRcdC5vbiggJ2tleWRvd24uYnV0dG9ucy1jb3B5JywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKCBlLmtleUNvZGUgPT09IDI3ICkgeyAvLyBlc2Ncblx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHRcdHRoYXQucHJvY2Vzc2luZyggZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQub24oICdjb3B5LmJ1dHRvbnMtY29weSBjdXQuYnV0dG9ucy1jb3B5JywgZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHR0aGF0LnByb2Nlc3NpbmcoIGZhbHNlICk7XG5cdFx0XHR9ICk7XG5cdH0sXG5cblx0ZXhwb3J0T3B0aW9uczoge30sXG5cblx0ZmllbGRTZXBhcmF0b3I6ICdcXHQnLFxuXG5cdGZpZWxkQm91bmRhcnk6ICcnLFxuXG5cdGhlYWRlcjogdHJ1ZSxcblxuXHRmb290ZXI6IGZhbHNlLFxuXG5cdHRpdGxlOiAnKicsXG5cblx0bWVzc2FnZVRvcDogJyonLFxuXG5cdG1lc3NhZ2VCb3R0b206ICcqJ1xufTtcblxuLy9cbi8vIENTViBleHBvcnRcbi8vXG5EYXRhVGFibGUuZXh0LmJ1dHRvbnMuY3N2SHRtbDUgPSB7XG5cdGJvbTogZmFsc2UsXG5cblx0Y2xhc3NOYW1lOiAnYnV0dG9ucy1jc3YgYnV0dG9ucy1odG1sNScsXG5cblx0YXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5GaWxlUmVhZGVyICE9PSB1bmRlZmluZWQgJiYgd2luZG93LkJsb2I7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24gKCBkdCApIHtcblx0XHRyZXR1cm4gZHQuaTE4biggJ2J1dHRvbnMuY3N2JywgJ0NTVicgKTtcblx0fSxcblxuXHRhY3Rpb246IGZ1bmN0aW9uICggZSwgZHQsIGJ1dHRvbiwgY29uZmlnICkge1xuXHRcdHRoaXMucHJvY2Vzc2luZyggdHJ1ZSApO1xuXG5cdFx0Ly8gU2V0IHRoZSB0ZXh0XG5cdFx0dmFyIG91dHB1dCA9IF9leHBvcnREYXRhKCBkdCwgY29uZmlnICkuc3RyO1xuXHRcdHZhciBpbmZvID0gZHQuYnV0dG9ucy5leHBvcnRJbmZvKGNvbmZpZyk7XG5cdFx0dmFyIGNoYXJzZXQgPSBjb25maWcuY2hhcnNldDtcblxuXHRcdGlmICggY29uZmlnLmN1c3RvbWl6ZSApIHtcblx0XHRcdG91dHB1dCA9IGNvbmZpZy5jdXN0b21pemUoIG91dHB1dCwgY29uZmlnLCBkdCApO1xuXHRcdH1cblxuXHRcdGlmICggY2hhcnNldCAhPT0gZmFsc2UgKSB7XG5cdFx0XHRpZiAoICEgY2hhcnNldCApIHtcblx0XHRcdFx0Y2hhcnNldCA9IGRvY3VtZW50LmNoYXJhY3RlclNldCB8fCBkb2N1bWVudC5jaGFyc2V0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNoYXJzZXQgKSB7XG5cdFx0XHRcdGNoYXJzZXQgPSAnO2NoYXJzZXQ9JytjaGFyc2V0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNoYXJzZXQgPSAnJztcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy5ib20gKSB7XG5cdFx0XHRvdXRwdXQgPSAnXFx1ZmVmZicgKyBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0X3NhdmVBcyhcblx0XHRcdG5ldyBCbG9iKCBbb3V0cHV0XSwge3R5cGU6ICd0ZXh0L2NzdicrY2hhcnNldH0gKSxcblx0XHRcdGluZm8uZmlsZW5hbWUsXG5cdFx0XHR0cnVlXG5cdFx0KTtcblxuXHRcdHRoaXMucHJvY2Vzc2luZyggZmFsc2UgKTtcblx0fSxcblxuXHRmaWxlbmFtZTogJyonLFxuXG5cdGV4dGVuc2lvbjogJy5jc3YnLFxuXG5cdGV4cG9ydE9wdGlvbnM6IHt9LFxuXG5cdGZpZWxkU2VwYXJhdG9yOiAnLCcsXG5cblx0ZmllbGRCb3VuZGFyeTogJ1wiJyxcblxuXHRlc2NhcGVDaGFyOiAnXCInLFxuXG5cdGNoYXJzZXQ6IG51bGwsXG5cblx0aGVhZGVyOiB0cnVlLFxuXG5cdGZvb3RlcjogZmFsc2Vcbn07XG5cbi8vXG4vLyBFeGNlbCAoeGxzeCkgZXhwb3J0XG4vL1xuRGF0YVRhYmxlLmV4dC5idXR0b25zLmV4Y2VsSHRtbDUgPSB7XG5cdGNsYXNzTmFtZTogJ2J1dHRvbnMtZXhjZWwgYnV0dG9ucy1odG1sNScsXG5cblx0YXZhaWxhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5GaWxlUmVhZGVyICE9PSB1bmRlZmluZWQgJiYgX2pzWmlwKCkgIT09IHVuZGVmaW5lZCAmJiAhIF9pc0R1ZmZTYWZhcmkoKSAmJiBfc2VyaWFsaXNlcjtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiAoIGR0ICkge1xuXHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy5leGNlbCcsICdFeGNlbCcgKTtcblx0fSxcblxuXHRhY3Rpb246IGZ1bmN0aW9uICggZSwgZHQsIGJ1dHRvbiwgY29uZmlnICkge1xuXHRcdHRoaXMucHJvY2Vzc2luZyggdHJ1ZSApO1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdHZhciByb3dQb3MgPSAwO1xuXHRcdHZhciBkYXRhU3RhcnRSb3csIGRhdGFFbmRSb3c7XG5cdFx0dmFyIGdldFhtbCA9IGZ1bmN0aW9uICggdHlwZSApIHtcblx0XHRcdHZhciBzdHIgPSBleGNlbFN0cmluZ3NbIHR5cGUgXTtcblxuXHRcdFx0Ly9zdHIgPSBzdHIucmVwbGFjZSggL3htbG5zOi9nLCAneG1sbnNfJyApLnJlcGxhY2UoIC9tYzovZywgJ21jXycgKTtcblxuXHRcdFx0cmV0dXJuICQucGFyc2VYTUwoIHN0ciApO1xuXHRcdH07XG5cdFx0dmFyIHJlbHMgPSBnZXRYbWwoJ3hsL3dvcmtzaGVldHMvc2hlZXQxLnhtbCcpO1xuXHRcdHZhciByZWxzR2V0ID0gcmVscy5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJzaGVldERhdGFcIiApWzBdO1xuXG5cdFx0dmFyIHhsc3ggPSB7XG5cdFx0XHRfcmVsczoge1xuXHRcdFx0XHRcIi5yZWxzXCI6IGdldFhtbCgnX3JlbHMvLnJlbHMnKVxuXHRcdFx0fSxcblx0XHRcdHhsOiB7XG5cdFx0XHRcdF9yZWxzOiB7XG5cdFx0XHRcdFx0XCJ3b3JrYm9vay54bWwucmVsc1wiOiBnZXRYbWwoJ3hsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzJylcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJ3b3JrYm9vay54bWxcIjogZ2V0WG1sKCd4bC93b3JrYm9vay54bWwnKSxcblx0XHRcdFx0XCJzdHlsZXMueG1sXCI6IGdldFhtbCgneGwvc3R5bGVzLnhtbCcpLFxuXHRcdFx0XHRcIndvcmtzaGVldHNcIjoge1xuXHRcdFx0XHRcdFwic2hlZXQxLnhtbFwiOiByZWxzXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblx0XHRcdFwiW0NvbnRlbnRfVHlwZXNdLnhtbFwiOiBnZXRYbWwoJ1tDb250ZW50X1R5cGVzXS54bWwnKVxuXHRcdH07XG5cblx0XHR2YXIgZGF0YSA9IGR0LmJ1dHRvbnMuZXhwb3J0RGF0YSggY29uZmlnLmV4cG9ydE9wdGlvbnMgKTtcblx0XHR2YXIgY3VycmVudFJvdywgcm93Tm9kZTtcblx0XHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCByb3cgKSB7XG5cdFx0XHRjdXJyZW50Um93ID0gcm93UG9zKzE7XG5cdFx0XHRyb3dOb2RlID0gX2NyZWF0ZU5vZGUoIHJlbHMsIFwicm93XCIsIHsgYXR0cjoge3I6Y3VycmVudFJvd30gfSApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49cm93Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHQvLyBDb25jYXQgYm90aCB0aGUgQ2VsbCBDb2x1bW5zIGFzIGEgbGV0dGVyIGFuZCB0aGUgUm93IG9mIHRoZSBjZWxsLlxuXHRcdFx0XHR2YXIgY2VsbElkID0gY3JlYXRlQ2VsbFBvcyhpKSArICcnICsgY3VycmVudFJvdztcblx0XHRcdFx0dmFyIGNlbGwgPSBudWxsO1xuXG5cdFx0XHRcdC8vIEZvciBudWxsLCB1bmRlZmluZWQgb2YgYmxhbmsgY2VsbCwgY29udGludWUgc28gaXQgZG9lc24ndCBjcmVhdGUgdGhlIF9jcmVhdGVOb2RlXG5cdFx0XHRcdGlmICggcm93W2ldID09PSBudWxsIHx8IHJvd1tpXSA9PT0gdW5kZWZpbmVkIHx8IHJvd1tpXSA9PT0gJycgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb25maWcuY3JlYXRlRW1wdHlDZWxscyA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdHJvd1tpXSA9ICcnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvcmlnaW5hbENvbnRlbnQgPSByb3dbaV07XG5cdFx0XHRcdHJvd1tpXSA9IHR5cGVvZiByb3dbaV0udHJpbSA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdD8gcm93W2ldLnRyaW0oKVxuXHRcdFx0XHRcdDogcm93W2ldO1xuXG5cdFx0XHRcdC8vIFNwZWNpYWwgbnVtYmVyIGZvcm1hdHRpbmcgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCB2YXIgaj0wLCBqZW49X2V4Y2VsU3BlY2lhbHMubGVuZ3RoIDsgajxqZW4gOyBqKysgKSB7XG5cdFx0XHRcdFx0dmFyIHNwZWNpYWwgPSBfZXhjZWxTcGVjaWFsc1tqXTtcblxuXHRcdFx0XHRcdC8vIFRPRE8gTmVlZCB0byBwcm92aWRlIHRoZSBhYmlsaXR5IGZvciB0aGUgc3BlY2lhbHMgdG8gc2F5XG5cdFx0XHRcdFx0Ly8gaWYgdGhleSBhcmUgcmV0dXJuaW5nIGEgc3RyaW5nLCBzaW5jZSBhdCB0aGUgbW9tZW50IGl0IGlzXG5cdFx0XHRcdFx0Ly8gYXNzdW1lZCB0byBiZSBhIG51bWJlclxuXHRcdFx0XHRcdGlmICggcm93W2ldLm1hdGNoICYmICEgcm93W2ldLm1hdGNoKC9eMFxcZCsvKSAmJiByb3dbaV0ubWF0Y2goIHNwZWNpYWwubWF0Y2ggKSApIHtcblx0XHRcdFx0XHRcdHZhciB2YWwgPSByb3dbaV0ucmVwbGFjZSgvW15cXGRcXC5cXC1dL2csICcnKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsLmZtdCApIHtcblx0XHRcdFx0XHRcdFx0dmFsID0gc3BlY2lhbC5mbXQoIHZhbCApO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjZWxsID0gX2NyZWF0ZU5vZGUoIHJlbHMsICdjJywge1xuXHRcdFx0XHRcdFx0XHRhdHRyOiB7XG5cdFx0XHRcdFx0XHRcdFx0cjogY2VsbElkLFxuXHRcdFx0XHRcdFx0XHRcdHM6IHNwZWNpYWwuc3R5bGVcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW46IFtcblx0XHRcdFx0XHRcdFx0XHRfY3JlYXRlTm9kZSggcmVscywgJ3YnLCB7IHRleHQ6IHZhbCB9IClcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoICEgY2VsbCApIHtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByb3dbaV0gPT09ICdudW1iZXInIHx8IChcblx0XHRcdFx0XHRcdHJvd1tpXS5tYXRjaCAmJlxuXHRcdFx0XHRcdFx0cm93W2ldLm1hdGNoKC9eLT9cXGQrKFxcLlxcZCspPyQvKSAmJlxuXHRcdFx0XHRcdFx0ISByb3dbaV0ubWF0Y2goL14wXFxkKy8pIClcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdC8vIERldGVjdCBudW1iZXJzIC0gZG9uJ3QgbWF0Y2ggbnVtYmVycyB3aXRoIGxlYWRpbmcgemVyb3Ncblx0XHRcdFx0XHRcdC8vIG9yIGEgbmVnYXRpdmUgYW55d2hlcmUgYnV0IHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0Y2VsbCA9IF9jcmVhdGVOb2RlKCByZWxzLCAnYycsIHtcblx0XHRcdFx0XHRcdFx0YXR0cjoge1xuXHRcdFx0XHRcdFx0XHRcdHQ6ICduJyxcblx0XHRcdFx0XHRcdFx0XHRyOiBjZWxsSWRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW46IFtcblx0XHRcdFx0XHRcdFx0XHRfY3JlYXRlTm9kZSggcmVscywgJ3YnLCB7IHRleHQ6IHJvd1tpXSB9IClcblx0XHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRcdC8vIFN0cmluZyBvdXRwdXQgLSByZXBsYWNlIG5vbiBzdGFuZGFyZCBjaGFyYWN0ZXJzIGZvciB0ZXh0IG91dHB1dFxuXHRcdFx0XHRcdFx0dmFyIHRleHQgPSAhIG9yaWdpbmFsQ29udGVudC5yZXBsYWNlID9cblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxDb250ZW50IDpcblx0XHRcdFx0XHRcdFx0b3JpZ2luYWxDb250ZW50LnJlcGxhY2UoL1tcXHgwMC1cXHgwOVxceDBCXFx4MENcXHgwRS1cXHgxRlxceDdGLVxceDlGXS9nLCAnJyk7XG5cblx0XHRcdFx0XHRcdGNlbGwgPSBfY3JlYXRlTm9kZSggcmVscywgJ2MnLCB7XG5cdFx0XHRcdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRcdFx0XHR0OiAnaW5saW5lU3RyJyxcblx0XHRcdFx0XHRcdFx0XHRyOiBjZWxsSWRcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW46e1xuXHRcdFx0XHRcdFx0XHRcdHJvdzogX2NyZWF0ZU5vZGUoIHJlbHMsICdpcycsIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuOiB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJvdzogX2NyZWF0ZU5vZGUoIHJlbHMsICd0Jywge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRleHQ6IHRleHQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXR0cjoge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0J3htbDpzcGFjZSc6ICdwcmVzZXJ2ZSdcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cm93Tm9kZS5hcHBlbmRDaGlsZCggY2VsbCApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZWxzR2V0LmFwcGVuZENoaWxkKHJvd05vZGUpO1xuXHRcdFx0cm93UG9zKys7XG5cdFx0fTtcblxuXHRcdGlmICggY29uZmlnLmN1c3RvbWl6ZURhdGEgKSB7XG5cdFx0XHRjb25maWcuY3VzdG9taXplRGF0YSggZGF0YSApO1xuXHRcdH1cblxuXHRcdHZhciBtZXJnZUNlbGxzID0gZnVuY3Rpb24gKCByb3csIGNvbHNwYW4gKSB7XG5cdFx0XHR2YXIgbWVyZ2VDZWxscyA9ICQoJ21lcmdlQ2VsbHMnLCByZWxzKTtcblxuXHRcdFx0bWVyZ2VDZWxsc1swXS5hcHBlbmRDaGlsZCggX2NyZWF0ZU5vZGUoIHJlbHMsICdtZXJnZUNlbGwnLCB7XG5cdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRyZWY6ICdBJytyb3crJzonK2NyZWF0ZUNlbGxQb3MoY29sc3Bhbikrcm93XG5cdFx0XHRcdH1cblx0XHRcdH0gKSApO1xuXHRcdFx0bWVyZ2VDZWxscy5hdHRyKCAnY291bnQnLCBwYXJzZUZsb2F0KG1lcmdlQ2VsbHMuYXR0ciggJ2NvdW50JyApKSsxICk7XG5cdFx0XHQkKCdyb3c6ZXEoJysocm93LTEpKycpIGMnLCByZWxzKS5hdHRyKCAncycsICc1MScgKTsgLy8gY2VudHJlXG5cdFx0fTtcblxuXHRcdC8vIFRpdGxlIGFuZCB0b3AgbWVzc2FnZXNcblx0XHR2YXIgZXhwb3J0SW5mbyA9IGR0LmJ1dHRvbnMuZXhwb3J0SW5mbyggY29uZmlnICk7XG5cdFx0aWYgKCBleHBvcnRJbmZvLnRpdGxlICkge1xuXHRcdFx0YWRkUm93KCBbZXhwb3J0SW5mby50aXRsZV0sIHJvd1BvcyApO1xuXHRcdFx0bWVyZ2VDZWxscyggcm93UG9zLCBkYXRhLmhlYWRlci5sZW5ndGgtMSApO1xuXHRcdH1cblxuXHRcdGlmICggZXhwb3J0SW5mby5tZXNzYWdlVG9wICkge1xuXHRcdFx0YWRkUm93KCBbZXhwb3J0SW5mby5tZXNzYWdlVG9wXSwgcm93UG9zICk7XG5cdFx0XHRtZXJnZUNlbGxzKCByb3dQb3MsIGRhdGEuaGVhZGVyLmxlbmd0aC0xICk7XG5cdFx0fVxuXG5cblx0XHQvLyBUYWJsZSBpdHNlbGZcblx0XHRpZiAoIGNvbmZpZy5oZWFkZXIgKSB7XG5cdFx0XHRhZGRSb3coIGRhdGEuaGVhZGVyLCByb3dQb3MgKTtcblx0XHRcdCQoJ3JvdzpsYXN0IGMnLCByZWxzKS5hdHRyKCAncycsICcyJyApOyAvLyBib2xkXG5cdFx0fVxuXHRcblx0XHRkYXRhU3RhcnRSb3cgPSByb3dQb3M7XG5cblx0XHRmb3IgKCB2YXIgbj0wLCBpZT1kYXRhLmJvZHkubGVuZ3RoIDsgbjxpZSA7IG4rKyApIHtcblx0XHRcdGFkZFJvdyggZGF0YS5ib2R5W25dLCByb3dQb3MgKTtcblx0XHR9XG5cdFxuXHRcdGRhdGFFbmRSb3cgPSByb3dQb3M7XG5cblx0XHRpZiAoIGNvbmZpZy5mb290ZXIgJiYgZGF0YS5mb290ZXIgKSB7XG5cdFx0XHRhZGRSb3coIGRhdGEuZm9vdGVyLCByb3dQb3MpO1xuXHRcdFx0JCgncm93Omxhc3QgYycsIHJlbHMpLmF0dHIoICdzJywgJzInICk7IC8vIGJvbGRcblx0XHR9XG5cblx0XHQvLyBCZWxvdyB0aGUgdGFibGVcblx0XHRpZiAoIGV4cG9ydEluZm8ubWVzc2FnZUJvdHRvbSApIHtcblx0XHRcdGFkZFJvdyggW2V4cG9ydEluZm8ubWVzc2FnZUJvdHRvbV0sIHJvd1BvcyApO1xuXHRcdFx0bWVyZ2VDZWxscyggcm93UG9zLCBkYXRhLmhlYWRlci5sZW5ndGgtMSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCBjb2x1bW4gd2lkdGhzXG5cdFx0dmFyIGNvbHMgPSBfY3JlYXRlTm9kZSggcmVscywgJ2NvbHMnICk7XG5cdFx0JCgnd29ya3NoZWV0JywgcmVscykucHJlcGVuZCggY29scyApO1xuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWRhdGEuaGVhZGVyLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29scy5hcHBlbmRDaGlsZCggX2NyZWF0ZU5vZGUoIHJlbHMsICdjb2wnLCB7XG5cdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRtaW46IGkrMSxcblx0XHRcdFx0XHRtYXg6IGkrMSxcblx0XHRcdFx0XHR3aWR0aDogX2V4Y2VsQ29sV2lkdGgoIGRhdGEsIGkgKSxcblx0XHRcdFx0XHRjdXN0b21XaWR0aDogMVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHQvLyBXb3JrYm9vayBtb2RpZmljYXRpb25zXG5cdFx0dmFyIHdvcmtib29rID0geGxzeC54bFsnd29ya2Jvb2sueG1sJ107XG5cblx0XHQkKCAnc2hlZXRzIHNoZWV0Jywgd29ya2Jvb2sgKS5hdHRyKCAnbmFtZScsIF9zaGVldG5hbWUoIGNvbmZpZyApICk7XG5cblx0XHQvLyBBdXRvIGZpbHRlciBmb3IgY29sdW1uc1xuXHRcdGlmICggY29uZmlnLmF1dG9GaWx0ZXIgKSB7XG5cdFx0XHQkKCdtZXJnZUNlbGxzJywgcmVscykuYmVmb3JlKCBfY3JlYXRlTm9kZSggcmVscywgJ2F1dG9GaWx0ZXInLCB7XG5cdFx0XHRcdGF0dHI6IHtcblx0XHRcdFx0XHRyZWY6ICdBJytkYXRhU3RhcnRSb3crJzonK2NyZWF0ZUNlbGxQb3MoZGF0YS5oZWFkZXIubGVuZ3RoLTEpK2RhdGFFbmRSb3dcblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cblx0XHRcdCQoJ2RlZmluZWROYW1lcycsIHdvcmtib29rKS5hcHBlbmQoIF9jcmVhdGVOb2RlKCB3b3JrYm9vaywgJ2RlZmluZWROYW1lJywge1xuXHRcdFx0XHRhdHRyOiB7XG5cdFx0XHRcdFx0bmFtZTogJ194bG5tLl9GaWx0ZXJEYXRhYmFzZScsXG5cdFx0XHRcdFx0bG9jYWxTaGVldElkOiAnMCcsXG5cdFx0XHRcdFx0aGlkZGVuOiAxXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRleHQ6IF9zaGVldG5hbWUoY29uZmlnKSsnISRBJCcrZGF0YVN0YXJ0Um93Kyc6JytjcmVhdGVDZWxsUG9zKGRhdGEuaGVhZGVyLmxlbmd0aC0xKStkYXRhRW5kUm93XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHQvLyBMZXQgdGhlIGRldmVsb3BlciBjdXN0b21pc2UgdGhlIGRvY3VtZW50IGlmIHRoZXkgd2FudCB0b1xuXHRcdGlmICggY29uZmlnLmN1c3RvbWl6ZSApIHtcblx0XHRcdGNvbmZpZy5jdXN0b21pemUoIHhsc3gsIGNvbmZpZywgZHQgKTtcblx0XHR9XG5cblx0XHQvLyBFeGNlbCBkb2Vzbid0IGxpa2UgYW4gZW1wdHkgbWVyZ2VDZWxscyB0YWdcblx0XHRpZiAoICQoJ21lcmdlQ2VsbHMnLCByZWxzKS5jaGlsZHJlbigpLmxlbmd0aCA9PT0gMCApIHtcblx0XHRcdCQoJ21lcmdlQ2VsbHMnLCByZWxzKS5yZW1vdmUoKTtcblx0XHR9XG5cblx0XHR2YXIganN6aXAgPSBfanNaaXAoKTtcblx0XHR2YXIgemlwID0gbmV3IGpzemlwKCk7XG5cdFx0dmFyIHppcENvbmZpZyA9IHtcblx0XHRcdHR5cGU6ICdibG9iJyxcblx0XHRcdG1pbWVUeXBlOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnXG5cdFx0fTtcblxuXHRcdF9hZGRUb1ppcCggemlwLCB4bHN4ICk7XG5cblx0XHRpZiAoIHppcC5nZW5lcmF0ZUFzeW5jICkge1xuXHRcdFx0Ly8gSlNaaXAgMytcblx0XHRcdHppcFxuXHRcdFx0XHQuZ2VuZXJhdGVBc3luYyggemlwQ29uZmlnIClcblx0XHRcdFx0LnRoZW4oIGZ1bmN0aW9uICggYmxvYiApIHtcblx0XHRcdFx0XHRfc2F2ZUFzKCBibG9iLCBleHBvcnRJbmZvLmZpbGVuYW1lICk7XG5cdFx0XHRcdFx0dGhhdC5wcm9jZXNzaW5nKCBmYWxzZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gSlNaaXAgMi41XG5cdFx0XHRfc2F2ZUFzKFxuXHRcdFx0XHR6aXAuZ2VuZXJhdGUoIHppcENvbmZpZyApLFxuXHRcdFx0XHRleHBvcnRJbmZvLmZpbGVuYW1lXG5cdFx0XHQpO1xuXHRcdFx0dGhpcy5wcm9jZXNzaW5nKCBmYWxzZSApO1xuXHRcdH1cblx0fSxcblxuXHRmaWxlbmFtZTogJyonLFxuXG5cdGV4dGVuc2lvbjogJy54bHN4JyxcblxuXHRleHBvcnRPcHRpb25zOiB7fSxcblxuXHRoZWFkZXI6IHRydWUsXG5cblx0Zm9vdGVyOiBmYWxzZSxcblxuXHR0aXRsZTogJyonLFxuXG5cdG1lc3NhZ2VUb3A6ICcqJyxcblxuXHRtZXNzYWdlQm90dG9tOiAnKicsXG5cblx0Y3JlYXRlRW1wdHlDZWxsczogZmFsc2UsXG5cblx0YXV0b0ZpbHRlcjogZmFsc2UsXG5cblx0c2hlZXROYW1lOiAnJ1xufTtcblxuLy9cbi8vIFBERiBleHBvcnQgLSB1c2luZyBwZGZNYWtlIC0gaHR0cDovL3BkZm1ha2Uub3JnXG4vL1xuRGF0YVRhYmxlLmV4dC5idXR0b25zLnBkZkh0bWw1ID0ge1xuXHRjbGFzc05hbWU6ICdidXR0b25zLXBkZiBidXR0b25zLWh0bWw1JyxcblxuXHRhdmFpbGFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gd2luZG93LkZpbGVSZWFkZXIgIT09IHVuZGVmaW5lZCAmJiBfcGRmTWFrZSgpO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uICggZHQgKSB7XG5cdFx0cmV0dXJuIGR0LmkxOG4oICdidXR0b25zLnBkZicsICdQREYnICk7XG5cdH0sXG5cblx0YWN0aW9uOiBmdW5jdGlvbiAoIGUsIGR0LCBidXR0b24sIGNvbmZpZyApIHtcblx0XHR0aGlzLnByb2Nlc3NpbmcoIHRydWUgKTtcblxuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHR2YXIgZGF0YSA9IGR0LmJ1dHRvbnMuZXhwb3J0RGF0YSggY29uZmlnLmV4cG9ydE9wdGlvbnMgKTtcblx0XHR2YXIgaW5mbyA9IGR0LmJ1dHRvbnMuZXhwb3J0SW5mbyggY29uZmlnICk7XG5cdFx0dmFyIHJvd3MgPSBbXTtcblxuXHRcdGlmICggY29uZmlnLmhlYWRlciApIHtcblx0XHRcdHJvd3MucHVzaCggJC5tYXAoIGRhdGEuaGVhZGVyLCBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dGV4dDogdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6IGQrJycsXG5cdFx0XHRcdFx0c3R5bGU6ICd0YWJsZUhlYWRlcidcblx0XHRcdFx0fTtcblx0XHRcdH0gKSApO1xuXHRcdH1cblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1kYXRhLmJvZHkubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRyb3dzLnB1c2goICQubWFwKCBkYXRhLmJvZHlbaV0sIGZ1bmN0aW9uICggZCApIHtcblx0XHRcdFx0aWYgKCBkID09PSBudWxsIHx8IGQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0ZXh0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogZCsnJyxcblx0XHRcdFx0XHRzdHlsZTogaSAlIDIgPyAndGFibGVCb2R5RXZlbicgOiAndGFibGVCb2R5T2RkJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBjb25maWcuZm9vdGVyICYmIGRhdGEuZm9vdGVyKSB7XG5cdFx0XHRyb3dzLnB1c2goICQubWFwKCBkYXRhLmZvb3RlciwgZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHRleHQ6IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/IGQgOiBkKycnLFxuXHRcdFx0XHRcdHN0eWxlOiAndGFibGVGb290ZXInXG5cdFx0XHRcdH07XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHR2YXIgZG9jID0ge1xuXHRcdFx0cGFnZVNpemU6IGNvbmZpZy5wYWdlU2l6ZSxcblx0XHRcdHBhZ2VPcmllbnRhdGlvbjogY29uZmlnLm9yaWVudGF0aW9uLFxuXHRcdFx0Y29udGVudDogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGFibGU6IHtcblx0XHRcdFx0XHRcdGhlYWRlclJvd3M6IDEsXG5cdFx0XHRcdFx0XHRib2R5OiByb3dzXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRsYXlvdXQ6ICdub0JvcmRlcnMnXG5cdFx0XHRcdH1cblx0XHRcdF0sXG5cdFx0XHRzdHlsZXM6IHtcblx0XHRcdFx0dGFibGVIZWFkZXI6IHtcblx0XHRcdFx0XHRib2xkOiB0cnVlLFxuXHRcdFx0XHRcdGZvbnRTaXplOiAxMSxcblx0XHRcdFx0XHRjb2xvcjogJ3doaXRlJyxcblx0XHRcdFx0XHRmaWxsQ29sb3I6ICcjMmQ0MTU0Jyxcblx0XHRcdFx0XHRhbGlnbm1lbnQ6ICdjZW50ZXInXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRhYmxlQm9keUV2ZW46IHt9LFxuXHRcdFx0XHR0YWJsZUJvZHlPZGQ6IHtcblx0XHRcdFx0XHRmaWxsQ29sb3I6ICcjZjNmM2YzJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0YWJsZUZvb3Rlcjoge1xuXHRcdFx0XHRcdGJvbGQ6IHRydWUsXG5cdFx0XHRcdFx0Zm9udFNpemU6IDExLFxuXHRcdFx0XHRcdGNvbG9yOiAnd2hpdGUnLFxuXHRcdFx0XHRcdGZpbGxDb2xvcjogJyMyZDQxNTQnXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRpdGxlOiB7XG5cdFx0XHRcdFx0YWxpZ25tZW50OiAnY2VudGVyJyxcblx0XHRcdFx0XHRmb250U2l6ZTogMTVcblx0XHRcdFx0fSxcblx0XHRcdFx0bWVzc2FnZToge31cblx0XHRcdH0sXG5cdFx0XHRkZWZhdWx0U3R5bGU6IHtcblx0XHRcdFx0Zm9udFNpemU6IDEwXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmICggaW5mby5tZXNzYWdlVG9wICkge1xuXHRcdFx0ZG9jLmNvbnRlbnQudW5zaGlmdCgge1xuXHRcdFx0XHR0ZXh0OiBpbmZvLm1lc3NhZ2VUb3AsXG5cdFx0XHRcdHN0eWxlOiAnbWVzc2FnZScsXG5cdFx0XHRcdG1hcmdpbjogWyAwLCAwLCAwLCAxMiBdXG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmZvLm1lc3NhZ2VCb3R0b20gKSB7XG5cdFx0XHRkb2MuY29udGVudC5wdXNoKCB7XG5cdFx0XHRcdHRleHQ6IGluZm8ubWVzc2FnZUJvdHRvbSxcblx0XHRcdFx0c3R5bGU6ICdtZXNzYWdlJyxcblx0XHRcdFx0bWFyZ2luOiBbIDAsIDAsIDAsIDEyIF1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIGluZm8udGl0bGUgKSB7XG5cdFx0XHRkb2MuY29udGVudC51bnNoaWZ0KCB7XG5cdFx0XHRcdHRleHQ6IGluZm8udGl0bGUsXG5cdFx0XHRcdHN0eWxlOiAndGl0bGUnLFxuXHRcdFx0XHRtYXJnaW46IFsgMCwgMCwgMCwgMTIgXVxuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggY29uZmlnLmN1c3RvbWl6ZSApIHtcblx0XHRcdGNvbmZpZy5jdXN0b21pemUoIGRvYywgY29uZmlnLCBkdCApO1xuXHRcdH1cblxuXHRcdHZhciBwZGYgPSBfcGRmTWFrZSgpLmNyZWF0ZVBkZiggZG9jICk7XG5cblx0XHRpZiAoIGNvbmZpZy5kb3dubG9hZCA9PT0gJ29wZW4nICYmICEgX2lzRHVmZlNhZmFyaSgpICkge1xuXHRcdFx0cGRmLm9wZW4oKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRwZGYuZG93bmxvYWQoIGluZm8uZmlsZW5hbWUgKTtcblx0XHR9XG5cblx0XHR0aGlzLnByb2Nlc3NpbmcoIGZhbHNlICk7XG5cdH0sXG5cblx0dGl0bGU6ICcqJyxcblxuXHRmaWxlbmFtZTogJyonLFxuXG5cdGV4dGVuc2lvbjogJy5wZGYnLFxuXG5cdGV4cG9ydE9wdGlvbnM6IHt9LFxuXG5cdG9yaWVudGF0aW9uOiAncG9ydHJhaXQnLFxuXG5cdHBhZ2VTaXplOiAnQTQnLFxuXG5cdGhlYWRlcjogdHJ1ZSxcblxuXHRmb290ZXI6IGZhbHNlLFxuXG5cdG1lc3NhZ2VUb3A6ICcqJyxcblxuXHRtZXNzYWdlQm90dG9tOiAnKicsXG5cblx0Y3VzdG9taXplOiBudWxsLFxuXG5cdGRvd25sb2FkOiAnZG93bmxvYWQnXG59O1xuXG5cbnJldHVybiBEYXRhVGFibGUuQnV0dG9ucztcbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-buttons/js/buttons.html5.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-buttons/js/buttons.print.js":
/*!*****************************************************************!*\
  !*** ./node_modules/datatables.net-buttons/js/buttons.print.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Print button for Buttons and DataTables.\n * 2016 SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! datatables.net */ \"./node_modules/datatables.net/js/jquery.dataTables.js\"), __webpack_require__(/*! datatables.net-buttons */ \"./node_modules/datatables.net-buttons/js/dataTables.buttons.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\nvar _link = document.createElement( 'a' );\n\n/**\n * Clone link and style tags, taking into account the need to change the source\n * path.\n *\n * @param  {node}     el Element to convert\n */\nvar _styleToAbs = function( el ) {\n\tvar url;\n\tvar clone = $(el).clone()[0];\n\tvar linkHost;\n\n\tif ( clone.nodeName.toLowerCase() === 'link' ) {\n\t\tclone.href = _relToAbs( clone.href );\n\t}\n\n\treturn clone.outerHTML;\n};\n\n/**\n * Convert a URL from a relative to an absolute address so it will work\n * correctly in the popup window which has no base URL.\n *\n * @param  {string} href URL\n */\nvar _relToAbs = function( href ) {\n\t// Assign to a link on the original page so the browser will do all the\n\t// hard work of figuring out where the file actually is\n\t_link.href = href;\n\tvar linkHost = _link.host;\n\n\t// IE doesn't have a trailing slash on the host\n\t// Chrome has it on the pathname\n\tif ( linkHost.indexOf('/') === -1 && _link.pathname.indexOf('/') !== 0) {\n\t\tlinkHost += '/';\n\t}\n\n\treturn _link.protocol+\"//\"+linkHost+_link.pathname+_link.search;\n};\n\n\nDataTable.ext.buttons.print = {\n\tclassName: 'buttons-print',\n\n\ttext: function ( dt ) {\n\t\treturn dt.i18n( 'buttons.print', 'Print' );\n\t},\n\n\taction: function ( e, dt, button, config ) {\n\t\tvar data = dt.buttons.exportData(\n\t\t\t$.extend( {decodeEntities: false}, config.exportOptions ) // XSS protection\n\t\t);\n\t\tvar exportInfo = dt.buttons.exportInfo( config );\n\t\tvar columnClasses = dt\n\t\t\t.columns( config.exportOptions.columns )\n\t\t\t.flatten()\n\t\t\t.map( function (idx) {\n\t\t\t\treturn dt.settings()[0].aoColumns[dt.column(idx).index()].sClass;\n\t\t\t} )\n\t\t\t.toArray();\n\n\t\tvar addRow = function ( d, tag ) {\n\t\t\tvar str = '<tr>';\n\n\t\t\tfor ( var i=0, ien=d.length ; i<ien ; i++ ) {\n\t\t\t\t// null and undefined aren't useful in the print output\n\t\t\t\tvar dataOut = d[i] === null || d[i] === undefined ?\n\t\t\t\t\t'' :\n\t\t\t\t\td[i];\n\t\t\t\tvar classAttr = columnClasses[i] ?\n\t\t\t\t\t'class=\"'+columnClasses[i]+'\"' :\n\t\t\t\t\t'';\n\n\t\t\t\tstr += '<'+tag+' '+classAttr+'>'+dataOut+'</'+tag+'>';\n\t\t\t}\n\n\t\t\treturn str + '</tr>';\n\t\t};\n\n\t\t// Construct a table for printing\n\t\tvar html = '<table class=\"'+dt.table().node().className+'\">';\n\n\t\tif ( config.header ) {\n\t\t\thtml += '<thead>'+ addRow( data.header, 'th' ) +'</thead>';\n\t\t}\n\n\t\thtml += '<tbody>';\n\t\tfor ( var i=0, ien=data.body.length ; i<ien ; i++ ) {\n\t\t\thtml += addRow( data.body[i], 'td' );\n\t\t}\n\t\thtml += '</tbody>';\n\n\t\tif ( config.footer && data.footer ) {\n\t\t\thtml += '<tfoot>'+ addRow( data.footer, 'th' ) +'</tfoot>';\n\t\t}\n\t\thtml += '</table>';\n\n\t\t// Open a new window for the printable table\n\t\tvar win = window.open( '', '' );\n\t\twin.document.close();\n\n\t\t// Inject the title and also a copy of the style and link tags from this\n\t\t// document so the table can retain its base styling. Note that we have\n\t\t// to use string manipulation as IE won't allow elements to be created\n\t\t// in the host document and then appended to the new window.\n\t\tvar head = '<title>'+exportInfo.title+'</title>';\n\t\t$('style, link').each( function () {\n\t\t\thead += _styleToAbs( this );\n\t\t} );\n\n\t\ttry {\n\t\t\twin.document.head.innerHTML = head; // Work around for Edge\n\t\t}\n\t\tcatch (e) {\n\t\t\t$(win.document.head).html( head ); // Old IE\n\t\t}\n\n\t\t// Inject the table and other surrounding information\n\t\twin.document.body.innerHTML =\n\t\t\t'<h1>'+exportInfo.title+'</h1>'+\n\t\t\t'<div>'+(exportInfo.messageTop || '')+'</div>'+\n\t\t\thtml+\n\t\t\t'<div>'+(exportInfo.messageBottom || '')+'</div>';\n\n\t\t$(win.document.body).addClass('dt-print-view');\n\n\t\t$('img', win.document.body).each( function ( i, img ) {\n\t\t\timg.setAttribute( 'src', _relToAbs( img.getAttribute('src') ) );\n\t\t} );\n\n\t\tif ( config.customize ) {\n\t\t\tconfig.customize( win, config, dt );\n\t\t}\n\n\t\t// Allow stylesheets time to load\n\t\tvar autoPrint = function () {\n\t\t\tif ( config.autoPrint ) {\n\t\t\t\twin.print(); // blocking - so close will not\n\t\t\t\twin.close(); // execute until this is done\n\t\t\t}\n\t\t};\n\n\t\tif ( navigator.userAgent.match(/Trident\\/\\d.\\d/) ) { // IE needs to call this without a setTimeout\n\t\t\tautoPrint();\n\t\t}\n\t\telse {\n\t\t\twin.setTimeout( autoPrint, 1000 );\n\t\t}\n\t},\n\n\ttitle: '*',\n\n\tmessageTop: '*',\n\n\tmessageBottom: '*',\n\n\texportOptions: {},\n\n\theader: true,\n\n\tfooter: false,\n\n\tautoPrint: true,\n\n\tcustomize: null\n};\n\n\nreturn DataTable.Buttons;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9idXR0b25zLnByaW50LmpzPzRmYmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsa0dBQWdCLEVBQUUsbUhBQXdCLENBQUMsbUNBQUU7QUFDbEU7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFxQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBOztBQUVBLGtCQUFrQjs7QUFFbEI7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0LWJ1dHRvbnMvanMvYnV0dG9ucy5wcmludC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogUHJpbnQgYnV0dG9uIGZvciBCdXR0b25zIGFuZCBEYXRhVGFibGVzLlxuICogMjAxNiBTcHJ5TWVkaWEgTHRkIC0gZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICovXG5cbihmdW5jdGlvbiggZmFjdG9yeSApe1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTURcblx0XHRkZWZpbmUoIFsnanF1ZXJ5JywgJ2RhdGF0YWJsZXMubmV0JywgJ2RhdGF0YWJsZXMubmV0LWJ1dHRvbnMnXSwgZnVuY3Rpb24gKCAkICkge1xuXHRcdFx0cmV0dXJuIGZhY3RvcnkoICQsIHdpbmRvdywgZG9jdW1lbnQgKTtcblx0XHR9ICk7XG5cdH1cblx0ZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyApIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHJvb3QsICQpIHtcblx0XHRcdGlmICggISByb290ICkge1xuXHRcdFx0XHRyb290ID0gd2luZG93O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJCB8fCAhICQuZm4uZGF0YVRhYmxlICkge1xuXHRcdFx0XHQkID0gcmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQnKShyb290LCAkKS4kO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICEgJC5mbi5kYXRhVGFibGUuQnV0dG9ucyApIHtcblx0XHRcdFx0cmVxdWlyZSgnZGF0YXRhYmxlcy5uZXQtYnV0dG9ucycpKHJvb3QsICQpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgcm9vdCwgcm9vdC5kb2N1bWVudCApO1xuXHRcdH07XG5cdH1cblx0ZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdGZhY3RvcnkoIGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCApO1xuXHR9XG59KGZ1bmN0aW9uKCAkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQgKSB7XG4ndXNlIHN0cmljdCc7XG52YXIgRGF0YVRhYmxlID0gJC5mbi5kYXRhVGFibGU7XG5cblxudmFyIF9saW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2EnICk7XG5cbi8qKlxuICogQ2xvbmUgbGluayBhbmQgc3R5bGUgdGFncywgdGFraW5nIGludG8gYWNjb3VudCB0aGUgbmVlZCB0byBjaGFuZ2UgdGhlIHNvdXJjZVxuICogcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtub2RlfSAgICAgZWwgRWxlbWVudCB0byBjb252ZXJ0XG4gKi9cbnZhciBfc3R5bGVUb0FicyA9IGZ1bmN0aW9uKCBlbCApIHtcblx0dmFyIHVybDtcblx0dmFyIGNsb25lID0gJChlbCkuY2xvbmUoKVswXTtcblx0dmFyIGxpbmtIb3N0O1xuXG5cdGlmICggY2xvbmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2xpbmsnICkge1xuXHRcdGNsb25lLmhyZWYgPSBfcmVsVG9BYnMoIGNsb25lLmhyZWYgKTtcblx0fVxuXG5cdHJldHVybiBjbG9uZS5vdXRlckhUTUw7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBVUkwgZnJvbSBhIHJlbGF0aXZlIHRvIGFuIGFic29sdXRlIGFkZHJlc3Mgc28gaXQgd2lsbCB3b3JrXG4gKiBjb3JyZWN0bHkgaW4gdGhlIHBvcHVwIHdpbmRvdyB3aGljaCBoYXMgbm8gYmFzZSBVUkwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBocmVmIFVSTFxuICovXG52YXIgX3JlbFRvQWJzID0gZnVuY3Rpb24oIGhyZWYgKSB7XG5cdC8vIEFzc2lnbiB0byBhIGxpbmsgb24gdGhlIG9yaWdpbmFsIHBhZ2Ugc28gdGhlIGJyb3dzZXIgd2lsbCBkbyBhbGwgdGhlXG5cdC8vIGhhcmQgd29yayBvZiBmaWd1cmluZyBvdXQgd2hlcmUgdGhlIGZpbGUgYWN0dWFsbHkgaXNcblx0X2xpbmsuaHJlZiA9IGhyZWY7XG5cdHZhciBsaW5rSG9zdCA9IF9saW5rLmhvc3Q7XG5cblx0Ly8gSUUgZG9lc24ndCBoYXZlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIGhvc3Rcblx0Ly8gQ2hyb21lIGhhcyBpdCBvbiB0aGUgcGF0aG5hbWVcblx0aWYgKCBsaW5rSG9zdC5pbmRleE9mKCcvJykgPT09IC0xICYmIF9saW5rLnBhdGhuYW1lLmluZGV4T2YoJy8nKSAhPT0gMCkge1xuXHRcdGxpbmtIb3N0ICs9ICcvJztcblx0fVxuXG5cdHJldHVybiBfbGluay5wcm90b2NvbCtcIi8vXCIrbGlua0hvc3QrX2xpbmsucGF0aG5hbWUrX2xpbmsuc2VhcmNoO1xufTtcblxuXG5EYXRhVGFibGUuZXh0LmJ1dHRvbnMucHJpbnQgPSB7XG5cdGNsYXNzTmFtZTogJ2J1dHRvbnMtcHJpbnQnLFxuXG5cdHRleHQ6IGZ1bmN0aW9uICggZHQgKSB7XG5cdFx0cmV0dXJuIGR0LmkxOG4oICdidXR0b25zLnByaW50JywgJ1ByaW50JyApO1xuXHR9LFxuXG5cdGFjdGlvbjogZnVuY3Rpb24gKCBlLCBkdCwgYnV0dG9uLCBjb25maWcgKSB7XG5cdFx0dmFyIGRhdGEgPSBkdC5idXR0b25zLmV4cG9ydERhdGEoXG5cdFx0XHQkLmV4dGVuZCgge2RlY29kZUVudGl0aWVzOiBmYWxzZX0sIGNvbmZpZy5leHBvcnRPcHRpb25zICkgLy8gWFNTIHByb3RlY3Rpb25cblx0XHQpO1xuXHRcdHZhciBleHBvcnRJbmZvID0gZHQuYnV0dG9ucy5leHBvcnRJbmZvKCBjb25maWcgKTtcblx0XHR2YXIgY29sdW1uQ2xhc3NlcyA9IGR0XG5cdFx0XHQuY29sdW1ucyggY29uZmlnLmV4cG9ydE9wdGlvbnMuY29sdW1ucyApXG5cdFx0XHQuZmxhdHRlbigpXG5cdFx0XHQubWFwKCBmdW5jdGlvbiAoaWR4KSB7XG5cdFx0XHRcdHJldHVybiBkdC5zZXR0aW5ncygpWzBdLmFvQ29sdW1uc1tkdC5jb2x1bW4oaWR4KS5pbmRleCgpXS5zQ2xhc3M7XG5cdFx0XHR9IClcblx0XHRcdC50b0FycmF5KCk7XG5cblx0XHR2YXIgYWRkUm93ID0gZnVuY3Rpb24gKCBkLCB0YWcgKSB7XG5cdFx0XHR2YXIgc3RyID0gJzx0cj4nO1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0Ly8gbnVsbCBhbmQgdW5kZWZpbmVkIGFyZW4ndCB1c2VmdWwgaW4gdGhlIHByaW50IG91dHB1dFxuXHRcdFx0XHR2YXIgZGF0YU91dCA9IGRbaV0gPT09IG51bGwgfHwgZFtpXSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0XHQnJyA6XG5cdFx0XHRcdFx0ZFtpXTtcblx0XHRcdFx0dmFyIGNsYXNzQXR0ciA9IGNvbHVtbkNsYXNzZXNbaV0gP1xuXHRcdFx0XHRcdCdjbGFzcz1cIicrY29sdW1uQ2xhc3Nlc1tpXSsnXCInIDpcblx0XHRcdFx0XHQnJztcblxuXHRcdFx0XHRzdHIgKz0gJzwnK3RhZysnICcrY2xhc3NBdHRyKyc+JytkYXRhT3V0Kyc8LycrdGFnKyc+Jztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHN0ciArICc8L3RyPic7XG5cdFx0fTtcblxuXHRcdC8vIENvbnN0cnVjdCBhIHRhYmxlIGZvciBwcmludGluZ1xuXHRcdHZhciBodG1sID0gJzx0YWJsZSBjbGFzcz1cIicrZHQudGFibGUoKS5ub2RlKCkuY2xhc3NOYW1lKydcIj4nO1xuXG5cdFx0aWYgKCBjb25maWcuaGVhZGVyICkge1xuXHRcdFx0aHRtbCArPSAnPHRoZWFkPicrIGFkZFJvdyggZGF0YS5oZWFkZXIsICd0aCcgKSArJzwvdGhlYWQ+Jztcblx0XHR9XG5cblx0XHRodG1sICs9ICc8dGJvZHk+Jztcblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49ZGF0YS5ib2R5Lmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0aHRtbCArPSBhZGRSb3coIGRhdGEuYm9keVtpXSwgJ3RkJyApO1xuXHRcdH1cblx0XHRodG1sICs9ICc8L3Rib2R5Pic7XG5cblx0XHRpZiAoIGNvbmZpZy5mb290ZXIgJiYgZGF0YS5mb290ZXIgKSB7XG5cdFx0XHRodG1sICs9ICc8dGZvb3Q+JysgYWRkUm93KCBkYXRhLmZvb3RlciwgJ3RoJyApICsnPC90Zm9vdD4nO1xuXHRcdH1cblx0XHRodG1sICs9ICc8L3RhYmxlPic7XG5cblx0XHQvLyBPcGVuIGEgbmV3IHdpbmRvdyBmb3IgdGhlIHByaW50YWJsZSB0YWJsZVxuXHRcdHZhciB3aW4gPSB3aW5kb3cub3BlbiggJycsICcnICk7XG5cdFx0d2luLmRvY3VtZW50LmNsb3NlKCk7XG5cblx0XHQvLyBJbmplY3QgdGhlIHRpdGxlIGFuZCBhbHNvIGEgY29weSBvZiB0aGUgc3R5bGUgYW5kIGxpbmsgdGFncyBmcm9tIHRoaXNcblx0XHQvLyBkb2N1bWVudCBzbyB0aGUgdGFibGUgY2FuIHJldGFpbiBpdHMgYmFzZSBzdHlsaW5nLiBOb3RlIHRoYXQgd2UgaGF2ZVxuXHRcdC8vIHRvIHVzZSBzdHJpbmcgbWFuaXB1bGF0aW9uIGFzIElFIHdvbid0IGFsbG93IGVsZW1lbnRzIHRvIGJlIGNyZWF0ZWRcblx0XHQvLyBpbiB0aGUgaG9zdCBkb2N1bWVudCBhbmQgdGhlbiBhcHBlbmRlZCB0byB0aGUgbmV3IHdpbmRvdy5cblx0XHR2YXIgaGVhZCA9ICc8dGl0bGU+JytleHBvcnRJbmZvLnRpdGxlKyc8L3RpdGxlPic7XG5cdFx0JCgnc3R5bGUsIGxpbmsnKS5lYWNoKCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRoZWFkICs9IF9zdHlsZVRvQWJzKCB0aGlzICk7XG5cdFx0fSApO1xuXG5cdFx0dHJ5IHtcblx0XHRcdHdpbi5kb2N1bWVudC5oZWFkLmlubmVySFRNTCA9IGhlYWQ7IC8vIFdvcmsgYXJvdW5kIGZvciBFZGdlXG5cdFx0fVxuXHRcdGNhdGNoIChlKSB7XG5cdFx0XHQkKHdpbi5kb2N1bWVudC5oZWFkKS5odG1sKCBoZWFkICk7IC8vIE9sZCBJRVxuXHRcdH1cblxuXHRcdC8vIEluamVjdCB0aGUgdGFibGUgYW5kIG90aGVyIHN1cnJvdW5kaW5nIGluZm9ybWF0aW9uXG5cdFx0d2luLmRvY3VtZW50LmJvZHkuaW5uZXJIVE1MID1cblx0XHRcdCc8aDE+JytleHBvcnRJbmZvLnRpdGxlKyc8L2gxPicrXG5cdFx0XHQnPGRpdj4nKyhleHBvcnRJbmZvLm1lc3NhZ2VUb3AgfHwgJycpKyc8L2Rpdj4nK1xuXHRcdFx0aHRtbCtcblx0XHRcdCc8ZGl2PicrKGV4cG9ydEluZm8ubWVzc2FnZUJvdHRvbSB8fCAnJykrJzwvZGl2Pic7XG5cblx0XHQkKHdpbi5kb2N1bWVudC5ib2R5KS5hZGRDbGFzcygnZHQtcHJpbnQtdmlldycpO1xuXG5cdFx0JCgnaW1nJywgd2luLmRvY3VtZW50LmJvZHkpLmVhY2goIGZ1bmN0aW9uICggaSwgaW1nICkge1xuXHRcdFx0aW1nLnNldEF0dHJpYnV0ZSggJ3NyYycsIF9yZWxUb0FicyggaW1nLmdldEF0dHJpYnV0ZSgnc3JjJykgKSApO1xuXHRcdH0gKTtcblxuXHRcdGlmICggY29uZmlnLmN1c3RvbWl6ZSApIHtcblx0XHRcdGNvbmZpZy5jdXN0b21pemUoIHdpbiwgY29uZmlnLCBkdCApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IHN0eWxlc2hlZXRzIHRpbWUgdG8gbG9hZFxuXHRcdHZhciBhdXRvUHJpbnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoIGNvbmZpZy5hdXRvUHJpbnQgKSB7XG5cdFx0XHRcdHdpbi5wcmludCgpOyAvLyBibG9ja2luZyAtIHNvIGNsb3NlIHdpbGwgbm90XG5cdFx0XHRcdHdpbi5jbG9zZSgpOyAvLyBleGVjdXRlIHVudGlsIHRoaXMgaXMgZG9uZVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRpZiAoIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1RyaWRlbnRcXC9cXGQuXFxkLykgKSB7IC8vIElFIG5lZWRzIHRvIGNhbGwgdGhpcyB3aXRob3V0IGEgc2V0VGltZW91dFxuXHRcdFx0YXV0b1ByaW50KCk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0d2luLnNldFRpbWVvdXQoIGF1dG9QcmludCwgMTAwMCApO1xuXHRcdH1cblx0fSxcblxuXHR0aXRsZTogJyonLFxuXG5cdG1lc3NhZ2VUb3A6ICcqJyxcblxuXHRtZXNzYWdlQm90dG9tOiAnKicsXG5cblx0ZXhwb3J0T3B0aW9uczoge30sXG5cblx0aGVhZGVyOiB0cnVlLFxuXG5cdGZvb3RlcjogZmFsc2UsXG5cblx0YXV0b1ByaW50OiB0cnVlLFxuXG5cdGN1c3RvbWl6ZTogbnVsbFxufTtcblxuXG5yZXR1cm4gRGF0YVRhYmxlLkJ1dHRvbnM7XG59KSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-buttons/js/buttons.print.js\n");

/***/ }),

/***/ "./node_modules/datatables.net-buttons/js/dataTables.buttons.js":
/*!**********************************************************************!*\
  !*** ./node_modules/datatables.net-buttons/js/dataTables.buttons.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! Buttons for DataTables 1.6.5\n * 2016-2020 SpryMedia Ltd - datatables.net/license\n */\n\n(function( factory ){\n\tif ( true ) {\n\t\t// AMD\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! datatables.net */ \"./node_modules/datatables.net/js/jquery.dataTables.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ( $ ) {\n\t\t\treturn factory( $, window, document );\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t}\n\telse {}\n}(function( $, window, document, undefined ) {\n'use strict';\nvar DataTable = $.fn.dataTable;\n\n\n// Used for namespacing events added to the document by each instance, so they\n// can be removed on destroy\nvar _instCounter = 0;\n\n// Button namespacing counter for namespacing events on individual buttons\nvar _buttonCounter = 0;\n\nvar _dtButtons = DataTable.ext.buttons;\n\n// Allow for jQuery slim\nfunction _fadeIn(el, duration, fn) {\n\tif ($.fn.animate) {\n\t\tel\n\t\t\t.stop()\n\t\t\t.fadeIn( duration, fn );\n\t}\n\telse {\n\t\tel.css('display', 'block');\n\n\t\tif (fn) {\n\t\t\tfn.call(el);\n\t\t}\n\t}\n}\n\nfunction _fadeOut(el, duration, fn) {\n\tif ($.fn.animate) {\n\t\tel\n\t\t\t.stop()\n\t\t\t.fadeOut( duration, fn );\n\t}\n\telse {\n\t\tel.css('display', 'none');\n\t\t\n\t\tif (fn) {\n\t\t\tfn.call(el);\n\t\t}\n\t}\n}\n\n/**\n * [Buttons description]\n * @param {[type]}\n * @param {[type]}\n */\nvar Buttons = function( dt, config )\n{\n\t// If not created with a `new` keyword then we return a wrapper function that\n\t// will take the settings object for a DT. This allows easy use of new instances\n\t// with the `layout` option - e.g. `topLeft: $.fn.dataTable.Buttons( ... )`.\n\tif ( !(this instanceof Buttons) ) {\n\t\treturn function (settings) {\n\t\t\treturn new Buttons( settings, dt ).container();\n\t\t};\n\t}\n\n\t// If there is no config set it to an empty object\n\tif ( typeof( config ) === 'undefined' ) {\n\t\tconfig = {};\t\n\t}\n\t\n\t// Allow a boolean true for defaults\n\tif ( config === true ) {\n\t\tconfig = {};\n\t}\n\n\t// For easy configuration of buttons an array can be given\n\tif ( Array.isArray( config ) ) {\n\t\tconfig = { buttons: config };\n\t}\n\n\tthis.c = $.extend( true, {}, Buttons.defaults, config );\n\n\t// Don't want a deep copy for the buttons\n\tif ( config.buttons ) {\n\t\tthis.c.buttons = config.buttons;\n\t}\n\n\tthis.s = {\n\t\tdt: new DataTable.Api( dt ),\n\t\tbuttons: [],\n\t\tlistenKeys: '',\n\t\tnamespace: 'dtb'+(_instCounter++)\n\t};\n\n\tthis.dom = {\n\t\tcontainer: $('<'+this.c.dom.container.tag+'/>')\n\t\t\t.addClass( this.c.dom.container.className )\n\t};\n\n\tthis._constructor();\n};\n\n\n$.extend( Buttons.prototype, {\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Public methods\n\t */\n\n\t/**\n\t * Get the action of a button\n\t * @param  {int|string} Button index\n\t * @return {function}\n\t *//**\n\t * Set the action of a button\n\t * @param  {node} node Button element\n\t * @param  {function} action Function to set\n\t * @return {Buttons} Self for chaining\n\t */\n\taction: function ( node, action )\n\t{\n\t\tvar button = this._nodeToButton( node );\n\n\t\tif ( action === undefined ) {\n\t\t\treturn button.conf.action;\n\t\t}\n\n\t\tbutton.conf.action = action;\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Add an active class to the button to make to look active or get current\n\t * active state.\n\t * @param  {node} node Button element\n\t * @param  {boolean} [flag] Enable / disable flag\n\t * @return {Buttons} Self for chaining or boolean for getter\n\t */\n\tactive: function ( node, flag ) {\n\t\tvar button = this._nodeToButton( node );\n\t\tvar klass = this.c.dom.button.active;\n\t\tvar jqNode = $(button.node);\n\n\t\tif ( flag === undefined ) {\n\t\t\treturn jqNode.hasClass( klass );\n\t\t}\n\n\t\tjqNode.toggleClass( klass, flag === undefined ? true : flag );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Add a new button\n\t * @param {object} config Button configuration object, base string name or function\n\t * @param {int|string} [idx] Button index for where to insert the button\n\t * @return {Buttons} Self for chaining\n\t */\n\tadd: function ( config, idx )\n\t{\n\t\tvar buttons = this.s.buttons;\n\n\t\tif ( typeof idx === 'string' ) {\n\t\t\tvar split = idx.split('-');\n\t\t\tvar base = this.s;\n\n\t\t\tfor ( var i=0, ien=split.length-1 ; i<ien ; i++ ) {\n\t\t\t\tbase = base.buttons[ split[i]*1 ];\n\t\t\t}\n\n\t\t\tbuttons = base.buttons;\n\t\t\tidx = split[ split.length-1 ]*1;\n\t\t}\n\n\t\tthis._expandButton( buttons, config, base !== undefined, idx );\n\t\tthis._draw();\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get the container node for the buttons\n\t * @return {jQuery} Buttons node\n\t */\n\tcontainer: function ()\n\t{\n\t\treturn this.dom.container;\n\t},\n\n\t/**\n\t * Disable a button\n\t * @param  {node} node Button node\n\t * @return {Buttons} Self for chaining\n\t */\n\tdisable: function ( node ) {\n\t\tvar button = this._nodeToButton( node );\n\n\t\t$(button.node)\n\t\t\t.addClass( this.c.dom.button.disabled )\n\t\t\t.attr('disabled', true);\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Destroy the instance, cleaning up event handlers and removing DOM\n\t * elements\n\t * @return {Buttons} Self for chaining\n\t */\n\tdestroy: function ()\n\t{\n\t\t// Key event listener\n\t\t$('body').off( 'keyup.'+this.s.namespace );\n\n\t\t// Individual button destroy (so they can remove their own events if\n\t\t// needed). Take a copy as the array is modified by `remove`\n\t\tvar buttons = this.s.buttons.slice();\n\t\tvar i, ien;\n\t\t\n\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tthis.remove( buttons[i].node );\n\t\t}\n\n\t\t// Container\n\t\tthis.dom.container.remove();\n\n\t\t// Remove from the settings object collection\n\t\tvar buttonInsts = this.s.dt.settings()[0];\n\n\t\tfor ( i=0, ien=buttonInsts.length ; i<ien ; i++ ) {\n\t\t\tif ( buttonInsts.inst === this ) {\n\t\t\t\tbuttonInsts.splice( i, 1 );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Enable / disable a button\n\t * @param  {node} node Button node\n\t * @param  {boolean} [flag=true] Enable / disable flag\n\t * @return {Buttons} Self for chaining\n\t */\n\tenable: function ( node, flag )\n\t{\n\t\tif ( flag === false ) {\n\t\t\treturn this.disable( node );\n\t\t}\n\n\t\tvar button = this._nodeToButton( node );\n\t\t$(button.node)\n\t\t\t.removeClass( this.c.dom.button.disabled )\n\t\t\t.removeAttr('disabled');\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get the instance name for the button set selector\n\t * @return {string} Instance name\n\t */\n\tname: function ()\n\t{\n\t\treturn this.c.name;\n\t},\n\n\t/**\n\t * Get a button's node of the buttons container if no button is given\n\t * @param  {node} [node] Button node\n\t * @return {jQuery} Button element, or container\n\t */\n\tnode: function ( node )\n\t{\n\t\tif ( ! node ) {\n\t\t\treturn this.dom.container;\n\t\t}\n\n\t\tvar button = this._nodeToButton( node );\n\t\treturn $(button.node);\n\t},\n\n\t/**\n\t * Set / get a processing class on the selected button\n\t * @param {element} node Triggering button node\n\t * @param  {boolean} flag true to add, false to remove, undefined to get\n\t * @return {boolean|Buttons} Getter value or this if a setter.\n\t */\n\tprocessing: function ( node, flag )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar button = this._nodeToButton( node );\n\n\t\tif ( flag === undefined ) {\n\t\t\treturn $(button.node).hasClass( 'processing' );\n\t\t}\n\n\t\t$(button.node).toggleClass( 'processing', flag );\n\n\t\t$(dt.table().node()).triggerHandler( 'buttons-processing.dt', [\n\t\t\tflag, dt.button( node ), dt, $(node), button.conf\n\t\t] );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Remove a button.\n\t * @param  {node} node Button node\n\t * @return {Buttons} Self for chaining\n\t */\n\tremove: function ( node )\n\t{\n\t\tvar button = this._nodeToButton( node );\n\t\tvar host = this._nodeToHost( node );\n\t\tvar dt = this.s.dt;\n\n\t\t// Remove any child buttons first\n\t\tif ( button.buttons.length ) {\n\t\t\tfor ( var i=button.buttons.length-1 ; i>=0 ; i-- ) {\n\t\t\t\tthis.remove( button.buttons[i].node );\n\t\t\t}\n\t\t}\n\n\t\t// Allow the button to remove event handlers, etc\n\t\tif ( button.conf.destroy ) {\n\t\t\tbutton.conf.destroy.call( dt.button(node), dt, $(node), button.conf );\n\t\t}\n\n\t\tthis._removeKey( button.conf );\n\n\t\t$(button.node).remove();\n\n\t\tvar idx = $.inArray( button, host );\n\t\thost.splice( idx, 1 );\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get the text for a button\n\t * @param  {int|string} node Button index\n\t * @return {string} Button text\n\t *//**\n\t * Set the text for a button\n\t * @param  {int|string|function} node Button index\n\t * @param  {string} label Text\n\t * @return {Buttons} Self for chaining\n\t */\n\ttext: function ( node, label )\n\t{\n\t\tvar button = this._nodeToButton( node );\n\t\tvar buttonLiner = this.c.dom.collection.buttonLiner;\n\t\tvar linerTag = button.inCollection && buttonLiner && buttonLiner.tag ?\n\t\t\tbuttonLiner.tag :\n\t\t\tthis.c.dom.buttonLiner.tag;\n\t\tvar dt = this.s.dt;\n\t\tvar jqNode = $(button.node);\n\t\tvar text = function ( opt ) {\n\t\t\treturn typeof opt === 'function' ?\n\t\t\t\topt( dt, jqNode, button.conf ) :\n\t\t\t\topt;\n\t\t};\n\n\t\tif ( label === undefined ) {\n\t\t\treturn text( button.conf.text );\n\t\t}\n\n\t\tbutton.conf.text = label;\n\n\t\tif ( linerTag ) {\n\t\t\tjqNode.children( linerTag ).html( text(label) );\n\t\t}\n\t\telse {\n\t\t\tjqNode.html( text(label) );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Constructor\n\t */\n\n\t/**\n\t * Buttons constructor\n\t * @private\n\t */\n\t_constructor: function ()\n\t{\n\t\tvar that = this;\n\t\tvar dt = this.s.dt;\n\t\tvar dtSettings = dt.settings()[0];\n\t\tvar buttons =  this.c.buttons;\n\n\t\tif ( ! dtSettings._buttons ) {\n\t\t\tdtSettings._buttons = [];\n\t\t}\n\n\t\tdtSettings._buttons.push( {\n\t\t\tinst: this,\n\t\t\tname: this.c.name\n\t\t} );\n\n\t\tfor ( var i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tthis.add( buttons[i] );\n\t\t}\n\n\t\tdt.on( 'destroy', function ( e, settings ) {\n\t\t\tif ( settings === dtSettings ) {\n\t\t\t\tthat.destroy();\n\t\t\t}\n\t\t} );\n\n\t\t// Global key event binding to listen for button keys\n\t\t$('body').on( 'keyup.'+this.s.namespace, function ( e ) {\n\t\t\tif ( ! document.activeElement || document.activeElement === document.body ) {\n\t\t\t\t// SUse a string of characters for fast lookup of if we need to\n\t\t\t\t// handle this\n\t\t\t\tvar character = String.fromCharCode(e.keyCode).toLowerCase();\n\n\t\t\t\tif ( that.s.listenKeys.toLowerCase().indexOf( character ) !== -1 ) {\n\t\t\t\t\tthat._keypress( character, e );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\n\t/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\t * Private methods\n\t */\n\n\t/**\n\t * Add a new button to the key press listener\n\t * @param {object} conf Resolved button configuration object\n\t * @private\n\t */\n\t_addKey: function ( conf )\n\t{\n\t\tif ( conf.key ) {\n\t\t\tthis.s.listenKeys += $.isPlainObject( conf.key ) ?\n\t\t\t\tconf.key.key :\n\t\t\t\tconf.key;\n\t\t}\n\t},\n\n\t/**\n\t * Insert the buttons into the container. Call without parameters!\n\t * @param  {node} [container] Recursive only - Insert point\n\t * @param  {array} [buttons] Recursive only - Buttons array\n\t * @private\n\t */\n\t_draw: function ( container, buttons )\n\t{\n\t\tif ( ! container ) {\n\t\t\tcontainer = this.dom.container;\n\t\t\tbuttons = this.s.buttons;\n\t\t}\n\n\t\tcontainer.children().detach();\n\n\t\tfor ( var i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tcontainer.append( buttons[i].inserter );\n\t\t\tcontainer.append( ' ' );\n\n\t\t\tif ( buttons[i].buttons && buttons[i].buttons.length ) {\n\t\t\t\tthis._draw( buttons[i].collection, buttons[i].buttons );\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Create buttons from an array of buttons\n\t * @param  {array} attachTo Buttons array to attach to\n\t * @param  {object} button Button definition\n\t * @param  {boolean} inCollection true if the button is in a collection\n\t * @private\n\t */\n\t_expandButton: function ( attachTo, button, inCollection, attachPoint )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar buttonCounter = 0;\n\t\tvar buttons = ! Array.isArray( button ) ?\n\t\t\t[ button ] :\n\t\t\tbutton;\n\n\t\tfor ( var i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tvar conf = this._resolveExtends( buttons[i] );\n\n\t\t\tif ( ! conf ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If the configuration is an array, then expand the buttons at this\n\t\t\t// point\n\t\t\tif ( Array.isArray( conf ) ) {\n\t\t\t\tthis._expandButton( attachTo, conf, inCollection, attachPoint );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar built = this._buildButton( conf, inCollection );\n\t\t\tif ( ! built ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif ( attachPoint !== undefined && attachPoint !== null ) {\n\t\t\t\tattachTo.splice( attachPoint, 0, built );\n\t\t\t\tattachPoint++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tattachTo.push( built );\n\t\t\t}\n\n\t\t\tif ( built.conf.buttons ) {\n\t\t\t\tbuilt.collection = $('<'+this.c.dom.collection.tag+'/>');\n\n\t\t\t\tbuilt.conf._collection = built.collection;\n\n\t\t\t\tthis._expandButton( built.buttons, built.conf.buttons, true, attachPoint );\n\t\t\t}\n\n\t\t\t// init call is made here, rather than buildButton as it needs to\n\t\t\t// be selectable, and for that it needs to be in the buttons array\n\t\t\tif ( conf.init ) {\n\t\t\t\tconf.init.call( dt.button( built.node ), dt, $(built.node), conf );\n\t\t\t}\n\n\t\t\tbuttonCounter++;\n\t\t}\n\t},\n\n\t/**\n\t * Create an individual button\n\t * @param  {object} config            Resolved button configuration\n\t * @param  {boolean} inCollection `true` if a collection button\n\t * @return {jQuery} Created button node (jQuery)\n\t * @private\n\t */\n\t_buildButton: function ( config, inCollection )\n\t{\n\t\tvar buttonDom = this.c.dom.button;\n\t\tvar linerDom = this.c.dom.buttonLiner;\n\t\tvar collectionDom = this.c.dom.collection;\n\t\tvar dt = this.s.dt;\n\t\tvar text = function ( opt ) {\n\t\t\treturn typeof opt === 'function' ?\n\t\t\t\topt( dt, button, config ) :\n\t\t\t\topt;\n\t\t};\n\n\t\tif ( inCollection && collectionDom.button ) {\n\t\t\tbuttonDom = collectionDom.button;\n\t\t}\n\n\t\tif ( inCollection && collectionDom.buttonLiner ) {\n\t\t\tlinerDom = collectionDom.buttonLiner;\n\t\t}\n\n\t\t// Make sure that the button is available based on whatever requirements\n\t\t// it has. For example, Flash buttons require Flash\n\t\tif ( config.available && ! config.available( dt, config ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar action = function ( e, dt, button, config ) {\n\t\t\tconfig.action.call( dt.button( button ), e, dt, button, config );\n\n\t\t\t$(dt.table().node()).triggerHandler( 'buttons-action.dt', [\n\t\t\t\tdt.button( button ), dt, button, config \n\t\t\t] );\n\t\t};\n\n\t\tvar tag = config.tag || buttonDom.tag;\n\t\tvar clickBlurs = config.clickBlurs === undefined ? true : config.clickBlurs\n\t\tvar button = $('<'+tag+'/>')\n\t\t\t.addClass( buttonDom.className )\n\t\t\t.attr( 'tabindex', this.s.dt.settings()[0].iTabIndex )\n\t\t\t.attr( 'aria-controls', this.s.dt.table().node().id )\n\t\t\t.on( 'click.dtb', function (e) {\n\t\t\t\te.preventDefault();\n\n\t\t\t\tif ( ! button.hasClass( buttonDom.disabled ) && config.action ) {\n\t\t\t\t\taction( e, dt, button, config );\n\t\t\t\t}\n\t\t\t\tif( clickBlurs ) {\n\t\t\t\t\tbutton.trigger('blur');\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.on( 'keyup.dtb', function (e) {\n\t\t\t\tif ( e.keyCode === 13 ) {\n\t\t\t\t\tif ( ! button.hasClass( buttonDom.disabled ) && config.action ) {\n\t\t\t\t\t\taction( e, dt, button, config );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} );\n\n\t\t// Make `a` tags act like a link\n\t\tif ( tag.toLowerCase() === 'a' ) {\n\t\t\tbutton.attr( 'href', '#' );\n\t\t}\n\n\t\t// Button tags should have `type=button` so they don't have any default behaviour\n\t\tif ( tag.toLowerCase() === 'button' ) {\n\t\t\tbutton.attr( 'type', 'button' );\n\t\t}\n\n\t\tif ( linerDom.tag ) {\n\t\t\tvar liner = $('<'+linerDom.tag+'/>')\n\t\t\t\t.html( text( config.text ) )\n\t\t\t\t.addClass( linerDom.className );\n\n\t\t\tif ( linerDom.tag.toLowerCase() === 'a' ) {\n\t\t\t\tliner.attr( 'href', '#' );\n\t\t\t}\n\n\t\t\tbutton.append( liner );\n\t\t}\n\t\telse {\n\t\t\tbutton.html( text( config.text ) );\n\t\t}\n\n\t\tif ( config.enabled === false ) {\n\t\t\tbutton.addClass( buttonDom.disabled );\n\t\t}\n\n\t\tif ( config.className ) {\n\t\t\tbutton.addClass( config.className );\n\t\t}\n\n\t\tif ( config.titleAttr ) {\n\t\t\tbutton.attr( 'title', text( config.titleAttr ) );\n\t\t}\n\n\t\tif ( config.attr ) {\n\t\t\tbutton.attr( config.attr );\n\t\t}\n\n\t\tif ( ! config.namespace ) {\n\t\t\tconfig.namespace = '.dt-button-'+(_buttonCounter++);\n\t\t}\n\n\t\tvar buttonContainer = this.c.dom.buttonContainer;\n\t\tvar inserter;\n\t\tif ( buttonContainer && buttonContainer.tag ) {\n\t\t\tinserter = $('<'+buttonContainer.tag+'/>')\n\t\t\t\t.addClass( buttonContainer.className )\n\t\t\t\t.append( button );\n\t\t}\n\t\telse {\n\t\t\tinserter = button;\n\t\t}\n\n\t\tthis._addKey( config );\n\n\t\t// Style integration callback for DOM manipulation\n\t\t// Note that this is _not_ documented. It is currently\n\t\t// for style integration only\n\t\tif( this.c.buttonCreated ) {\n\t\t\tinserter = this.c.buttonCreated( config, inserter );\n\t\t}\n\n\t\treturn {\n\t\t\tconf:         config,\n\t\t\tnode:         button.get(0),\n\t\t\tinserter:     inserter,\n\t\t\tbuttons:      [],\n\t\t\tinCollection: inCollection,\n\t\t\tcollection:   null\n\t\t};\n\t},\n\n\t/**\n\t * Get the button object from a node (recursive)\n\t * @param  {node} node Button node\n\t * @param  {array} [buttons] Button array, uses base if not defined\n\t * @return {object} Button object\n\t * @private\n\t */\n\t_nodeToButton: function ( node, buttons )\n\t{\n\t\tif ( ! buttons ) {\n\t\t\tbuttons = this.s.buttons;\n\t\t}\n\n\t\tfor ( var i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tif ( buttons[i].node === node ) {\n\t\t\t\treturn buttons[i];\n\t\t\t}\n\n\t\t\tif ( buttons[i].buttons.length ) {\n\t\t\t\tvar ret = this._nodeToButton( node, buttons[i].buttons );\n\n\t\t\t\tif ( ret ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Get container array for a button from a button node (recursive)\n\t * @param  {node} node Button node\n\t * @param  {array} [buttons] Button array, uses base if not defined\n\t * @return {array} Button's host array\n\t * @private\n\t */\n\t_nodeToHost: function ( node, buttons )\n\t{\n\t\tif ( ! buttons ) {\n\t\t\tbuttons = this.s.buttons;\n\t\t}\n\n\t\tfor ( var i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tif ( buttons[i].node === node ) {\n\t\t\t\treturn buttons;\n\t\t\t}\n\n\t\t\tif ( buttons[i].buttons.length ) {\n\t\t\t\tvar ret = this._nodeToHost( node, buttons[i].buttons );\n\n\t\t\t\tif ( ret ) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Handle a key press - determine if any button's key configured matches\n\t * what was typed and trigger the action if so.\n\t * @param  {string} character The character pressed\n\t * @param  {object} e Key event that triggered this call\n\t * @private\n\t */\n\t_keypress: function ( character, e )\n\t{\n\t\t// Check if this button press already activated on another instance of Buttons\n\t\tif ( e._buttonsHandled ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar run = function ( conf, node ) {\n\t\t\tif ( ! conf.key ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( conf.key === character ) {\n\t\t\t\te._buttonsHandled = true;\n\t\t\t\t$(node).click();\n\t\t\t}\n\t\t\telse if ( $.isPlainObject( conf.key ) ) {\n\t\t\t\tif ( conf.key.key !== character ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( conf.key.shiftKey && ! e.shiftKey ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( conf.key.altKey && ! e.altKey ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( conf.key.ctrlKey && ! e.ctrlKey ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( conf.key.metaKey && ! e.metaKey ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Made it this far - it is good\n\t\t\t\te._buttonsHandled = true;\n\t\t\t\t$(node).click();\n\t\t\t}\n\t\t};\n\n\t\tvar recurse = function ( a ) {\n\t\t\tfor ( var i=0, ien=a.length ; i<ien ; i++ ) {\n\t\t\t\trun( a[i].conf, a[i].node );\n\n\t\t\t\tif ( a[i].buttons.length ) {\n\t\t\t\t\trecurse( a[i].buttons );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\trecurse( this.s.buttons );\n\t},\n\n\t/**\n\t * Remove a key from the key listener for this instance (to be used when a\n\t * button is removed)\n\t * @param  {object} conf Button configuration\n\t * @private\n\t */\n\t_removeKey: function ( conf )\n\t{\n\t\tif ( conf.key ) {\n\t\t\tvar character = $.isPlainObject( conf.key ) ?\n\t\t\t\tconf.key.key :\n\t\t\t\tconf.key;\n\n\t\t\t// Remove only one character, as multiple buttons could have the\n\t\t\t// same listening key\n\t\t\tvar a = this.s.listenKeys.split('');\n\t\t\tvar idx = $.inArray( character, a );\n\t\t\ta.splice( idx, 1 );\n\t\t\tthis.s.listenKeys = a.join('');\n\t\t}\n\t},\n\n\t/**\n\t * Resolve a button configuration\n\t * @param  {string|function|object} conf Button config to resolve\n\t * @return {object} Button configuration\n\t * @private\n\t */\n\t_resolveExtends: function ( conf )\n\t{\n\t\tvar dt = this.s.dt;\n\t\tvar i, ien;\n\t\tvar toConfObject = function ( base ) {\n\t\t\tvar loop = 0;\n\n\t\t\t// Loop until we have resolved to a button configuration, or an\n\t\t\t// array of button configurations (which will be iterated\n\t\t\t// separately)\n\t\t\twhile ( ! $.isPlainObject(base) && ! Array.isArray(base) ) {\n\t\t\t\tif ( base === undefined ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( typeof base === 'function' ) {\n\t\t\t\t\tbase = base( dt, conf );\n\n\t\t\t\t\tif ( ! base ) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( typeof base === 'string' ) {\n\t\t\t\t\tif ( ! _dtButtons[ base ] ) {\n\t\t\t\t\t\tthrow 'Unknown button type: '+base;\n\t\t\t\t\t}\n\n\t\t\t\t\tbase = _dtButtons[ base ];\n\t\t\t\t}\n\n\t\t\t\tloop++;\n\t\t\t\tif ( loop > 30 ) {\n\t\t\t\t\t// Protect against misconfiguration killing the browser\n\t\t\t\t\tthrow 'Buttons: Too many iterations';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn Array.isArray( base ) ?\n\t\t\t\tbase :\n\t\t\t\t$.extend( {}, base );\n\t\t};\n\n\t\tconf = toConfObject( conf );\n\n\t\twhile ( conf && conf.extend ) {\n\t\t\t// Use `toConfObject` in case the button definition being extended\n\t\t\t// is itself a string or a function\n\t\t\tif ( ! _dtButtons[ conf.extend ] ) {\n\t\t\t\tthrow 'Cannot extend unknown button type: '+conf.extend;\n\t\t\t}\n\n\t\t\tvar objArray = toConfObject( _dtButtons[ conf.extend ] );\n\t\t\tif ( Array.isArray( objArray ) ) {\n\t\t\t\treturn objArray;\n\t\t\t}\n\t\t\telse if ( ! objArray ) {\n\t\t\t\t// This is a little brutal as it might be possible to have a\n\t\t\t\t// valid button without the extend, but if there is no extend\n\t\t\t\t// then the host button would be acting in an undefined state\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Stash the current class name\n\t\t\tvar originalClassName = objArray.className;\n\n\t\t\tconf = $.extend( {}, objArray, conf );\n\n\t\t\t// The extend will have overwritten the original class name if the\n\t\t\t// `conf` object also assigned a class, but we want to concatenate\n\t\t\t// them so they are list that is combined from all extended buttons\n\t\t\tif ( originalClassName && conf.className !== originalClassName ) {\n\t\t\t\tconf.className = originalClassName+' '+conf.className;\n\t\t\t}\n\n\t\t\t// Buttons to be added to a collection  -gives the ability to define\n\t\t\t// if buttons should be added to the start or end of a collection\n\t\t\tvar postfixButtons = conf.postfixButtons;\n\t\t\tif ( postfixButtons ) {\n\t\t\t\tif ( ! conf.buttons ) {\n\t\t\t\t\tconf.buttons = [];\n\t\t\t\t}\n\n\t\t\t\tfor ( i=0, ien=postfixButtons.length ; i<ien ; i++ ) {\n\t\t\t\t\tconf.buttons.push( postfixButtons[i] );\n\t\t\t\t}\n\n\t\t\t\tconf.postfixButtons = null;\n\t\t\t}\n\n\t\t\tvar prefixButtons = conf.prefixButtons;\n\t\t\tif ( prefixButtons ) {\n\t\t\t\tif ( ! conf.buttons ) {\n\t\t\t\t\tconf.buttons = [];\n\t\t\t\t}\n\n\t\t\t\tfor ( i=0, ien=prefixButtons.length ; i<ien ; i++ ) {\n\t\t\t\t\tconf.buttons.splice( i, 0, prefixButtons[i] );\n\t\t\t\t}\n\n\t\t\t\tconf.prefixButtons = null;\n\t\t\t}\n\n\t\t\t// Although we want the `conf` object to overwrite almost all of\n\t\t\t// the properties of the object being extended, the `extend`\n\t\t\t// property should come from the object being extended\n\t\t\tconf.extend = objArray.extend;\n\t\t}\n\n\t\treturn conf;\n\t},\n\n\t/**\n\t * Display (and replace if there is an existing one) a popover attached to a button\n\t * @param {string|node} content Content to show\n\t * @param {DataTable.Api} hostButton DT API instance of the button\n\t * @param {object} inOpts Options (see object below for all options)\n\t */\n\t_popover: function ( content, hostButton, inOpts ) {\n\t\tvar dt = hostButton;\n\t\tvar buttonsSettings = this.c;\n\t\tvar options = $.extend( {\n\t\t\talign: 'button-left', // button-right, dt-container\n\t\t\tautoClose: false,\n\t\t\tbackground: true,\n\t\t\tbackgroundClassName: 'dt-button-background',\n\t\t\tcontentClassName: buttonsSettings.dom.collection.className,\n\t\t\tcollectionLayout: '',\n\t\t\tcollectionTitle: '',\n\t\t\tdropup: false,\n\t\t\tfade: 400,\n\t\t\trightAlignClassName: 'dt-button-right',\n\t\t\ttag: buttonsSettings.dom.collection.tag\n\t\t}, inOpts );\n\t\tvar hostNode = hostButton.node();\n\n\t\tvar close = function () {\n\t\t\t_fadeOut(\n\t\t\t\t$('.dt-button-collection'),\n\t\t\t\toptions.fade,\n\t\t\t\tfunction () {\n\t\t\t\t\t$(this).detach();\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t$(dt.buttons( '[aria-haspopup=\"true\"][aria-expanded=\"true\"]' ).nodes())\n\t\t\t\t.attr('aria-expanded', 'false');\n\n\t\t\t$('div.dt-button-background').off( 'click.dtb-collection' );\n\t\t\tButtons.background( false, options.backgroundClassName, options.fade, hostNode );\n\n\t\t\t$('body').off( '.dtb-collection' );\n\t\t\tdt.off( 'buttons-action.b-internal' );\n\t\t};\n\n\t\tif (content === false) {\n\t\t\tclose();\n\t\t}\n\n\t\tvar existingExpanded = $(dt.buttons( '[aria-haspopup=\"true\"][aria-expanded=\"true\"]' ).nodes());\n\t\tif ( existingExpanded.length ) {\n\t\t\thostNode = existingExpanded.eq(0);\n\n\t\t\tclose();\n\t\t}\n\n\t\tvar display = $('<div/>')\n\t\t\t.addClass('dt-button-collection')\n\t\t\t.addClass(options.collectionLayout)\n\t\t\t.css('display', 'none');\n\n\t\tcontent = $(content)\n\t\t\t.addClass(options.contentClassName)\n\t\t\t.attr('role', 'menu')\n\t\t\t.appendTo(display);\n\n\t\thostNode.attr( 'aria-expanded', 'true' );\n\n\t\tif ( hostNode.parents('body')[0] !== document.body ) {\n\t\t\thostNode = document.body.lastChild;\n\t\t}\n\n\t\tif ( options.collectionTitle ) {\n\t\t\tdisplay.prepend('<div class=\"dt-button-collection-title\">'+options.collectionTitle+'</div>');\n\t\t}\n\n\t\t_fadeIn( display.insertAfter( hostNode ), options.fade );\n\n\t\tvar tableContainer = $( hostButton.table().container() );\n\t\tvar position = display.css( 'position' );\n\n\t\tif ( options.align === 'dt-container' ) {\n\t\t\thostNode = hostNode.parent();\n\t\t\tdisplay.css('width', tableContainer.width());\n\t\t}\n\n\t\t// Align the popover relative to the DataTables container\n\t\t// Useful for wide popovers such as SearchPanes\n\t\tif (\n\t\t\tposition === 'absolute' &&\n\t\t\t(\n\t\t\t\tdisplay.hasClass( options.rightAlignClassName ) ||\n\t\t\t\tdisplay.hasClass( options.leftAlignClassName ) ||\n\t\t\t\toptions.align === 'dt-container'\n\t\t\t)\n\t\t) {\n\n\t\t\tvar hostPosition = hostNode.position();\n\n\t\t\tdisplay.css( {\n\t\t\t\ttop: hostPosition.top + hostNode.outerHeight(),\n\t\t\t\tleft: hostPosition.left\n\t\t\t} );\n\n\t\t\t// calculate overflow when positioned beneath\n\t\t\tvar collectionHeight = display.outerHeight();\n\t\t\tvar tableBottom = tableContainer.offset().top + tableContainer.height();\n\t\t\tvar listBottom = hostPosition.top + hostNode.outerHeight() + collectionHeight;\n\t\t\tvar bottomOverflow = listBottom - tableBottom;\n\n\t\t\t// calculate overflow when positioned above\n\t\t\tvar listTop = hostPosition.top - collectionHeight;\n\t\t\tvar tableTop = tableContainer.offset().top;\n\t\t\tvar topOverflow = tableTop - listTop;\n\n\t\t\t// if bottom overflow is larger, move to the top because it fits better, or if dropup is requested\n\t\t\tvar moveTop = hostPosition.top - collectionHeight - 5;\n\t\t\tif ( (bottomOverflow > topOverflow || options.dropup) && -moveTop < tableTop ) {\n\t\t\t\tdisplay.css( 'top', moveTop);\n\t\t\t}\n\n\t\t\t// Get the size of the container (left and width - and thus also right)\n\t\t\tvar tableLeft = tableContainer.offset().left;\n\t\t\tvar tableWidth = tableContainer.width();\n\t\t\tvar tableRight = tableLeft + tableWidth;\n\n\t\t\t// Get the size of the popover (left and width - and ...)\n\t\t\tvar popoverLeft = display.offset().left;\n\t\t\tvar popoverWidth = display.width();\n\t\t\tvar popoverRight = popoverLeft + popoverWidth;\n\n\t\t\t// Get the size of the host buttons (left and width - and ...)\n\t\t\tvar buttonsLeft = hostNode.offset().left;\n\t\t\tvar buttonsWidth = hostNode.outerWidth()\n\t\t\tvar buttonsRight = buttonsLeft + buttonsWidth;\n\t\t\t\n\t\t\t// You've then got all the numbers you need to do some calculations and if statements,\n\t\t\t//  so we can do some quick JS maths and apply it only once\n\t\t\t// If it has the right align class OR the buttons are right aligned OR the button container is floated right,\n\t\t\t//  then calculate left position for the popover to align the popover to the right hand\n\t\t\t//  side of the button - check to see if the left of the popover is inside the table container.\n\t\t\t// If not, move the popover so it is, but not more than it means that the popover is to the right of the table container\n\t\t\tvar popoverShuffle = 0;\n\t\t\tif ( display.hasClass( options.rightAlignClassName )) {\n\t\t\t\tpopoverShuffle = buttonsRight - popoverRight;\n\t\t\t\tif(tableLeft > (popoverLeft + popoverShuffle)){\n\t\t\t\t\tvar leftGap = tableLeft - (popoverLeft + popoverShuffle);\n\t\t\t\t\tvar rightGap = tableRight - (popoverRight + popoverShuffle);\n\t\n\t\t\t\t\tif(leftGap > rightGap){\n\t\t\t\t\t\tpopoverShuffle += rightGap; \n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpopoverShuffle += leftGap;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// else attempt to left align the popover to the button. Similar to above, if the popover's right goes past the table container's right,\n\t\t\t//  then move it back, but not so much that it goes past the left of the table container\n\t\t\telse {\n\t\t\t\tpopoverShuffle = tableLeft - popoverLeft;\n\n\t\t\t\tif(tableRight < (popoverRight + popoverShuffle)){\n\t\t\t\t\tvar leftGap = tableLeft - (popoverLeft + popoverShuffle);\n\t\t\t\t\tvar rightGap = tableRight - (popoverRight + popoverShuffle);\n\n\t\t\t\t\tif(leftGap > rightGap ){\n\t\t\t\t\t\tpopoverShuffle += rightGap;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpopoverShuffle += leftGap;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdisplay.css('left', display.position().left + popoverShuffle);\n\t\t\t\n\t\t}\n\t\telse if (position === 'absolute') {\n\t\t\t// Align relative to the host button\n\t\t\tvar hostPosition = hostNode.position();\n\n\t\t\tdisplay.css( {\n\t\t\t\ttop: hostPosition.top + hostNode.outerHeight(),\n\t\t\t\tleft: hostPosition.left\n\t\t\t} );\n\n\t\t\t// calculate overflow when positioned beneath\n\t\t\tvar collectionHeight = display.outerHeight();\n\t\t\tvar top = hostNode.offset().top\n\t\t\tvar popoverShuffle = 0;\n\n\t\t\t// Get the size of the host buttons (left and width - and ...)\n\t\t\tvar buttonsLeft = hostNode.offset().left;\n\t\t\tvar buttonsWidth = hostNode.outerWidth()\n\t\t\tvar buttonsRight = buttonsLeft + buttonsWidth;\n\n\t\t\t// Get the size of the popover (left and width - and ...)\n\t\t\tvar popoverLeft = display.offset().left;\n\t\t\tvar popoverWidth = content.width();\n\t\t\tvar popoverRight = popoverLeft + popoverWidth;\n\n\t\t\tvar moveTop = hostPosition.top - collectionHeight - 5;\n\t\t\tvar tableBottom = tableContainer.offset().top + tableContainer.height();\n\t\t\tvar listBottom = hostPosition.top + hostNode.outerHeight() + collectionHeight;\n\t\t\tvar bottomOverflow = listBottom - tableBottom;\n\n\t\t\t// calculate overflow when positioned above\n\t\t\tvar listTop = hostPosition.top - collectionHeight;\n\t\t\tvar tableTop = tableContainer.offset().top;\n\t\t\tvar topOverflow = tableTop - listTop;\n\n\t\t\tif ( (bottomOverflow > topOverflow || options.dropup) && -moveTop < tableTop ) {\n\t\t\t\tdisplay.css( 'top', moveTop);\n\t\t\t}\n\n\t\t\tpopoverShuffle = options.align === 'button-right'\n\t\t\t\t? buttonsRight - popoverRight\n\t\t\t\t: buttonsLeft - popoverLeft;\n\n\t\t\tdisplay.css('left', display.position().left + popoverShuffle);\n\t\t}\n\t\telse {\n\t\t\t// Fix position - centre on screen\n\t\t\tvar top = display.height() / 2;\n\t\t\tif ( top > $(window).height() / 2 ) {\n\t\t\t\ttop = $(window).height() / 2;\n\t\t\t}\n\n\t\t\tdisplay.css( 'marginTop', top*-1 );\n\t\t}\n\n\t\tif ( options.background ) {\n\t\t\tButtons.background( true, options.backgroundClassName, options.fade, hostNode );\n\t\t}\n\n\t\t// This is bonkers, but if we don't have a click listener on the\n\t\t// background element, iOS Safari will ignore the body click\n\t\t// listener below. An empty function here is all that is\n\t\t// required to make it work...\n\t\t$('div.dt-button-background').on( 'click.dtb-collection', function () {} );\n\n\t\t$('body')\n\t\t\t.on( 'click.dtb-collection', function (e) {\n\t\t\t\t// andSelf is deprecated in jQ1.8, but we want 1.7 compat\n\t\t\t\tvar back = $.fn.addBack ? 'addBack' : 'andSelf';\n\t\t\t\tvar parent = $(e.target).parent()[0];\n\n\t\t\t\tif (( ! $(e.target).parents()[back]().filter( content ).length  && !$(parent).hasClass('dt-buttons')) || $(e.target).hasClass('dt-button-background')) {\n\t\t\t\t\tclose();\n\t\t\t\t}\n\t\t\t} )\n\t\t\t.on( 'keyup.dtb-collection', function (e) {\n\t\t\t\tif ( e.keyCode === 27 ) {\n\t\t\t\t\tclose();\n\t\t\t\t}\n\t\t\t} );\n\n\t\tif ( options.autoClose ) {\n\t\t\tsetTimeout( function () {\n\t\t\t\tdt.on( 'buttons-action.b-internal', function (e, btn, dt, node) {\n\t\t\t\t\tif ( node[0] === hostNode[0] ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tclose();\n\t\t\t\t} );\n\t\t\t}, 0);\n\t\t}\n\n\t\t$(display).trigger('buttons-popover.dt');\n\t}\n} );\n\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * Statics\n */\n\n/**\n * Show / hide a background layer behind a collection\n * @param  {boolean} Flag to indicate if the background should be shown or\n *   hidden \n * @param  {string} Class to assign to the background\n * @static\n */\nButtons.background = function ( show, className, fade, insertPoint ) {\n\tif ( fade === undefined ) {\n\t\tfade = 400;\n\t}\n\tif ( ! insertPoint ) {\n\t\tinsertPoint = document.body;\n\t}\n\n\tif ( show ) {\n\t\t_fadeIn(\n\t\t\t$('<div/>')\n\t\t\t\t.addClass( className )\n\t\t\t\t.css( 'display', 'none' )\n\t\t\t\t.insertAfter( insertPoint ),\n\t\t\tfade\n\t\t);\n\t}\n\telse {\n\t\t_fadeOut(\n\t\t\t$('div.'+className),\n\t\t\tfade,\n\t\t\tfunction () {\n\t\t\t\t$(this)\n\t\t\t\t\t.removeClass( className )\n\t\t\t\t\t.remove();\n\t\t\t}\n\t\t);\n\t}\n};\n\n/**\n * Instance selector - select Buttons instances based on an instance selector\n * value from the buttons assigned to a DataTable. This is only useful if\n * multiple instances are attached to a DataTable.\n * @param  {string|int|array} Instance selector - see `instance-selector`\n *   documentation on the DataTables site\n * @param  {array} Button instance array that was attached to the DataTables\n *   settings object\n * @return {array} Buttons instances\n * @static\n */\nButtons.instanceSelector = function ( group, buttons )\n{\n\tif ( group === undefined || group === null ) {\n\t\treturn $.map( buttons, function ( v ) {\n\t\t\treturn v.inst;\n\t\t} );\n\t}\n\n\tvar ret = [];\n\tvar names = $.map( buttons, function ( v ) {\n\t\treturn v.name;\n\t} );\n\n\t// Flatten the group selector into an array of single options\n\tvar process = function ( input ) {\n\t\tif ( Array.isArray( input ) ) {\n\t\t\tfor ( var i=0, ien=input.length ; i<ien ; i++ ) {\n\t\t\t\tprocess( input[i] );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( typeof input === 'string' ) {\n\t\t\tif ( input.indexOf( ',' ) !== -1 ) {\n\t\t\t\t// String selector, list of names\n\t\t\t\tprocess( input.split(',') );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// String selector individual name\n\t\t\t\tvar idx = $.inArray( input.trim(), names );\n\n\t\t\t\tif ( idx !== -1 ) {\n\t\t\t\t\tret.push( buttons[ idx ].inst );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( typeof input === 'number' ) {\n\t\t\t// Index selector\n\t\t\tret.push( buttons[ input ].inst );\n\t\t}\n\t};\n\t\n\tprocess( group );\n\n\treturn ret;\n};\n\n/**\n * Button selector - select one or more buttons from a selector input so some\n * operation can be performed on them.\n * @param  {array} Button instances array that the selector should operate on\n * @param  {string|int|node|jQuery|array} Button selector - see\n *   `button-selector` documentation on the DataTables site\n * @return {array} Array of objects containing `inst` and `idx` properties of\n *   the selected buttons so you know which instance each button belongs to.\n * @static\n */\nButtons.buttonSelector = function ( insts, selector )\n{\n\tvar ret = [];\n\tvar nodeBuilder = function ( a, buttons, baseIdx ) {\n\t\tvar button;\n\t\tvar idx;\n\n\t\tfor ( var i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\tbutton = buttons[i];\n\n\t\t\tif ( button ) {\n\t\t\t\tidx = baseIdx !== undefined ?\n\t\t\t\t\tbaseIdx+i :\n\t\t\t\t\ti+'';\n\n\t\t\t\ta.push( {\n\t\t\t\t\tnode: button.node,\n\t\t\t\t\tname: button.conf.name,\n\t\t\t\t\tidx:  idx\n\t\t\t\t} );\n\n\t\t\t\tif ( button.buttons ) {\n\t\t\t\t\tnodeBuilder( a, button.buttons, idx+'-' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar run = function ( selector, inst ) {\n\t\tvar i, ien;\n\t\tvar buttons = [];\n\t\tnodeBuilder( buttons, inst.s.buttons );\n\n\t\tvar nodes = $.map( buttons, function (v) {\n\t\t\treturn v.node;\n\t\t} );\n\n\t\tif ( Array.isArray( selector ) || selector instanceof $ ) {\n\t\t\tfor ( i=0, ien=selector.length ; i<ien ; i++ ) {\n\t\t\t\trun( selector[i], inst );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ( selector === null || selector === undefined || selector === '*' ) {\n\t\t\t// Select all\n\t\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\t\tret.push( {\n\t\t\t\t\tinst: inst,\n\t\t\t\t\tnode: buttons[i].node\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t\telse if ( typeof selector === 'number' ) {\n\t\t\t// Main button index selector\n\t\t\tret.push( {\n\t\t\t\tinst: inst,\n\t\t\t\tnode: inst.s.buttons[ selector ].node\n\t\t\t} );\n\t\t}\n\t\telse if ( typeof selector === 'string' ) {\n\t\t\tif ( selector.indexOf( ',' ) !== -1 ) {\n\t\t\t\t// Split\n\t\t\t\tvar a = selector.split(',');\n\n\t\t\t\tfor ( i=0, ien=a.length ; i<ien ; i++ ) {\n\t\t\t\t\trun( a[i].trim(), inst );\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( selector.match( /^\\d+(\\-\\d+)*$/ ) ) {\n\t\t\t\t// Sub-button index selector\n\t\t\t\tvar indexes = $.map( buttons, function (v) {\n\t\t\t\t\treturn v.idx;\n\t\t\t\t} );\n\n\t\t\t\tret.push( {\n\t\t\t\t\tinst: inst,\n\t\t\t\t\tnode: buttons[ $.inArray( selector, indexes ) ].node\n\t\t\t\t} );\n\t\t\t}\n\t\t\telse if ( selector.indexOf( ':name' ) !== -1 ) {\n\t\t\t\t// Button name selector\n\t\t\t\tvar name = selector.replace( ':name', '' );\n\n\t\t\t\tfor ( i=0, ien=buttons.length ; i<ien ; i++ ) {\n\t\t\t\t\tif ( buttons[i].name === name ) {\n\t\t\t\t\t\tret.push( {\n\t\t\t\t\t\t\tinst: inst,\n\t\t\t\t\t\t\tnode: buttons[i].node\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// jQuery selector on the nodes\n\t\t\t\t$( nodes ).filter( selector ).each( function () {\n\t\t\t\t\tret.push( {\n\t\t\t\t\t\tinst: inst,\n\t\t\t\t\t\tnode: this\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t\telse if ( typeof selector === 'object' && selector.nodeName ) {\n\t\t\t// Node selector\n\t\t\tvar idx = $.inArray( selector, nodes );\n\n\t\t\tif ( idx !== -1 ) {\n\t\t\t\tret.push( {\n\t\t\t\t\tinst: inst,\n\t\t\t\t\tnode: nodes[ idx ]\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\t};\n\n\n\tfor ( var i=0, ien=insts.length ; i<ien ; i++ ) {\n\t\tvar inst = insts[i];\n\n\t\trun( selector, inst );\n\t}\n\n\treturn ret;\n};\n\n\n/**\n * Buttons defaults. For full documentation, please refer to the docs/option\n * directory or the DataTables site.\n * @type {Object}\n * @static\n */\nButtons.defaults = {\n\tbuttons: [ 'copy', 'excel', 'csv', 'pdf', 'print' ],\n\tname: 'main',\n\ttabIndex: 0,\n\tdom: {\n\t\tcontainer: {\n\t\t\ttag: 'div',\n\t\t\tclassName: 'dt-buttons'\n\t\t},\n\t\tcollection: {\n\t\t\ttag: 'div',\n\t\t\tclassName: ''\n\t\t},\n\t\tbutton: {\n\t\t\t// Flash buttons will not work with `<button>` in IE - it has to be `<a>`\n\t\t\ttag: 'ActiveXObject' in window ?\n\t\t\t\t'a' :\n\t\t\t\t'button',\n\t\t\tclassName: 'dt-button',\n\t\t\tactive: 'active',\n\t\t\tdisabled: 'disabled'\n\t\t},\n\t\tbuttonLiner: {\n\t\t\ttag: 'span',\n\t\t\tclassName: ''\n\t\t}\n\t}\n};\n\n/**\n * Version information\n * @type {string}\n * @static\n */\nButtons.version = '1.6.5';\n\n\n$.extend( _dtButtons, {\n\tcollection: {\n\t\ttext: function ( dt ) {\n\t\t\treturn dt.i18n( 'buttons.collection', 'Collection' );\n\t\t},\n\t\tclassName: 'buttons-collection',\n\t\tinit: function ( dt, button, config ) {\n\t\t\tbutton.attr( 'aria-expanded', false );\n\t\t},\n\t\taction: function ( e, dt, button, config ) {\n\t\t\te.stopPropagation();\n\n\t\t\tif ( config._collection.parents('body').length ) {\n\t\t\t\tthis.popover(false, config);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.popover(config._collection, config);\n\t\t\t}\n\t\t},\n\t\tattr: {\n\t\t\t'aria-haspopup': true\n\t\t}\n\t\t// Also the popover options, defined in Buttons.popover\n\t},\n\tcopy: function ( dt, conf ) {\n\t\tif ( _dtButtons.copyHtml5 ) {\n\t\t\treturn 'copyHtml5';\n\t\t}\n\t\tif ( _dtButtons.copyFlash && _dtButtons.copyFlash.available( dt, conf ) ) {\n\t\t\treturn 'copyFlash';\n\t\t}\n\t},\n\tcsv: function ( dt, conf ) {\n\t\t// Common option that will use the HTML5 or Flash export buttons\n\t\tif ( _dtButtons.csvHtml5 && _dtButtons.csvHtml5.available( dt, conf ) ) {\n\t\t\treturn 'csvHtml5';\n\t\t}\n\t\tif ( _dtButtons.csvFlash && _dtButtons.csvFlash.available( dt, conf ) ) {\n\t\t\treturn 'csvFlash';\n\t\t}\n\t},\n\texcel: function ( dt, conf ) {\n\t\t// Common option that will use the HTML5 or Flash export buttons\n\t\tif ( _dtButtons.excelHtml5 && _dtButtons.excelHtml5.available( dt, conf ) ) {\n\t\t\treturn 'excelHtml5';\n\t\t}\n\t\tif ( _dtButtons.excelFlash && _dtButtons.excelFlash.available( dt, conf ) ) {\n\t\t\treturn 'excelFlash';\n\t\t}\n\t},\n\tpdf: function ( dt, conf ) {\n\t\t// Common option that will use the HTML5 or Flash export buttons\n\t\tif ( _dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available( dt, conf ) ) {\n\t\t\treturn 'pdfHtml5';\n\t\t}\n\t\tif ( _dtButtons.pdfFlash && _dtButtons.pdfFlash.available( dt, conf ) ) {\n\t\t\treturn 'pdfFlash';\n\t\t}\n\t},\n\tpageLength: function ( dt ) {\n\t\tvar lengthMenu = dt.settings()[0].aLengthMenu;\n\t\tvar vals = Array.isArray( lengthMenu[0] ) ? lengthMenu[0] : lengthMenu;\n\t\tvar lang = Array.isArray( lengthMenu[0] ) ? lengthMenu[1] : lengthMenu;\n\t\tvar text = function ( dt ) {\n\t\t\treturn dt.i18n( 'buttons.pageLength', {\n\t\t\t\t\"-1\": 'Show all rows',\n\t\t\t\t_:    'Show %d rows'\n\t\t\t}, dt.page.len() );\n\t\t};\n\n\t\treturn {\n\t\t\textend: 'collection',\n\t\t\ttext: text,\n\t\t\tclassName: 'buttons-page-length',\n\t\t\tautoClose: true,\n\t\t\tbuttons: $.map( vals, function ( val, i ) {\n\t\t\t\treturn {\n\t\t\t\t\ttext: lang[i],\n\t\t\t\t\tclassName: 'button-page-length',\n\t\t\t\t\taction: function ( e, dt ) {\n\t\t\t\t\t\tdt.page.len( val ).draw();\n\t\t\t\t\t},\n\t\t\t\t\tinit: function ( dt, node, conf ) {\n\t\t\t\t\t\tvar that = this;\n\t\t\t\t\t\tvar fn = function () {\n\t\t\t\t\t\t\tthat.active( dt.page.len() === val );\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tdt.on( 'length.dt'+conf.namespace, fn );\n\t\t\t\t\t\tfn();\n\t\t\t\t\t},\n\t\t\t\t\tdestroy: function ( dt, node, conf ) {\n\t\t\t\t\t\tdt.off( 'length.dt'+conf.namespace );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t} ),\n\t\t\tinit: function ( dt, node, conf ) {\n\t\t\t\tvar that = this;\n\t\t\t\tdt.on( 'length.dt'+conf.namespace, function () {\n\t\t\t\t\tthat.text( conf.text );\n\t\t\t\t} );\n\t\t\t},\n\t\t\tdestroy: function ( dt, node, conf ) {\n\t\t\t\tdt.off( 'length.dt'+conf.namespace );\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables API\n *\n * For complete documentation, please refer to the docs/api directory or the\n * DataTables site\n */\n\n// Buttons group and individual button selector\nDataTable.Api.register( 'buttons()', function ( group, selector ) {\n\t// Argument shifting\n\tif ( selector === undefined ) {\n\t\tselector = group;\n\t\tgroup = undefined;\n\t}\n\n\tthis.selector.buttonGroup = group;\n\n\tvar res = this.iterator( true, 'table', function ( ctx ) {\n\t\tif ( ctx._buttons ) {\n\t\t\treturn Buttons.buttonSelector(\n\t\t\t\tButtons.instanceSelector( group, ctx._buttons ),\n\t\t\t\tselector\n\t\t\t);\n\t\t}\n\t}, true );\n\n\tres._groupSelector = group;\n\treturn res;\n} );\n\n// Individual button selector\nDataTable.Api.register( 'button()', function ( group, selector ) {\n\t// just run buttons() and truncate\n\tvar buttons = this.buttons( group, selector );\n\n\tif ( buttons.length > 1 ) {\n\t\tbuttons.splice( 1, buttons.length );\n\t}\n\n\treturn buttons;\n} );\n\n// Active buttons\nDataTable.Api.registerPlural( 'buttons().active()', 'button().active()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.map( function ( set ) {\n\t\t\treturn set.inst.active( set.node );\n\t\t} );\n\t}\n\n\treturn this.each( function ( set ) {\n\t\tset.inst.active( set.node, flag );\n\t} );\n} );\n\n// Get / set button action\nDataTable.Api.registerPlural( 'buttons().action()', 'button().action()', function ( action ) {\n\tif ( action === undefined ) {\n\t\treturn this.map( function ( set ) {\n\t\t\treturn set.inst.action( set.node );\n\t\t} );\n\t}\n\n\treturn this.each( function ( set ) {\n\t\tset.inst.action( set.node, action );\n\t} );\n} );\n\n// Enable / disable buttons\nDataTable.Api.register( ['buttons().enable()', 'button().enable()'], function ( flag ) {\n\treturn this.each( function ( set ) {\n\t\tset.inst.enable( set.node, flag );\n\t} );\n} );\n\n// Disable buttons\nDataTable.Api.register( ['buttons().disable()', 'button().disable()'], function () {\n\treturn this.each( function ( set ) {\n\t\tset.inst.disable( set.node );\n\t} );\n} );\n\n// Get button nodes\nDataTable.Api.registerPlural( 'buttons().nodes()', 'button().node()', function () {\n\tvar jq = $();\n\n\t// jQuery will automatically reduce duplicates to a single entry\n\t$( this.each( function ( set ) {\n\t\tjq = jq.add( set.inst.node( set.node ) );\n\t} ) );\n\n\treturn jq;\n} );\n\n// Get / set button processing state\nDataTable.Api.registerPlural( 'buttons().processing()', 'button().processing()', function ( flag ) {\n\tif ( flag === undefined ) {\n\t\treturn this.map( function ( set ) {\n\t\t\treturn set.inst.processing( set.node );\n\t\t} );\n\t}\n\n\treturn this.each( function ( set ) {\n\t\tset.inst.processing( set.node, flag );\n\t} );\n} );\n\n// Get / set button text (i.e. the button labels)\nDataTable.Api.registerPlural( 'buttons().text()', 'button().text()', function ( label ) {\n\tif ( label === undefined ) {\n\t\treturn this.map( function ( set ) {\n\t\t\treturn set.inst.text( set.node );\n\t\t} );\n\t}\n\n\treturn this.each( function ( set ) {\n\t\tset.inst.text( set.node, label );\n\t} );\n} );\n\n// Trigger a button's action\nDataTable.Api.registerPlural( 'buttons().trigger()', 'button().trigger()', function () {\n\treturn this.each( function ( set ) {\n\t\tset.inst.node( set.node ).trigger( 'click' );\n\t} );\n} );\n\n// Button resolver to the popover\nDataTable.Api.register( 'button().popover()', function (content, options) {\n\treturn this.map( function ( set ) {\n\t\treturn set.inst._popover( content, this.button(this[0].node), options );\n\t} );\n} );\n\n// Get the container elements\nDataTable.Api.register( 'buttons().containers()', function () {\n\tvar jq = $();\n\tvar groupSelector = this._groupSelector;\n\n\t// We need to use the group selector directly, since if there are no buttons\n\t// the result set will be empty\n\tthis.iterator( true, 'table', function ( ctx ) {\n\t\tif ( ctx._buttons ) {\n\t\t\tvar insts = Buttons.instanceSelector( groupSelector, ctx._buttons );\n\n\t\t\tfor ( var i=0, ien=insts.length ; i<ien ; i++ ) {\n\t\t\t\tjq = jq.add( insts[i].container() );\n\t\t\t}\n\t\t}\n\t} );\n\n\treturn jq;\n} );\n\nDataTable.Api.register( 'buttons().container()', function () {\n\t// API level of nesting is `buttons()` so we can zip into the containers method\n\treturn this.containers().eq(0);\n} );\n\n// Add a new button\nDataTable.Api.register( 'button().add()', function ( idx, conf ) {\n\tvar ctx = this.context;\n\n\t// Don't use `this` as it could be empty - select the instances directly\n\tif ( ctx.length ) {\n\t\tvar inst = Buttons.instanceSelector( this._groupSelector, ctx[0]._buttons );\n\n\t\tif ( inst.length ) {\n\t\t\tinst[0].add( conf, idx );\n\t\t}\n\t}\n\n\treturn this.button( this._groupSelector, idx );\n} );\n\n// Destroy the button sets selected\nDataTable.Api.register( 'buttons().destroy()', function () {\n\tthis.pluck( 'inst' ).unique().each( function ( inst ) {\n\t\tinst.destroy();\n\t} );\n\n\treturn this;\n} );\n\n// Remove a button\nDataTable.Api.registerPlural( 'buttons().remove()', 'buttons().remove()', function () {\n\tthis.each( function ( set ) {\n\t\tset.inst.remove( set.node );\n\t} );\n\n\treturn this;\n} );\n\n// Information box that can be used by buttons\nvar _infoTimer;\nDataTable.Api.register( 'buttons.info()', function ( title, message, time ) {\n\tvar that = this;\n\n\tif ( title === false ) {\n\t\tthis.off('destroy.btn-info');\n\t\t_fadeOut(\n\t\t\t$('#datatables_buttons_info'),\n\t\t\t400,\n\t\t\tfunction () {\n\t\t\t\t$(this).remove();\n\t\t\t}\n\t\t);\n\t\tclearTimeout( _infoTimer );\n\t\t_infoTimer = null;\n\n\t\treturn this;\n\t}\n\n\tif ( _infoTimer ) {\n\t\tclearTimeout( _infoTimer );\n\t}\n\n\tif ( $('#datatables_buttons_info').length ) {\n\t\t$('#datatables_buttons_info').remove();\n\t}\n\n\ttitle = title ? '<h2>'+title+'</h2>' : '';\n\n\t_fadeIn(\n\t\t$('<div id=\"datatables_buttons_info\" class=\"dt-button-info\"/>')\n\t\t\t.html( title )\n\t\t\t.append( $('<div/>')[ typeof message === 'string' ? 'html' : 'append' ]( message ) )\n\t\t\t.css( 'display', 'none' )\n\t\t\t.appendTo( 'body' )\n\t);\n\n\tif ( time !== undefined && time !== 0 ) {\n\t\t_infoTimer = setTimeout( function () {\n\t\t\tthat.buttons.info( false );\n\t\t}, time );\n\t}\n\n\tthis.on('destroy.btn-info', function () {\n\t\tthat.buttons.info(false);\n\t});\n\n\treturn this;\n} );\n\n// Get data from the table for export - this is common to a number of plug-in\n// buttons so it is included in the Buttons core library\nDataTable.Api.register( 'buttons.exportData()', function ( options ) {\n\tif ( this.context.length ) {\n\t\treturn _exportData( new DataTable.Api( this.context[0] ), options );\n\t}\n} );\n\n// Get information about the export that is common to many of the export data\n// types (DRY)\nDataTable.Api.register( 'buttons.exportInfo()', function ( conf ) {\n\tif ( ! conf ) {\n\t\tconf = {};\n\t}\n\n\treturn {\n\t\tfilename: _filename( conf ),\n\t\ttitle: _title( conf ),\n\t\tmessageTop: _message(this, conf.message || conf.messageTop, 'top'),\n\t\tmessageBottom: _message(this, conf.messageBottom, 'bottom')\n\t};\n} );\n\n\n\n/**\n * Get the file name for an exported file.\n *\n * @param {object}\tconfig Button configuration\n * @param {boolean} incExtension Include the file name extension\n */\nvar _filename = function ( config )\n{\n\t// Backwards compatibility\n\tvar filename = config.filename === '*' && config.title !== '*' && config.title !== undefined && config.title !== null && config.title !== '' ?\n\t\tconfig.title :\n\t\tconfig.filename;\n\n\tif ( typeof filename === 'function' ) {\n\t\tfilename = filename();\n\t}\n\n\tif ( filename === undefined || filename === null ) {\n\t\treturn null;\n\t}\n\n\tif ( filename.indexOf( '*' ) !== -1 ) {\n\t\tfilename = filename.replace( '*', $('head > title').text() ).trim();\n\t}\n\n\t// Strip characters which the OS will object to\n\tfilename = filename.replace(/[^a-zA-Z0-9_\\u00A1-\\uFFFF\\.,\\-_ !\\(\\)]/g, \"\");\n\n\tvar extension = _stringOrFunction( config.extension );\n\tif ( ! extension ) {\n\t\textension = '';\n\t}\n\n\treturn filename + extension;\n};\n\n/**\n * Simply utility method to allow parameters to be given as a function\n *\n * @param {undefined|string|function} option Option\n * @return {null|string} Resolved value\n */\nvar _stringOrFunction = function ( option )\n{\n\tif ( option === null || option === undefined ) {\n\t\treturn null;\n\t}\n\telse if ( typeof option === 'function' ) {\n\t\treturn option();\n\t}\n\treturn option;\n};\n\n/**\n * Get the title for an exported file.\n *\n * @param {object} config\tButton configuration\n */\nvar _title = function ( config )\n{\n\tvar title = _stringOrFunction( config.title );\n\n\treturn title === null ?\n\t\tnull : title.indexOf( '*' ) !== -1 ?\n\t\t\ttitle.replace( '*', $('head > title').text() || 'Exported data' ) :\n\t\t\ttitle;\n};\n\nvar _message = function ( dt, option, position )\n{\n\tvar message = _stringOrFunction( option );\n\tif ( message === null ) {\n\t\treturn null;\n\t}\n\n\tvar caption = $('caption', dt.table().container()).eq(0);\n\tif ( message === '*' ) {\n\t\tvar side = caption.css( 'caption-side' );\n\t\tif ( side !== position ) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn caption.length ?\n\t\t\tcaption.text() :\n\t\t\t'';\n\t}\n\n\treturn message;\n};\n\n\n\n\n\n\n\nvar _exportTextarea = $('<textarea/>')[0];\nvar _exportData = function ( dt, inOpts )\n{\n\tvar config = $.extend( true, {}, {\n\t\trows:           null,\n\t\tcolumns:        '',\n\t\tmodifier:       {\n\t\t\tsearch: 'applied',\n\t\t\torder:  'applied'\n\t\t},\n\t\torthogonal:     'display',\n\t\tstripHtml:      true,\n\t\tstripNewlines:  true,\n\t\tdecodeEntities: true,\n\t\ttrim:           true,\n\t\tformat:         {\n\t\t\theader: function ( d ) {\n\t\t\t\treturn strip( d );\n\t\t\t},\n\t\t\tfooter: function ( d ) {\n\t\t\t\treturn strip( d );\n\t\t\t},\n\t\t\tbody: function ( d ) {\n\t\t\t\treturn strip( d );\n\t\t\t}\n\t\t},\n\t\tcustomizeData: null\n\t}, inOpts );\n\n\tvar strip = function ( str ) {\n\t\tif ( typeof str !== 'string' ) {\n\t\t\treturn str;\n\t\t}\n\n\t\t// Always remove script tags\n\t\tstr = str.replace( /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '' );\n\n\t\t// Always remove comments\n\t\tstr = str.replace( /<!\\-\\-.*?\\-\\->/g, '' );\n\n\t\tif ( config.stripHtml ) {\n\t\t\tstr = str.replace( /<([^>'\"]*('[^']*'|\"[^\"]*\")?)*>/g, '' );\n\t\t}\n\n\t\tif ( config.trim ) {\n\t\t\tstr = str.replace( /^\\s+|\\s+$/g, '' );\n\t\t}\n\n\t\tif ( config.stripNewlines ) {\n\t\t\tstr = str.replace( /\\n/g, ' ' );\n\t\t}\n\n\t\tif ( config.decodeEntities ) {\n\t\t\t_exportTextarea.innerHTML = str;\n\t\t\tstr = _exportTextarea.value;\n\t\t}\n\n\t\treturn str;\n\t};\n\n\n\tvar header = dt.columns( config.columns ).indexes().map( function (idx) {\n\t\tvar el = dt.column( idx ).header();\n\t\treturn config.format.header( el.innerHTML, idx, el );\n\t} ).toArray();\n\n\tvar footer = dt.table().footer() ?\n\t\tdt.columns( config.columns ).indexes().map( function (idx) {\n\t\t\tvar el = dt.column( idx ).footer();\n\t\t\treturn config.format.footer( el ? el.innerHTML : '', idx, el );\n\t\t} ).toArray() :\n\t\tnull;\n\t\n\t// If Select is available on this table, and any rows are selected, limit the export\n\t// to the selected rows. If no rows are selected, all rows will be exported. Specify\n\t// a `selected` modifier to control directly.\n\tvar modifier = $.extend( {}, config.modifier );\n\tif ( dt.select && typeof dt.select.info === 'function' && modifier.selected === undefined ) {\n\t\tif ( dt.rows( config.rows, $.extend( { selected: true }, modifier ) ).any() ) {\n\t\t\t$.extend( modifier, { selected: true } )\n\t\t}\n\t}\n\n\tvar rowIndexes = dt.rows( config.rows, modifier ).indexes().toArray();\n\tvar selectedCells = dt.cells( rowIndexes, config.columns );\n\tvar cells = selectedCells\n\t\t.render( config.orthogonal )\n\t\t.toArray();\n\tvar cellNodes = selectedCells\n\t\t.nodes()\n\t\t.toArray();\n\n\tvar columns = header.length;\n\tvar rows = columns > 0 ? cells.length / columns : 0;\n\tvar body = [];\n\tvar cellCounter = 0;\n\n\tfor ( var i=0, ien=rows ; i<ien ; i++ ) {\n\t\tvar row = [ columns ];\n\n\t\tfor ( var j=0 ; j<columns ; j++ ) {\n\t\t\trow[j] = config.format.body( cells[ cellCounter ], i, j, cellNodes[ cellCounter ] );\n\t\t\tcellCounter++;\n\t\t}\n\n\t\tbody[i] = row;\n\t}\n\n\tvar data = {\n\t\theader: header,\n\t\tfooter: footer,\n\t\tbody:   body\n\t};\n\n\tif ( config.customizeData ) {\n\t\tconfig.customizeData( data );\n\t}\n\n\treturn data;\n};\n\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n * DataTables interface\n */\n\n// Attach to DataTables objects for global access\n$.fn.dataTable.Buttons = Buttons;\n$.fn.DataTable.Buttons = Buttons;\n\n\n\n// DataTables creation - check if the buttons have been defined for this table,\n// they will have been if the `B` option was used in `dom`, otherwise we should\n// create the buttons instance here so they can be inserted into the document\n// using the API. Listen for `init` for compatibility with pre 1.10.10, but to\n// be removed in future.\n$(document).on( 'init.dt plugin-init.dt', function (e, settings) {\n\tif ( e.namespace !== 'dt' ) {\n\t\treturn;\n\t}\n\n\tvar opts = settings.oInit.buttons || DataTable.defaults.buttons;\n\n\tif ( opts && ! settings._buttons ) {\n\t\tnew Buttons( settings, opts ).container();\n\t}\n} );\n\nfunction _init ( settings, options ) {\n\tvar api = new DataTable.Api( settings );\n\tvar opts = options\n\t\t? options\n\t\t: api.init().buttons || DataTable.defaults.buttons;\n\n\treturn new Buttons( api, opts ).container();\n}\n\n// DataTables `dom` feature option\nDataTable.ext.feature.push( {\n\tfnInit: _init,\n\tcFeature: \"B\"\n} );\n\n// DataTables 2 layout feature\nif ( DataTable.ext.features ) {\n\tDataTable.ext.features.register( 'buttons', _init );\n}\n\n\nreturn Buttons;\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9kYXRhVGFibGVzLmJ1dHRvbnMuanM/MTA1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQTBDO0FBQ2hEO0FBQ0EsRUFBRSxpQ0FBUSxDQUFDLHlFQUFRLEVBQUUsa0dBQWdCLENBQUMsbUNBQUU7QUFDeEM7QUFDQSxHQUFHO0FBQUEsa0dBQUU7QUFDTDtBQUNBLE1BQU0sRUFpQko7QUFDRixDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FB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QUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEU7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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O0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7OztBQUlEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pELHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQixRQUFRO0FBQ2xDOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQtYnV0dG9ucy9qcy9kYXRhVGFibGVzLmJ1dHRvbnMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQnV0dG9ucyBmb3IgRGF0YVRhYmxlcyAxLjYuNVxuICogwqkyMDE2LTIwMjAgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4oZnVuY3Rpb24oIGZhY3RvcnkgKXtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKCBbJ2pxdWVyeScsICdkYXRhdGFibGVzLm5ldCddLCBmdW5jdGlvbiAoICQgKSB7XG5cdFx0XHRyZXR1cm4gZmFjdG9yeSggJCwgd2luZG93LCBkb2N1bWVudCApO1xuXHRcdH0gKTtcblx0fVxuXHRlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocm9vdCwgJCkge1xuXHRcdFx0aWYgKCAhIHJvb3QgKSB7XG5cdFx0XHRcdHJvb3QgPSB3aW5kb3c7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggISAkIHx8ICEgJC5mbi5kYXRhVGFibGUgKSB7XG5cdFx0XHRcdCQgPSByZXF1aXJlKCdkYXRhdGFibGVzLm5ldCcpKHJvb3QsICQpLiQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWN0b3J5KCAkLCByb290LCByb290LmRvY3VtZW50ICk7XG5cdFx0fTtcblx0fVxuXHRlbHNlIHtcblx0XHQvLyBCcm93c2VyXG5cdFx0ZmFjdG9yeSggalF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50ICk7XG5cdH1cbn0oZnVuY3Rpb24oICQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCApIHtcbid1c2Ugc3RyaWN0JztcbnZhciBEYXRhVGFibGUgPSAkLmZuLmRhdGFUYWJsZTtcblxuXG4vLyBVc2VkIGZvciBuYW1lc3BhY2luZyBldmVudHMgYWRkZWQgdG8gdGhlIGRvY3VtZW50IGJ5IGVhY2ggaW5zdGFuY2UsIHNvIHRoZXlcbi8vIGNhbiBiZSByZW1vdmVkIG9uIGRlc3Ryb3lcbnZhciBfaW5zdENvdW50ZXIgPSAwO1xuXG4vLyBCdXR0b24gbmFtZXNwYWNpbmcgY291bnRlciBmb3IgbmFtZXNwYWNpbmcgZXZlbnRzIG9uIGluZGl2aWR1YWwgYnV0dG9uc1xudmFyIF9idXR0b25Db3VudGVyID0gMDtcblxudmFyIF9kdEJ1dHRvbnMgPSBEYXRhVGFibGUuZXh0LmJ1dHRvbnM7XG5cbi8vIEFsbG93IGZvciBqUXVlcnkgc2xpbVxuZnVuY3Rpb24gX2ZhZGVJbihlbCwgZHVyYXRpb24sIGZuKSB7XG5cdGlmICgkLmZuLmFuaW1hdGUpIHtcblx0XHRlbFxuXHRcdFx0LnN0b3AoKVxuXHRcdFx0LmZhZGVJbiggZHVyYXRpb24sIGZuICk7XG5cdH1cblx0ZWxzZSB7XG5cdFx0ZWwuY3NzKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cblx0XHRpZiAoZm4pIHtcblx0XHRcdGZuLmNhbGwoZWwpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBfZmFkZU91dChlbCwgZHVyYXRpb24sIGZuKSB7XG5cdGlmICgkLmZuLmFuaW1hdGUpIHtcblx0XHRlbFxuXHRcdFx0LnN0b3AoKVxuXHRcdFx0LmZhZGVPdXQoIGR1cmF0aW9uLCBmbiApO1xuXHR9XG5cdGVsc2Uge1xuXHRcdGVsLmNzcygnZGlzcGxheScsICdub25lJyk7XG5cdFx0XG5cdFx0aWYgKGZuKSB7XG5cdFx0XHRmbi5jYWxsKGVsKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBbQnV0dG9ucyBkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSB7W3R5cGVdfVxuICogQHBhcmFtIHtbdHlwZV19XG4gKi9cbnZhciBCdXR0b25zID0gZnVuY3Rpb24oIGR0LCBjb25maWcgKVxue1xuXHQvLyBJZiBub3QgY3JlYXRlZCB3aXRoIGEgYG5ld2Aga2V5d29yZCB0aGVuIHdlIHJldHVybiBhIHdyYXBwZXIgZnVuY3Rpb24gdGhhdFxuXHQvLyB3aWxsIHRha2UgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBEVC4gVGhpcyBhbGxvd3MgZWFzeSB1c2Ugb2YgbmV3IGluc3RhbmNlc1xuXHQvLyB3aXRoIHRoZSBgbGF5b3V0YCBvcHRpb24gLSBlLmcuIGB0b3BMZWZ0OiAkLmZuLmRhdGFUYWJsZS5CdXR0b25zKCAuLi4gKWAuXG5cdGlmICggISh0aGlzIGluc3RhbmNlb2YgQnV0dG9ucykgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuXHRcdFx0cmV0dXJuIG5ldyBCdXR0b25zKCBzZXR0aW5ncywgZHQgKS5jb250YWluZXIoKTtcblx0XHR9O1xuXHR9XG5cblx0Ly8gSWYgdGhlcmUgaXMgbm8gY29uZmlnIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3Rcblx0aWYgKCB0eXBlb2YoIGNvbmZpZyApID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRjb25maWcgPSB7fTtcdFxuXHR9XG5cdFxuXHQvLyBBbGxvdyBhIGJvb2xlYW4gdHJ1ZSBmb3IgZGVmYXVsdHNcblx0aWYgKCBjb25maWcgPT09IHRydWUgKSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXHQvLyBGb3IgZWFzeSBjb25maWd1cmF0aW9uIG9mIGJ1dHRvbnMgYW4gYXJyYXkgY2FuIGJlIGdpdmVuXG5cdGlmICggQXJyYXkuaXNBcnJheSggY29uZmlnICkgKSB7XG5cdFx0Y29uZmlnID0geyBidXR0b25zOiBjb25maWcgfTtcblx0fVxuXG5cdHRoaXMuYyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwgQnV0dG9ucy5kZWZhdWx0cywgY29uZmlnICk7XG5cblx0Ly8gRG9uJ3Qgd2FudCBhIGRlZXAgY29weSBmb3IgdGhlIGJ1dHRvbnNcblx0aWYgKCBjb25maWcuYnV0dG9ucyApIHtcblx0XHR0aGlzLmMuYnV0dG9ucyA9IGNvbmZpZy5idXR0b25zO1xuXHR9XG5cblx0dGhpcy5zID0ge1xuXHRcdGR0OiBuZXcgRGF0YVRhYmxlLkFwaSggZHQgKSxcblx0XHRidXR0b25zOiBbXSxcblx0XHRsaXN0ZW5LZXlzOiAnJyxcblx0XHRuYW1lc3BhY2U6ICdkdGInKyhfaW5zdENvdW50ZXIrKylcblx0fTtcblxuXHR0aGlzLmRvbSA9IHtcblx0XHRjb250YWluZXI6ICQoJzwnK3RoaXMuYy5kb20uY29udGFpbmVyLnRhZysnLz4nKVxuXHRcdFx0LmFkZENsYXNzKCB0aGlzLmMuZG9tLmNvbnRhaW5lci5jbGFzc05hbWUgKVxuXHR9O1xuXG5cdHRoaXMuX2NvbnN0cnVjdG9yKCk7XG59O1xuXG5cbiQuZXh0ZW5kKCBCdXR0b25zLnByb3RvdHlwZSwge1xuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIFB1YmxpYyBtZXRob2RzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGFjdGlvbiBvZiBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtpbnR8c3RyaW5nfSBCdXR0b24gaW5kZXhcblx0ICogQHJldHVybiB7ZnVuY3Rpb259XG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIGFjdGlvbiBvZiBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBlbGVtZW50XG5cdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBhY3Rpb24gRnVuY3Rpb24gdG8gc2V0XG5cdCAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXG5cdCAqL1xuXHRhY3Rpb246IGZ1bmN0aW9uICggbm9kZSwgYWN0aW9uIClcblx0e1xuXHRcdHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24oIG5vZGUgKTtcblxuXHRcdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4gYnV0dG9uLmNvbmYuYWN0aW9uO1xuXHRcdH1cblxuXHRcdGJ1dHRvbi5jb25mLmFjdGlvbiA9IGFjdGlvbjtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGQgYW4gYWN0aXZlIGNsYXNzIHRvIHRoZSBidXR0b24gdG8gbWFrZSB0byBsb29rIGFjdGl2ZSBvciBnZXQgY3VycmVudFxuXHQgKiBhY3RpdmUgc3RhdGUuXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgQnV0dG9uIGVsZW1lbnRcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gW2ZsYWddIEVuYWJsZSAvIGRpc2FibGUgZmxhZ1xuXHQgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZyBvciBib29sZWFuIGZvciBnZXR0ZXJcblx0ICovXG5cdGFjdGl2ZTogZnVuY3Rpb24gKCBub2RlLCBmbGFnICkge1xuXHRcdHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24oIG5vZGUgKTtcblx0XHR2YXIga2xhc3MgPSB0aGlzLmMuZG9tLmJ1dHRvbi5hY3RpdmU7XG5cdFx0dmFyIGpxTm9kZSA9ICQoYnV0dG9uLm5vZGUpO1xuXG5cdFx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFOb2RlLmhhc0NsYXNzKCBrbGFzcyApO1xuXHRcdH1cblxuXHRcdGpxTm9kZS50b2dnbGVDbGFzcygga2xhc3MsIGZsYWcgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBmbGFnICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogQWRkIGEgbmV3IGJ1dHRvblxuXHQgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIEJ1dHRvbiBjb25maWd1cmF0aW9uIG9iamVjdCwgYmFzZSBzdHJpbmcgbmFtZSBvciBmdW5jdGlvblxuXHQgKiBAcGFyYW0ge2ludHxzdHJpbmd9IFtpZHhdIEJ1dHRvbiBpbmRleCBmb3Igd2hlcmUgdG8gaW5zZXJ0IHRoZSBidXR0b25cblx0ICogQHJldHVybiB7QnV0dG9uc30gU2VsZiBmb3IgY2hhaW5pbmdcblx0ICovXG5cdGFkZDogZnVuY3Rpb24gKCBjb25maWcsIGlkeCApXG5cdHtcblx0XHR2YXIgYnV0dG9ucyA9IHRoaXMucy5idXR0b25zO1xuXG5cdFx0aWYgKCB0eXBlb2YgaWR4ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdHZhciBzcGxpdCA9IGlkeC5zcGxpdCgnLScpO1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLnM7XG5cblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1zcGxpdC5sZW5ndGgtMSA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRiYXNlID0gYmFzZS5idXR0b25zWyBzcGxpdFtpXSoxIF07XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbnMgPSBiYXNlLmJ1dHRvbnM7XG5cdFx0XHRpZHggPSBzcGxpdFsgc3BsaXQubGVuZ3RoLTEgXSoxO1xuXHRcdH1cblxuXHRcdHRoaXMuX2V4cGFuZEJ1dHRvbiggYnV0dG9ucywgY29uZmlnLCBiYXNlICE9PSB1bmRlZmluZWQsIGlkeCApO1xuXHRcdHRoaXMuX2RyYXcoKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGNvbnRhaW5lciBub2RlIGZvciB0aGUgYnV0dG9uc1xuXHQgKiBAcmV0dXJuIHtqUXVlcnl9IEJ1dHRvbnMgbm9kZVxuXHQgKi9cblx0Y29udGFpbmVyOiBmdW5jdGlvbiAoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuZG9tLmNvbnRhaW5lcjtcblx0fSxcblxuXHQvKipcblx0ICogRGlzYWJsZSBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBub2RlXG5cdCAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXG5cdCAqL1xuXHRkaXNhYmxlOiBmdW5jdGlvbiAoIG5vZGUgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSApO1xuXG5cdFx0JChidXR0b24ubm9kZSlcblx0XHRcdC5hZGRDbGFzcyggdGhpcy5jLmRvbS5idXR0b24uZGlzYWJsZWQgKVxuXHRcdFx0LmF0dHIoJ2Rpc2FibGVkJywgdHJ1ZSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogRGVzdHJveSB0aGUgaW5zdGFuY2UsIGNsZWFuaW5nIHVwIGV2ZW50IGhhbmRsZXJzIGFuZCByZW1vdmluZyBET01cblx0ICogZWxlbWVudHNcblx0ICogQHJldHVybiB7QnV0dG9uc30gU2VsZiBmb3IgY2hhaW5pbmdcblx0ICovXG5cdGRlc3Ryb3k6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHQvLyBLZXkgZXZlbnQgbGlzdGVuZXJcblx0XHQkKCdib2R5Jykub2ZmKCAna2V5dXAuJyt0aGlzLnMubmFtZXNwYWNlICk7XG5cblx0XHQvLyBJbmRpdmlkdWFsIGJ1dHRvbiBkZXN0cm95IChzbyB0aGV5IGNhbiByZW1vdmUgdGhlaXIgb3duIGV2ZW50cyBpZlxuXHRcdC8vIG5lZWRlZCkuIFRha2UgYSBjb3B5IGFzIHRoZSBhcnJheSBpcyBtb2RpZmllZCBieSBgcmVtb3ZlYFxuXHRcdHZhciBidXR0b25zID0gdGhpcy5zLmJ1dHRvbnMuc2xpY2UoKTtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdFxuXHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR0aGlzLnJlbW92ZSggYnV0dG9uc1tpXS5ub2RlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udGFpbmVyXG5cdFx0dGhpcy5kb20uY29udGFpbmVyLnJlbW92ZSgpO1xuXG5cdFx0Ly8gUmVtb3ZlIGZyb20gdGhlIHNldHRpbmdzIG9iamVjdCBjb2xsZWN0aW9uXG5cdFx0dmFyIGJ1dHRvbkluc3RzID0gdGhpcy5zLmR0LnNldHRpbmdzKClbMF07XG5cblx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25JbnN0cy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYnV0dG9uSW5zdHMuaW5zdCA9PT0gdGhpcyApIHtcblx0XHRcdFx0YnV0dG9uSW5zdHMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFbmFibGUgLyBkaXNhYmxlIGEgYnV0dG9uXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgQnV0dG9uIG5vZGVcblx0ICogQHBhcmFtICB7Ym9vbGVhbn0gW2ZsYWc9dHJ1ZV0gRW5hYmxlIC8gZGlzYWJsZSBmbGFnXG5cdCAqIEByZXR1cm4ge0J1dHRvbnN9IFNlbGYgZm9yIGNoYWluaW5nXG5cdCAqL1xuXHRlbmFibGU6IGZ1bmN0aW9uICggbm9kZSwgZmxhZyApXG5cdHtcblx0XHRpZiAoIGZsYWcgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZGlzYWJsZSggbm9kZSApO1xuXHRcdH1cblxuXHRcdHZhciBidXR0b24gPSB0aGlzLl9ub2RlVG9CdXR0b24oIG5vZGUgKTtcblx0XHQkKGJ1dHRvbi5ub2RlKVxuXHRcdFx0LnJlbW92ZUNsYXNzKCB0aGlzLmMuZG9tLmJ1dHRvbi5kaXNhYmxlZCApXG5cdFx0XHQucmVtb3ZlQXR0cignZGlzYWJsZWQnKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGluc3RhbmNlIG5hbWUgZm9yIHRoZSBidXR0b24gc2V0IHNlbGVjdG9yXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gSW5zdGFuY2UgbmFtZVxuXHQgKi9cblx0bmFtZTogZnVuY3Rpb24gKClcblx0e1xuXHRcdHJldHVybiB0aGlzLmMubmFtZTtcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGEgYnV0dG9uJ3Mgbm9kZSBvZiB0aGUgYnV0dG9ucyBjb250YWluZXIgaWYgbm8gYnV0dG9uIGlzIGdpdmVuXG5cdCAqIEBwYXJhbSAge25vZGV9IFtub2RlXSBCdXR0b24gbm9kZVxuXHQgKiBAcmV0dXJuIHtqUXVlcnl9IEJ1dHRvbiBlbGVtZW50LCBvciBjb250YWluZXJcblx0ICovXG5cdG5vZGU6IGZ1bmN0aW9uICggbm9kZSApXG5cdHtcblx0XHRpZiAoICEgbm9kZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmRvbS5jb250YWluZXI7XG5cdFx0fVxuXG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSApO1xuXHRcdHJldHVybiAkKGJ1dHRvbi5ub2RlKTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IC8gZ2V0IGEgcHJvY2Vzc2luZyBjbGFzcyBvbiB0aGUgc2VsZWN0ZWQgYnV0dG9uXG5cdCAqIEBwYXJhbSB7ZWxlbWVudH0gbm9kZSBUcmlnZ2VyaW5nIGJ1dHRvbiBub2RlXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW59IGZsYWcgdHJ1ZSB0byBhZGQsIGZhbHNlIHRvIHJlbW92ZSwgdW5kZWZpbmVkIHRvIGdldFxuXHQgKiBAcmV0dXJuIHtib29sZWFufEJ1dHRvbnN9IEdldHRlciB2YWx1ZSBvciB0aGlzIGlmIGEgc2V0dGVyLlxuXHQgKi9cblx0cHJvY2Vzc2luZzogZnVuY3Rpb24gKCBub2RlLCBmbGFnIClcblx0e1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblx0XHR2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKCBub2RlICk7XG5cblx0XHRpZiAoIGZsYWcgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybiAkKGJ1dHRvbi5ub2RlKS5oYXNDbGFzcyggJ3Byb2Nlc3NpbmcnICk7XG5cdFx0fVxuXG5cdFx0JChidXR0b24ubm9kZSkudG9nZ2xlQ2xhc3MoICdwcm9jZXNzaW5nJywgZmxhZyApO1xuXG5cdFx0JChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlckhhbmRsZXIoICdidXR0b25zLXByb2Nlc3NpbmcuZHQnLCBbXG5cdFx0XHRmbGFnLCBkdC5idXR0b24oIG5vZGUgKSwgZHQsICQobm9kZSksIGJ1dHRvbi5jb25mXG5cdFx0XSApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGJ1dHRvbi5cblx0ICogQHBhcmFtICB7bm9kZX0gbm9kZSBCdXR0b24gbm9kZVxuXHQgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZ1xuXHQgKi9cblx0cmVtb3ZlOiBmdW5jdGlvbiAoIG5vZGUgKVxuXHR7XG5cdFx0dmFyIGJ1dHRvbiA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSApO1xuXHRcdHZhciBob3N0ID0gdGhpcy5fbm9kZVRvSG9zdCggbm9kZSApO1xuXHRcdHZhciBkdCA9IHRoaXMucy5kdDtcblxuXHRcdC8vIFJlbW92ZSBhbnkgY2hpbGQgYnV0dG9ucyBmaXJzdFxuXHRcdGlmICggYnV0dG9uLmJ1dHRvbnMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggdmFyIGk9YnV0dG9uLmJ1dHRvbnMubGVuZ3RoLTEgOyBpPj0wIDsgaS0tICkge1xuXHRcdFx0XHR0aGlzLnJlbW92ZSggYnV0dG9uLmJ1dHRvbnNbaV0ubm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFsbG93IHRoZSBidXR0b24gdG8gcmVtb3ZlIGV2ZW50IGhhbmRsZXJzLCBldGNcblx0XHRpZiAoIGJ1dHRvbi5jb25mLmRlc3Ryb3kgKSB7XG5cdFx0XHRidXR0b24uY29uZi5kZXN0cm95LmNhbGwoIGR0LmJ1dHRvbihub2RlKSwgZHQsICQobm9kZSksIGJ1dHRvbi5jb25mICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fcmVtb3ZlS2V5KCBidXR0b24uY29uZiApO1xuXG5cdFx0JChidXR0b24ubm9kZSkucmVtb3ZlKCk7XG5cblx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCBidXR0b24sIGhvc3QgKTtcblx0XHRob3N0LnNwbGljZSggaWR4LCAxICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IHRoZSB0ZXh0IGZvciBhIGJ1dHRvblxuXHQgKiBAcGFyYW0gIHtpbnR8c3RyaW5nfSBub2RlIEJ1dHRvbiBpbmRleFxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IEJ1dHRvbiB0ZXh0XG5cdCAqLy8qKlxuXHQgKiBTZXQgdGhlIHRleHQgZm9yIGEgYnV0dG9uXG5cdCAqIEBwYXJhbSAge2ludHxzdHJpbmd8ZnVuY3Rpb259IG5vZGUgQnV0dG9uIGluZGV4XG5cdCAqIEBwYXJhbSAge3N0cmluZ30gbGFiZWwgVGV4dFxuXHQgKiBAcmV0dXJuIHtCdXR0b25zfSBTZWxmIGZvciBjaGFpbmluZ1xuXHQgKi9cblx0dGV4dDogZnVuY3Rpb24gKCBub2RlLCBsYWJlbCApXG5cdHtcblx0XHR2YXIgYnV0dG9uID0gdGhpcy5fbm9kZVRvQnV0dG9uKCBub2RlICk7XG5cdFx0dmFyIGJ1dHRvbkxpbmVyID0gdGhpcy5jLmRvbS5jb2xsZWN0aW9uLmJ1dHRvbkxpbmVyO1xuXHRcdHZhciBsaW5lclRhZyA9IGJ1dHRvbi5pbkNvbGxlY3Rpb24gJiYgYnV0dG9uTGluZXIgJiYgYnV0dG9uTGluZXIudGFnID9cblx0XHRcdGJ1dHRvbkxpbmVyLnRhZyA6XG5cdFx0XHR0aGlzLmMuZG9tLmJ1dHRvbkxpbmVyLnRhZztcblx0XHR2YXIgZHQgPSB0aGlzLnMuZHQ7XG5cdFx0dmFyIGpxTm9kZSA9ICQoYnV0dG9uLm5vZGUpO1xuXHRcdHZhciB0ZXh0ID0gZnVuY3Rpb24gKCBvcHQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdG9wdCggZHQsIGpxTm9kZSwgYnV0dG9uLmNvbmYgKSA6XG5cdFx0XHRcdG9wdDtcblx0XHR9O1xuXG5cdFx0aWYgKCBsYWJlbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuIHRleHQoIGJ1dHRvbi5jb25mLnRleHQgKTtcblx0XHR9XG5cblx0XHRidXR0b24uY29uZi50ZXh0ID0gbGFiZWw7XG5cblx0XHRpZiAoIGxpbmVyVGFnICkge1xuXHRcdFx0anFOb2RlLmNoaWxkcmVuKCBsaW5lclRhZyApLmh0bWwoIHRleHQobGFiZWwpICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0anFOb2RlLmh0bWwoIHRleHQobGFiZWwpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblxuXHQvKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG5cdCAqIENvbnN0cnVjdG9yXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBCdXR0b25zIGNvbnN0cnVjdG9yXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfY29uc3RydWN0b3I6IGZ1bmN0aW9uICgpXG5cdHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBkdFNldHRpbmdzID0gZHQuc2V0dGluZ3MoKVswXTtcblx0XHR2YXIgYnV0dG9ucyA9ICB0aGlzLmMuYnV0dG9ucztcblxuXHRcdGlmICggISBkdFNldHRpbmdzLl9idXR0b25zICkge1xuXHRcdFx0ZHRTZXR0aW5ncy5fYnV0dG9ucyA9IFtdO1xuXHRcdH1cblxuXHRcdGR0U2V0dGluZ3MuX2J1dHRvbnMucHVzaCgge1xuXHRcdFx0aW5zdDogdGhpcyxcblx0XHRcdG5hbWU6IHRoaXMuYy5uYW1lXG5cdFx0fSApO1xuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHR0aGlzLmFkZCggYnV0dG9uc1tpXSApO1xuXHRcdH1cblxuXHRcdGR0Lm9uKCAnZGVzdHJveScsIGZ1bmN0aW9uICggZSwgc2V0dGluZ3MgKSB7XG5cdFx0XHRpZiAoIHNldHRpbmdzID09PSBkdFNldHRpbmdzICkge1xuXHRcdFx0XHR0aGF0LmRlc3Ryb3koKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHQvLyBHbG9iYWwga2V5IGV2ZW50IGJpbmRpbmcgdG8gbGlzdGVuIGZvciBidXR0b24ga2V5c1xuXHRcdCQoJ2JvZHknKS5vbiggJ2tleXVwLicrdGhpcy5zLm5hbWVzcGFjZSwgZnVuY3Rpb24gKCBlICkge1xuXHRcdFx0aWYgKCAhIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSApIHtcblx0XHRcdFx0Ly8gU1VzZSBhIHN0cmluZyBvZiBjaGFyYWN0ZXJzIGZvciBmYXN0IGxvb2t1cCBvZiBpZiB3ZSBuZWVkIHRvXG5cdFx0XHRcdC8vIGhhbmRsZSB0aGlzXG5cdFx0XHRcdHZhciBjaGFyYWN0ZXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSkudG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0XHRpZiAoIHRoYXQucy5saXN0ZW5LZXlzLnRvTG93ZXJDYXNlKCkuaW5kZXhPZiggY2hhcmFjdGVyICkgIT09IC0xICkge1xuXHRcdFx0XHRcdHRoYXQuX2tleXByZXNzKCBjaGFyYWN0ZXIsIGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXG5cdC8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcblx0ICogUHJpdmF0ZSBtZXRob2RzXG5cdCAqL1xuXG5cdC8qKlxuXHQgKiBBZGQgYSBuZXcgYnV0dG9uIHRvIHRoZSBrZXkgcHJlc3MgbGlzdGVuZXJcblx0ICogQHBhcmFtIHtvYmplY3R9IGNvbmYgUmVzb2x2ZWQgYnV0dG9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYWRkS2V5OiBmdW5jdGlvbiAoIGNvbmYgKVxuXHR7XG5cdFx0aWYgKCBjb25mLmtleSApIHtcblx0XHRcdHRoaXMucy5saXN0ZW5LZXlzICs9ICQuaXNQbGFpbk9iamVjdCggY29uZi5rZXkgKSA/XG5cdFx0XHRcdGNvbmYua2V5LmtleSA6XG5cdFx0XHRcdGNvbmYua2V5O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSW5zZXJ0IHRoZSBidXR0b25zIGludG8gdGhlIGNvbnRhaW5lci4gQ2FsbCB3aXRob3V0IHBhcmFtZXRlcnMhXG5cdCAqIEBwYXJhbSAge25vZGV9IFtjb250YWluZXJdIFJlY3Vyc2l2ZSBvbmx5IC0gSW5zZXJ0IHBvaW50XG5cdCAqIEBwYXJhbSAge2FycmF5fSBbYnV0dG9uc10gUmVjdXJzaXZlIG9ubHkgLSBCdXR0b25zIGFycmF5XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZHJhdzogZnVuY3Rpb24gKCBjb250YWluZXIsIGJ1dHRvbnMgKVxuXHR7XG5cdFx0aWYgKCAhIGNvbnRhaW5lciApIHtcblx0XHRcdGNvbnRhaW5lciA9IHRoaXMuZG9tLmNvbnRhaW5lcjtcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLnMuYnV0dG9ucztcblx0XHR9XG5cblx0XHRjb250YWluZXIuY2hpbGRyZW4oKS5kZXRhY2goKTtcblxuXHRcdGZvciAoIHZhciBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZCggYnV0dG9uc1tpXS5pbnNlcnRlciApO1xuXHRcdFx0Y29udGFpbmVyLmFwcGVuZCggJyAnICk7XG5cblx0XHRcdGlmICggYnV0dG9uc1tpXS5idXR0b25zICYmIGJ1dHRvbnNbaV0uYnV0dG9ucy5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMuX2RyYXcoIGJ1dHRvbnNbaV0uY29sbGVjdGlvbiwgYnV0dG9uc1tpXS5idXR0b25zICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYnV0dG9ucyBmcm9tIGFuIGFycmF5IG9mIGJ1dHRvbnNcblx0ICogQHBhcmFtICB7YXJyYXl9IGF0dGFjaFRvIEJ1dHRvbnMgYXJyYXkgdG8gYXR0YWNoIHRvXG5cdCAqIEBwYXJhbSAge29iamVjdH0gYnV0dG9uIEJ1dHRvbiBkZWZpbml0aW9uXG5cdCAqIEBwYXJhbSAge2Jvb2xlYW59IGluQ29sbGVjdGlvbiB0cnVlIGlmIHRoZSBidXR0b24gaXMgaW4gYSBjb2xsZWN0aW9uXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfZXhwYW5kQnV0dG9uOiBmdW5jdGlvbiAoIGF0dGFjaFRvLCBidXR0b24sIGluQ29sbGVjdGlvbiwgYXR0YWNoUG9pbnQgKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBidXR0b25Db3VudGVyID0gMDtcblx0XHR2YXIgYnV0dG9ucyA9ICEgQXJyYXkuaXNBcnJheSggYnV0dG9uICkgP1xuXHRcdFx0WyBidXR0b24gXSA6XG5cdFx0XHRidXR0b247XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdHZhciBjb25mID0gdGhpcy5fcmVzb2x2ZUV4dGVuZHMoIGJ1dHRvbnNbaV0gKTtcblxuXHRcdFx0aWYgKCAhIGNvbmYgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGUgY29uZmlndXJhdGlvbiBpcyBhbiBhcnJheSwgdGhlbiBleHBhbmQgdGhlIGJ1dHRvbnMgYXQgdGhpc1xuXHRcdFx0Ly8gcG9pbnRcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggY29uZiApICkge1xuXHRcdFx0XHR0aGlzLl9leHBhbmRCdXR0b24oIGF0dGFjaFRvLCBjb25mLCBpbkNvbGxlY3Rpb24sIGF0dGFjaFBvaW50ICk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgYnVpbHQgPSB0aGlzLl9idWlsZEJ1dHRvbiggY29uZiwgaW5Db2xsZWN0aW9uICk7XG5cdFx0XHRpZiAoICEgYnVpbHQgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGF0dGFjaFBvaW50ICE9PSB1bmRlZmluZWQgJiYgYXR0YWNoUG9pbnQgIT09IG51bGwgKSB7XG5cdFx0XHRcdGF0dGFjaFRvLnNwbGljZSggYXR0YWNoUG9pbnQsIDAsIGJ1aWx0ICk7XG5cdFx0XHRcdGF0dGFjaFBvaW50Kys7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0YXR0YWNoVG8ucHVzaCggYnVpbHQgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidWlsdC5jb25mLmJ1dHRvbnMgKSB7XG5cdFx0XHRcdGJ1aWx0LmNvbGxlY3Rpb24gPSAkKCc8Jyt0aGlzLmMuZG9tLmNvbGxlY3Rpb24udGFnKycvPicpO1xuXG5cdFx0XHRcdGJ1aWx0LmNvbmYuX2NvbGxlY3Rpb24gPSBidWlsdC5jb2xsZWN0aW9uO1xuXG5cdFx0XHRcdHRoaXMuX2V4cGFuZEJ1dHRvbiggYnVpbHQuYnV0dG9ucywgYnVpbHQuY29uZi5idXR0b25zLCB0cnVlLCBhdHRhY2hQb2ludCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBpbml0IGNhbGwgaXMgbWFkZSBoZXJlLCByYXRoZXIgdGhhbiBidWlsZEJ1dHRvbiBhcyBpdCBuZWVkcyB0b1xuXHRcdFx0Ly8gYmUgc2VsZWN0YWJsZSwgYW5kIGZvciB0aGF0IGl0IG5lZWRzIHRvIGJlIGluIHRoZSBidXR0b25zIGFycmF5XG5cdFx0XHRpZiAoIGNvbmYuaW5pdCApIHtcblx0XHRcdFx0Y29uZi5pbml0LmNhbGwoIGR0LmJ1dHRvbiggYnVpbHQubm9kZSApLCBkdCwgJChidWlsdC5ub2RlKSwgY29uZiApO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b25Db3VudGVyKys7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGUgYW4gaW5kaXZpZHVhbCBidXR0b25cblx0ICogQHBhcmFtICB7b2JqZWN0fSBjb25maWcgICAgICAgICAgICBSZXNvbHZlZCBidXR0b24gY29uZmlndXJhdGlvblxuXHQgKiBAcGFyYW0gIHtib29sZWFufSBpbkNvbGxlY3Rpb24gYHRydWVgIGlmIGEgY29sbGVjdGlvbiBidXR0b25cblx0ICogQHJldHVybiB7alF1ZXJ5fSBDcmVhdGVkIGJ1dHRvbiBub2RlIChqUXVlcnkpXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfYnVpbGRCdXR0b246IGZ1bmN0aW9uICggY29uZmlnLCBpbkNvbGxlY3Rpb24gKVxuXHR7XG5cdFx0dmFyIGJ1dHRvbkRvbSA9IHRoaXMuYy5kb20uYnV0dG9uO1xuXHRcdHZhciBsaW5lckRvbSA9IHRoaXMuYy5kb20uYnV0dG9uTGluZXI7XG5cdFx0dmFyIGNvbGxlY3Rpb25Eb20gPSB0aGlzLmMuZG9tLmNvbGxlY3Rpb247XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciB0ZXh0ID0gZnVuY3Rpb24gKCBvcHQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJyA/XG5cdFx0XHRcdG9wdCggZHQsIGJ1dHRvbiwgY29uZmlnICkgOlxuXHRcdFx0XHRvcHQ7XG5cdFx0fTtcblxuXHRcdGlmICggaW5Db2xsZWN0aW9uICYmIGNvbGxlY3Rpb25Eb20uYnV0dG9uICkge1xuXHRcdFx0YnV0dG9uRG9tID0gY29sbGVjdGlvbkRvbS5idXR0b247XG5cdFx0fVxuXG5cdFx0aWYgKCBpbkNvbGxlY3Rpb24gJiYgY29sbGVjdGlvbkRvbS5idXR0b25MaW5lciApIHtcblx0XHRcdGxpbmVyRG9tID0gY29sbGVjdGlvbkRvbS5idXR0b25MaW5lcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgYnV0dG9uIGlzIGF2YWlsYWJsZSBiYXNlZCBvbiB3aGF0ZXZlciByZXF1aXJlbWVudHNcblx0XHQvLyBpdCBoYXMuIEZvciBleGFtcGxlLCBGbGFzaCBidXR0b25zIHJlcXVpcmUgRmxhc2hcblx0XHRpZiAoIGNvbmZpZy5hdmFpbGFibGUgJiYgISBjb25maWcuYXZhaWxhYmxlKCBkdCwgY29uZmlnICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dmFyIGFjdGlvbiA9IGZ1bmN0aW9uICggZSwgZHQsIGJ1dHRvbiwgY29uZmlnICkge1xuXHRcdFx0Y29uZmlnLmFjdGlvbi5jYWxsKCBkdC5idXR0b24oIGJ1dHRvbiApLCBlLCBkdCwgYnV0dG9uLCBjb25maWcgKTtcblxuXHRcdFx0JChkdC50YWJsZSgpLm5vZGUoKSkudHJpZ2dlckhhbmRsZXIoICdidXR0b25zLWFjdGlvbi5kdCcsIFtcblx0XHRcdFx0ZHQuYnV0dG9uKCBidXR0b24gKSwgZHQsIGJ1dHRvbiwgY29uZmlnIFxuXHRcdFx0XSApO1xuXHRcdH07XG5cblx0XHR2YXIgdGFnID0gY29uZmlnLnRhZyB8fCBidXR0b25Eb20udGFnO1xuXHRcdHZhciBjbGlja0JsdXJzID0gY29uZmlnLmNsaWNrQmx1cnMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBjb25maWcuY2xpY2tCbHVyc1xuXHRcdHZhciBidXR0b24gPSAkKCc8Jyt0YWcrJy8+Jylcblx0XHRcdC5hZGRDbGFzcyggYnV0dG9uRG9tLmNsYXNzTmFtZSApXG5cdFx0XHQuYXR0ciggJ3RhYmluZGV4JywgdGhpcy5zLmR0LnNldHRpbmdzKClbMF0uaVRhYkluZGV4IClcblx0XHRcdC5hdHRyKCAnYXJpYS1jb250cm9scycsIHRoaXMucy5kdC50YWJsZSgpLm5vZGUoKS5pZCApXG5cdFx0XHQub24oICdjbGljay5kdGInLCBmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cblx0XHRcdFx0aWYgKCAhIGJ1dHRvbi5oYXNDbGFzcyggYnV0dG9uRG9tLmRpc2FibGVkICkgJiYgY29uZmlnLmFjdGlvbiApIHtcblx0XHRcdFx0XHRhY3Rpb24oIGUsIGR0LCBidXR0b24sIGNvbmZpZyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCBjbGlja0JsdXJzICkge1xuXHRcdFx0XHRcdGJ1dHRvbi50cmlnZ2VyKCdibHVyJyk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKVxuXHRcdFx0Lm9uKCAna2V5dXAuZHRiJywgZnVuY3Rpb24gKGUpIHtcblx0XHRcdFx0aWYgKCBlLmtleUNvZGUgPT09IDEzICkge1xuXHRcdFx0XHRcdGlmICggISBidXR0b24uaGFzQ2xhc3MoIGJ1dHRvbkRvbS5kaXNhYmxlZCApICYmIGNvbmZpZy5hY3Rpb24gKSB7XG5cdFx0XHRcdFx0XHRhY3Rpb24oIGUsIGR0LCBidXR0b24sIGNvbmZpZyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSBgYWAgdGFncyBhY3QgbGlrZSBhIGxpbmtcblx0XHRpZiAoIHRhZy50b0xvd2VyQ2FzZSgpID09PSAnYScgKSB7XG5cdFx0XHRidXR0b24uYXR0ciggJ2hyZWYnLCAnIycgKTtcblx0XHR9XG5cblx0XHQvLyBCdXR0b24gdGFncyBzaG91bGQgaGF2ZSBgdHlwZT1idXR0b25gIHNvIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgZGVmYXVsdCBiZWhhdmlvdXJcblx0XHRpZiAoIHRhZy50b0xvd2VyQ2FzZSgpID09PSAnYnV0dG9uJyApIHtcblx0XHRcdGJ1dHRvbi5hdHRyKCAndHlwZScsICdidXR0b24nICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBsaW5lckRvbS50YWcgKSB7XG5cdFx0XHR2YXIgbGluZXIgPSAkKCc8JytsaW5lckRvbS50YWcrJy8+Jylcblx0XHRcdFx0Lmh0bWwoIHRleHQoIGNvbmZpZy50ZXh0ICkgKVxuXHRcdFx0XHQuYWRkQ2xhc3MoIGxpbmVyRG9tLmNsYXNzTmFtZSApO1xuXG5cdFx0XHRpZiAoIGxpbmVyRG9tLnRhZy50b0xvd2VyQ2FzZSgpID09PSAnYScgKSB7XG5cdFx0XHRcdGxpbmVyLmF0dHIoICdocmVmJywgJyMnICk7XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbi5hcHBlbmQoIGxpbmVyICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0YnV0dG9uLmh0bWwoIHRleHQoIGNvbmZpZy50ZXh0ICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy5lbmFibGVkID09PSBmYWxzZSApIHtcblx0XHRcdGJ1dHRvbi5hZGRDbGFzcyggYnV0dG9uRG9tLmRpc2FibGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBjb25maWcuY2xhc3NOYW1lICkge1xuXHRcdFx0YnV0dG9uLmFkZENsYXNzKCBjb25maWcuY2xhc3NOYW1lICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBjb25maWcudGl0bGVBdHRyICkge1xuXHRcdFx0YnV0dG9uLmF0dHIoICd0aXRsZScsIHRleHQoIGNvbmZpZy50aXRsZUF0dHIgKSApO1xuXHRcdH1cblxuXHRcdGlmICggY29uZmlnLmF0dHIgKSB7XG5cdFx0XHRidXR0b24uYXR0ciggY29uZmlnLmF0dHIgKTtcblx0XHR9XG5cblx0XHRpZiAoICEgY29uZmlnLm5hbWVzcGFjZSApIHtcblx0XHRcdGNvbmZpZy5uYW1lc3BhY2UgPSAnLmR0LWJ1dHRvbi0nKyhfYnV0dG9uQ291bnRlcisrKTtcblx0XHR9XG5cblx0XHR2YXIgYnV0dG9uQ29udGFpbmVyID0gdGhpcy5jLmRvbS5idXR0b25Db250YWluZXI7XG5cdFx0dmFyIGluc2VydGVyO1xuXHRcdGlmICggYnV0dG9uQ29udGFpbmVyICYmIGJ1dHRvbkNvbnRhaW5lci50YWcgKSB7XG5cdFx0XHRpbnNlcnRlciA9ICQoJzwnK2J1dHRvbkNvbnRhaW5lci50YWcrJy8+Jylcblx0XHRcdFx0LmFkZENsYXNzKCBidXR0b25Db250YWluZXIuY2xhc3NOYW1lIClcblx0XHRcdFx0LmFwcGVuZCggYnV0dG9uICk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0aW5zZXJ0ZXIgPSBidXR0b247XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWRkS2V5KCBjb25maWcgKTtcblxuXHRcdC8vIFN0eWxlIGludGVncmF0aW9uIGNhbGxiYWNrIGZvciBET00gbWFuaXB1bGF0aW9uXG5cdFx0Ly8gTm90ZSB0aGF0IHRoaXMgaXMgX25vdF8gZG9jdW1lbnRlZC4gSXQgaXMgY3VycmVudGx5XG5cdFx0Ly8gZm9yIHN0eWxlIGludGVncmF0aW9uIG9ubHlcblx0XHRpZiggdGhpcy5jLmJ1dHRvbkNyZWF0ZWQgKSB7XG5cdFx0XHRpbnNlcnRlciA9IHRoaXMuYy5idXR0b25DcmVhdGVkKCBjb25maWcsIGluc2VydGVyICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGNvbmY6ICAgICAgICAgY29uZmlnLFxuXHRcdFx0bm9kZTogICAgICAgICBidXR0b24uZ2V0KDApLFxuXHRcdFx0aW5zZXJ0ZXI6ICAgICBpbnNlcnRlcixcblx0XHRcdGJ1dHRvbnM6ICAgICAgW10sXG5cdFx0XHRpbkNvbGxlY3Rpb246IGluQ29sbGVjdGlvbixcblx0XHRcdGNvbGxlY3Rpb246ICAgbnVsbFxuXHRcdH07XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYnV0dG9uIG9iamVjdCBmcm9tIGEgbm9kZSAocmVjdXJzaXZlKVxuXHQgKiBAcGFyYW0gIHtub2RlfSBub2RlIEJ1dHRvbiBub2RlXG5cdCAqIEBwYXJhbSAge2FycmF5fSBbYnV0dG9uc10gQnV0dG9uIGFycmF5LCB1c2VzIGJhc2UgaWYgbm90IGRlZmluZWRcblx0ICogQHJldHVybiB7b2JqZWN0fSBCdXR0b24gb2JqZWN0XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRfbm9kZVRvQnV0dG9uOiBmdW5jdGlvbiAoIG5vZGUsIGJ1dHRvbnMgKVxuXHR7XG5cdFx0aWYgKCAhIGJ1dHRvbnMgKSB7XG5cdFx0XHRidXR0b25zID0gdGhpcy5zLmJ1dHRvbnM7XG5cdFx0fVxuXG5cdFx0Zm9yICggdmFyIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRpZiAoIGJ1dHRvbnNbaV0ubm9kZSA9PT0gbm9kZSApIHtcblx0XHRcdFx0cmV0dXJuIGJ1dHRvbnNbaV07XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uc1tpXS5idXR0b25zLmxlbmd0aCApIHtcblx0XHRcdFx0dmFyIHJldCA9IHRoaXMuX25vZGVUb0J1dHRvbiggbm9kZSwgYnV0dG9uc1tpXS5idXR0b25zICk7XG5cblx0XHRcdFx0aWYgKCByZXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogR2V0IGNvbnRhaW5lciBhcnJheSBmb3IgYSBidXR0b24gZnJvbSBhIGJ1dHRvbiBub2RlIChyZWN1cnNpdmUpXG5cdCAqIEBwYXJhbSAge25vZGV9IG5vZGUgQnV0dG9uIG5vZGVcblx0ICogQHBhcmFtICB7YXJyYXl9IFtidXR0b25zXSBCdXR0b24gYXJyYXksIHVzZXMgYmFzZSBpZiBub3QgZGVmaW5lZFxuXHQgKiBAcmV0dXJuIHthcnJheX0gQnV0dG9uJ3MgaG9zdCBhcnJheVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X25vZGVUb0hvc3Q6IGZ1bmN0aW9uICggbm9kZSwgYnV0dG9ucyApXG5cdHtcblx0XHRpZiAoICEgYnV0dG9ucyApIHtcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLnMuYnV0dG9ucztcblx0XHR9XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGlmICggYnV0dG9uc1tpXS5ub2RlID09PSBub2RlICkge1xuXHRcdFx0XHRyZXR1cm4gYnV0dG9ucztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b25zW2ldLmJ1dHRvbnMubGVuZ3RoICkge1xuXHRcdFx0XHR2YXIgcmV0ID0gdGhpcy5fbm9kZVRvSG9zdCggbm9kZSwgYnV0dG9uc1tpXS5idXR0b25zICk7XG5cblx0XHRcdFx0aWYgKCByZXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogSGFuZGxlIGEga2V5IHByZXNzIC0gZGV0ZXJtaW5lIGlmIGFueSBidXR0b24ncyBrZXkgY29uZmlndXJlZCBtYXRjaGVzXG5cdCAqIHdoYXQgd2FzIHR5cGVkIGFuZCB0cmlnZ2VyIHRoZSBhY3Rpb24gaWYgc28uXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gY2hhcmFjdGVyIFRoZSBjaGFyYWN0ZXIgcHJlc3NlZFxuXHQgKiBAcGFyYW0gIHtvYmplY3R9IGUgS2V5IGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2FsbFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2tleXByZXNzOiBmdW5jdGlvbiAoIGNoYXJhY3RlciwgZSApXG5cdHtcblx0XHQvLyBDaGVjayBpZiB0aGlzIGJ1dHRvbiBwcmVzcyBhbHJlYWR5IGFjdGl2YXRlZCBvbiBhbm90aGVyIGluc3RhbmNlIG9mIEJ1dHRvbnNcblx0XHRpZiAoIGUuX2J1dHRvbnNIYW5kbGVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBydW4gPSBmdW5jdGlvbiAoIGNvbmYsIG5vZGUgKSB7XG5cdFx0XHRpZiAoICEgY29uZi5rZXkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb25mLmtleSA9PT0gY2hhcmFjdGVyICkge1xuXHRcdFx0XHRlLl9idXR0b25zSGFuZGxlZCA9IHRydWU7XG5cdFx0XHRcdCQobm9kZSkuY2xpY2soKTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCAkLmlzUGxhaW5PYmplY3QoIGNvbmYua2V5ICkgKSB7XG5cdFx0XHRcdGlmICggY29uZi5rZXkua2V5ICE9PSBjaGFyYWN0ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb25mLmtleS5zaGlmdEtleSAmJiAhIGUuc2hpZnRLZXkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb25mLmtleS5hbHRLZXkgJiYgISBlLmFsdEtleSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGNvbmYua2V5LmN0cmxLZXkgJiYgISBlLmN0cmxLZXkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjb25mLmtleS5tZXRhS2V5ICYmICEgZS5tZXRhS2V5ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1hZGUgaXQgdGhpcyBmYXIgLSBpdCBpcyBnb29kXG5cdFx0XHRcdGUuX2J1dHRvbnNIYW5kbGVkID0gdHJ1ZTtcblx0XHRcdFx0JChub2RlKS5jbGljaygpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgcmVjdXJzZSA9IGZ1bmN0aW9uICggYSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1hLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRydW4oIGFbaV0uY29uZiwgYVtpXS5ub2RlICk7XG5cblx0XHRcdFx0aWYgKCBhW2ldLmJ1dHRvbnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJlY3Vyc2UoIGFbaV0uYnV0dG9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHJlY3Vyc2UoIHRoaXMucy5idXR0b25zICk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbW92ZSBhIGtleSBmcm9tIHRoZSBrZXkgbGlzdGVuZXIgZm9yIHRoaXMgaW5zdGFuY2UgKHRvIGJlIHVzZWQgd2hlbiBhXG5cdCAqIGJ1dHRvbiBpcyByZW1vdmVkKVxuXHQgKiBAcGFyYW0gIHtvYmplY3R9IGNvbmYgQnV0dG9uIGNvbmZpZ3VyYXRpb25cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9yZW1vdmVLZXk6IGZ1bmN0aW9uICggY29uZiApXG5cdHtcblx0XHRpZiAoIGNvbmYua2V5ICkge1xuXHRcdFx0dmFyIGNoYXJhY3RlciA9ICQuaXNQbGFpbk9iamVjdCggY29uZi5rZXkgKSA/XG5cdFx0XHRcdGNvbmYua2V5LmtleSA6XG5cdFx0XHRcdGNvbmYua2V5O1xuXG5cdFx0XHQvLyBSZW1vdmUgb25seSBvbmUgY2hhcmFjdGVyLCBhcyBtdWx0aXBsZSBidXR0b25zIGNvdWxkIGhhdmUgdGhlXG5cdFx0XHQvLyBzYW1lIGxpc3RlbmluZyBrZXlcblx0XHRcdHZhciBhID0gdGhpcy5zLmxpc3RlbktleXMuc3BsaXQoJycpO1xuXHRcdFx0dmFyIGlkeCA9ICQuaW5BcnJheSggY2hhcmFjdGVyLCBhICk7XG5cdFx0XHRhLnNwbGljZSggaWR4LCAxICk7XG5cdFx0XHR0aGlzLnMubGlzdGVuS2V5cyA9IGEuam9pbignJyk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNvbHZlIGEgYnV0dG9uIGNvbmZpZ3VyYXRpb25cblx0ICogQHBhcmFtICB7c3RyaW5nfGZ1bmN0aW9ufG9iamVjdH0gY29uZiBCdXR0b24gY29uZmlnIHRvIHJlc29sdmVcblx0ICogQHJldHVybiB7b2JqZWN0fSBCdXR0b24gY29uZmlndXJhdGlvblxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3Jlc29sdmVFeHRlbmRzOiBmdW5jdGlvbiAoIGNvbmYgKVxuXHR7XG5cdFx0dmFyIGR0ID0gdGhpcy5zLmR0O1xuXHRcdHZhciBpLCBpZW47XG5cdFx0dmFyIHRvQ29uZk9iamVjdCA9IGZ1bmN0aW9uICggYmFzZSApIHtcblx0XHRcdHZhciBsb29wID0gMDtcblxuXHRcdFx0Ly8gTG9vcCB1bnRpbCB3ZSBoYXZlIHJlc29sdmVkIHRvIGEgYnV0dG9uIGNvbmZpZ3VyYXRpb24sIG9yIGFuXG5cdFx0XHQvLyBhcnJheSBvZiBidXR0b24gY29uZmlndXJhdGlvbnMgKHdoaWNoIHdpbGwgYmUgaXRlcmF0ZWRcblx0XHRcdC8vIHNlcGFyYXRlbHkpXG5cdFx0XHR3aGlsZSAoICEgJC5pc1BsYWluT2JqZWN0KGJhc2UpICYmICEgQXJyYXkuaXNBcnJheShiYXNlKSApIHtcblx0XHRcdFx0aWYgKCBiYXNlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0eXBlb2YgYmFzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRiYXNlID0gYmFzZSggZHQsIGNvbmYgKTtcblxuXHRcdFx0XHRcdGlmICggISBiYXNlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmICggdHlwZW9mIGJhc2UgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGlmICggISBfZHRCdXR0b25zWyBiYXNlIF0gKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnVW5rbm93biBidXR0b24gdHlwZTogJytiYXNlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJhc2UgPSBfZHRCdXR0b25zWyBiYXNlIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRsb29wKys7XG5cdFx0XHRcdGlmICggbG9vcCA+IDMwICkge1xuXHRcdFx0XHRcdC8vIFByb3RlY3QgYWdhaW5zdCBtaXNjb25maWd1cmF0aW9uIGtpbGxpbmcgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHR0aHJvdyAnQnV0dG9uczogVG9vIG1hbnkgaXRlcmF0aW9ucyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIEFycmF5LmlzQXJyYXkoIGJhc2UgKSA/XG5cdFx0XHRcdGJhc2UgOlxuXHRcdFx0XHQkLmV4dGVuZCgge30sIGJhc2UgKTtcblx0XHR9O1xuXG5cdFx0Y29uZiA9IHRvQ29uZk9iamVjdCggY29uZiApO1xuXG5cdFx0d2hpbGUgKCBjb25mICYmIGNvbmYuZXh0ZW5kICkge1xuXHRcdFx0Ly8gVXNlIGB0b0NvbmZPYmplY3RgIGluIGNhc2UgdGhlIGJ1dHRvbiBkZWZpbml0aW9uIGJlaW5nIGV4dGVuZGVkXG5cdFx0XHQvLyBpcyBpdHNlbGYgYSBzdHJpbmcgb3IgYSBmdW5jdGlvblxuXHRcdFx0aWYgKCAhIF9kdEJ1dHRvbnNbIGNvbmYuZXh0ZW5kIF0gKSB7XG5cdFx0XHRcdHRocm93ICdDYW5ub3QgZXh0ZW5kIHVua25vd24gYnV0dG9uIHR5cGU6ICcrY29uZi5leHRlbmQ7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBvYmpBcnJheSA9IHRvQ29uZk9iamVjdCggX2R0QnV0dG9uc1sgY29uZi5leHRlbmQgXSApO1xuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmpBcnJheSApICkge1xuXHRcdFx0XHRyZXR1cm4gb2JqQXJyYXk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggISBvYmpBcnJheSApIHtcblx0XHRcdFx0Ly8gVGhpcyBpcyBhIGxpdHRsZSBicnV0YWwgYXMgaXQgbWlnaHQgYmUgcG9zc2libGUgdG8gaGF2ZSBhXG5cdFx0XHRcdC8vIHZhbGlkIGJ1dHRvbiB3aXRob3V0IHRoZSBleHRlbmQsIGJ1dCBpZiB0aGVyZSBpcyBubyBleHRlbmRcblx0XHRcdFx0Ly8gdGhlbiB0aGUgaG9zdCBidXR0b24gd291bGQgYmUgYWN0aW5nIGluIGFuIHVuZGVmaW5lZCBzdGF0ZVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXNoIHRoZSBjdXJyZW50IGNsYXNzIG5hbWVcblx0XHRcdHZhciBvcmlnaW5hbENsYXNzTmFtZSA9IG9iakFycmF5LmNsYXNzTmFtZTtcblxuXHRcdFx0Y29uZiA9ICQuZXh0ZW5kKCB7fSwgb2JqQXJyYXksIGNvbmYgKTtcblxuXHRcdFx0Ly8gVGhlIGV4dGVuZCB3aWxsIGhhdmUgb3ZlcndyaXR0ZW4gdGhlIG9yaWdpbmFsIGNsYXNzIG5hbWUgaWYgdGhlXG5cdFx0XHQvLyBgY29uZmAgb2JqZWN0IGFsc28gYXNzaWduZWQgYSBjbGFzcywgYnV0IHdlIHdhbnQgdG8gY29uY2F0ZW5hdGVcblx0XHRcdC8vIHRoZW0gc28gdGhleSBhcmUgbGlzdCB0aGF0IGlzIGNvbWJpbmVkIGZyb20gYWxsIGV4dGVuZGVkIGJ1dHRvbnNcblx0XHRcdGlmICggb3JpZ2luYWxDbGFzc05hbWUgJiYgY29uZi5jbGFzc05hbWUgIT09IG9yaWdpbmFsQ2xhc3NOYW1lICkge1xuXHRcdFx0XHRjb25mLmNsYXNzTmFtZSA9IG9yaWdpbmFsQ2xhc3NOYW1lKycgJytjb25mLmNsYXNzTmFtZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0dG9ucyB0byBiZSBhZGRlZCB0byBhIGNvbGxlY3Rpb24gIC1naXZlcyB0aGUgYWJpbGl0eSB0byBkZWZpbmVcblx0XHRcdC8vIGlmIGJ1dHRvbnMgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgYSBjb2xsZWN0aW9uXG5cdFx0XHR2YXIgcG9zdGZpeEJ1dHRvbnMgPSBjb25mLnBvc3RmaXhCdXR0b25zO1xuXHRcdFx0aWYgKCBwb3N0Zml4QnV0dG9ucyApIHtcblx0XHRcdFx0aWYgKCAhIGNvbmYuYnV0dG9ucyApIHtcblx0XHRcdFx0XHRjb25mLmJ1dHRvbnMgPSBbXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPXBvc3RmaXhCdXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRcdGNvbmYuYnV0dG9ucy5wdXNoKCBwb3N0Zml4QnV0dG9uc1tpXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y29uZi5wb3N0Zml4QnV0dG9ucyA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwcmVmaXhCdXR0b25zID0gY29uZi5wcmVmaXhCdXR0b25zO1xuXHRcdFx0aWYgKCBwcmVmaXhCdXR0b25zICkge1xuXHRcdFx0XHRpZiAoICEgY29uZi5idXR0b25zICkge1xuXHRcdFx0XHRcdGNvbmYuYnV0dG9ucyA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Zm9yICggaT0wLCBpZW49cHJlZml4QnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRjb25mLmJ1dHRvbnMuc3BsaWNlKCBpLCAwLCBwcmVmaXhCdXR0b25zW2ldICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25mLnByZWZpeEJ1dHRvbnMgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBbHRob3VnaCB3ZSB3YW50IHRoZSBgY29uZmAgb2JqZWN0IHRvIG92ZXJ3cml0ZSBhbG1vc3QgYWxsIG9mXG5cdFx0XHQvLyB0aGUgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0IGJlaW5nIGV4dGVuZGVkLCB0aGUgYGV4dGVuZGBcblx0XHRcdC8vIHByb3BlcnR5IHNob3VsZCBjb21lIGZyb20gdGhlIG9iamVjdCBiZWluZyBleHRlbmRlZFxuXHRcdFx0Y29uZi5leHRlbmQgPSBvYmpBcnJheS5leHRlbmQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbmY7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERpc3BsYXkgKGFuZCByZXBsYWNlIGlmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIG9uZSkgYSBwb3BvdmVyIGF0dGFjaGVkIHRvIGEgYnV0dG9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfG5vZGV9IGNvbnRlbnQgQ29udGVudCB0byBzaG93XG5cdCAqIEBwYXJhbSB7RGF0YVRhYmxlLkFwaX0gaG9zdEJ1dHRvbiBEVCBBUEkgaW5zdGFuY2Ugb2YgdGhlIGJ1dHRvblxuXHQgKiBAcGFyYW0ge29iamVjdH0gaW5PcHRzIE9wdGlvbnMgKHNlZSBvYmplY3QgYmVsb3cgZm9yIGFsbCBvcHRpb25zKVxuXHQgKi9cblx0X3BvcG92ZXI6IGZ1bmN0aW9uICggY29udGVudCwgaG9zdEJ1dHRvbiwgaW5PcHRzICkge1xuXHRcdHZhciBkdCA9IGhvc3RCdXR0b247XG5cdFx0dmFyIGJ1dHRvbnNTZXR0aW5ncyA9IHRoaXMuYztcblx0XHR2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKCB7XG5cdFx0XHRhbGlnbjogJ2J1dHRvbi1sZWZ0JywgLy8gYnV0dG9uLXJpZ2h0LCBkdC1jb250YWluZXJcblx0XHRcdGF1dG9DbG9zZTogZmFsc2UsXG5cdFx0XHRiYWNrZ3JvdW5kOiB0cnVlLFxuXHRcdFx0YmFja2dyb3VuZENsYXNzTmFtZTogJ2R0LWJ1dHRvbi1iYWNrZ3JvdW5kJyxcblx0XHRcdGNvbnRlbnRDbGFzc05hbWU6IGJ1dHRvbnNTZXR0aW5ncy5kb20uY29sbGVjdGlvbi5jbGFzc05hbWUsXG5cdFx0XHRjb2xsZWN0aW9uTGF5b3V0OiAnJyxcblx0XHRcdGNvbGxlY3Rpb25UaXRsZTogJycsXG5cdFx0XHRkcm9wdXA6IGZhbHNlLFxuXHRcdFx0ZmFkZTogNDAwLFxuXHRcdFx0cmlnaHRBbGlnbkNsYXNzTmFtZTogJ2R0LWJ1dHRvbi1yaWdodCcsXG5cdFx0XHR0YWc6IGJ1dHRvbnNTZXR0aW5ncy5kb20uY29sbGVjdGlvbi50YWdcblx0XHR9LCBpbk9wdHMgKTtcblx0XHR2YXIgaG9zdE5vZGUgPSBob3N0QnV0dG9uLm5vZGUoKTtcblxuXHRcdHZhciBjbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdF9mYWRlT3V0KFxuXHRcdFx0XHQkKCcuZHQtYnV0dG9uLWNvbGxlY3Rpb24nKSxcblx0XHRcdFx0b3B0aW9ucy5mYWRlLFxuXHRcdFx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0JCh0aGlzKS5kZXRhY2goKTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblxuXHRcdFx0JChkdC5idXR0b25zKCAnW2FyaWEtaGFzcG9wdXA9XCJ0cnVlXCJdW2FyaWEtZXhwYW5kZWQ9XCJ0cnVlXCJdJyApLm5vZGVzKCkpXG5cdFx0XHRcdC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cblx0XHRcdCQoJ2Rpdi5kdC1idXR0b24tYmFja2dyb3VuZCcpLm9mZiggJ2NsaWNrLmR0Yi1jb2xsZWN0aW9uJyApO1xuXHRcdFx0QnV0dG9ucy5iYWNrZ3JvdW5kKCBmYWxzZSwgb3B0aW9ucy5iYWNrZ3JvdW5kQ2xhc3NOYW1lLCBvcHRpb25zLmZhZGUsIGhvc3ROb2RlICk7XG5cblx0XHRcdCQoJ2JvZHknKS5vZmYoICcuZHRiLWNvbGxlY3Rpb24nICk7XG5cdFx0XHRkdC5vZmYoICdidXR0b25zLWFjdGlvbi5iLWludGVybmFsJyApO1xuXHRcdH07XG5cblx0XHRpZiAoY29udGVudCA9PT0gZmFsc2UpIHtcblx0XHRcdGNsb3NlKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGV4aXN0aW5nRXhwYW5kZWQgPSAkKGR0LmJ1dHRvbnMoICdbYXJpYS1oYXNwb3B1cD1cInRydWVcIl1bYXJpYS1leHBhbmRlZD1cInRydWVcIl0nICkubm9kZXMoKSk7XG5cdFx0aWYgKCBleGlzdGluZ0V4cGFuZGVkLmxlbmd0aCApIHtcblx0XHRcdGhvc3ROb2RlID0gZXhpc3RpbmdFeHBhbmRlZC5lcSgwKTtcblxuXHRcdFx0Y2xvc2UoKTtcblx0XHR9XG5cblx0XHR2YXIgZGlzcGxheSA9ICQoJzxkaXYvPicpXG5cdFx0XHQuYWRkQ2xhc3MoJ2R0LWJ1dHRvbi1jb2xsZWN0aW9uJylcblx0XHRcdC5hZGRDbGFzcyhvcHRpb25zLmNvbGxlY3Rpb25MYXlvdXQpXG5cdFx0XHQuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcblxuXHRcdGNvbnRlbnQgPSAkKGNvbnRlbnQpXG5cdFx0XHQuYWRkQ2xhc3Mob3B0aW9ucy5jb250ZW50Q2xhc3NOYW1lKVxuXHRcdFx0LmF0dHIoJ3JvbGUnLCAnbWVudScpXG5cdFx0XHQuYXBwZW5kVG8oZGlzcGxheSk7XG5cblx0XHRob3N0Tm9kZS5hdHRyKCAnYXJpYS1leHBhbmRlZCcsICd0cnVlJyApO1xuXG5cdFx0aWYgKCBob3N0Tm9kZS5wYXJlbnRzKCdib2R5JylbMF0gIT09IGRvY3VtZW50LmJvZHkgKSB7XG5cdFx0XHRob3N0Tm9kZSA9IGRvY3VtZW50LmJvZHkubGFzdENoaWxkO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy5jb2xsZWN0aW9uVGl0bGUgKSB7XG5cdFx0XHRkaXNwbGF5LnByZXBlbmQoJzxkaXYgY2xhc3M9XCJkdC1idXR0b24tY29sbGVjdGlvbi10aXRsZVwiPicrb3B0aW9ucy5jb2xsZWN0aW9uVGl0bGUrJzwvZGl2PicpO1xuXHRcdH1cblxuXHRcdF9mYWRlSW4oIGRpc3BsYXkuaW5zZXJ0QWZ0ZXIoIGhvc3ROb2RlICksIG9wdGlvbnMuZmFkZSApO1xuXG5cdFx0dmFyIHRhYmxlQ29udGFpbmVyID0gJCggaG9zdEJ1dHRvbi50YWJsZSgpLmNvbnRhaW5lcigpICk7XG5cdFx0dmFyIHBvc2l0aW9uID0gZGlzcGxheS5jc3MoICdwb3NpdGlvbicgKTtcblxuXHRcdGlmICggb3B0aW9ucy5hbGlnbiA9PT0gJ2R0LWNvbnRhaW5lcicgKSB7XG5cdFx0XHRob3N0Tm9kZSA9IGhvc3ROb2RlLnBhcmVudCgpO1xuXHRcdFx0ZGlzcGxheS5jc3MoJ3dpZHRoJywgdGFibGVDb250YWluZXIud2lkdGgoKSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxpZ24gdGhlIHBvcG92ZXIgcmVsYXRpdmUgdG8gdGhlIERhdGFUYWJsZXMgY29udGFpbmVyXG5cdFx0Ly8gVXNlZnVsIGZvciB3aWRlIHBvcG92ZXJzIHN1Y2ggYXMgU2VhcmNoUGFuZXNcblx0XHRpZiAoXG5cdFx0XHRwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJyAmJlxuXHRcdFx0KFxuXHRcdFx0XHRkaXNwbGF5Lmhhc0NsYXNzKCBvcHRpb25zLnJpZ2h0QWxpZ25DbGFzc05hbWUgKSB8fFxuXHRcdFx0XHRkaXNwbGF5Lmhhc0NsYXNzKCBvcHRpb25zLmxlZnRBbGlnbkNsYXNzTmFtZSApIHx8XG5cdFx0XHRcdG9wdGlvbnMuYWxpZ24gPT09ICdkdC1jb250YWluZXInXG5cdFx0XHQpXG5cdFx0KSB7XG5cblx0XHRcdHZhciBob3N0UG9zaXRpb24gPSBob3N0Tm9kZS5wb3NpdGlvbigpO1xuXG5cdFx0XHRkaXNwbGF5LmNzcygge1xuXHRcdFx0XHR0b3A6IGhvc3RQb3NpdGlvbi50b3AgKyBob3N0Tm9kZS5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRsZWZ0OiBob3N0UG9zaXRpb24ubGVmdFxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3ZlcmZsb3cgd2hlbiBwb3NpdGlvbmVkIGJlbmVhdGhcblx0XHRcdHZhciBjb2xsZWN0aW9uSGVpZ2h0ID0gZGlzcGxheS5vdXRlckhlaWdodCgpO1xuXHRcdFx0dmFyIHRhYmxlQm90dG9tID0gdGFibGVDb250YWluZXIub2Zmc2V0KCkudG9wICsgdGFibGVDb250YWluZXIuaGVpZ2h0KCk7XG5cdFx0XHR2YXIgbGlzdEJvdHRvbSA9IGhvc3RQb3NpdGlvbi50b3AgKyBob3N0Tm9kZS5vdXRlckhlaWdodCgpICsgY29sbGVjdGlvbkhlaWdodDtcblx0XHRcdHZhciBib3R0b21PdmVyZmxvdyA9IGxpc3RCb3R0b20gLSB0YWJsZUJvdHRvbTtcblxuXHRcdFx0Ly8gY2FsY3VsYXRlIG92ZXJmbG93IHdoZW4gcG9zaXRpb25lZCBhYm92ZVxuXHRcdFx0dmFyIGxpc3RUb3AgPSBob3N0UG9zaXRpb24udG9wIC0gY29sbGVjdGlvbkhlaWdodDtcblx0XHRcdHZhciB0YWJsZVRvcCA9IHRhYmxlQ29udGFpbmVyLm9mZnNldCgpLnRvcDtcblx0XHRcdHZhciB0b3BPdmVyZmxvdyA9IHRhYmxlVG9wIC0gbGlzdFRvcDtcblxuXHRcdFx0Ly8gaWYgYm90dG9tIG92ZXJmbG93IGlzIGxhcmdlciwgbW92ZSB0byB0aGUgdG9wIGJlY2F1c2UgaXQgZml0cyBiZXR0ZXIsIG9yIGlmIGRyb3B1cCBpcyByZXF1ZXN0ZWRcblx0XHRcdHZhciBtb3ZlVG9wID0gaG9zdFBvc2l0aW9uLnRvcCAtIGNvbGxlY3Rpb25IZWlnaHQgLSA1O1xuXHRcdFx0aWYgKCAoYm90dG9tT3ZlcmZsb3cgPiB0b3BPdmVyZmxvdyB8fCBvcHRpb25zLmRyb3B1cCkgJiYgLW1vdmVUb3AgPCB0YWJsZVRvcCApIHtcblx0XHRcdFx0ZGlzcGxheS5jc3MoICd0b3AnLCBtb3ZlVG9wKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gR2V0IHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgKGxlZnQgYW5kIHdpZHRoIC0gYW5kIHRodXMgYWxzbyByaWdodClcblx0XHRcdHZhciB0YWJsZUxlZnQgPSB0YWJsZUNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dmFyIHRhYmxlV2lkdGggPSB0YWJsZUNvbnRhaW5lci53aWR0aCgpO1xuXHRcdFx0dmFyIHRhYmxlUmlnaHQgPSB0YWJsZUxlZnQgKyB0YWJsZVdpZHRoO1xuXG5cdFx0XHQvLyBHZXQgdGhlIHNpemUgb2YgdGhlIHBvcG92ZXIgKGxlZnQgYW5kIHdpZHRoIC0gYW5kIC4uLilcblx0XHRcdHZhciBwb3BvdmVyTGVmdCA9IGRpc3BsYXkub2Zmc2V0KCkubGVmdDtcblx0XHRcdHZhciBwb3BvdmVyV2lkdGggPSBkaXNwbGF5LndpZHRoKCk7XG5cdFx0XHR2YXIgcG9wb3ZlclJpZ2h0ID0gcG9wb3ZlckxlZnQgKyBwb3BvdmVyV2lkdGg7XG5cblx0XHRcdC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgaG9zdCBidXR0b25zIChsZWZ0IGFuZCB3aWR0aCAtIGFuZCAuLi4pXG5cdFx0XHR2YXIgYnV0dG9uc0xlZnQgPSBob3N0Tm9kZS5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dmFyIGJ1dHRvbnNXaWR0aCA9IGhvc3ROb2RlLm91dGVyV2lkdGgoKVxuXHRcdFx0dmFyIGJ1dHRvbnNSaWdodCA9IGJ1dHRvbnNMZWZ0ICsgYnV0dG9uc1dpZHRoO1xuXHRcdFx0XG5cdFx0XHQvLyBZb3UndmUgdGhlbiBnb3QgYWxsIHRoZSBudW1iZXJzIHlvdSBuZWVkIHRvIGRvIHNvbWUgY2FsY3VsYXRpb25zIGFuZCBpZiBzdGF0ZW1lbnRzLFxuXHRcdFx0Ly8gIHNvIHdlIGNhbiBkbyBzb21lIHF1aWNrIEpTIG1hdGhzIGFuZCBhcHBseSBpdCBvbmx5IG9uY2Vcblx0XHRcdC8vIElmIGl0IGhhcyB0aGUgcmlnaHQgYWxpZ24gY2xhc3MgT1IgdGhlIGJ1dHRvbnMgYXJlIHJpZ2h0IGFsaWduZWQgT1IgdGhlIGJ1dHRvbiBjb250YWluZXIgaXMgZmxvYXRlZCByaWdodCxcblx0XHRcdC8vICB0aGVuIGNhbGN1bGF0ZSBsZWZ0IHBvc2l0aW9uIGZvciB0aGUgcG9wb3ZlciB0byBhbGlnbiB0aGUgcG9wb3ZlciB0byB0aGUgcmlnaHQgaGFuZFxuXHRcdFx0Ly8gIHNpZGUgb2YgdGhlIGJ1dHRvbiAtIGNoZWNrIHRvIHNlZSBpZiB0aGUgbGVmdCBvZiB0aGUgcG9wb3ZlciBpcyBpbnNpZGUgdGhlIHRhYmxlIGNvbnRhaW5lci5cblx0XHRcdC8vIElmIG5vdCwgbW92ZSB0aGUgcG9wb3ZlciBzbyBpdCBpcywgYnV0IG5vdCBtb3JlIHRoYW4gaXQgbWVhbnMgdGhhdCB0aGUgcG9wb3ZlciBpcyB0byB0aGUgcmlnaHQgb2YgdGhlIHRhYmxlIGNvbnRhaW5lclxuXHRcdFx0dmFyIHBvcG92ZXJTaHVmZmxlID0gMDtcblx0XHRcdGlmICggZGlzcGxheS5oYXNDbGFzcyggb3B0aW9ucy5yaWdodEFsaWduQ2xhc3NOYW1lICkpIHtcblx0XHRcdFx0cG9wb3ZlclNodWZmbGUgPSBidXR0b25zUmlnaHQgLSBwb3BvdmVyUmlnaHQ7XG5cdFx0XHRcdGlmKHRhYmxlTGVmdCA+IChwb3BvdmVyTGVmdCArIHBvcG92ZXJTaHVmZmxlKSl7XG5cdFx0XHRcdFx0dmFyIGxlZnRHYXAgPSB0YWJsZUxlZnQgLSAocG9wb3ZlckxlZnQgKyBwb3BvdmVyU2h1ZmZsZSk7XG5cdFx0XHRcdFx0dmFyIHJpZ2h0R2FwID0gdGFibGVSaWdodCAtIChwb3BvdmVyUmlnaHQgKyBwb3BvdmVyU2h1ZmZsZSk7XG5cdFxuXHRcdFx0XHRcdGlmKGxlZnRHYXAgPiByaWdodEdhcCl7XG5cdFx0XHRcdFx0XHRwb3BvdmVyU2h1ZmZsZSArPSByaWdodEdhcDsgXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9wb3ZlclNodWZmbGUgKz0gbGVmdEdhcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGVsc2UgYXR0ZW1wdCB0byBsZWZ0IGFsaWduIHRoZSBwb3BvdmVyIHRvIHRoZSBidXR0b24uIFNpbWlsYXIgdG8gYWJvdmUsIGlmIHRoZSBwb3BvdmVyJ3MgcmlnaHQgZ29lcyBwYXN0IHRoZSB0YWJsZSBjb250YWluZXIncyByaWdodCxcblx0XHRcdC8vICB0aGVuIG1vdmUgaXQgYmFjaywgYnV0IG5vdCBzbyBtdWNoIHRoYXQgaXQgZ29lcyBwYXN0IHRoZSBsZWZ0IG9mIHRoZSB0YWJsZSBjb250YWluZXJcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRwb3BvdmVyU2h1ZmZsZSA9IHRhYmxlTGVmdCAtIHBvcG92ZXJMZWZ0O1xuXG5cdFx0XHRcdGlmKHRhYmxlUmlnaHQgPCAocG9wb3ZlclJpZ2h0ICsgcG9wb3ZlclNodWZmbGUpKXtcblx0XHRcdFx0XHR2YXIgbGVmdEdhcCA9IHRhYmxlTGVmdCAtIChwb3BvdmVyTGVmdCArIHBvcG92ZXJTaHVmZmxlKTtcblx0XHRcdFx0XHR2YXIgcmlnaHRHYXAgPSB0YWJsZVJpZ2h0IC0gKHBvcG92ZXJSaWdodCArIHBvcG92ZXJTaHVmZmxlKTtcblxuXHRcdFx0XHRcdGlmKGxlZnRHYXAgPiByaWdodEdhcCApe1xuXHRcdFx0XHRcdFx0cG9wb3ZlclNodWZmbGUgKz0gcmlnaHRHYXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0cG9wb3ZlclNodWZmbGUgKz0gbGVmdEdhcDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRkaXNwbGF5LmNzcygnbGVmdCcsIGRpc3BsYXkucG9zaXRpb24oKS5sZWZ0ICsgcG9wb3ZlclNodWZmbGUpO1xuXHRcdFx0XG5cdFx0fVxuXHRcdGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG5cdFx0XHQvLyBBbGlnbiByZWxhdGl2ZSB0byB0aGUgaG9zdCBidXR0b25cblx0XHRcdHZhciBob3N0UG9zaXRpb24gPSBob3N0Tm9kZS5wb3NpdGlvbigpO1xuXG5cdFx0XHRkaXNwbGF5LmNzcygge1xuXHRcdFx0XHR0b3A6IGhvc3RQb3NpdGlvbi50b3AgKyBob3N0Tm9kZS5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRsZWZ0OiBob3N0UG9zaXRpb24ubGVmdFxuXHRcdFx0fSApO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3ZlcmZsb3cgd2hlbiBwb3NpdGlvbmVkIGJlbmVhdGhcblx0XHRcdHZhciBjb2xsZWN0aW9uSGVpZ2h0ID0gZGlzcGxheS5vdXRlckhlaWdodCgpO1xuXHRcdFx0dmFyIHRvcCA9IGhvc3ROb2RlLm9mZnNldCgpLnRvcFxuXHRcdFx0dmFyIHBvcG92ZXJTaHVmZmxlID0gMDtcblxuXHRcdFx0Ly8gR2V0IHRoZSBzaXplIG9mIHRoZSBob3N0IGJ1dHRvbnMgKGxlZnQgYW5kIHdpZHRoIC0gYW5kIC4uLilcblx0XHRcdHZhciBidXR0b25zTGVmdCA9IGhvc3ROb2RlLm9mZnNldCgpLmxlZnQ7XG5cdFx0XHR2YXIgYnV0dG9uc1dpZHRoID0gaG9zdE5vZGUub3V0ZXJXaWR0aCgpXG5cdFx0XHR2YXIgYnV0dG9uc1JpZ2h0ID0gYnV0dG9uc0xlZnQgKyBidXR0b25zV2lkdGg7XG5cblx0XHRcdC8vIEdldCB0aGUgc2l6ZSBvZiB0aGUgcG9wb3ZlciAobGVmdCBhbmQgd2lkdGggLSBhbmQgLi4uKVxuXHRcdFx0dmFyIHBvcG92ZXJMZWZ0ID0gZGlzcGxheS5vZmZzZXQoKS5sZWZ0O1xuXHRcdFx0dmFyIHBvcG92ZXJXaWR0aCA9IGNvbnRlbnQud2lkdGgoKTtcblx0XHRcdHZhciBwb3BvdmVyUmlnaHQgPSBwb3BvdmVyTGVmdCArIHBvcG92ZXJXaWR0aDtcblxuXHRcdFx0dmFyIG1vdmVUb3AgPSBob3N0UG9zaXRpb24udG9wIC0gY29sbGVjdGlvbkhlaWdodCAtIDU7XG5cdFx0XHR2YXIgdGFibGVCb3R0b20gPSB0YWJsZUNvbnRhaW5lci5vZmZzZXQoKS50b3AgKyB0YWJsZUNvbnRhaW5lci5oZWlnaHQoKTtcblx0XHRcdHZhciBsaXN0Qm90dG9tID0gaG9zdFBvc2l0aW9uLnRvcCArIGhvc3ROb2RlLm91dGVySGVpZ2h0KCkgKyBjb2xsZWN0aW9uSGVpZ2h0O1xuXHRcdFx0dmFyIGJvdHRvbU92ZXJmbG93ID0gbGlzdEJvdHRvbSAtIHRhYmxlQm90dG9tO1xuXG5cdFx0XHQvLyBjYWxjdWxhdGUgb3ZlcmZsb3cgd2hlbiBwb3NpdGlvbmVkIGFib3ZlXG5cdFx0XHR2YXIgbGlzdFRvcCA9IGhvc3RQb3NpdGlvbi50b3AgLSBjb2xsZWN0aW9uSGVpZ2h0O1xuXHRcdFx0dmFyIHRhYmxlVG9wID0gdGFibGVDb250YWluZXIub2Zmc2V0KCkudG9wO1xuXHRcdFx0dmFyIHRvcE92ZXJmbG93ID0gdGFibGVUb3AgLSBsaXN0VG9wO1xuXG5cdFx0XHRpZiAoIChib3R0b21PdmVyZmxvdyA+IHRvcE92ZXJmbG93IHx8IG9wdGlvbnMuZHJvcHVwKSAmJiAtbW92ZVRvcCA8IHRhYmxlVG9wICkge1xuXHRcdFx0XHRkaXNwbGF5LmNzcyggJ3RvcCcsIG1vdmVUb3ApO1xuXHRcdFx0fVxuXG5cdFx0XHRwb3BvdmVyU2h1ZmZsZSA9IG9wdGlvbnMuYWxpZ24gPT09ICdidXR0b24tcmlnaHQnXG5cdFx0XHRcdD8gYnV0dG9uc1JpZ2h0IC0gcG9wb3ZlclJpZ2h0XG5cdFx0XHRcdDogYnV0dG9uc0xlZnQgLSBwb3BvdmVyTGVmdDtcblxuXHRcdFx0ZGlzcGxheS5jc3MoJ2xlZnQnLCBkaXNwbGF5LnBvc2l0aW9uKCkubGVmdCArIHBvcG92ZXJTaHVmZmxlKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBGaXggcG9zaXRpb24gLSBjZW50cmUgb24gc2NyZWVuXG5cdFx0XHR2YXIgdG9wID0gZGlzcGxheS5oZWlnaHQoKSAvIDI7XG5cdFx0XHRpZiAoIHRvcCA+ICQod2luZG93KS5oZWlnaHQoKSAvIDIgKSB7XG5cdFx0XHRcdHRvcCA9ICQod2luZG93KS5oZWlnaHQoKSAvIDI7XG5cdFx0XHR9XG5cblx0XHRcdGRpc3BsYXkuY3NzKCAnbWFyZ2luVG9wJywgdG9wKi0xICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLmJhY2tncm91bmQgKSB7XG5cdFx0XHRCdXR0b25zLmJhY2tncm91bmQoIHRydWUsIG9wdGlvbnMuYmFja2dyb3VuZENsYXNzTmFtZSwgb3B0aW9ucy5mYWRlLCBob3N0Tm9kZSApO1xuXHRcdH1cblxuXHRcdC8vIFRoaXMgaXMgYm9ua2VycywgYnV0IGlmIHdlIGRvbid0IGhhdmUgYSBjbGljayBsaXN0ZW5lciBvbiB0aGVcblx0XHQvLyBiYWNrZ3JvdW5kIGVsZW1lbnQsIGlPUyBTYWZhcmkgd2lsbCBpZ25vcmUgdGhlIGJvZHkgY2xpY2tcblx0XHQvLyBsaXN0ZW5lciBiZWxvdy4gQW4gZW1wdHkgZnVuY3Rpb24gaGVyZSBpcyBhbGwgdGhhdCBpc1xuXHRcdC8vIHJlcXVpcmVkIHRvIG1ha2UgaXQgd29yay4uLlxuXHRcdCQoJ2Rpdi5kdC1idXR0b24tYmFja2dyb3VuZCcpLm9uKCAnY2xpY2suZHRiLWNvbGxlY3Rpb24nLCBmdW5jdGlvbiAoKSB7fSApO1xuXG5cdFx0JCgnYm9keScpXG5cdFx0XHQub24oICdjbGljay5kdGItY29sbGVjdGlvbicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdC8vIGFuZFNlbGYgaXMgZGVwcmVjYXRlZCBpbiBqUTEuOCwgYnV0IHdlIHdhbnQgMS43IGNvbXBhdFxuXHRcdFx0XHR2YXIgYmFjayA9ICQuZm4uYWRkQmFjayA/ICdhZGRCYWNrJyA6ICdhbmRTZWxmJztcblx0XHRcdFx0dmFyIHBhcmVudCA9ICQoZS50YXJnZXQpLnBhcmVudCgpWzBdO1xuXG5cdFx0XHRcdGlmICgoICEgJChlLnRhcmdldCkucGFyZW50cygpW2JhY2tdKCkuZmlsdGVyKCBjb250ZW50ICkubGVuZ3RoICAmJiAhJChwYXJlbnQpLmhhc0NsYXNzKCdkdC1idXR0b25zJykpIHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKCdkdC1idXR0b24tYmFja2dyb3VuZCcpKSB7XG5cdFx0XHRcdFx0Y2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApXG5cdFx0XHQub24oICdrZXl1cC5kdGItY29sbGVjdGlvbicsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdGlmICggZS5rZXlDb2RlID09PSAyNyApIHtcblx0XHRcdFx0XHRjbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cblx0XHRpZiAoIG9wdGlvbnMuYXV0b0Nsb3NlICkge1xuXHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRkdC5vbiggJ2J1dHRvbnMtYWN0aW9uLmItaW50ZXJuYWwnLCBmdW5jdGlvbiAoZSwgYnRuLCBkdCwgbm9kZSkge1xuXHRcdFx0XHRcdGlmICggbm9kZVswXSA9PT0gaG9zdE5vZGVbMF0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNsb3NlKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sIDApO1xuXHRcdH1cblxuXHRcdCQoZGlzcGxheSkudHJpZ2dlcignYnV0dG9ucy1wb3BvdmVyLmR0Jyk7XG5cdH1cbn0gKTtcblxuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIFN0YXRpY3NcbiAqL1xuXG4vKipcbiAqIFNob3cgLyBoaWRlIGEgYmFja2dyb3VuZCBsYXllciBiZWhpbmQgYSBjb2xsZWN0aW9uXG4gKiBAcGFyYW0gIHtib29sZWFufSBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBiYWNrZ3JvdW5kIHNob3VsZCBiZSBzaG93biBvclxuICogICBoaWRkZW4gXG4gKiBAcGFyYW0gIHtzdHJpbmd9IENsYXNzIHRvIGFzc2lnbiB0byB0aGUgYmFja2dyb3VuZFxuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmJhY2tncm91bmQgPSBmdW5jdGlvbiAoIHNob3csIGNsYXNzTmFtZSwgZmFkZSwgaW5zZXJ0UG9pbnQgKSB7XG5cdGlmICggZmFkZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdGZhZGUgPSA0MDA7XG5cdH1cblx0aWYgKCAhIGluc2VydFBvaW50ICkge1xuXHRcdGluc2VydFBvaW50ID0gZG9jdW1lbnQuYm9keTtcblx0fVxuXG5cdGlmICggc2hvdyApIHtcblx0XHRfZmFkZUluKFxuXHRcdFx0JCgnPGRpdi8+Jylcblx0XHRcdFx0LmFkZENsYXNzKCBjbGFzc05hbWUgKVxuXHRcdFx0XHQuY3NzKCAnZGlzcGxheScsICdub25lJyApXG5cdFx0XHRcdC5pbnNlcnRBZnRlciggaW5zZXJ0UG9pbnQgKSxcblx0XHRcdGZhZGVcblx0XHQpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdF9mYWRlT3V0KFxuXHRcdFx0JCgnZGl2LicrY2xhc3NOYW1lKSxcblx0XHRcdGZhZGUsXG5cdFx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdCQodGhpcylcblx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoIGNsYXNzTmFtZSApXG5cdFx0XHRcdFx0LnJlbW92ZSgpO1xuXHRcdFx0fVxuXHRcdCk7XG5cdH1cbn07XG5cbi8qKlxuICogSW5zdGFuY2Ugc2VsZWN0b3IgLSBzZWxlY3QgQnV0dG9ucyBpbnN0YW5jZXMgYmFzZWQgb24gYW4gaW5zdGFuY2Ugc2VsZWN0b3JcbiAqIHZhbHVlIGZyb20gdGhlIGJ1dHRvbnMgYXNzaWduZWQgdG8gYSBEYXRhVGFibGUuIFRoaXMgaXMgb25seSB1c2VmdWwgaWZcbiAqIG11bHRpcGxlIGluc3RhbmNlcyBhcmUgYXR0YWNoZWQgdG8gYSBEYXRhVGFibGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd8aW50fGFycmF5fSBJbnN0YW5jZSBzZWxlY3RvciAtIHNlZSBgaW5zdGFuY2Utc2VsZWN0b3JgXG4gKiAgIGRvY3VtZW50YXRpb24gb24gdGhlIERhdGFUYWJsZXMgc2l0ZVxuICogQHBhcmFtICB7YXJyYXl9IEJ1dHRvbiBpbnN0YW5jZSBhcnJheSB0aGF0IHdhcyBhdHRhY2hlZCB0byB0aGUgRGF0YVRhYmxlc1xuICogICBzZXR0aW5ncyBvYmplY3RcbiAqIEByZXR1cm4ge2FycmF5fSBCdXR0b25zIGluc3RhbmNlc1xuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmluc3RhbmNlU2VsZWN0b3IgPSBmdW5jdGlvbiAoIGdyb3VwLCBidXR0b25zIClcbntcblx0aWYgKCBncm91cCA9PT0gdW5kZWZpbmVkIHx8IGdyb3VwID09PSBudWxsICkge1xuXHRcdHJldHVybiAkLm1hcCggYnV0dG9ucywgZnVuY3Rpb24gKCB2ICkge1xuXHRcdFx0cmV0dXJuIHYuaW5zdDtcblx0XHR9ICk7XG5cdH1cblxuXHR2YXIgcmV0ID0gW107XG5cdHZhciBuYW1lcyA9ICQubWFwKCBidXR0b25zLCBmdW5jdGlvbiAoIHYgKSB7XG5cdFx0cmV0dXJuIHYubmFtZTtcblx0fSApO1xuXG5cdC8vIEZsYXR0ZW4gdGhlIGdyb3VwIHNlbGVjdG9yIGludG8gYW4gYXJyYXkgb2Ygc2luZ2xlIG9wdGlvbnNcblx0dmFyIHByb2Nlc3MgPSBmdW5jdGlvbiAoIGlucHV0ICkge1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggaW5wdXQgKSApIHtcblx0XHRcdGZvciAoIHZhciBpPTAsIGllbj1pbnB1dC5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0cHJvY2VzcyggaW5wdXRbaV0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRpZiAoIGlucHV0LmluZGV4T2YoICcsJyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gU3RyaW5nIHNlbGVjdG9yLCBsaXN0IG9mIG5hbWVzXG5cdFx0XHRcdHByb2Nlc3MoIGlucHV0LnNwbGl0KCcsJykgKTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBTdHJpbmcgc2VsZWN0b3IgaW5kaXZpZHVhbCBuYW1lXG5cdFx0XHRcdHZhciBpZHggPSAkLmluQXJyYXkoIGlucHV0LnRyaW0oKSwgbmFtZXMgKTtcblxuXHRcdFx0XHRpZiAoIGlkeCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIGJ1dHRvbnNbIGlkeCBdLmluc3QgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJyApIHtcblx0XHRcdC8vIEluZGV4IHNlbGVjdG9yXG5cdFx0XHRyZXQucHVzaCggYnV0dG9uc1sgaW5wdXQgXS5pbnN0ICk7XG5cdFx0fVxuXHR9O1xuXHRcblx0cHJvY2VzcyggZ3JvdXAgKTtcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBCdXR0b24gc2VsZWN0b3IgLSBzZWxlY3Qgb25lIG9yIG1vcmUgYnV0dG9ucyBmcm9tIGEgc2VsZWN0b3IgaW5wdXQgc28gc29tZVxuICogb3BlcmF0aW9uIGNhbiBiZSBwZXJmb3JtZWQgb24gdGhlbS5cbiAqIEBwYXJhbSAge2FycmF5fSBCdXR0b24gaW5zdGFuY2VzIGFycmF5IHRoYXQgdGhlIHNlbGVjdG9yIHNob3VsZCBvcGVyYXRlIG9uXG4gKiBAcGFyYW0gIHtzdHJpbmd8aW50fG5vZGV8alF1ZXJ5fGFycmF5fSBCdXR0b24gc2VsZWN0b3IgLSBzZWVcbiAqICAgYGJ1dHRvbi1zZWxlY3RvcmAgZG9jdW1lbnRhdGlvbiBvbiB0aGUgRGF0YVRhYmxlcyBzaXRlXG4gKiBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIGBpbnN0YCBhbmQgYGlkeGAgcHJvcGVydGllcyBvZlxuICogICB0aGUgc2VsZWN0ZWQgYnV0dG9ucyBzbyB5b3Uga25vdyB3aGljaCBpbnN0YW5jZSBlYWNoIGJ1dHRvbiBiZWxvbmdzIHRvLlxuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmJ1dHRvblNlbGVjdG9yID0gZnVuY3Rpb24gKCBpbnN0cywgc2VsZWN0b3IgKVxue1xuXHR2YXIgcmV0ID0gW107XG5cdHZhciBub2RlQnVpbGRlciA9IGZ1bmN0aW9uICggYSwgYnV0dG9ucywgYmFzZUlkeCApIHtcblx0XHR2YXIgYnV0dG9uO1xuXHRcdHZhciBpZHg7XG5cblx0XHRmb3IgKCB2YXIgaT0wLCBpZW49YnV0dG9ucy5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdGJ1dHRvbiA9IGJ1dHRvbnNbaV07XG5cblx0XHRcdGlmICggYnV0dG9uICkge1xuXHRcdFx0XHRpZHggPSBiYXNlSWR4ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRcdGJhc2VJZHgraSA6XG5cdFx0XHRcdFx0aSsnJztcblxuXHRcdFx0XHRhLnB1c2goIHtcblx0XHRcdFx0XHRub2RlOiBidXR0b24ubm9kZSxcblx0XHRcdFx0XHRuYW1lOiBidXR0b24uY29uZi5uYW1lLFxuXHRcdFx0XHRcdGlkeDogIGlkeFxuXHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0aWYgKCBidXR0b24uYnV0dG9ucyApIHtcblx0XHRcdFx0XHRub2RlQnVpbGRlciggYSwgYnV0dG9uLmJ1dHRvbnMsIGlkeCsnLScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHR2YXIgcnVuID0gZnVuY3Rpb24gKCBzZWxlY3RvciwgaW5zdCApIHtcblx0XHR2YXIgaSwgaWVuO1xuXHRcdHZhciBidXR0b25zID0gW107XG5cdFx0bm9kZUJ1aWxkZXIoIGJ1dHRvbnMsIGluc3Qucy5idXR0b25zICk7XG5cblx0XHR2YXIgbm9kZXMgPSAkLm1hcCggYnV0dG9ucywgZnVuY3Rpb24gKHYpIHtcblx0XHRcdHJldHVybiB2Lm5vZGU7XG5cdFx0fSApO1xuXG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCBzZWxlY3RvciApIHx8IHNlbGVjdG9yIGluc3RhbmNlb2YgJCApIHtcblx0XHRcdGZvciAoIGk9MCwgaWVuPXNlbGVjdG9yLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRydW4oIHNlbGVjdG9yW2ldLCBpbnN0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciA9PT0gbnVsbCB8fCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkIHx8IHNlbGVjdG9yID09PSAnKicgKSB7XG5cdFx0XHQvLyBTZWxlY3QgYWxsXG5cdFx0XHRmb3IgKCBpPTAsIGllbj1idXR0b25zLmxlbmd0aCA7IGk8aWVuIDsgaSsrICkge1xuXHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdGluc3Q6IGluc3QsXG5cdFx0XHRcdFx0bm9kZTogYnV0dG9uc1tpXS5ub2RlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHQvLyBNYWluIGJ1dHRvbiBpbmRleCBzZWxlY3RvclxuXHRcdFx0cmV0LnB1c2goIHtcblx0XHRcdFx0aW5zdDogaW5zdCxcblx0XHRcdFx0bm9kZTogaW5zdC5zLmJ1dHRvbnNbIHNlbGVjdG9yIF0ubm9kZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0XHRlbHNlIGlmICggdHlwZW9mIHNlbGVjdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdGlmICggc2VsZWN0b3IuaW5kZXhPZiggJywnICkgIT09IC0xICkge1xuXHRcdFx0XHQvLyBTcGxpdFxuXHRcdFx0XHR2YXIgYSA9IHNlbGVjdG9yLnNwbGl0KCcsJyk7XG5cblx0XHRcdFx0Zm9yICggaT0wLCBpZW49YS5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcblx0XHRcdFx0XHRydW4oIGFbaV0udHJpbSgpLCBpbnN0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKCBzZWxlY3Rvci5tYXRjaCggL15cXGQrKFxcLVxcZCspKiQvICkgKSB7XG5cdFx0XHRcdC8vIFN1Yi1idXR0b24gaW5kZXggc2VsZWN0b3Jcblx0XHRcdFx0dmFyIGluZGV4ZXMgPSAkLm1hcCggYnV0dG9ucywgZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0XHRyZXR1cm4gdi5pZHg7XG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdGluc3Q6IGluc3QsXG5cdFx0XHRcdFx0bm9kZTogYnV0dG9uc1sgJC5pbkFycmF5KCBzZWxlY3RvciwgaW5kZXhlcyApIF0ubm9kZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICggc2VsZWN0b3IuaW5kZXhPZiggJzpuYW1lJyApICE9PSAtMSApIHtcblx0XHRcdFx0Ly8gQnV0dG9uIG5hbWUgc2VsZWN0b3Jcblx0XHRcdFx0dmFyIG5hbWUgPSBzZWxlY3Rvci5yZXBsYWNlKCAnOm5hbWUnLCAnJyApO1xuXG5cdFx0XHRcdGZvciAoIGk9MCwgaWVuPWJ1dHRvbnMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBidXR0b25zW2ldLm5hbWUgPT09IG5hbWUgKSB7XG5cdFx0XHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRpbnN0OiBpbnN0LFxuXHRcdFx0XHRcdFx0XHRub2RlOiBidXR0b25zW2ldLm5vZGVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHQvLyBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIG5vZGVzXG5cdFx0XHRcdCQoIG5vZGVzICkuZmlsdGVyKCBzZWxlY3RvciApLmVhY2goIGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdFx0aW5zdDogaW5zdCxcblx0XHRcdFx0XHRcdG5vZGU6IHRoaXNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gJ29iamVjdCcgJiYgc2VsZWN0b3Iubm9kZU5hbWUgKSB7XG5cdFx0XHQvLyBOb2RlIHNlbGVjdG9yXG5cdFx0XHR2YXIgaWR4ID0gJC5pbkFycmF5KCBzZWxlY3Rvciwgbm9kZXMgKTtcblxuXHRcdFx0aWYgKCBpZHggIT09IC0xICkge1xuXHRcdFx0XHRyZXQucHVzaCgge1xuXHRcdFx0XHRcdGluc3Q6IGluc3QsXG5cdFx0XHRcdFx0bm9kZTogbm9kZXNbIGlkeCBdXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblxuXHRmb3IgKCB2YXIgaT0wLCBpZW49aW5zdHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFyIGluc3QgPSBpbnN0c1tpXTtcblxuXHRcdHJ1biggc2VsZWN0b3IsIGluc3QgKTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbi8qKlxuICogQnV0dG9ucyBkZWZhdWx0cy4gRm9yIGZ1bGwgZG9jdW1lbnRhdGlvbiwgcGxlYXNlIHJlZmVyIHRvIHRoZSBkb2NzL29wdGlvblxuICogZGlyZWN0b3J5IG9yIHRoZSBEYXRhVGFibGVzIHNpdGUuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICovXG5CdXR0b25zLmRlZmF1bHRzID0ge1xuXHRidXR0b25zOiBbICdjb3B5JywgJ2V4Y2VsJywgJ2NzdicsICdwZGYnLCAncHJpbnQnIF0sXG5cdG5hbWU6ICdtYWluJyxcblx0dGFiSW5kZXg6IDAsXG5cdGRvbToge1xuXHRcdGNvbnRhaW5lcjoge1xuXHRcdFx0dGFnOiAnZGl2Jyxcblx0XHRcdGNsYXNzTmFtZTogJ2R0LWJ1dHRvbnMnXG5cdFx0fSxcblx0XHRjb2xsZWN0aW9uOiB7XG5cdFx0XHR0YWc6ICdkaXYnLFxuXHRcdFx0Y2xhc3NOYW1lOiAnJ1xuXHRcdH0sXG5cdFx0YnV0dG9uOiB7XG5cdFx0XHQvLyBGbGFzaCBidXR0b25zIHdpbGwgbm90IHdvcmsgd2l0aCBgPGJ1dHRvbj5gIGluIElFIC0gaXQgaGFzIHRvIGJlIGA8YT5gXG5cdFx0XHR0YWc6ICdBY3RpdmVYT2JqZWN0JyBpbiB3aW5kb3cgP1xuXHRcdFx0XHQnYScgOlxuXHRcdFx0XHQnYnV0dG9uJyxcblx0XHRcdGNsYXNzTmFtZTogJ2R0LWJ1dHRvbicsXG5cdFx0XHRhY3RpdmU6ICdhY3RpdmUnLFxuXHRcdFx0ZGlzYWJsZWQ6ICdkaXNhYmxlZCdcblx0XHR9LFxuXHRcdGJ1dHRvbkxpbmVyOiB7XG5cdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdGNsYXNzTmFtZTogJydcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvcm1hdGlvblxuICogQHR5cGUge3N0cmluZ31cbiAqIEBzdGF0aWNcbiAqL1xuQnV0dG9ucy52ZXJzaW9uID0gJzEuNi41JztcblxuXG4kLmV4dGVuZCggX2R0QnV0dG9ucywge1xuXHRjb2xsZWN0aW9uOiB7XG5cdFx0dGV4dDogZnVuY3Rpb24gKCBkdCApIHtcblx0XHRcdHJldHVybiBkdC5pMThuKCAnYnV0dG9ucy5jb2xsZWN0aW9uJywgJ0NvbGxlY3Rpb24nICk7XG5cdFx0fSxcblx0XHRjbGFzc05hbWU6ICdidXR0b25zLWNvbGxlY3Rpb24nLFxuXHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIGJ1dHRvbiwgY29uZmlnICkge1xuXHRcdFx0YnV0dG9uLmF0dHIoICdhcmlhLWV4cGFuZGVkJywgZmFsc2UgKTtcblx0XHR9LFxuXHRcdGFjdGlvbjogZnVuY3Rpb24gKCBlLCBkdCwgYnV0dG9uLCBjb25maWcgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG5cdFx0XHRpZiAoIGNvbmZpZy5fY29sbGVjdGlvbi5wYXJlbnRzKCdib2R5JykubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnBvcG92ZXIoZmFsc2UsIGNvbmZpZyk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0dGhpcy5wb3BvdmVyKGNvbmZpZy5fY29sbGVjdGlvbiwgY29uZmlnKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGF0dHI6IHtcblx0XHRcdCdhcmlhLWhhc3BvcHVwJzogdHJ1ZVxuXHRcdH1cblx0XHQvLyBBbHNvIHRoZSBwb3BvdmVyIG9wdGlvbnMsIGRlZmluZWQgaW4gQnV0dG9ucy5wb3BvdmVyXG5cdH0sXG5cdGNvcHk6IGZ1bmN0aW9uICggZHQsIGNvbmYgKSB7XG5cdFx0aWYgKCBfZHRCdXR0b25zLmNvcHlIdG1sNSApIHtcblx0XHRcdHJldHVybiAnY29weUh0bWw1Jztcblx0XHR9XG5cdFx0aWYgKCBfZHRCdXR0b25zLmNvcHlGbGFzaCAmJiBfZHRCdXR0b25zLmNvcHlGbGFzaC5hdmFpbGFibGUoIGR0LCBjb25mICkgKSB7XG5cdFx0XHRyZXR1cm4gJ2NvcHlGbGFzaCc7XG5cdFx0fVxuXHR9LFxuXHRjc3Y6IGZ1bmN0aW9uICggZHQsIGNvbmYgKSB7XG5cdFx0Ly8gQ29tbW9uIG9wdGlvbiB0aGF0IHdpbGwgdXNlIHRoZSBIVE1MNSBvciBGbGFzaCBleHBvcnQgYnV0dG9uc1xuXHRcdGlmICggX2R0QnV0dG9ucy5jc3ZIdG1sNSAmJiBfZHRCdXR0b25zLmNzdkh0bWw1LmF2YWlsYWJsZSggZHQsIGNvbmYgKSApIHtcblx0XHRcdHJldHVybiAnY3N2SHRtbDUnO1xuXHRcdH1cblx0XHRpZiAoIF9kdEJ1dHRvbnMuY3N2Rmxhc2ggJiYgX2R0QnV0dG9ucy5jc3ZGbGFzaC5hdmFpbGFibGUoIGR0LCBjb25mICkgKSB7XG5cdFx0XHRyZXR1cm4gJ2NzdkZsYXNoJztcblx0XHR9XG5cdH0sXG5cdGV4Y2VsOiBmdW5jdGlvbiAoIGR0LCBjb25mICkge1xuXHRcdC8vIENvbW1vbiBvcHRpb24gdGhhdCB3aWxsIHVzZSB0aGUgSFRNTDUgb3IgRmxhc2ggZXhwb3J0IGJ1dHRvbnNcblx0XHRpZiAoIF9kdEJ1dHRvbnMuZXhjZWxIdG1sNSAmJiBfZHRCdXR0b25zLmV4Y2VsSHRtbDUuYXZhaWxhYmxlKCBkdCwgY29uZiApICkge1xuXHRcdFx0cmV0dXJuICdleGNlbEh0bWw1Jztcblx0XHR9XG5cdFx0aWYgKCBfZHRCdXR0b25zLmV4Y2VsRmxhc2ggJiYgX2R0QnV0dG9ucy5leGNlbEZsYXNoLmF2YWlsYWJsZSggZHQsIGNvbmYgKSApIHtcblx0XHRcdHJldHVybiAnZXhjZWxGbGFzaCc7XG5cdFx0fVxuXHR9LFxuXHRwZGY6IGZ1bmN0aW9uICggZHQsIGNvbmYgKSB7XG5cdFx0Ly8gQ29tbW9uIG9wdGlvbiB0aGF0IHdpbGwgdXNlIHRoZSBIVE1MNSBvciBGbGFzaCBleHBvcnQgYnV0dG9uc1xuXHRcdGlmICggX2R0QnV0dG9ucy5wZGZIdG1sNSAmJiBfZHRCdXR0b25zLnBkZkh0bWw1LmF2YWlsYWJsZSggZHQsIGNvbmYgKSApIHtcblx0XHRcdHJldHVybiAncGRmSHRtbDUnO1xuXHRcdH1cblx0XHRpZiAoIF9kdEJ1dHRvbnMucGRmRmxhc2ggJiYgX2R0QnV0dG9ucy5wZGZGbGFzaC5hdmFpbGFibGUoIGR0LCBjb25mICkgKSB7XG5cdFx0XHRyZXR1cm4gJ3BkZkZsYXNoJztcblx0XHR9XG5cdH0sXG5cdHBhZ2VMZW5ndGg6IGZ1bmN0aW9uICggZHQgKSB7XG5cdFx0dmFyIGxlbmd0aE1lbnUgPSBkdC5zZXR0aW5ncygpWzBdLmFMZW5ndGhNZW51O1xuXHRcdHZhciB2YWxzID0gQXJyYXkuaXNBcnJheSggbGVuZ3RoTWVudVswXSApID8gbGVuZ3RoTWVudVswXSA6IGxlbmd0aE1lbnU7XG5cdFx0dmFyIGxhbmcgPSBBcnJheS5pc0FycmF5KCBsZW5ndGhNZW51WzBdICkgPyBsZW5ndGhNZW51WzFdIDogbGVuZ3RoTWVudTtcblx0XHR2YXIgdGV4dCA9IGZ1bmN0aW9uICggZHQgKSB7XG5cdFx0XHRyZXR1cm4gZHQuaTE4biggJ2J1dHRvbnMucGFnZUxlbmd0aCcsIHtcblx0XHRcdFx0XCItMVwiOiAnU2hvdyBhbGwgcm93cycsXG5cdFx0XHRcdF86ICAgICdTaG93ICVkIHJvd3MnXG5cdFx0XHR9LCBkdC5wYWdlLmxlbigpICk7XG5cdFx0fTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRleHRlbmQ6ICdjb2xsZWN0aW9uJyxcblx0XHRcdHRleHQ6IHRleHQsXG5cdFx0XHRjbGFzc05hbWU6ICdidXR0b25zLXBhZ2UtbGVuZ3RoJyxcblx0XHRcdGF1dG9DbG9zZTogdHJ1ZSxcblx0XHRcdGJ1dHRvbnM6ICQubWFwKCB2YWxzLCBmdW5jdGlvbiAoIHZhbCwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0ZXh0OiBsYW5nW2ldLFxuXHRcdFx0XHRcdGNsYXNzTmFtZTogJ2J1dHRvbi1wYWdlLWxlbmd0aCcsXG5cdFx0XHRcdFx0YWN0aW9uOiBmdW5jdGlvbiAoIGUsIGR0ICkge1xuXHRcdFx0XHRcdFx0ZHQucGFnZS5sZW4oIHZhbCApLmRyYXcoKTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmYgKSB7XG5cdFx0XHRcdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRcdFx0XHR2YXIgZm4gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0XHRcdHRoYXQuYWN0aXZlKCBkdC5wYWdlLmxlbigpID09PSB2YWwgKTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdGR0Lm9uKCAnbGVuZ3RoLmR0Jytjb25mLm5hbWVzcGFjZSwgZm4gKTtcblx0XHRcdFx0XHRcdGZuKCk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRkZXN0cm95OiBmdW5jdGlvbiAoIGR0LCBub2RlLCBjb25mICkge1xuXHRcdFx0XHRcdFx0ZHQub2ZmKCAnbGVuZ3RoLmR0Jytjb25mLm5hbWVzcGFjZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0gKSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmYgKSB7XG5cdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdFx0ZHQub24oICdsZW5ndGguZHQnK2NvbmYubmFtZXNwYWNlLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdFx0dGhhdC50ZXh0KCBjb25mLnRleHQgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdGRlc3Ryb3k6IGZ1bmN0aW9uICggZHQsIG5vZGUsIGNvbmYgKSB7XG5cdFx0XHRcdGR0Lm9mZiggJ2xlbmd0aC5kdCcrY29uZi5uYW1lc3BhY2UgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAqIERhdGFUYWJsZXMgQVBJXG4gKlxuICogRm9yIGNvbXBsZXRlIGRvY3VtZW50YXRpb24sIHBsZWFzZSByZWZlciB0byB0aGUgZG9jcy9hcGkgZGlyZWN0b3J5IG9yIHRoZVxuICogRGF0YVRhYmxlcyBzaXRlXG4gKi9cblxuLy8gQnV0dG9ucyBncm91cCBhbmQgaW5kaXZpZHVhbCBidXR0b24gc2VsZWN0b3JcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zKCknLCBmdW5jdGlvbiAoIGdyb3VwLCBzZWxlY3RvciApIHtcblx0Ly8gQXJndW1lbnQgc2hpZnRpbmdcblx0aWYgKCBzZWxlY3RvciA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHNlbGVjdG9yID0gZ3JvdXA7XG5cdFx0Z3JvdXAgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHR0aGlzLnNlbGVjdG9yLmJ1dHRvbkdyb3VwID0gZ3JvdXA7XG5cblx0dmFyIHJlcyA9IHRoaXMuaXRlcmF0b3IoIHRydWUsICd0YWJsZScsIGZ1bmN0aW9uICggY3R4ICkge1xuXHRcdGlmICggY3R4Ll9idXR0b25zICkge1xuXHRcdFx0cmV0dXJuIEJ1dHRvbnMuYnV0dG9uU2VsZWN0b3IoXG5cdFx0XHRcdEJ1dHRvbnMuaW5zdGFuY2VTZWxlY3RvciggZ3JvdXAsIGN0eC5fYnV0dG9ucyApLFxuXHRcdFx0XHRzZWxlY3RvclxuXHRcdFx0KTtcblx0XHR9XG5cdH0sIHRydWUgKTtcblxuXHRyZXMuX2dyb3VwU2VsZWN0b3IgPSBncm91cDtcblx0cmV0dXJuIHJlcztcbn0gKTtcblxuLy8gSW5kaXZpZHVhbCBidXR0b24gc2VsZWN0b3JcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b24oKScsIGZ1bmN0aW9uICggZ3JvdXAsIHNlbGVjdG9yICkge1xuXHQvLyBqdXN0IHJ1biBidXR0b25zKCkgYW5kIHRydW5jYXRlXG5cdHZhciBidXR0b25zID0gdGhpcy5idXR0b25zKCBncm91cCwgc2VsZWN0b3IgKTtcblxuXHRpZiAoIGJ1dHRvbnMubGVuZ3RoID4gMSApIHtcblx0XHRidXR0b25zLnNwbGljZSggMSwgYnV0dG9ucy5sZW5ndGggKTtcblx0fVxuXG5cdHJldHVybiBidXR0b25zO1xufSApO1xuXG4vLyBBY3RpdmUgYnV0dG9uc1xuRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCggJ2J1dHRvbnMoKS5hY3RpdmUoKScsICdidXR0b24oKS5hY3RpdmUoKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRcdHJldHVybiBzZXQuaW5zdC5hY3RpdmUoIHNldC5ub2RlICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0c2V0Lmluc3QuYWN0aXZlKCBzZXQubm9kZSwgZmxhZyApO1xuXHR9ICk7XG59ICk7XG5cbi8vIEdldCAvIHNldCBidXR0b24gYWN0aW9uXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnYnV0dG9ucygpLmFjdGlvbigpJywgJ2J1dHRvbigpLmFjdGlvbigpJywgZnVuY3Rpb24gKCBhY3Rpb24gKSB7XG5cdGlmICggYWN0aW9uID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRcdHJldHVybiBzZXQuaW5zdC5hY3Rpb24oIHNldC5ub2RlICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0c2V0Lmluc3QuYWN0aW9uKCBzZXQubm9kZSwgYWN0aW9uICk7XG5cdH0gKTtcbn0gKTtcblxuLy8gRW5hYmxlIC8gZGlzYWJsZSBidXR0b25zXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyKCBbJ2J1dHRvbnMoKS5lbmFibGUoKScsICdidXR0b24oKS5lbmFibGUoKSddLCBmdW5jdGlvbiAoIGZsYWcgKSB7XG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHNldC5pbnN0LmVuYWJsZSggc2V0Lm5vZGUsIGZsYWcgKTtcblx0fSApO1xufSApO1xuXG4vLyBEaXNhYmxlIGJ1dHRvbnNcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoIFsnYnV0dG9ucygpLmRpc2FibGUoKScsICdidXR0b24oKS5kaXNhYmxlKCknXSwgZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRzZXQuaW5zdC5kaXNhYmxlKCBzZXQubm9kZSApO1xuXHR9ICk7XG59ICk7XG5cbi8vIEdldCBidXR0b24gbm9kZXNcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoICdidXR0b25zKCkubm9kZXMoKScsICdidXR0b24oKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG5cdHZhciBqcSA9ICQoKTtcblxuXHQvLyBqUXVlcnkgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZHVjZSBkdXBsaWNhdGVzIHRvIGEgc2luZ2xlIGVudHJ5XG5cdCQoIHRoaXMuZWFjaCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0anEgPSBqcS5hZGQoIHNldC5pbnN0Lm5vZGUoIHNldC5ub2RlICkgKTtcblx0fSApICk7XG5cblx0cmV0dXJuIGpxO1xufSApO1xuXG4vLyBHZXQgLyBzZXQgYnV0dG9uIHByb2Nlc3Npbmcgc3RhdGVcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoICdidXR0b25zKCkucHJvY2Vzc2luZygpJywgJ2J1dHRvbigpLnByb2Nlc3NpbmcoKScsIGZ1bmN0aW9uICggZmxhZyApIHtcblx0aWYgKCBmbGFnID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRcdHJldHVybiBzZXQuaW5zdC5wcm9jZXNzaW5nKCBzZXQubm9kZSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHNldC5pbnN0LnByb2Nlc3NpbmcoIHNldC5ub2RlLCBmbGFnICk7XG5cdH0gKTtcbn0gKTtcblxuLy8gR2V0IC8gc2V0IGJ1dHRvbiB0ZXh0IChpLmUuIHRoZSBidXR0b24gbGFiZWxzKVxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlclBsdXJhbCggJ2J1dHRvbnMoKS50ZXh0KCknLCAnYnV0dG9uKCkudGV4dCgpJywgZnVuY3Rpb24gKCBsYWJlbCApIHtcblx0aWYgKCBsYWJlbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0XHRyZXR1cm4gc2V0Lmluc3QudGV4dCggc2V0Lm5vZGUgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiAoIHNldCApIHtcblx0XHRzZXQuaW5zdC50ZXh0KCBzZXQubm9kZSwgbGFiZWwgKTtcblx0fSApO1xufSApO1xuXG4vLyBUcmlnZ2VyIGEgYnV0dG9uJ3MgYWN0aW9uXG5EYXRhVGFibGUuQXBpLnJlZ2lzdGVyUGx1cmFsKCAnYnV0dG9ucygpLnRyaWdnZXIoKScsICdidXR0b24oKS50cmlnZ2VyKCknLCBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHNldC5pbnN0Lm5vZGUoIHNldC5ub2RlICkudHJpZ2dlciggJ2NsaWNrJyApO1xuXHR9ICk7XG59ICk7XG5cbi8vIEJ1dHRvbiByZXNvbHZlciB0byB0aGUgcG9wb3ZlclxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlciggJ2J1dHRvbigpLnBvcG92ZXIoKScsIGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG5cdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24gKCBzZXQgKSB7XG5cdFx0cmV0dXJuIHNldC5pbnN0Ll9wb3BvdmVyKCBjb250ZW50LCB0aGlzLmJ1dHRvbih0aGlzWzBdLm5vZGUpLCBvcHRpb25zICk7XG5cdH0gKTtcbn0gKTtcblxuLy8gR2V0IHRoZSBjb250YWluZXIgZWxlbWVudHNcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zKCkuY29udGFpbmVycygpJywgZnVuY3Rpb24gKCkge1xuXHR2YXIganEgPSAkKCk7XG5cdHZhciBncm91cFNlbGVjdG9yID0gdGhpcy5fZ3JvdXBTZWxlY3RvcjtcblxuXHQvLyBXZSBuZWVkIHRvIHVzZSB0aGUgZ3JvdXAgc2VsZWN0b3IgZGlyZWN0bHksIHNpbmNlIGlmIHRoZXJlIGFyZSBubyBidXR0b25zXG5cdC8vIHRoZSByZXN1bHQgc2V0IHdpbGwgYmUgZW1wdHlcblx0dGhpcy5pdGVyYXRvciggdHJ1ZSwgJ3RhYmxlJywgZnVuY3Rpb24gKCBjdHggKSB7XG5cdFx0aWYgKCBjdHguX2J1dHRvbnMgKSB7XG5cdFx0XHR2YXIgaW5zdHMgPSBCdXR0b25zLmluc3RhbmNlU2VsZWN0b3IoIGdyb3VwU2VsZWN0b3IsIGN0eC5fYnV0dG9ucyApO1xuXG5cdFx0XHRmb3IgKCB2YXIgaT0wLCBpZW49aW5zdHMubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0XHRcdGpxID0ganEuYWRkKCBpbnN0c1tpXS5jb250YWluZXIoKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xuXG5cdHJldHVybiBqcTtcbn0gKTtcblxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlciggJ2J1dHRvbnMoKS5jb250YWluZXIoKScsIGZ1bmN0aW9uICgpIHtcblx0Ly8gQVBJIGxldmVsIG9mIG5lc3RpbmcgaXMgYGJ1dHRvbnMoKWAgc28gd2UgY2FuIHppcCBpbnRvIHRoZSBjb250YWluZXJzIG1ldGhvZFxuXHRyZXR1cm4gdGhpcy5jb250YWluZXJzKCkuZXEoMCk7XG59ICk7XG5cbi8vIEFkZCBhIG5ldyBidXR0b25cbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b24oKS5hZGQoKScsIGZ1bmN0aW9uICggaWR4LCBjb25mICkge1xuXHR2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG5cdC8vIERvbid0IHVzZSBgdGhpc2AgYXMgaXQgY291bGQgYmUgZW1wdHkgLSBzZWxlY3QgdGhlIGluc3RhbmNlcyBkaXJlY3RseVxuXHRpZiAoIGN0eC5sZW5ndGggKSB7XG5cdFx0dmFyIGluc3QgPSBCdXR0b25zLmluc3RhbmNlU2VsZWN0b3IoIHRoaXMuX2dyb3VwU2VsZWN0b3IsIGN0eFswXS5fYnV0dG9ucyApO1xuXG5cdFx0aWYgKCBpbnN0Lmxlbmd0aCApIHtcblx0XHRcdGluc3RbMF0uYWRkKCBjb25mLCBpZHggKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdGhpcy5idXR0b24oIHRoaXMuX2dyb3VwU2VsZWN0b3IsIGlkeCApO1xufSApO1xuXG4vLyBEZXN0cm95IHRoZSBidXR0b24gc2V0cyBzZWxlY3RlZFxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlciggJ2J1dHRvbnMoKS5kZXN0cm95KCknLCBmdW5jdGlvbiAoKSB7XG5cdHRoaXMucGx1Y2soICdpbnN0JyApLnVuaXF1ZSgpLmVhY2goIGZ1bmN0aW9uICggaW5zdCApIHtcblx0XHRpbnN0LmRlc3Ryb3koKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG4vLyBSZW1vdmUgYSBidXR0b25cbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWwoICdidXR0b25zKCkucmVtb3ZlKCknLCAnYnV0dG9ucygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuXHR0aGlzLmVhY2goIGZ1bmN0aW9uICggc2V0ICkge1xuXHRcdHNldC5pbnN0LnJlbW92ZSggc2V0Lm5vZGUgKTtcblx0fSApO1xuXG5cdHJldHVybiB0aGlzO1xufSApO1xuXG4vLyBJbmZvcm1hdGlvbiBib3ggdGhhdCBjYW4gYmUgdXNlZCBieSBidXR0b25zXG52YXIgX2luZm9UaW1lcjtcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zLmluZm8oKScsIGZ1bmN0aW9uICggdGl0bGUsIG1lc3NhZ2UsIHRpbWUgKSB7XG5cdHZhciB0aGF0ID0gdGhpcztcblxuXHRpZiAoIHRpdGxlID09PSBmYWxzZSApIHtcblx0XHR0aGlzLm9mZignZGVzdHJveS5idG4taW5mbycpO1xuXHRcdF9mYWRlT3V0KFxuXHRcdFx0JCgnI2RhdGF0YWJsZXNfYnV0dG9uc19pbmZvJyksXG5cdFx0XHQ0MDAsXG5cdFx0XHRmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdCQodGhpcykucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0XHRjbGVhclRpbWVvdXQoIF9pbmZvVGltZXIgKTtcblx0XHRfaW5mb1RpbWVyID0gbnVsbDtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cblx0aWYgKCBfaW5mb1RpbWVyICkge1xuXHRcdGNsZWFyVGltZW91dCggX2luZm9UaW1lciApO1xuXHR9XG5cblx0aWYgKCAkKCcjZGF0YXRhYmxlc19idXR0b25zX2luZm8nKS5sZW5ndGggKSB7XG5cdFx0JCgnI2RhdGF0YWJsZXNfYnV0dG9uc19pbmZvJykucmVtb3ZlKCk7XG5cdH1cblxuXHR0aXRsZSA9IHRpdGxlID8gJzxoMj4nK3RpdGxlKyc8L2gyPicgOiAnJztcblxuXHRfZmFkZUluKFxuXHRcdCQoJzxkaXYgaWQ9XCJkYXRhdGFibGVzX2J1dHRvbnNfaW5mb1wiIGNsYXNzPVwiZHQtYnV0dG9uLWluZm9cIi8+Jylcblx0XHRcdC5odG1sKCB0aXRsZSApXG5cdFx0XHQuYXBwZW5kKCAkKCc8ZGl2Lz4nKVsgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnID8gJ2h0bWwnIDogJ2FwcGVuZCcgXSggbWVzc2FnZSApIClcblx0XHRcdC5jc3MoICdkaXNwbGF5JywgJ25vbmUnIClcblx0XHRcdC5hcHBlbmRUbyggJ2JvZHknIClcblx0KTtcblxuXHRpZiAoIHRpbWUgIT09IHVuZGVmaW5lZCAmJiB0aW1lICE9PSAwICkge1xuXHRcdF9pbmZvVGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XG5cdFx0XHR0aGF0LmJ1dHRvbnMuaW5mbyggZmFsc2UgKTtcblx0XHR9LCB0aW1lICk7XG5cdH1cblxuXHR0aGlzLm9uKCdkZXN0cm95LmJ0bi1pbmZvJywgZnVuY3Rpb24gKCkge1xuXHRcdHRoYXQuYnV0dG9ucy5pbmZvKGZhbHNlKTtcblx0fSk7XG5cblx0cmV0dXJuIHRoaXM7XG59ICk7XG5cbi8vIEdldCBkYXRhIGZyb20gdGhlIHRhYmxlIGZvciBleHBvcnQgLSB0aGlzIGlzIGNvbW1vbiB0byBhIG51bWJlciBvZiBwbHVnLWluXG4vLyBidXR0b25zIHNvIGl0IGlzIGluY2x1ZGVkIGluIHRoZSBCdXR0b25zIGNvcmUgbGlicmFyeVxuRGF0YVRhYmxlLkFwaS5yZWdpc3RlciggJ2J1dHRvbnMuZXhwb3J0RGF0YSgpJywgZnVuY3Rpb24gKCBvcHRpb25zICkge1xuXHRpZiAoIHRoaXMuY29udGV4dC5sZW5ndGggKSB7XG5cdFx0cmV0dXJuIF9leHBvcnREYXRhKCBuZXcgRGF0YVRhYmxlLkFwaSggdGhpcy5jb250ZXh0WzBdICksIG9wdGlvbnMgKTtcblx0fVxufSApO1xuXG4vLyBHZXQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGV4cG9ydCB0aGF0IGlzIGNvbW1vbiB0byBtYW55IG9mIHRoZSBleHBvcnQgZGF0YVxuLy8gdHlwZXMgKERSWSlcbkRhdGFUYWJsZS5BcGkucmVnaXN0ZXIoICdidXR0b25zLmV4cG9ydEluZm8oKScsIGZ1bmN0aW9uICggY29uZiApIHtcblx0aWYgKCAhIGNvbmYgKSB7XG5cdFx0Y29uZiA9IHt9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRmaWxlbmFtZTogX2ZpbGVuYW1lKCBjb25mICksXG5cdFx0dGl0bGU6IF90aXRsZSggY29uZiApLFxuXHRcdG1lc3NhZ2VUb3A6IF9tZXNzYWdlKHRoaXMsIGNvbmYubWVzc2FnZSB8fCBjb25mLm1lc3NhZ2VUb3AsICd0b3AnKSxcblx0XHRtZXNzYWdlQm90dG9tOiBfbWVzc2FnZSh0aGlzLCBjb25mLm1lc3NhZ2VCb3R0b20sICdib3R0b20nKVxuXHR9O1xufSApO1xuXG5cblxuLyoqXG4gKiBHZXQgdGhlIGZpbGUgbmFtZSBmb3IgYW4gZXhwb3J0ZWQgZmlsZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH1cdGNvbmZpZyBCdXR0b24gY29uZmlndXJhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBpbmNFeHRlbnNpb24gSW5jbHVkZSB0aGUgZmlsZSBuYW1lIGV4dGVuc2lvblxuICovXG52YXIgX2ZpbGVuYW1lID0gZnVuY3Rpb24gKCBjb25maWcgKVxue1xuXHQvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuXHR2YXIgZmlsZW5hbWUgPSBjb25maWcuZmlsZW5hbWUgPT09ICcqJyAmJiBjb25maWcudGl0bGUgIT09ICcqJyAmJiBjb25maWcudGl0bGUgIT09IHVuZGVmaW5lZCAmJiBjb25maWcudGl0bGUgIT09IG51bGwgJiYgY29uZmlnLnRpdGxlICE9PSAnJyA/XG5cdFx0Y29uZmlnLnRpdGxlIDpcblx0XHRjb25maWcuZmlsZW5hbWU7XG5cblx0aWYgKCB0eXBlb2YgZmlsZW5hbWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0ZmlsZW5hbWUgPSBmaWxlbmFtZSgpO1xuXHR9XG5cblx0aWYgKCBmaWxlbmFtZSA9PT0gdW5kZWZpbmVkIHx8IGZpbGVuYW1lID09PSBudWxsICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0aWYgKCBmaWxlbmFtZS5pbmRleE9mKCAnKicgKSAhPT0gLTEgKSB7XG5cdFx0ZmlsZW5hbWUgPSBmaWxlbmFtZS5yZXBsYWNlKCAnKicsICQoJ2hlYWQgPiB0aXRsZScpLnRleHQoKSApLnRyaW0oKTtcblx0fVxuXG5cdC8vIFN0cmlwIGNoYXJhY3RlcnMgd2hpY2ggdGhlIE9TIHdpbGwgb2JqZWN0IHRvXG5cdGZpbGVuYW1lID0gZmlsZW5hbWUucmVwbGFjZSgvW15hLXpBLVowLTlfXFx1MDBBMS1cXHVGRkZGXFwuLFxcLV8gIVxcKFxcKV0vZywgXCJcIik7XG5cblx0dmFyIGV4dGVuc2lvbiA9IF9zdHJpbmdPckZ1bmN0aW9uKCBjb25maWcuZXh0ZW5zaW9uICk7XG5cdGlmICggISBleHRlbnNpb24gKSB7XG5cdFx0ZXh0ZW5zaW9uID0gJyc7XG5cdH1cblxuXHRyZXR1cm4gZmlsZW5hbWUgKyBleHRlbnNpb247XG59O1xuXG4vKipcbiAqIFNpbXBseSB1dGlsaXR5IG1ldGhvZCB0byBhbGxvdyBwYXJhbWV0ZXJzIHRvIGJlIGdpdmVuIGFzIGEgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge3VuZGVmaW5lZHxzdHJpbmd8ZnVuY3Rpb259IG9wdGlvbiBPcHRpb25cbiAqIEByZXR1cm4ge251bGx8c3RyaW5nfSBSZXNvbHZlZCB2YWx1ZVxuICovXG52YXIgX3N0cmluZ09yRnVuY3Rpb24gPSBmdW5jdGlvbiAoIG9wdGlvbiApXG57XG5cdGlmICggb3B0aW9uID09PSBudWxsIHx8IG9wdGlvbiA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cdGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nICkge1xuXHRcdHJldHVybiBvcHRpb24oKTtcblx0fVxuXHRyZXR1cm4gb3B0aW9uO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHRpdGxlIGZvciBhbiBleHBvcnRlZCBmaWxlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcdEJ1dHRvbiBjb25maWd1cmF0aW9uXG4gKi9cbnZhciBfdGl0bGUgPSBmdW5jdGlvbiAoIGNvbmZpZyApXG57XG5cdHZhciB0aXRsZSA9IF9zdHJpbmdPckZ1bmN0aW9uKCBjb25maWcudGl0bGUgKTtcblxuXHRyZXR1cm4gdGl0bGUgPT09IG51bGwgP1xuXHRcdG51bGwgOiB0aXRsZS5pbmRleE9mKCAnKicgKSAhPT0gLTEgP1xuXHRcdFx0dGl0bGUucmVwbGFjZSggJyonLCAkKCdoZWFkID4gdGl0bGUnKS50ZXh0KCkgfHwgJ0V4cG9ydGVkIGRhdGEnICkgOlxuXHRcdFx0dGl0bGU7XG59O1xuXG52YXIgX21lc3NhZ2UgPSBmdW5jdGlvbiAoIGR0LCBvcHRpb24sIHBvc2l0aW9uIClcbntcblx0dmFyIG1lc3NhZ2UgPSBfc3RyaW5nT3JGdW5jdGlvbiggb3B0aW9uICk7XG5cdGlmICggbWVzc2FnZSA9PT0gbnVsbCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBjYXB0aW9uID0gJCgnY2FwdGlvbicsIGR0LnRhYmxlKCkuY29udGFpbmVyKCkpLmVxKDApO1xuXHRpZiAoIG1lc3NhZ2UgPT09ICcqJyApIHtcblx0XHR2YXIgc2lkZSA9IGNhcHRpb24uY3NzKCAnY2FwdGlvbi1zaWRlJyApO1xuXHRcdGlmICggc2lkZSAhPT0gcG9zaXRpb24gKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2FwdGlvbi5sZW5ndGggP1xuXHRcdFx0Y2FwdGlvbi50ZXh0KCkgOlxuXHRcdFx0Jyc7XG5cdH1cblxuXHRyZXR1cm4gbWVzc2FnZTtcbn07XG5cblxuXG5cblxuXG5cbnZhciBfZXhwb3J0VGV4dGFyZWEgPSAkKCc8dGV4dGFyZWEvPicpWzBdO1xudmFyIF9leHBvcnREYXRhID0gZnVuY3Rpb24gKCBkdCwgaW5PcHRzIClcbntcblx0dmFyIGNvbmZpZyA9ICQuZXh0ZW5kKCB0cnVlLCB7fSwge1xuXHRcdHJvd3M6ICAgICAgICAgICBudWxsLFxuXHRcdGNvbHVtbnM6ICAgICAgICAnJyxcblx0XHRtb2RpZmllcjogICAgICAge1xuXHRcdFx0c2VhcmNoOiAnYXBwbGllZCcsXG5cdFx0XHRvcmRlcjogICdhcHBsaWVkJ1xuXHRcdH0sXG5cdFx0b3J0aG9nb25hbDogICAgICdkaXNwbGF5Jyxcblx0XHRzdHJpcEh0bWw6ICAgICAgdHJ1ZSxcblx0XHRzdHJpcE5ld2xpbmVzOiAgdHJ1ZSxcblx0XHRkZWNvZGVFbnRpdGllczogdHJ1ZSxcblx0XHR0cmltOiAgICAgICAgICAgdHJ1ZSxcblx0XHRmb3JtYXQ6ICAgICAgICAge1xuXHRcdFx0aGVhZGVyOiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpcCggZCApO1xuXHRcdFx0fSxcblx0XHRcdGZvb3RlcjogZnVuY3Rpb24gKCBkICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaXAoIGQgKTtcblx0XHRcdH0sXG5cdFx0XHRib2R5OiBmdW5jdGlvbiAoIGQgKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpcCggZCApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0Y3VzdG9taXplRGF0YTogbnVsbFxuXHR9LCBpbk9wdHMgKTtcblxuXHR2YXIgc3RyaXAgPSBmdW5jdGlvbiAoIHN0ciApIHtcblx0XHRpZiAoIHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9XG5cblx0XHQvLyBBbHdheXMgcmVtb3ZlIHNjcmlwdCB0YWdzXG5cdFx0c3RyID0gc3RyLnJlcGxhY2UoIC88c2NyaXB0XFxiW148XSooPzooPyE8XFwvc2NyaXB0Pik8W148XSopKjxcXC9zY3JpcHQ+L2dpLCAnJyApO1xuXG5cdFx0Ly8gQWx3YXlzIHJlbW92ZSBjb21tZW50c1xuXHRcdHN0ciA9IHN0ci5yZXBsYWNlKCAvPCFcXC1cXC0uKj9cXC1cXC0+L2csICcnICk7XG5cblx0XHRpZiAoIGNvbmZpZy5zdHJpcEh0bWwgKSB7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggLzwoW14+J1wiXSooJ1teJ10qJ3xcIlteXCJdKlwiKT8pKj4vZywgJycgKTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy50cmltICkge1xuXHRcdFx0c3RyID0gc3RyLnJlcGxhY2UoIC9eXFxzK3xcXHMrJC9nLCAnJyApO1xuXHRcdH1cblxuXHRcdGlmICggY29uZmlnLnN0cmlwTmV3bGluZXMgKSB7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggL1xcbi9nLCAnICcgKTtcblx0XHR9XG5cblx0XHRpZiAoIGNvbmZpZy5kZWNvZGVFbnRpdGllcyApIHtcblx0XHRcdF9leHBvcnRUZXh0YXJlYS5pbm5lckhUTUwgPSBzdHI7XG5cdFx0XHRzdHIgPSBfZXhwb3J0VGV4dGFyZWEudmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuXG5cdHZhciBoZWFkZXIgPSBkdC5jb2x1bW5zKCBjb25maWcuY29sdW1ucyApLmluZGV4ZXMoKS5tYXAoIGZ1bmN0aW9uIChpZHgpIHtcblx0XHR2YXIgZWwgPSBkdC5jb2x1bW4oIGlkeCApLmhlYWRlcigpO1xuXHRcdHJldHVybiBjb25maWcuZm9ybWF0LmhlYWRlciggZWwuaW5uZXJIVE1MLCBpZHgsIGVsICk7XG5cdH0gKS50b0FycmF5KCk7XG5cblx0dmFyIGZvb3RlciA9IGR0LnRhYmxlKCkuZm9vdGVyKCkgP1xuXHRcdGR0LmNvbHVtbnMoIGNvbmZpZy5jb2x1bW5zICkuaW5kZXhlcygpLm1hcCggZnVuY3Rpb24gKGlkeCkge1xuXHRcdFx0dmFyIGVsID0gZHQuY29sdW1uKCBpZHggKS5mb290ZXIoKTtcblx0XHRcdHJldHVybiBjb25maWcuZm9ybWF0LmZvb3RlciggZWwgPyBlbC5pbm5lckhUTUwgOiAnJywgaWR4LCBlbCApO1xuXHRcdH0gKS50b0FycmF5KCkgOlxuXHRcdG51bGw7XG5cdFxuXHQvLyBJZiBTZWxlY3QgaXMgYXZhaWxhYmxlIG9uIHRoaXMgdGFibGUsIGFuZCBhbnkgcm93cyBhcmUgc2VsZWN0ZWQsIGxpbWl0IHRoZSBleHBvcnRcblx0Ly8gdG8gdGhlIHNlbGVjdGVkIHJvd3MuIElmIG5vIHJvd3MgYXJlIHNlbGVjdGVkLCBhbGwgcm93cyB3aWxsIGJlIGV4cG9ydGVkLiBTcGVjaWZ5XG5cdC8vIGEgYHNlbGVjdGVkYCBtb2RpZmllciB0byBjb250cm9sIGRpcmVjdGx5LlxuXHR2YXIgbW9kaWZpZXIgPSAkLmV4dGVuZCgge30sIGNvbmZpZy5tb2RpZmllciApO1xuXHRpZiAoIGR0LnNlbGVjdCAmJiB0eXBlb2YgZHQuc2VsZWN0LmluZm8gPT09ICdmdW5jdGlvbicgJiYgbW9kaWZpZXIuc2VsZWN0ZWQgPT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIGR0LnJvd3MoIGNvbmZpZy5yb3dzLCAkLmV4dGVuZCggeyBzZWxlY3RlZDogdHJ1ZSB9LCBtb2RpZmllciApICkuYW55KCkgKSB7XG5cdFx0XHQkLmV4dGVuZCggbW9kaWZpZXIsIHsgc2VsZWN0ZWQ6IHRydWUgfSApXG5cdFx0fVxuXHR9XG5cblx0dmFyIHJvd0luZGV4ZXMgPSBkdC5yb3dzKCBjb25maWcucm93cywgbW9kaWZpZXIgKS5pbmRleGVzKCkudG9BcnJheSgpO1xuXHR2YXIgc2VsZWN0ZWRDZWxscyA9IGR0LmNlbGxzKCByb3dJbmRleGVzLCBjb25maWcuY29sdW1ucyApO1xuXHR2YXIgY2VsbHMgPSBzZWxlY3RlZENlbGxzXG5cdFx0LnJlbmRlciggY29uZmlnLm9ydGhvZ29uYWwgKVxuXHRcdC50b0FycmF5KCk7XG5cdHZhciBjZWxsTm9kZXMgPSBzZWxlY3RlZENlbGxzXG5cdFx0Lm5vZGVzKClcblx0XHQudG9BcnJheSgpO1xuXG5cdHZhciBjb2x1bW5zID0gaGVhZGVyLmxlbmd0aDtcblx0dmFyIHJvd3MgPSBjb2x1bW5zID4gMCA/IGNlbGxzLmxlbmd0aCAvIGNvbHVtbnMgOiAwO1xuXHR2YXIgYm9keSA9IFtdO1xuXHR2YXIgY2VsbENvdW50ZXIgPSAwO1xuXG5cdGZvciAoIHZhciBpPTAsIGllbj1yb3dzIDsgaTxpZW4gOyBpKysgKSB7XG5cdFx0dmFyIHJvdyA9IFsgY29sdW1ucyBdO1xuXG5cdFx0Zm9yICggdmFyIGo9MCA7IGo8Y29sdW1ucyA7IGorKyApIHtcblx0XHRcdHJvd1tqXSA9IGNvbmZpZy5mb3JtYXQuYm9keSggY2VsbHNbIGNlbGxDb3VudGVyIF0sIGksIGosIGNlbGxOb2Rlc1sgY2VsbENvdW50ZXIgXSApO1xuXHRcdFx0Y2VsbENvdW50ZXIrKztcblx0XHR9XG5cblx0XHRib2R5W2ldID0gcm93O1xuXHR9XG5cblx0dmFyIGRhdGEgPSB7XG5cdFx0aGVhZGVyOiBoZWFkZXIsXG5cdFx0Zm9vdGVyOiBmb290ZXIsXG5cdFx0Ym9keTogICBib2R5XG5cdH07XG5cblx0aWYgKCBjb25maWcuY3VzdG9taXplRGF0YSApIHtcblx0XHRjb25maWcuY3VzdG9taXplRGF0YSggZGF0YSApO1xuXHR9XG5cblx0cmV0dXJuIGRhdGE7XG59O1xuXG5cbi8qICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gKiBEYXRhVGFibGVzIGludGVyZmFjZVxuICovXG5cbi8vIEF0dGFjaCB0byBEYXRhVGFibGVzIG9iamVjdHMgZm9yIGdsb2JhbCBhY2Nlc3NcbiQuZm4uZGF0YVRhYmxlLkJ1dHRvbnMgPSBCdXR0b25zO1xuJC5mbi5EYXRhVGFibGUuQnV0dG9ucyA9IEJ1dHRvbnM7XG5cblxuXG4vLyBEYXRhVGFibGVzIGNyZWF0aW9uIC0gY2hlY2sgaWYgdGhlIGJ1dHRvbnMgaGF2ZSBiZWVuIGRlZmluZWQgZm9yIHRoaXMgdGFibGUsXG4vLyB0aGV5IHdpbGwgaGF2ZSBiZWVuIGlmIHRoZSBgQmAgb3B0aW9uIHdhcyB1c2VkIGluIGBkb21gLCBvdGhlcndpc2Ugd2Ugc2hvdWxkXG4vLyBjcmVhdGUgdGhlIGJ1dHRvbnMgaW5zdGFuY2UgaGVyZSBzbyB0aGV5IGNhbiBiZSBpbnNlcnRlZCBpbnRvIHRoZSBkb2N1bWVudFxuLy8gdXNpbmcgdGhlIEFQSS4gTGlzdGVuIGZvciBgaW5pdGAgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBwcmUgMS4xMC4xMCwgYnV0IHRvXG4vLyBiZSByZW1vdmVkIGluIGZ1dHVyZS5cbiQoZG9jdW1lbnQpLm9uKCAnaW5pdC5kdCBwbHVnaW4taW5pdC5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncykge1xuXHRpZiAoIGUubmFtZXNwYWNlICE9PSAnZHQnICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHZhciBvcHRzID0gc2V0dGluZ3Mub0luaXQuYnV0dG9ucyB8fCBEYXRhVGFibGUuZGVmYXVsdHMuYnV0dG9ucztcblxuXHRpZiAoIG9wdHMgJiYgISBzZXR0aW5ncy5fYnV0dG9ucyApIHtcblx0XHRuZXcgQnV0dG9ucyggc2V0dGluZ3MsIG9wdHMgKS5jb250YWluZXIoKTtcblx0fVxufSApO1xuXG5mdW5jdGlvbiBfaW5pdCAoIHNldHRpbmdzLCBvcHRpb25zICkge1xuXHR2YXIgYXBpID0gbmV3IERhdGFUYWJsZS5BcGkoIHNldHRpbmdzICk7XG5cdHZhciBvcHRzID0gb3B0aW9uc1xuXHRcdD8gb3B0aW9uc1xuXHRcdDogYXBpLmluaXQoKS5idXR0b25zIHx8IERhdGFUYWJsZS5kZWZhdWx0cy5idXR0b25zO1xuXG5cdHJldHVybiBuZXcgQnV0dG9ucyggYXBpLCBvcHRzICkuY29udGFpbmVyKCk7XG59XG5cbi8vIERhdGFUYWJsZXMgYGRvbWAgZmVhdHVyZSBvcHRpb25cbkRhdGFUYWJsZS5leHQuZmVhdHVyZS5wdXNoKCB7XG5cdGZuSW5pdDogX2luaXQsXG5cdGNGZWF0dXJlOiBcIkJcIlxufSApO1xuXG4vLyBEYXRhVGFibGVzIDIgbGF5b3V0IGZlYXR1cmVcbmlmICggRGF0YVRhYmxlLmV4dC5mZWF0dXJlcyApIHtcblx0RGF0YVRhYmxlLmV4dC5mZWF0dXJlcy5yZWdpc3RlciggJ2J1dHRvbnMnLCBfaW5pdCApO1xufVxuXG5cbnJldHVybiBCdXR0b25zO1xufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net-buttons/js/dataTables.buttons.js\n");

/***/ }),

/***/ "./node_modules/datatables.net/js/jquery.dataTables.js":
/*!*************************************************************!*\
  !*** ./node_modules/datatables.net/js/jquery.dataTables.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! DataTables 1.10.23\n * 2008-2020 SpryMedia Ltd - datatables.net/license\n */\n\n/**\n * @summary     DataTables\n * @description Paginate, search and order HTML tables\n * @version     1.10.23\n * @file        jquery.dataTables.js\n * @author      SpryMedia Ltd\n * @contact     www.datatables.net\n * @copyright   Copyright 2008-2020 SpryMedia Ltd.\n *\n * This source file is free software, available under the following license:\n *   MIT license - http://datatables.net/license\n *\n * This source file is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.\n *\n * For details please refer to: http://www.datatables.net\n */\n\n/*jslint evil: true, undef: true, browser: true */\n/*globals $,require,jQuery,define,_selector_run,_selector_opts,_selector_first,_selector_row_indexes,_ext,_Api,_api_register,_api_registerPlural,_re_new_lines,_re_html,_re_formatted_numeric,_re_escape_regex,_empty,_intVal,_numToDecimal,_isNumber,_isHtml,_htmlNumeric,_pluck,_pluck_order,_range,_stripHtml,_unique,_fnBuildAjax,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnAjaxDataSrc,_fnAddColumn,_fnColumnOptions,_fnAdjustColumnSizing,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnVisbleColumns,_fnGetColumns,_fnColumnTypes,_fnApplyColumnDefs,_fnHungarianMap,_fnCamelToHungarian,_fnLanguageCompat,_fnBrowserDetect,_fnAddData,_fnAddTr,_fnNodeToDataIndex,_fnNodeToColumnIndex,_fnGetCellData,_fnSetCellData,_fnSplitObjNotation,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnGetDataMaster,_fnClearTable,_fnDeleteIndex,_fnInvalidate,_fnGetRowElements,_fnCreateTr,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAddOptionsHtml,_fnDetectHeader,_fnGetUniqueThs,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnFilterCreateSearch,_fnEscapeRegex,_fnFilterData,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnInfoMacros,_fnInitialise,_fnInitComplete,_fnLengthChange,_fnFeatureHtmlLength,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnFeatureHtmlTable,_fnScrollDraw,_fnApplyToChildren,_fnCalculateColumnWidths,_fnThrottle,_fnConvertToWidth,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnSortFlatten,_fnSort,_fnSortAria,_fnSortListener,_fnSortAttachListener,_fnSortingClasses,_fnSortData,_fnSaveState,_fnLoadState,_fnSettingsFromNode,_fnLog,_fnMap,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnLengthOverflow,_fnRenderer,_fnDataSource,_fnRowAttributes*/\n\n(function (factory) {\n    \"use strict\";\n\n    if (true) {\n        // AMD\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function ($) {\n            return factory($, window, document);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    }\n    else {}\n}\n    (function ($, window, document, undefined) {\n        \"use strict\";\n\n        /**\n         * DataTables is a plug-in for the jQuery Javascript library. It is a highly\n         * flexible tool, based upon the foundations of progressive enhancement,\n         * which will add advanced interaction controls to any HTML table. For a\n         * full list of features please refer to\n         * [DataTables.net](href=\"http://datatables.net).\n         *\n         * Note that the `DataTable` object is not a global variable but is aliased\n         * to `jQuery.fn.DataTable` and `jQuery.fn.dataTable` through which it may\n         * be  accessed.\n         *\n         *  @class\n         *  @param {object} [init={}] Configuration object for DataTables. Options\n         *    are defined by {@link DataTable.defaults}\n         *  @requires jQuery 1.7+\n         *\n         *  @example\n         *    // Basic initialisation\n         *    $(document).ready( function {\n         *      $('#example').dataTable();\n         *    } );\n         *\n         *  @example\n         *    // Initialisation with configuration options - in this case, disable\n         *    // pagination and sorting.\n         *    $(document).ready( function {\n         *      $('#example').dataTable( {\n         *        \"paginate\": false,\n         *        \"sort\": false\n         *      } );\n         *    } );\n         */\n        var DataTable = function (options) {\n            /**\n             * Perform a jQuery selector action on the table's TR elements (from the tbody) and\n             * return the resulting jQuery object.\n             *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n             *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n             *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter\n             *    criterion (\"applied\") or all TR elements (i.e. no filter).\n             *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.\n             *    Can be either 'current', whereby the current sorting of the table is used, or\n             *    'original' whereby the original order the data was read into the table is used.\n             *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n             *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n             *    'current' and filter is 'applied', regardless of what they might be given as.\n             *  @returns {object} jQuery object, filtered by the given selector.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Highlight every second row\n             *      oTable.$('tr:odd').css('backgroundColor', 'blue');\n             *    } );\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Filter to rows with 'Webkit' in them, add a background colour and then\n             *      // remove the filter, thus highlighting the 'Webkit' rows only.\n             *      oTable.fnFilter('Webkit');\n             *      oTable.$('tr', {\"search\": \"applied\"}).css('backgroundColor', 'blue');\n             *      oTable.fnFilter('');\n             *    } );\n             */\n            this.$ = function (sSelector, oOpts) {\n                return this.api(true).$(sSelector, oOpts);\n            };\n\n\n            /**\n             * Almost identical to $ in operation, but in this case returns the data for the matched\n             * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes\n             * rather than any descendants, so the data can be obtained for the row/cell. If matching\n             * rows are found, the data returned is the original data array/object that was used to\n             * create the row (or a generated array if from a DOM source).\n             *\n             * This method is often useful in-combination with $ where both functions are given the\n             * same parameters and the array indexes will match identically.\n             *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on\n             *  @param {object} [oOpts] Optional parameters for modifying the rows to be included\n             *  @param {string} [oOpts.filter=none] Select elements that meet the current filter\n             *    criterion (\"applied\") or all elements (i.e. no filter).\n             *  @param {string} [oOpts.order=current] Order of the data in the processed array.\n             *    Can be either 'current', whereby the current sorting of the table is used, or\n             *    'original' whereby the original order the data was read into the table is used.\n             *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page\n             *    (\"current\") or not (\"all\"). If 'current' is given, then order is assumed to be\n             *    'current' and filter is 'applied', regardless of what they might be given as.\n             *  @returns {array} Data for the matched elements. If any elements, as a result of the\n             *    selector, were not TR, TD or TH elements in the DataTable, they will have a null\n             *    entry in the array.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Get the data from the first row in the table\n             *      var data = oTable._('tr:first');\n             *\n             *      // Do something useful with the data\n             *      alert( \"First cell is: \"+data[0] );\n             *    } );\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Filter to 'Webkit' and get all data for\n             *      oTable.fnFilter('Webkit');\n             *      var data = oTable._('tr', {\"search\": \"applied\"});\n             *\n             *      // Do something with the data\n             *      alert( data.length+\" rows matched the search\" );\n             *    } );\n             */\n            this._ = function (sSelector, oOpts) {\n                return this.api(true).rows(sSelector, oOpts).data();\n            };\n\n\n            /**\n             * Create a DataTables Api instance, with the currently selected tables for\n             * the Api's context.\n             * @param {boolean} [traditional=false] Set the API instance's context to be\n             *   only the table referred to by the `DataTable.ext.iApiIndex` option, as was\n             *   used in the API presented by DataTables 1.9- (i.e. the traditional mode),\n             *   or if all tables captured in the jQuery object should be used.\n             * @return {DataTables.Api}\n             */\n            this.api = function (traditional) {\n                return traditional ?\n                    new _Api(\n                        _fnSettingsFromNode(this[_ext.iApiIndex])\n                    ) :\n                    new _Api(this);\n            };\n\n\n            /**\n             * Add a single new row or multiple rows of data to the table. Please note\n             * that this is suitable for client-side processing only - if you are using\n             * server-side processing (i.e. \"bServerSide\": true), then to add data, you\n             * must add it to the data source, i.e. the server-side, through an Ajax call.\n             *  @param {array|object} data The data to be added to the table. This can be:\n             *    <ul>\n             *      <li>1D array of data - add a single row with the data provided</li>\n             *      <li>2D array of arrays - add multiple rows in a single call</li>\n             *      <li>object - data object when using <i>mData</i></li>\n             *      <li>array of objects - multiple data objects when using <i>mData</i></li>\n             *    </ul>\n             *  @param {bool} [redraw=true] redraw the table or not\n             *  @returns {array} An array of integers, representing the list of indexes in\n             *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to\n             *    the table.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    // Global var for counter\n             *    var giCount = 2;\n             *\n             *    $(document).ready(function() {\n             *      $('#example').dataTable();\n             *    } );\n             *\n             *    function fnClickAddRow() {\n             *      $('#example').dataTable().fnAddData( [\n             *        giCount+\".1\",\n             *        giCount+\".2\",\n             *        giCount+\".3\",\n             *        giCount+\".4\" ]\n             *      );\n             *\n             *      giCount++;\n             *    }\n             */\n            this.fnAddData = function (data, redraw) {\n                var api = this.api(true);\n\n                /* Check if we want to add multiple rows or not */\n                var rows = Array.isArray(data) && (Array.isArray(data[0]) || $.isPlainObject(data[0])) ?\n                    api.rows.add(data) :\n                    api.row.add(data);\n\n                if (redraw === undefined || redraw) {\n                    api.draw();\n                }\n\n                return rows.flatten().toArray();\n            };\n\n\n            /**\n             * This function will make DataTables recalculate the column sizes, based on the data\n             * contained in the table and the sizes applied to the columns (in the DOM, CSS or\n             * through the sWidth parameter). This can be useful when the width of the table's\n             * parent element changes (for example a window resize).\n             *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable( {\n             *        \"sScrollY\": \"200px\",\n             *        \"bPaginate\": false\n             *      } );\n             *\n             *      $(window).on('resize', function () {\n             *        oTable.fnAdjustColumnSizing();\n             *      } );\n             *    } );\n             */\n            this.fnAdjustColumnSizing = function (bRedraw) {\n                var api = this.api(true).columns.adjust();\n                var settings = api.settings()[0];\n                var scroll = settings.oScroll;\n\n                if (bRedraw === undefined || bRedraw) {\n                    api.draw(false);\n                }\n                else if (scroll.sX !== \"\" || scroll.sY !== \"\") {\n                    /* If not redrawing, but scrolling, we want to apply the new column sizes anyway */\n                    _fnScrollDraw(settings);\n                }\n            };\n\n\n            /**\n             * Quickly and simply clear a table\n             *  @param {bool} [bRedraw=true] redraw the table or not\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)\n             *      oTable.fnClearTable();\n             *    } );\n             */\n            this.fnClearTable = function (bRedraw) {\n                var api = this.api(true).clear();\n\n                if (bRedraw === undefined || bRedraw) {\n                    api.draw();\n                }\n            };\n\n\n            /**\n             * The exact opposite of 'opening' a row, this function will close any rows which\n             * are currently 'open'.\n             *  @param {node} nTr the table row to 'close'\n             *  @returns {int} 0 on success, or 1 if failed (can't find the row)\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable;\n             *\n             *      // 'open' an information row when a row is clicked on\n             *      $('#example tbody tr').click( function () {\n             *        if ( oTable.fnIsOpen(this) ) {\n             *          oTable.fnClose( this );\n             *        } else {\n             *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n             *        }\n             *      } );\n             *\n             *      oTable = $('#example').dataTable();\n             *    } );\n             */\n            this.fnClose = function (nTr) {\n                this.api(true).row(nTr).child.hide();\n            };\n\n\n            /**\n             * Remove a row for the table\n             *  @param {mixed} target The index of the row from aoData to be deleted, or\n             *    the TR element you want to delete\n             *  @param {function|null} [callBack] Callback function\n             *  @param {bool} [redraw=true] Redraw the table or not\n             *  @returns {array} The row that was deleted\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Immediately remove the first row\n             *      oTable.fnDeleteRow( 0 );\n             *    } );\n             */\n            this.fnDeleteRow = function (target, callback, redraw) {\n                var api = this.api(true);\n                var rows = api.rows(target);\n                var settings = rows.settings()[0];\n                var data = settings.aoData[rows[0][0]];\n\n                rows.remove();\n\n                if (callback) {\n                    callback.call(this, settings, data);\n                }\n\n                if (redraw === undefined || redraw) {\n                    api.draw();\n                }\n\n                return data;\n            };\n\n\n            /**\n             * Restore the table to it's original state in the DOM by removing all of DataTables\n             * enhancements, alterations to the DOM structure of the table and event listeners.\n             *  @param {boolean} [remove=false] Completely remove the table from the DOM\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      // This example is fairly pointless in reality, but shows how fnDestroy can be used\n             *      var oTable = $('#example').dataTable();\n             *      oTable.fnDestroy();\n             *    } );\n             */\n            this.fnDestroy = function (remove) {\n                this.api(true).destroy(remove);\n            };\n\n\n            /**\n             * Redraw the table\n             *  @param {bool} [complete=true] Re-filter and resort (if enabled) the table before the draw.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)\n             *      oTable.fnDraw();\n             *    } );\n             */\n            this.fnDraw = function (complete) {\n                // Note that this isn't an exact match to the old call to _fnDraw - it takes\n                // into account the new data, but can hold position.\n                this.api(true).draw(complete);\n            };\n\n\n            /**\n             * Filter the input based on data\n             *  @param {string} sInput String to filter the table on\n             *  @param {int|null} [iColumn] Column to limit filtering to\n             *  @param {bool} [bRegex=false] Treat as regular expression or not\n             *  @param {bool} [bSmart=true] Perform smart filtering or not\n             *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)\n             *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Sometime later - filter...\n             *      oTable.fnFilter( 'test string' );\n             *    } );\n             */\n            this.fnFilter = function (sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {\n                var api = this.api(true);\n\n                if (iColumn === null || iColumn === undefined) {\n                    api.search(sInput, bRegex, bSmart, bCaseInsensitive);\n                }\n                else {\n                    api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive);\n                }\n\n                api.draw();\n            };\n\n\n            /**\n             * Get the data for the whole table, an individual row or an individual cell based on the\n             * provided parameters.\n             *  @param {int|node} [src] A TR row node, TD/TH cell node or an integer. If given as\n             *    a TR node then the data source for the whole row will be returned. If given as a\n             *    TD/TH cell node then iCol will be automatically calculated and the data for the\n             *    cell returned. If given as an integer, then this is treated as the aoData internal\n             *    data index for the row (see fnGetPosition) and the data for that row used.\n             *  @param {int} [col] Optional column index that you want the data of.\n             *  @returns {array|object|string} If mRow is undefined, then the data for all rows is\n             *    returned. If mRow is defined, just data for that row, and is iCol is\n             *    defined, only data for the designated cell is returned.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    // Row data\n             *    $(document).ready(function() {\n             *      oTable = $('#example').dataTable();\n             *\n             *      oTable.$('tr').click( function () {\n             *        var data = oTable.fnGetData( this );\n             *        // ... do something with the array / object of data for the row\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Individual cell data\n             *    $(document).ready(function() {\n             *      oTable = $('#example').dataTable();\n             *\n             *      oTable.$('td').click( function () {\n             *        var sData = oTable.fnGetData( this );\n             *        alert( 'The cell clicked on had the value of '+sData );\n             *      } );\n             *    } );\n             */\n            this.fnGetData = function (src, col) {\n                var api = this.api(true);\n\n                if (src !== undefined) {\n                    var type = src.nodeName ? src.nodeName.toLowerCase() : '';\n\n                    return col !== undefined || type == 'td' || type == 'th' ?\n                        api.cell(src, col).data() :\n                        api.row(src).data() || null;\n                }\n\n                return api.data().toArray();\n            };\n\n\n            /**\n             * Get an array of the TR nodes that are used in the table's body. Note that you will\n             * typically want to use the '$' API method in preference to this as it is more\n             * flexible.\n             *  @param {int} [iRow] Optional row index for the TR element you want\n             *  @returns {array|node} If iRow is undefined, returns an array of all TR elements\n             *    in the table's body, or iRow is defined, just the TR element requested.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Get the nodes from the table\n             *      var nNodes = oTable.fnGetNodes( );\n             *    } );\n             */\n            this.fnGetNodes = function (iRow) {\n                var api = this.api(true);\n\n                return iRow !== undefined ?\n                    api.row(iRow).node() :\n                    api.rows().nodes().flatten().toArray();\n            };\n\n\n            /**\n             * Get the array indexes of a particular cell from it's DOM element\n             * and column index including hidden columns\n             *  @param {node} node this can either be a TR, TD or TH in the table's body\n             *  @returns {int} If nNode is given as a TR, then a single index is returned, or\n             *    if given as a cell, an array of [row index, column index (visible),\n             *    column index (all)] is given.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      $('#example tbody td').click( function () {\n             *        // Get the position of the current data from the node\n             *        var aPos = oTable.fnGetPosition( this );\n             *\n             *        // Get the data array for this row\n             *        var aData = oTable.fnGetData( aPos[0] );\n             *\n             *        // Update the data array and return the value\n             *        aData[ aPos[1] ] = 'clicked';\n             *        this.innerHTML = 'clicked';\n             *      } );\n             *\n             *      // Init DataTables\n             *      oTable = $('#example').dataTable();\n             *    } );\n             */\n            this.fnGetPosition = function (node) {\n                var api = this.api(true);\n                var nodeName = node.nodeName.toUpperCase();\n\n                if (nodeName == 'TR') {\n                    return api.row(node).index();\n                }\n                else if (nodeName == 'TD' || nodeName == 'TH') {\n                    var cell = api.cell(node).index();\n\n                    return [\n                        cell.row,\n                        cell.columnVisible,\n                        cell.column\n                    ];\n                }\n                return null;\n            };\n\n\n            /**\n             * Check to see if a row is 'open' or not.\n             *  @param {node} nTr the table row to check\n             *  @returns {boolean} true if the row is currently open, false otherwise\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable;\n             *\n             *      // 'open' an information row when a row is clicked on\n             *      $('#example tbody tr').click( function () {\n             *        if ( oTable.fnIsOpen(this) ) {\n             *          oTable.fnClose( this );\n             *        } else {\n             *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n             *        }\n             *      } );\n             *\n             *      oTable = $('#example').dataTable();\n             *    } );\n             */\n            this.fnIsOpen = function (nTr) {\n                return this.api(true).row(nTr).child.isShown();\n            };\n\n\n            /**\n             * This function will place a new row directly after a row which is currently\n             * on display on the page, with the HTML contents that is passed into the\n             * function. This can be used, for example, to ask for confirmation that a\n             * particular record should be deleted.\n             *  @param {node} nTr The table row to 'open'\n             *  @param {string|node|jQuery} mHtml The HTML to put into the row\n             *  @param {string} sClass Class to give the new TD cell\n             *  @returns {node} The row opened. Note that if the table row passed in as the\n             *    first parameter, is not found in the table, this method will silently\n             *    return.\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable;\n             *\n             *      // 'open' an information row when a row is clicked on\n             *      $('#example tbody tr').click( function () {\n             *        if ( oTable.fnIsOpen(this) ) {\n             *          oTable.fnClose( this );\n             *        } else {\n             *          oTable.fnOpen( this, \"Temporary row opened\", \"info_row\" );\n             *        }\n             *      } );\n             *\n             *      oTable = $('#example').dataTable();\n             *    } );\n             */\n            this.fnOpen = function (nTr, mHtml, sClass) {\n                return this.api(true)\n                    .row(nTr)\n                    .child(mHtml, sClass)\n                    .show()\n                    .child()[0];\n            };\n\n\n            /**\n             * Change the pagination - provides the internal logic for pagination in a simple API\n             * function. With this function you can have a DataTables table go to the next,\n             * previous, first or last pages.\n             *  @param {string|int} mAction Paging action to take: \"first\", \"previous\", \"next\" or \"last\"\n             *    or page number to jump to (integer), note that page 0 is the first page.\n             *  @param {bool} [bRedraw=true] Redraw the table or not\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *      oTable.fnPageChange( 'next' );\n             *    } );\n             */\n            this.fnPageChange = function (mAction, bRedraw) {\n                var api = this.api(true).page(mAction);\n\n                if (bRedraw === undefined || bRedraw) {\n                    api.draw(false);\n                }\n            };\n\n\n            /**\n             * Show a particular column\n             *  @param {int} iCol The column whose display should be changed\n             *  @param {bool} bShow Show (true) or hide (false) the column\n             *  @param {bool} [bRedraw=true] Redraw the table or not\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Hide the second column after initialisation\n             *      oTable.fnSetColumnVis( 1, false );\n             *    } );\n             */\n            this.fnSetColumnVis = function (iCol, bShow, bRedraw) {\n                var api = this.api(true).column(iCol).visible(bShow);\n\n                if (bRedraw === undefined || bRedraw) {\n                    api.columns.adjust().draw();\n                }\n            };\n\n\n            /**\n             * Get the settings for a particular table for external manipulation\n             *  @returns {object} DataTables settings object. See\n             *    {@link DataTable.models.oSettings}\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *      var oSettings = oTable.fnSettings();\n             *\n             *      // Show an example parameter from the settings\n             *      alert( oSettings._iDisplayStart );\n             *    } );\n             */\n            this.fnSettings = function () {\n                return _fnSettingsFromNode(this[_ext.iApiIndex]);\n            };\n\n\n            /**\n             * Sort the table by a particular column\n             *  @param {int} iCol the data index to sort on. Note that this will not match the\n             *    'display index' if you have hidden data entries\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Sort immediately with columns 0 and 1\n             *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );\n             *    } );\n             */\n            this.fnSort = function (aaSort) {\n                this.api(true).order(aaSort).draw();\n            };\n\n\n            /**\n             * Attach a sort listener to an element for a given column\n             *  @param {node} nNode the element to attach the sort listener to\n             *  @param {int} iColumn the column that a click on this node will sort on\n             *  @param {function} [fnCallback] callback function when sort is run\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *\n             *      // Sort on column 1, when 'sorter' is clicked on\n             *      oTable.fnSortListener( document.getElementById('sorter'), 1 );\n             *    } );\n             */\n            this.fnSortListener = function (nNode, iColumn, fnCallback) {\n                this.api(true).order.listener(nNode, iColumn, fnCallback);\n            };\n\n\n            /**\n             * Update a table cell or row - this method will accept either a single value to\n             * update the cell with, an array of values with one element for each column or\n             * an object in the same format as the original data source. The function is\n             * self-referencing in order to make the multi column updates easier.\n             *  @param {object|array|string} mData Data to update the cell/row with\n             *  @param {node|int} mRow TR element you want to update or the aoData index\n             *  @param {int} [iColumn] The column to update, give as null or undefined to\n             *    update a whole row.\n             *  @param {bool} [bRedraw=true] Redraw the table or not\n             *  @param {bool} [bAction=true] Perform pre-draw actions or not\n             *  @returns {int} 0 on success, 1 on error\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell\n             *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], $('tbody tr')[0] ); // Row\n             *    } );\n             */\n            this.fnUpdate = function (mData, mRow, iColumn, bRedraw, bAction) {\n                var api = this.api(true);\n\n                if (iColumn === undefined || iColumn === null) {\n                    api.row(mRow).data(mData);\n                }\n                else {\n                    api.cell(mRow, iColumn).data(mData);\n                }\n\n                if (bAction === undefined || bAction) {\n                    api.columns.adjust();\n                }\n\n                if (bRedraw === undefined || bRedraw) {\n                    api.draw();\n                }\n                return 0;\n            };\n\n\n            /**\n             * Provide a common method for plug-ins to check the version of DataTables being used, in order\n             * to ensure compatibility.\n             *  @param {string} sVersion Version string to check for, in the format \"X.Y.Z\". Note that the\n             *    formats \"X\" and \"X.Y\" are also acceptable.\n             *  @returns {boolean} true if this version of DataTables is greater or equal to the required\n             *    version, or false if this version of DataTales is not suitable\n             *  @method\n             *  @dtopt API\n             *  @deprecated Since v1.10\n             *\n             *  @example\n             *    $(document).ready(function() {\n             *      var oTable = $('#example').dataTable();\n             *      alert( oTable.fnVersionCheck( '1.9.0' ) );\n             *    } );\n             */\n            this.fnVersionCheck = _ext.fnVersionCheck;\n\n\n            var _that = this;\n            var emptyInit = options === undefined;\n            var len = this.length;\n\n            if (emptyInit) {\n                options = {};\n            }\n\n            this.oApi = this.internal = _ext.internal;\n\n            // Extend with old style plug-in API methods\n            for (var fn in DataTable.ext.internal) {\n                if (fn) {\n                    this[fn] = _fnExternApiFunc(fn);\n                }\n            }\n\n            this.each(function () {\n                // For each initialisation we want to give it a clean initialisation\n                // object that can be bashed around\n                var o = {};\n                var oInit = len > 1 ? // optimisation for single table case\n                    _fnExtend(o, options, true) :\n                    options;\n\n                /*global oInit,_that,emptyInit*/\n                var i = 0, iLen, j, jLen, k, kLen;\n                var sId = this.getAttribute('id');\n                var bInitHandedOff = false;\n                var defaults = DataTable.defaults;\n                var $this = $(this);\n\n\n                /* Sanity check */\n                if (this.nodeName.toLowerCase() != 'table') {\n                    _fnLog(null, 0, 'Non-table node initialisation (' + this.nodeName + ')', 2);\n                    return;\n                }\n\n                /* Backwards compatibility for the defaults */\n                _fnCompatOpts(defaults);\n                _fnCompatCols(defaults.column);\n\n                /* Convert the camel-case defaults to Hungarian */\n                _fnCamelToHungarian(defaults, defaults, true);\n                _fnCamelToHungarian(defaults.column, defaults.column, true);\n\n                /* Setting up the initialisation object */\n                _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()), true);\n\n\n\n                /* Check to see if we are re-initialising a table */\n                var allSettings = DataTable.settings;\n                for (i = 0, iLen = allSettings.length; i < iLen; i++) {\n                    var s = allSettings[i];\n\n                    /* Base check on table node */\n                    if (\n                        s.nTable == this ||\n                        (s.nTHead && s.nTHead.parentNode == this) ||\n                        (s.nTFoot && s.nTFoot.parentNode == this)\n                    ) {\n                        var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve;\n                        var bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;\n\n                        if (emptyInit || bRetrieve) {\n                            return s.oInstance;\n                        }\n                        else if (bDestroy) {\n                            s.oInstance.fnDestroy();\n                            break;\n                        }\n                        else {\n                            _fnLog(s, 0, 'Cannot reinitialise DataTable', 3);\n                            return;\n                        }\n                    }\n\n                    /* If the element we are initialising has the same ID as a table which was previously\n                     * initialised, but the table nodes don't match (from before) then we destroy the old\n                     * instance by simply deleting it. This is under the assumption that the table has been\n                     * destroyed by other methods. Anyone using non-id selectors will need to do this manually\n                     */\n                    if (s.sTableId == this.id) {\n                        allSettings.splice(i, 1);\n                        break;\n                    }\n                }\n\n                /* Ensure the table has an ID - required for accessibility */\n                if (sId === null || sId === \"\") {\n                    sId = \"DataTables_Table_\" + (DataTable.ext._unique++);\n                    this.id = sId;\n                }\n\n                /* Create the settings object for this table and set some of the default parameters */\n                var oSettings = $.extend(true, {}, DataTable.models.oSettings, {\n                    \"sDestroyWidth\": $this[0].style.width,\n                    \"sInstance\": sId,\n                    \"sTableId\": sId\n                });\n                oSettings.nTable = this;\n                oSettings.oApi = _that.internal;\n                oSettings.oInit = oInit;\n\n                allSettings.push(oSettings);\n\n                // Need to add the instance after the instance after the settings object has been added\n                // to the settings array, so we can self reference the table instance if more than one\n                oSettings.oInstance = (_that.length === 1) ? _that : $this.dataTable();\n\n                // Backwards compatibility, before we apply all the defaults\n                _fnCompatOpts(oInit);\n                _fnLanguageCompat(oInit.oLanguage);\n\n                // If the length menu is given, but the init display length is not, use the length menu\n                if (oInit.aLengthMenu && !oInit.iDisplayLength) {\n                    oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ?\n                        oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0];\n                }\n\n                // Apply the defaults and init options to make a single init object will all\n                // options defined from defaults and instance options.\n                oInit = _fnExtend($.extend(true, {}, defaults), oInit);\n\n\n                // Map the initialisation options onto the settings object\n                _fnMap(oSettings.oFeatures, oInit, [\n                    \"bPaginate\",\n                    \"bLengthChange\",\n                    \"bFilter\",\n                    \"bSort\",\n                    \"bSortMulti\",\n                    \"bInfo\",\n                    \"bProcessing\",\n                    \"bAutoWidth\",\n                    \"bSortClasses\",\n                    \"bServerSide\",\n                    \"bDeferRender\"\n                ]);\n                _fnMap(oSettings, oInit, [\n                    \"asStripeClasses\",\n                    \"ajax\",\n                    \"fnServerData\",\n                    \"fnFormatNumber\",\n                    \"sServerMethod\",\n                    \"aaSorting\",\n                    \"aaSortingFixed\",\n                    \"aLengthMenu\",\n                    \"sPaginationType\",\n                    \"sAjaxSource\",\n                    \"sAjaxDataProp\",\n                    \"iStateDuration\",\n                    \"sDom\",\n                    \"bSortCellsTop\",\n                    \"iTabIndex\",\n                    \"fnStateLoadCallback\",\n                    \"fnStateSaveCallback\",\n                    \"renderer\",\n                    \"searchDelay\",\n                    \"rowId\",\n                    [\"iCookieDuration\", \"iStateDuration\"], // backwards compat\n                    [\"oSearch\", \"oPreviousSearch\"],\n                    [\"aoSearchCols\", \"aoPreSearchCols\"],\n                    [\"iDisplayLength\", \"_iDisplayLength\"]\n                ]);\n                _fnMap(oSettings.oScroll, oInit, [\n                    [\"sScrollX\", \"sX\"],\n                    [\"sScrollXInner\", \"sXInner\"],\n                    [\"sScrollY\", \"sY\"],\n                    [\"bScrollCollapse\", \"bCollapse\"]\n                ]);\n                _fnMap(oSettings.oLanguage, oInit, \"fnInfoCallback\");\n\n                /* Callback functions which are array driven */\n                _fnCallbackReg(oSettings, 'aoDrawCallback', oInit.fnDrawCallback, 'user');\n                _fnCallbackReg(oSettings, 'aoServerParams', oInit.fnServerParams, 'user');\n                _fnCallbackReg(oSettings, 'aoStateSaveParams', oInit.fnStateSaveParams, 'user');\n                _fnCallbackReg(oSettings, 'aoStateLoadParams', oInit.fnStateLoadParams, 'user');\n                _fnCallbackReg(oSettings, 'aoStateLoaded', oInit.fnStateLoaded, 'user');\n                _fnCallbackReg(oSettings, 'aoRowCallback', oInit.fnRowCallback, 'user');\n                _fnCallbackReg(oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow, 'user');\n                _fnCallbackReg(oSettings, 'aoHeaderCallback', oInit.fnHeaderCallback, 'user');\n                _fnCallbackReg(oSettings, 'aoFooterCallback', oInit.fnFooterCallback, 'user');\n                _fnCallbackReg(oSettings, 'aoInitComplete', oInit.fnInitComplete, 'user');\n                _fnCallbackReg(oSettings, 'aoPreDrawCallback', oInit.fnPreDrawCallback, 'user');\n\n                oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);\n\n                /* Browser support detection */\n                _fnBrowserDetect(oSettings);\n\n                var oClasses = oSettings.oClasses;\n\n                $.extend(oClasses, DataTable.ext.classes, oInit.oClasses);\n                $this.addClass(oClasses.sTable);\n\n\n                if (oSettings.iInitDisplayStart === undefined) {\n                    /* Display start point, taking into account the save saving */\n                    oSettings.iInitDisplayStart = oInit.iDisplayStart;\n                    oSettings._iDisplayStart = oInit.iDisplayStart;\n                }\n\n                if (oInit.iDeferLoading !== null) {\n                    oSettings.bDeferLoading = true;\n                    var tmp = Array.isArray(oInit.iDeferLoading);\n                    oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading;\n                    oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading;\n                }\n\n                /* Language definitions */\n                var oLanguage = oSettings.oLanguage;\n                $.extend(true, oLanguage, oInit.oLanguage);\n\n                if (oLanguage.sUrl) {\n                    /* Get the language definitions from a file - because this Ajax call makes the language\n                     * get async to the remainder of this function we use bInitHandedOff to indicate that\n                     * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor\n                     */\n                    $.ajax({\n                        dataType: 'json',\n                        url: oLanguage.sUrl,\n                        success: function (json) {\n                            _fnLanguageCompat(json);\n                            _fnCamelToHungarian(defaults.oLanguage, json);\n                            $.extend(true, oLanguage, json);\n                            _fnInitialise(oSettings);\n                        },\n                        error: function () {\n                            // Error occurred loading language file, continue on as best we can\n                            _fnInitialise(oSettings);\n                        }\n                    });\n                    bInitHandedOff = true;\n                }\n\n                /*\n                 * Stripes\n                 */\n                if (oInit.asStripeClasses === null) {\n                    oSettings.asStripeClasses = [\n                        oClasses.sStripeOdd,\n                        oClasses.sStripeEven\n                    ];\n                }\n\n                /* Remove row stripe classes if they are already on the table row */\n                var stripeClasses = oSettings.asStripeClasses;\n                var rowOne = $this.children('tbody').find('tr').eq(0);\n                if ($.inArray(true, $.map(stripeClasses, function (el, i) {\n                    return rowOne.hasClass(el);\n                })) !== -1) {\n                    $('tbody tr', this).removeClass(stripeClasses.join(' '));\n                    oSettings.asDestroyStripes = stripeClasses.slice();\n                }\n\n                /*\n                 * Columns\n                 * See if we should load columns automatically or use defined ones\n                 */\n                var anThs = [];\n                var aoColumnsInit;\n                var nThead = this.getElementsByTagName('thead');\n                if (nThead.length !== 0) {\n                    _fnDetectHeader(oSettings.aoHeader, nThead[0]);\n                    anThs = _fnGetUniqueThs(oSettings);\n                }\n\n                /* If not given a column array, generate one with nulls */\n                if (oInit.aoColumns === null) {\n                    aoColumnsInit = [];\n                    for (i = 0, iLen = anThs.length; i < iLen; i++) {\n                        aoColumnsInit.push(null);\n                    }\n                }\n                else {\n                    aoColumnsInit = oInit.aoColumns;\n                }\n\n                /* Add the columns */\n                for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) {\n                    _fnAddColumn(oSettings, anThs ? anThs[i] : null);\n                }\n\n                /* Apply the column definitions */\n                _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {\n                    _fnColumnOptions(oSettings, iCol, oDef);\n                });\n\n                /* HTML5 attribute detection - build an mData object automatically if the\n                 * attributes are found\n                 */\n                if (rowOne.length) {\n                    var a = function (cell, name) {\n                        return cell.getAttribute('data-' + name) !== null ? name : null;\n                    };\n\n                    $(rowOne[0]).children('th, td').each(function (i, cell) {\n                        var col = oSettings.aoColumns[i];\n\n                        if (col.mData === i) {\n                            var sort = a(cell, 'sort') || a(cell, 'order');\n                            var filter = a(cell, 'filter') || a(cell, 'search');\n\n                            if (sort !== null || filter !== null) {\n                                col.mData = {\n                                    _: i + '.display',\n                                    sort: sort !== null ? i + '.@data-' + sort : undefined,\n                                    type: sort !== null ? i + '.@data-' + sort : undefined,\n                                    filter: filter !== null ? i + '.@data-' + filter : undefined\n                                };\n\n                                _fnColumnOptions(oSettings, i);\n                            }\n                        }\n                    });\n                }\n\n                var features = oSettings.oFeatures;\n                var loadedInit = function () {\n                    /*\n                     * Sorting\n                     * @todo For modularisation (1.11) this needs to do into a sort start up handler\n                     */\n\n                    // If aaSorting is not defined, then we use the first indicator in asSorting\n                    // in case that has been altered, so the default sort reflects that option\n                    if (oInit.aaSorting === undefined) {\n                        var sorting = oSettings.aaSorting;\n                        for (i = 0, iLen = sorting.length; i < iLen; i++) {\n                            sorting[i][1] = oSettings.aoColumns[i].asSorting[0];\n                        }\n                    }\n\n                    /* Do a first pass on the sorting classes (allows any size changes to be taken into\n                     * account, and also will apply sorting disabled classes if disabled\n                     */\n                    _fnSortingClasses(oSettings);\n\n                    if (features.bSort) {\n                        _fnCallbackReg(oSettings, 'aoDrawCallback', function () {\n                            if (oSettings.bSorted) {\n                                var aSort = _fnSortFlatten(oSettings);\n                                var sortedColumns = {};\n\n                                $.each(aSort, function (i, val) {\n                                    sortedColumns[val.src] = val.dir;\n                                });\n\n                                _fnCallbackFire(oSettings, null, 'order', [oSettings, aSort, sortedColumns]);\n                                _fnSortAria(oSettings);\n                            }\n                        });\n                    }\n\n                    _fnCallbackReg(oSettings, 'aoDrawCallback', function () {\n                        if (oSettings.bSorted || _fnDataSource(oSettings) === 'ssp' || features.bDeferRender) {\n                            _fnSortingClasses(oSettings);\n                        }\n                    }, 'sc');\n\n\n                    /*\n                     * Final init\n                     * Cache the header, body and footer as required, creating them if needed\n                     */\n\n                    // Work around for Webkit bug 83867 - store the caption-side before removing from doc\n                    var captions = $this.children('caption').each(function () {\n                        this._captionSide = $(this).css('caption-side');\n                    });\n\n                    var thead = $this.children('thead');\n                    if (thead.length === 0) {\n                        thead = $('<thead/>').appendTo($this);\n                    }\n                    oSettings.nTHead = thead[0];\n\n                    var tbody = $this.children('tbody');\n                    if (tbody.length === 0) {\n                        tbody = $('<tbody/>').appendTo($this);\n                    }\n                    oSettings.nTBody = tbody[0];\n\n                    var tfoot = $this.children('tfoot');\n                    if (tfoot.length === 0 && captions.length > 0 && (oSettings.oScroll.sX !== \"\" || oSettings.oScroll.sY !== \"\")) {\n                        // If we are a scrolling table, and no footer has been given, then we need to create\n                        // a tfoot element for the caption element to be appended to\n                        tfoot = $('<tfoot/>').appendTo($this);\n                    }\n\n                    if (tfoot.length === 0 || tfoot.children().length === 0) {\n                        $this.addClass(oClasses.sNoFooter);\n                    }\n                    else if (tfoot.length > 0) {\n                        oSettings.nTFoot = tfoot[0];\n                        _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot);\n                    }\n\n                    /* Check if there is data passing into the constructor */\n                    if (oInit.aaData) {\n                        for (i = 0; i < oInit.aaData.length; i++) {\n                            _fnAddData(oSettings, oInit.aaData[i]);\n                        }\n                    }\n                    else if (oSettings.bDeferLoading || _fnDataSource(oSettings) == 'dom') {\n                        /* Grab the data from the page - only do this when deferred loading or no Ajax\n                         * source since there is no point in reading the DOM data if we are then going\n                         * to replace it with Ajax data\n                         */\n                        _fnAddTr(oSettings, $(oSettings.nTBody).children('tr'));\n                    }\n\n                    /* Copy the data index array */\n                    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();\n\n                    /* Initialisation complete - table can be drawn */\n                    oSettings.bInitialised = true;\n\n                    /* Check if we need to initialise the table (it might not have been handed off to the\n                     * language processor)\n                     */\n                    if (bInitHandedOff === false) {\n                        _fnInitialise(oSettings);\n                    }\n                };\n\n                /* Must be done after everything which can be overridden by the state saving! */\n                if (oInit.bStateSave) {\n                    features.bStateSave = true;\n                    _fnCallbackReg(oSettings, 'aoDrawCallback', _fnSaveState, 'state_save');\n                    _fnLoadState(oSettings, oInit, loadedInit);\n                }\n                else {\n                    loadedInit();\n                }\n\n            });\n            _that = null;\n            return this;\n        };\n\n\n        /*\n         * It is useful to have variables which are scoped locally so only the\n         * DataTables functions can access them and they don't leak into global space.\n         * At the same time these functions are often useful over multiple files in the\n         * core and API, so we list, or at least document, all variables which are used\n         * by DataTables as private variables here. This also ensures that there is no\n         * clashing of variable names and that they can easily referenced for reuse.\n         */\n\n\n        // Defined else where\n        //  _selector_run\n        //  _selector_opts\n        //  _selector_first\n        //  _selector_row_indexes\n\n        var _ext; // DataTable.ext\n        var _Api; // DataTable.Api\n        var _api_register; // DataTable.Api.register\n        var _api_registerPlural; // DataTable.Api.registerPlural\n\n        var _re_dic = {};\n        var _re_new_lines = /[\\r\\n\\u2028]/g;\n        var _re_html = /<.*?>/g;\n\n        // This is not strict ISO8601 - Date.parse() is quite lax, although\n        // implementations differ between browsers.\n        var _re_date = /^\\d{2,4}[\\.\\/\\-]\\d{1,2}[\\.\\/\\-]\\d{1,2}([T ]{1}\\d{1,2}[:\\.]\\d{2}([\\.:]\\d{2})?)?$/;\n\n        // Escape regular expression special characters\n        var _re_escape_regex = new RegExp('(\\\\' + ['/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\\\', '$', '^', '-'].join('|\\\\') + ')', 'g');\n\n        // http://en.wikipedia.org/wiki/Foreign_exchange_market\n        // - \\u20BD - Russian ruble.\n        // - \\u20a9 - South Korean Won\n        // - \\u20BA - Turkish Lira\n        // - \\u20B9 - Indian Rupee\n        // - R - Brazil (R$) and South Africa\n        // - fr - Swiss Franc\n        // - kr - Swedish krona, Norwegian krone and Danish krone\n        // - \\u2009 is thin space and \\u202F is narrow no-break space, both used in many\n        // -  - Bitcoin\n        // -  - Ethereum\n        //   standards as thousands separators.\n        var _re_formatted_numeric = /['\\u00A0,$%\\u2009\\u202F\\u20BD\\u20a9\\u20BArfk]/gi;\n\n\n        var _empty = function (d) {\n            return !d || d === true || d === '-' ? true : false;\n        };\n\n\n        var _intVal = function (s) {\n            var integer = parseInt(s, 10);\n            return !isNaN(integer) && isFinite(s) ? integer : null;\n        };\n\n        // Convert from a formatted number with characters other than `.` as the\n        // decimal place, to a Javascript number\n        var _numToDecimal = function (num, decimalPoint) {\n            // Cache created regular expressions for speed as this function is called often\n            if (!_re_dic[decimalPoint]) {\n                _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), 'g');\n            }\n            return typeof num === 'string' && decimalPoint !== '.' ?\n                num.replace(/\\./g, '').replace(_re_dic[decimalPoint], '.') :\n                num;\n        };\n\n\n        var _isNumber = function (d, decimalPoint, formatted) {\n            var strType = typeof d === 'string';\n\n            // If empty return immediately so there must be a number if it is a\n            // formatted string (this stops the string \"k\", or \"kr\", etc being detected\n            // as a formatted number for currency\n            if (_empty(d)) {\n                return true;\n            }\n\n            if (decimalPoint && strType) {\n                d = _numToDecimal(d, decimalPoint);\n            }\n\n            if (formatted && strType) {\n                d = d.replace(_re_formatted_numeric, '');\n            }\n\n            return !isNaN(parseFloat(d)) && isFinite(d);\n        };\n\n\n        // A string without HTML in it can be considered to be HTML still\n        var _isHtml = function (d) {\n            return _empty(d) || typeof d === 'string';\n        };\n\n\n        var _htmlNumeric = function (d, decimalPoint, formatted) {\n            if (_empty(d)) {\n                return true;\n            }\n\n            var html = _isHtml(d);\n            return !html ?\n                null :\n                _isNumber(_stripHtml(d), decimalPoint, formatted) ?\n                    true :\n                    null;\n        };\n\n\n        var _pluck = function (a, prop, prop2) {\n            var out = [];\n            var i = 0, ien = a.length;\n\n            // Could have the test in the loop for slightly smaller code, but speed\n            // is essential here\n            if (prop2 !== undefined) {\n                for (; i < ien; i++) {\n                    if (a[i] && a[i][prop]) {\n                        out.push(a[i][prop][prop2]);\n                    }\n                }\n            }\n            else {\n                for (; i < ien; i++) {\n                    if (a[i]) {\n                        out.push(a[i][prop]);\n                    }\n                }\n            }\n\n            return out;\n        };\n\n\n        // Basically the same as _pluck, but rather than looping over `a` we use `order`\n        // as the indexes to pick from `a`\n        var _pluck_order = function (a, order, prop, prop2) {\n            var out = [];\n            var i = 0, ien = order.length;\n\n            // Could have the test in the loop for slightly smaller code, but speed\n            // is essential here\n            if (prop2 !== undefined) {\n                for (; i < ien; i++) {\n                    if (a[order[i]][prop]) {\n                        out.push(a[order[i]][prop][prop2]);\n                    }\n                }\n            }\n            else {\n                for (; i < ien; i++) {\n                    out.push(a[order[i]][prop]);\n                }\n            }\n\n            return out;\n        };\n\n\n        var _range = function (len, start) {\n            var out = [];\n            var end;\n\n            if (start === undefined) {\n                start = 0;\n                end = len;\n            }\n            else {\n                end = start;\n                start = len;\n            }\n\n            for (var i = start; i < end; i++) {\n                out.push(i);\n            }\n\n            return out;\n        };\n\n\n        var _removeEmpty = function (a) {\n            var out = [];\n\n            for (var i = 0, ien = a.length; i < ien; i++) {\n                if (a[i]) { // careful - will remove all falsy values!\n                    out.push(a[i]);\n                }\n            }\n\n            return out;\n        };\n\n\n        var _stripHtml = function (d) {\n            return d.replace(_re_html, '');\n        };\n\n\n        /**\n         * Determine if all values in the array are unique. This means we can short\n         * cut the _unique method at the cost of a single loop. A sorted array is used\n         * to easily check the values.\n         *\n         * @param  {array} src Source array\n         * @return {boolean} true if all unique, false otherwise\n         * @ignore\n         */\n        var _areAllUnique = function (src) {\n            if (src.length < 2) {\n                return true;\n            }\n\n            var sorted = src.slice().sort();\n            var last = sorted[0];\n\n            for (var i = 1, ien = sorted.length; i < ien; i++) {\n                if (sorted[i] === last) {\n                    return false;\n                }\n\n                last = sorted[i];\n            }\n\n            return true;\n        };\n\n\n        /**\n         * Find the unique elements in a source array.\n         *\n         * @param  {array} src Source array\n         * @return {array} Array of unique items\n         * @ignore\n         */\n        var _unique = function (src) {\n            if (_areAllUnique(src)) {\n                return src.slice();\n            }\n\n            // A faster unique method is to use object keys to identify used values,\n            // but this doesn't work with arrays or objects, which we must also\n            // consider. See jsperf.com/compare-array-unique-versions/4 for more\n            // information.\n            var\n                out = [],\n                val,\n                i, ien = src.length,\n                j, k = 0;\n\n            again: for (i = 0; i < ien; i++) {\n                val = src[i];\n\n                for (j = 0; j < k; j++) {\n                    if (out[j] === val) {\n                        continue again;\n                    }\n                }\n\n                out.push(val);\n                k++;\n            }\n\n            return out;\n        };\n\n        // Surprisingly this is faster than [].concat.apply\n        // https://jsperf.com/flatten-an-array-loop-vs-reduce/2\n        var _flatten = function (out, val) {\n            if (Array.isArray(val)) {\n                for (var i = 0; i < val.length; i++) {\n                    _flatten(out, val[i]);\n                }\n            }\n            else {\n                out.push(val);\n            }\n\n            return out;\n        }\n\n        // Array.isArray polyfill.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray\n        if (!Array.isArray) {\n            Array.isArray = function (arg) {\n                return Object.prototype.toString.call(arg) === '[object Array]';\n            };\n        }\n\n        // .trim() polyfill\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim\n        if (!String.prototype.trim) {\n            String.prototype.trim = function () {\n                return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n            };\n        }\n\n        /**\n         * DataTables utility methods\n         *\n         * This namespace provides helper methods that DataTables uses internally to\n         * create a DataTable, but which are not exclusively used only for DataTables.\n         * These methods can be used by extension authors to save the duplication of\n         * code.\n         *\n         *  @namespace\n         */\n        DataTable.util = {\n            /**\n             * Throttle the calls to a function. Arguments and context are maintained\n             * for the throttled function.\n             *\n             * @param {function} fn Function to be called\n             * @param {integer} freq Call frequency in mS\n             * @return {function} Wrapped function\n             */\n            throttle: function (fn, freq) {\n                var\n                    frequency = freq !== undefined ? freq : 200,\n                    last,\n                    timer;\n\n                return function () {\n                    var\n                        that = this,\n                        now = +new Date(),\n                        args = arguments;\n\n                    if (last && now < last + frequency) {\n                        clearTimeout(timer);\n\n                        timer = setTimeout(function () {\n                            last = undefined;\n                            fn.apply(that, args);\n                        }, frequency);\n                    }\n                    else {\n                        last = now;\n                        fn.apply(that, args);\n                    }\n                };\n            },\n\n\n            /**\n             * Escape a string such that it can be used in a regular expression\n             *\n             *  @param {string} val string to escape\n             *  @returns {string} escaped string\n             */\n            escapeRegex: function (val) {\n                return val.replace(_re_escape_regex, '\\\\$1');\n            }\n        };\n\n\n\n        /**\n         * Create a mapping object that allows camel case parameters to be looked up\n         * for their Hungarian counterparts. The mapping is stored in a private\n         * parameter called `_hungarianMap` which can be accessed on the source object.\n         *  @param {object} o\n         *  @memberof DataTable#oApi\n         */\n        function _fnHungarianMap(o) {\n            var\n                hungarian = 'a aa ai ao as b fn i m o s ',\n                match,\n                newKey,\n                map = {};\n\n            $.each(o, function (key, val) {\n                match = key.match(/^([^A-Z]+?)([A-Z])/);\n\n                if (match && hungarian.indexOf(match[1] + ' ') !== -1) {\n                    newKey = key.replace(match[0], match[2].toLowerCase());\n                    map[newKey] = key;\n\n                    if (match[1] === 'o') {\n                        _fnHungarianMap(o[key]);\n                    }\n                }\n            });\n\n            o._hungarianMap = map;\n        }\n\n\n        /**\n         * Convert from camel case parameters to Hungarian, based on a Hungarian map\n         * created by _fnHungarianMap.\n         *  @param {object} src The model object which holds all parameters that can be\n         *    mapped.\n         *  @param {object} user The object to convert from camel case to Hungarian.\n         *  @param {boolean} force When set to `true`, properties which already have a\n         *    Hungarian value in the `user` object will be overwritten. Otherwise they\n         *    won't be.\n         *  @memberof DataTable#oApi\n         */\n        function _fnCamelToHungarian(src, user, force) {\n            if (!src._hungarianMap) {\n                _fnHungarianMap(src);\n            }\n\n            var hungarianKey;\n\n            $.each(user, function (key, val) {\n                hungarianKey = src._hungarianMap[key];\n\n                if (hungarianKey !== undefined && (force || user[hungarianKey] === undefined)) {\n                    // For objects, we need to buzz down into the object to copy parameters\n                    if (hungarianKey.charAt(0) === 'o') {\n                        // Copy the camelCase options over to the hungarian\n                        if (!user[hungarianKey]) {\n                            user[hungarianKey] = {};\n                        }\n                        $.extend(true, user[hungarianKey], user[key]);\n\n                        _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);\n                    }\n                    else {\n                        user[hungarianKey] = user[key];\n                    }\n                }\n            });\n        }\n\n\n        /**\n         * Language compatibility - when certain options are given, and others aren't, we\n         * need to duplicate the values over, in order to provide backwards compatibility\n         * with older language files.\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnLanguageCompat(lang) {\n            // Note the use of the Hungarian notation for the parameters in this method as\n            // this is called after the mapping of camelCase to Hungarian\n            var defaults = DataTable.defaults.oLanguage;\n\n            // Default mapping\n            var defaultDecimal = defaults.sDecimal;\n            if (defaultDecimal) {\n                _addNumericSort(defaultDecimal);\n            }\n\n            if (lang) {\n                var zeroRecords = lang.sZeroRecords;\n\n                // Backwards compatibility - if there is no sEmptyTable given, then use the same as\n                // sZeroRecords - assuming that is given.\n                if (!lang.sEmptyTable && zeroRecords &&\n                    defaults.sEmptyTable === \"No data available in table\") {\n                    _fnMap(lang, lang, 'sZeroRecords', 'sEmptyTable');\n                }\n\n                // Likewise with loading records\n                if (!lang.sLoadingRecords && zeroRecords &&\n                    defaults.sLoadingRecords === \"Loading...\") {\n                    _fnMap(lang, lang, 'sZeroRecords', 'sLoadingRecords');\n                }\n\n                // Old parameter name of the thousands separator mapped onto the new\n                if (lang.sInfoThousands) {\n                    lang.sThousands = lang.sInfoThousands;\n                }\n\n                var decimal = lang.sDecimal;\n                if (decimal && defaultDecimal !== decimal) {\n                    _addNumericSort(decimal);\n                }\n            }\n        }\n\n\n        /**\n         * Map one parameter onto another\n         *  @param {object} o Object to map\n         *  @param {*} knew The new parameter name\n         *  @param {*} old The old parameter name\n         */\n        var _fnCompatMap = function (o, knew, old) {\n            if (o[knew] !== undefined) {\n                o[old] = o[knew];\n            }\n        };\n\n\n        /**\n         * Provide backwards compatibility for the main DT options. Note that the new\n         * options are mapped onto the old parameters, so this is an external interface\n         * change only.\n         *  @param {object} init Object to map\n         */\n        function _fnCompatOpts(init) {\n            _fnCompatMap(init, 'ordering', 'bSort');\n            _fnCompatMap(init, 'orderMulti', 'bSortMulti');\n            _fnCompatMap(init, 'orderClasses', 'bSortClasses');\n            _fnCompatMap(init, 'orderCellsTop', 'bSortCellsTop');\n            _fnCompatMap(init, 'order', 'aaSorting');\n            _fnCompatMap(init, 'orderFixed', 'aaSortingFixed');\n            _fnCompatMap(init, 'paging', 'bPaginate');\n            _fnCompatMap(init, 'pagingType', 'sPaginationType');\n            _fnCompatMap(init, 'pageLength', 'iDisplayLength');\n            _fnCompatMap(init, 'searching', 'bFilter');\n\n            // Boolean initialisation of x-scrolling\n            if (typeof init.sScrollX === 'boolean') {\n                init.sScrollX = init.sScrollX ? '100%' : '';\n            }\n            if (typeof init.scrollX === 'boolean') {\n                init.scrollX = init.scrollX ? '100%' : '';\n            }\n\n            // Column search objects are in an array, so it needs to be converted\n            // element by element\n            var searchCols = init.aoSearchCols;\n\n            if (searchCols) {\n                for (var i = 0, ien = searchCols.length; i < ien; i++) {\n                    if (searchCols[i]) {\n                        _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);\n                    }\n                }\n            }\n        }\n\n\n        /**\n         * Provide backwards compatibility for column options. Note that the new options\n         * are mapped onto the old parameters, so this is an external interface change\n         * only.\n         *  @param {object} init Object to map\n         */\n        function _fnCompatCols(init) {\n            _fnCompatMap(init, 'orderable', 'bSortable');\n            _fnCompatMap(init, 'orderData', 'aDataSort');\n            _fnCompatMap(init, 'orderSequence', 'asSorting');\n            _fnCompatMap(init, 'orderDataType', 'sortDataType');\n\n            // orderData can be given as an integer\n            var dataSort = init.aDataSort;\n            if (typeof dataSort === 'number' && !Array.isArray(dataSort)) {\n                init.aDataSort = [dataSort];\n            }\n        }\n\n\n        /**\n         * Browser feature detection for capabilities, quirks\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnBrowserDetect(settings) {\n            // We don't need to do this every time DataTables is constructed, the values\n            // calculated are specific to the browser and OS configuration which we\n            // don't expect to change between initialisations\n            if (!DataTable.__browser) {\n                var browser = {};\n                DataTable.__browser = browser;\n\n                // Scrolling feature / quirks detection\n                var n = $('<div/>')\n                    .css({\n                        position: 'fixed',\n                        top: 0,\n                        left: $(window).scrollLeft() * -1, // allow for scrolling\n                        height: 1,\n                        width: 1,\n                        overflow: 'hidden'\n                    })\n                    .append(\n                        $('<div/>')\n                            .css({\n                                position: 'absolute',\n                                top: 1,\n                                left: 1,\n                                width: 100,\n                                overflow: 'scroll'\n                            })\n                            .append(\n                                $('<div/>')\n                                    .css({\n                                        width: '100%',\n                                        height: 10\n                                    })\n                            )\n                    )\n                    .appendTo('body');\n\n                var outer = n.children();\n                var inner = outer.children();\n\n                // Numbers below, in order, are:\n                // inner.offsetWidth, inner.clientWidth, outer.offsetWidth, outer.clientWidth\n                //\n                // IE6 XP:                           100 100 100  83\n                // IE7 Vista:                        100 100 100  83\n                // IE 8+ Windows:                     83  83 100  83\n                // Evergreen Windows:                 83  83 100  83\n                // Evergreen Mac with scrollbars:     85  85 100  85\n                // Evergreen Mac without scrollbars: 100 100 100 100\n\n                // Get scrollbar width\n                browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth;\n\n                // IE6/7 will oversize a width 100% element inside a scrolling element, to\n                // include the width of the scrollbar, while other browsers ensure the inner\n                // element is contained without forcing scrolling\n                browser.bScrollOversize = inner[0].offsetWidth === 100 && outer[0].clientWidth !== 100;\n\n                // In rtl text layout, some browsers (most, but not all) will place the\n                // scrollbar on the left, rather than the right.\n                browser.bScrollbarLeft = Math.round(inner.offset().left) !== 1;\n\n                // IE8- don't provide height and width for getBoundingClientRect\n                browser.bBounding = n[0].getBoundingClientRect().width ? true : false;\n\n                n.remove();\n            }\n\n            $.extend(settings.oBrowser, DataTable.__browser);\n            settings.oScroll.iBarWidth = DataTable.__browser.barWidth;\n        }\n\n\n        /**\n         * Array.prototype reduce[Right] method, used for browsers which don't support\n         * JS 1.6. Done this way to reduce code size, since we iterate either way\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnReduce(that, fn, init, start, end, inc) {\n            var\n                i = start,\n                value,\n                isSet = false;\n\n            if (init !== undefined) {\n                value = init;\n                isSet = true;\n            }\n\n            while (i !== end) {\n                if (!that.hasOwnProperty(i)) {\n                    continue;\n                }\n\n                value = isSet ?\n                    fn(value, that[i], i, that) :\n                    that[i];\n\n                isSet = true;\n                i += inc;\n            }\n\n            return value;\n        }\n\n        /**\n         * Add a column to the list used for the table with default values\n         *  @param {object} oSettings dataTables settings object\n         *  @param {node} nTh The th element for this column\n         *  @memberof DataTable#oApi\n         */\n        function _fnAddColumn(oSettings, nTh) {\n            // Add column to aoColumns array\n            var oDefaults = DataTable.defaults.column;\n            var iCol = oSettings.aoColumns.length;\n            var oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {\n                \"nTh\": nTh ? nTh : document.createElement('th'),\n                \"sTitle\": oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : '',\n                \"aDataSort\": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],\n                \"mData\": oDefaults.mData ? oDefaults.mData : iCol,\n                idx: iCol\n            });\n            oSettings.aoColumns.push(oCol);\n\n            // Add search object for column specific search. Note that the `searchCols[ iCol ]`\n            // passed into extend can be undefined. This allows the user to give a default\n            // with only some of the parameters defined, and also not give a default\n            var searchCols = oSettings.aoPreSearchCols;\n            searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]);\n\n            // Use the default column options function to initialise classes etc\n            _fnColumnOptions(oSettings, iCol, $(nTh).data());\n        }\n\n\n        /**\n         * Apply options for a column\n         *  @param {object} oSettings dataTables settings object\n         *  @param {int} iCol column index to consider\n         *  @param {object} oOptions object with sType, bVisible and bSearchable etc\n         *  @memberof DataTable#oApi\n         */\n        function _fnColumnOptions(oSettings, iCol, oOptions) {\n            var oCol = oSettings.aoColumns[iCol];\n            var oClasses = oSettings.oClasses;\n            var th = $(oCol.nTh);\n\n            // Try to get width information from the DOM. We can't get it from CSS\n            // as we'd need to parse the CSS stylesheet. `width` option can override\n            if (!oCol.sWidthOrig) {\n                // Width attribute\n                oCol.sWidthOrig = th.attr('width') || null;\n\n                // Style attribute\n                var t = (th.attr('style') || '').match(/width:\\s*(\\d+[pxem%]+)/);\n                if (t) {\n                    oCol.sWidthOrig = t[1];\n                }\n            }\n\n            /* User specified column options */\n            if (oOptions !== undefined && oOptions !== null) {\n                // Backwards compatibility\n                _fnCompatCols(oOptions);\n\n                // Map camel case parameters to their Hungarian counterparts\n                _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);\n\n                /* Backwards compatibility for mDataProp */\n                if (oOptions.mDataProp !== undefined && !oOptions.mData) {\n                    oOptions.mData = oOptions.mDataProp;\n                }\n\n                if (oOptions.sType) {\n                    oCol._sManualType = oOptions.sType;\n                }\n\n                // `class` is a reserved word in Javascript, so we need to provide\n                // the ability to use a valid name for the camel case input\n                if (oOptions.className && !oOptions.sClass) {\n                    oOptions.sClass = oOptions.className;\n                }\n                if (oOptions.sClass) {\n                    th.addClass(oOptions.sClass);\n                }\n\n                $.extend(oCol, oOptions);\n                _fnMap(oCol, oOptions, \"sWidth\", \"sWidthOrig\");\n\n                /* iDataSort to be applied (backwards compatibility), but aDataSort will take\n                 * priority if defined\n                 */\n                if (oOptions.iDataSort !== undefined) {\n                    oCol.aDataSort = [oOptions.iDataSort];\n                }\n                _fnMap(oCol, oOptions, \"aDataSort\");\n            }\n\n            /* Cache the data get and set functions for speed */\n            var mDataSrc = oCol.mData;\n            var mData = _fnGetObjectDataFn(mDataSrc);\n            var mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;\n\n            var attrTest = function (src) {\n                return typeof src === 'string' && src.indexOf('@') !== -1;\n            };\n            oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (\n                attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)\n            );\n            oCol._setter = null;\n\n            oCol.fnGetData = function (rowData, type, meta) {\n                var innerData = mData(rowData, type, undefined, meta);\n\n                return mRender && type ?\n                    mRender(innerData, type, rowData, meta) :\n                    innerData;\n            };\n            oCol.fnSetData = function (rowData, val, meta) {\n                return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);\n            };\n\n            // Indicate if DataTables should read DOM data as an object or array\n            // Used in _fnGetRowElements\n            if (typeof mDataSrc !== 'number') {\n                oSettings._rowReadObject = true;\n            }\n\n            /* Feature sorting overrides column specific when off */\n            if (!oSettings.oFeatures.bSort) {\n                oCol.bSortable = false;\n                th.addClass(oClasses.sSortableNone); // Have to add class here as order event isn't called\n            }\n\n            /* Check that the class assignment is correct for sorting */\n            var bAsc = $.inArray('asc', oCol.asSorting) !== -1;\n            var bDesc = $.inArray('desc', oCol.asSorting) !== -1;\n            if (!oCol.bSortable || (!bAsc && !bDesc)) {\n                oCol.sSortingClass = oClasses.sSortableNone;\n                oCol.sSortingClassJUI = \"\";\n            }\n            else if (bAsc && !bDesc) {\n                oCol.sSortingClass = oClasses.sSortableAsc;\n                oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed;\n            }\n            else if (!bAsc && bDesc) {\n                oCol.sSortingClass = oClasses.sSortableDesc;\n                oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed;\n            }\n            else {\n                oCol.sSortingClass = oClasses.sSortable;\n                oCol.sSortingClassJUI = oClasses.sSortJUI;\n            }\n        }\n\n\n        /**\n         * Adjust the table column widths for new data. Note: you would probably want to\n         * do a redraw after calling this function!\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnAdjustColumnSizing(settings) {\n            /* Not interested in doing column width calculation if auto-width is disabled */\n            if (settings.oFeatures.bAutoWidth !== false) {\n                var columns = settings.aoColumns;\n\n                _fnCalculateColumnWidths(settings);\n                for (var i = 0, iLen = columns.length; i < iLen; i++) {\n                    columns[i].nTh.style.width = columns[i].sWidth;\n                }\n            }\n\n            var scroll = settings.oScroll;\n            if (scroll.sY !== '' || scroll.sX !== '') {\n                _fnScrollDraw(settings);\n            }\n\n            _fnCallbackFire(settings, null, 'column-sizing', [settings]);\n        }\n\n\n        /**\n         * Covert the index of a visible column to the index in the data array (take account\n         * of hidden columns)\n         *  @param {object} oSettings dataTables settings object\n         *  @param {int} iMatch Visible column index to lookup\n         *  @returns {int} i the data index\n         *  @memberof DataTable#oApi\n         */\n        function _fnVisibleToColumnIndex(oSettings, iMatch) {\n            var aiVis = _fnGetColumns(oSettings, 'bVisible');\n\n            return typeof aiVis[iMatch] === 'number' ?\n                aiVis[iMatch] :\n                null;\n        }\n\n\n        /**\n         * Covert the index of an index in the data array and convert it to the visible\n         *   column index (take account of hidden columns)\n         *  @param {int} iMatch Column index to lookup\n         *  @param {object} oSettings dataTables settings object\n         *  @returns {int} i the data index\n         *  @memberof DataTable#oApi\n         */\n        function _fnColumnIndexToVisible(oSettings, iMatch) {\n            var aiVis = _fnGetColumns(oSettings, 'bVisible');\n            var iPos = $.inArray(iMatch, aiVis);\n\n            return iPos !== -1 ? iPos : null;\n        }\n\n\n        /**\n         * Get the number of visible columns\n         *  @param {object} oSettings dataTables settings object\n         *  @returns {int} i the number of visible columns\n         *  @memberof DataTable#oApi\n         */\n        function _fnVisbleColumns(oSettings) {\n            var vis = 0;\n\n            // No reduce in IE8, use a loop for now\n            $.each(oSettings.aoColumns, function (i, col) {\n                if (col.bVisible && $(col.nTh).css('display') !== 'none') {\n                    vis++;\n                }\n            });\n\n            return vis;\n        }\n\n\n        /**\n         * Get an array of column indexes that match a given property\n         *  @param {object} oSettings dataTables settings object\n         *  @param {string} sParam Parameter in aoColumns to look for - typically\n         *    bVisible or bSearchable\n         *  @returns {array} Array of indexes with matched properties\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetColumns(oSettings, sParam) {\n            var a = [];\n\n            $.map(oSettings.aoColumns, function (val, i) {\n                if (val[sParam]) {\n                    a.push(i);\n                }\n            });\n\n            return a;\n        }\n\n\n        /**\n         * Calculate the 'type' of a column\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnColumnTypes(settings) {\n            var columns = settings.aoColumns;\n            var data = settings.aoData;\n            var types = DataTable.ext.type.detect;\n            var i, ien, j, jen, k, ken;\n            var col, cell, detectedType, cache;\n\n            // For each column, spin over the\n            for (i = 0, ien = columns.length; i < ien; i++) {\n                col = columns[i];\n                cache = [];\n\n                if (!col.sType && col._sManualType) {\n                    col.sType = col._sManualType;\n                }\n                else if (!col.sType) {\n                    for (j = 0, jen = types.length; j < jen; j++) {\n                        for (k = 0, ken = data.length; k < ken; k++) {\n                            // Use a cache array so we only need to get the type data\n                            // from the formatter once (when using multiple detectors)\n                            if (cache[k] === undefined) {\n                                cache[k] = _fnGetCellData(settings, k, i, 'type');\n                            }\n\n                            detectedType = types[j](cache[k], settings);\n\n                            // If null, then this type can't apply to this column, so\n                            // rather than testing all cells, break out. There is an\n                            // exception for the last type which is `html`. We need to\n                            // scan all rows since it is possible to mix string and HTML\n                            // types\n                            if (!detectedType && j !== types.length - 1) {\n                                break;\n                            }\n\n                            // Only a single match is needed for html type since it is\n                            // bottom of the pile and very similar to string\n                            if (detectedType === 'html') {\n                                break;\n                            }\n                        }\n\n                        // Type is valid for all data points in the column - use this\n                        // type\n                        if (detectedType) {\n                            col.sType = detectedType;\n                            break;\n                        }\n                    }\n\n                    // Fall back - if no type was detected, always use string\n                    if (!col.sType) {\n                        col.sType = 'string';\n                    }\n                }\n            }\n        }\n\n\n        /**\n         * Take the column definitions and static columns arrays and calculate how\n         * they relate to column indexes. The callback function will then apply the\n         * definition found for a column to a suitable configuration object.\n         *  @param {object} oSettings dataTables settings object\n         *  @param {array} aoColDefs The aoColumnDefs array that is to be applied\n         *  @param {array} aoCols The aoColumns array that defines columns individually\n         *  @param {function} fn Callback function - takes two parameters, the calculated\n         *    column index and the definition for that column.\n         *  @memberof DataTable#oApi\n         */\n        function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {\n            var i, iLen, j, jLen, k, kLen, def;\n            var columns = oSettings.aoColumns;\n\n            // Column definitions with aTargets\n            if (aoColDefs) {\n                /* Loop over the definitions array - loop in reverse so first instance has priority */\n                for (i = aoColDefs.length - 1; i >= 0; i--) {\n                    def = aoColDefs[i];\n\n                    /* Each definition can target multiple columns, as it is an array */\n                    var aTargets = def.targets !== undefined ?\n                        def.targets :\n                        def.aTargets;\n\n                    if (!Array.isArray(aTargets)) {\n                        aTargets = [aTargets];\n                    }\n\n                    for (j = 0, jLen = aTargets.length; j < jLen; j++) {\n                        if (typeof aTargets[j] === 'number' && aTargets[j] >= 0) {\n                            /* Add columns that we don't yet know about */\n                            while (columns.length <= aTargets[j]) {\n                                _fnAddColumn(oSettings);\n                            }\n\n                            /* Integer, basic index */\n                            fn(aTargets[j], def);\n                        }\n                        else if (typeof aTargets[j] === 'number' && aTargets[j] < 0) {\n                            /* Negative integer, right to left column counting */\n                            fn(columns.length + aTargets[j], def);\n                        }\n                        else if (typeof aTargets[j] === 'string') {\n                            /* Class name matching on TH element */\n                            for (k = 0, kLen = columns.length; k < kLen; k++) {\n                                if (aTargets[j] == \"_all\" ||\n                                    $(columns[k].nTh).hasClass(aTargets[j])) {\n                                    fn(k, def);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Statically defined columns array\n            if (aoCols) {\n                for (i = 0, iLen = aoCols.length; i < iLen; i++) {\n                    fn(i, aoCols[i]);\n                }\n            }\n        }\n\n        /**\n         * Add a data array to the table, creating DOM node etc. This is the parallel to\n         * _fnGatherData, but for adding rows from a Javascript source, rather than a\n         * DOM source.\n         *  @param {object} oSettings dataTables settings object\n         *  @param {array} aData data array to be added\n         *  @param {node} [nTr] TR element to add to the table - optional. If not given,\n         *    DataTables will create a row automatically\n         *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n         *    if nTr is.\n         *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed\n         *  @memberof DataTable#oApi\n         */\n        function _fnAddData(oSettings, aDataIn, nTr, anTds) {\n            /* Create the object for storing information about this new row */\n            var iRow = oSettings.aoData.length;\n            var oData = $.extend(true, {}, DataTable.models.oRow, {\n                src: nTr ? 'dom' : 'data',\n                idx: iRow\n            });\n\n            oData._aData = aDataIn;\n            oSettings.aoData.push(oData);\n\n            /* Create the cells */\n            var nTd, sThisType;\n            var columns = oSettings.aoColumns;\n\n            // Invalidate the column types as the new data needs to be revalidated\n            for (var i = 0, iLen = columns.length; i < iLen; i++) {\n                columns[i].sType = null;\n            }\n\n            /* Add to the display array */\n            oSettings.aiDisplayMaster.push(iRow);\n\n            var id = oSettings.rowIdFn(aDataIn);\n            if (id !== undefined) {\n                oSettings.aIds[id] = oData;\n            }\n\n            /* Create the DOM information, or register it if already present */\n            if (nTr || !oSettings.oFeatures.bDeferRender) {\n                _fnCreateTr(oSettings, iRow, nTr, anTds);\n            }\n\n            return iRow;\n        }\n\n\n        /**\n         * Add one or more TR elements to the table. Generally we'd expect to\n         * use this for reading data from a DOM sourced table, but it could be\n         * used for an TR element. Note that if a TR is given, it is used (i.e.\n         * it is not cloned).\n         *  @param {object} settings dataTables settings object\n         *  @param {array|node|jQuery} trs The TR element(s) to add to the table\n         *  @returns {array} Array of indexes for the added rows\n         *  @memberof DataTable#oApi\n         */\n        function _fnAddTr(settings, trs) {\n            var row;\n\n            // Allow an individual node to be passed in\n            if (!(trs instanceof $)) {\n                trs = $(trs);\n            }\n\n            return trs.map(function (i, el) {\n                row = _fnGetRowElements(settings, el);\n                return _fnAddData(settings, row.data, el, row.cells);\n            });\n        }\n\n\n        /**\n         * Take a TR element and convert it to an index in aoData\n         *  @param {object} oSettings dataTables settings object\n         *  @param {node} n the TR element to find\n         *  @returns {int} index if the node is found, null if not\n         *  @memberof DataTable#oApi\n         */\n        function _fnNodeToDataIndex(oSettings, n) {\n            return (n._DT_RowIndex !== undefined) ? n._DT_RowIndex : null;\n        }\n\n\n        /**\n         * Take a TD element and convert it into a column data index (not the visible index)\n         *  @param {object} oSettings dataTables settings object\n         *  @param {int} iRow The row number the TD/TH can be found in\n         *  @param {node} n The TD/TH element to find\n         *  @returns {int} index if the node is found, -1 if not\n         *  @memberof DataTable#oApi\n         */\n        function _fnNodeToColumnIndex(oSettings, iRow, n) {\n            return $.inArray(n, oSettings.aoData[iRow].anCells);\n        }\n\n\n        /**\n         * Get the data for a given cell from the internal cache, taking into account data mapping\n         *  @param {object} settings dataTables settings object\n         *  @param {int} rowIdx aoData row id\n         *  @param {int} colIdx Column index\n         *  @param {string} type data get type ('display', 'type' 'filter' 'sort')\n         *  @returns {*} Cell data\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetCellData(settings, rowIdx, colIdx, type) {\n            var draw = settings.iDraw;\n            var col = settings.aoColumns[colIdx];\n            var rowData = settings.aoData[rowIdx]._aData;\n            var defaultContent = col.sDefaultContent;\n            var cellData = col.fnGetData(rowData, type, {\n                settings: settings,\n                row: rowIdx,\n                col: colIdx\n            });\n\n            if (cellData === undefined) {\n                if (settings.iDrawError != draw && defaultContent === null) {\n                    _fnLog(settings, 0, \"Requested unknown parameter \" +\n                        (typeof col.mData == 'function' ? '{function}' : \"'\" + col.mData + \"'\") +\n                        \" for row \" + rowIdx + \", column \" + colIdx, 4);\n                    settings.iDrawError = draw;\n                }\n                return defaultContent;\n            }\n\n            // When the data source is null and a specific data type is requested (i.e.\n            // not the original data), we can use default column data\n            if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== undefined) {\n                cellData = defaultContent;\n            }\n            else if (typeof cellData === 'function') {\n                // If the data source is a function, then we run it and use the return,\n                // executing in the scope of the data object (for instances)\n                return cellData.call(rowData);\n            }\n\n            if (cellData === null && type == 'display') {\n                return '';\n            }\n            return cellData;\n        }\n\n\n        /**\n         * Set the value for a specific cell, into the internal data cache\n         *  @param {object} settings dataTables settings object\n         *  @param {int} rowIdx aoData row id\n         *  @param {int} colIdx Column index\n         *  @param {*} val Value to set\n         *  @memberof DataTable#oApi\n         */\n        function _fnSetCellData(settings, rowIdx, colIdx, val) {\n            var col = settings.aoColumns[colIdx];\n            var rowData = settings.aoData[rowIdx]._aData;\n\n            col.fnSetData(rowData, val, {\n                settings: settings,\n                row: rowIdx,\n                col: colIdx\n            });\n        }\n\n\n        // Private variable that is used to match action syntax in the data property object\n        var __reArray = /\\[.*?\\]$/;\n        var __reFn = /\\(\\)$/;\n\n        /**\n         * Split string on periods, taking into account escaped periods\n         * @param  {string} str String to split\n         * @return {array} Split string\n         */\n        function _fnSplitObjNotation(str) {\n            return $.map(str.match(/(\\\\.|[^\\.])+/g) || [''], function (s) {\n                return s.replace(/\\\\\\./g, '.');\n            });\n        }\n\n\n        /**\n         * Return a function that can be used to get data from a source object, taking\n         * into account the ability to use nested objects as a source\n         *  @param {string|int|function} mSource The data source for the object\n         *  @returns {function} Data get function\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetObjectDataFn(mSource) {\n            if ($.isPlainObject(mSource)) {\n                /* Build an object of get functions, and wrap them in a single call */\n                var o = {};\n                $.each(mSource, function (key, val) {\n                    if (val) {\n                        o[key] = _fnGetObjectDataFn(val);\n                    }\n                });\n\n                return function (data, type, row, meta) {\n                    var t = o[type] || o._;\n                    return t !== undefined ?\n                        t(data, type, row, meta) :\n                        data;\n                };\n            }\n            else if (mSource === null) {\n                /* Give an empty string for rendering / sorting etc */\n                return function (data) { // type, row and meta also passed, but not used\n                    return data;\n                };\n            }\n            else if (typeof mSource === 'function') {\n                return function (data, type, row, meta) {\n                    return mSource(data, type, row, meta);\n                };\n            }\n            else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n                mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {\n                /* If there is a . in the source string then the data source is in a\n                 * nested object so we loop over the data for each level to get the next\n                 * level down. On each loop we test for undefined, and if found immediately\n                 * return. This allows entire objects to be missing and sDefaultContent to\n                 * be used if defined, rather than throwing an error\n                 */\n                var fetchData = function (data, type, src) {\n                    var arrayNotation, funcNotation, out, innerSrc;\n\n                    if (src !== \"\") {\n                        var a = _fnSplitObjNotation(src);\n\n                        for (var i = 0, iLen = a.length; i < iLen; i++) {\n                            // Check if we are dealing with special notation\n                            arrayNotation = a[i].match(__reArray);\n                            funcNotation = a[i].match(__reFn);\n\n                            if (arrayNotation) {\n                                // Array notation\n                                a[i] = a[i].replace(__reArray, '');\n\n                                // Condition allows simply [] to be passed in\n                                if (a[i] !== \"\") {\n                                    data = data[a[i]];\n                                }\n                                out = [];\n\n                                // Get the remainder of the nested object to get\n                                a.splice(0, i + 1);\n                                innerSrc = a.join('.');\n\n                                // Traverse each entry in the array getting the properties requested\n                                if (Array.isArray(data)) {\n                                    for (var j = 0, jLen = data.length; j < jLen; j++) {\n                                        out.push(fetchData(data[j], type, innerSrc));\n                                    }\n                                }\n\n                                // If a string is given in between the array notation indicators, that\n                                // is used to join the strings together, otherwise an array is returned\n                                var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);\n                                data = (join === \"\") ? out : out.join(join);\n\n                                // The inner call to fetchData has already traversed through the remainder\n                                // of the source requested, so we exit from the loop\n                                break;\n                            }\n                            else if (funcNotation) {\n                                // Function call\n                                a[i] = a[i].replace(__reFn, '');\n                                data = data[a[i]]();\n                                continue;\n                            }\n\n                            if (data === null || data[a[i]] === undefined) {\n                                return undefined;\n                            }\n                            data = data[a[i]];\n                        }\n                    }\n\n                    return data;\n                };\n\n                return function (data, type) { // row and meta also passed, but not used\n                    return fetchData(data, type, mSource);\n                };\n            }\n            else {\n                /* Array or flat object mapping */\n                return function (data, type) { // row and meta also passed, but not used\n                    return data[mSource];\n                };\n            }\n        }\n\n\n        /**\n         * Return a function that can be used to set data from a source object, taking\n         * into account the ability to use nested objects as a source\n         *  @param {string|int|function} mSource The data source for the object\n         *  @returns {function} Data set function\n         *  @memberof DataTable#oApi\n         */\n        function _fnSetObjectDataFn(mSource) {\n            if ($.isPlainObject(mSource)) {\n                /* Unlike get, only the underscore (global) option is used for for\n                 * setting data since we don't know the type here. This is why an object\n                 * option is not documented for `mData` (which is read/write), but it is\n                 * for `mRender` which is read only.\n                 */\n                return _fnSetObjectDataFn(mSource._);\n            }\n            else if (mSource === null) {\n                /* Nothing to do when the data source is null */\n                return function () { };\n            }\n            else if (typeof mSource === 'function') {\n                return function (data, val, meta) {\n                    mSource(data, 'set', val, meta);\n                };\n            }\n            else if (typeof mSource === 'string' && (mSource.indexOf('.') !== -1 ||\n                mSource.indexOf('[') !== -1 || mSource.indexOf('(') !== -1)) {\n                /* Like the get, we need to get data from a nested object */\n                var setData = function (data, val, src) {\n                    var a = _fnSplitObjNotation(src), b;\n                    var aLast = a[a.length - 1];\n                    var arrayNotation, funcNotation, o, innerSrc;\n\n                    for (var i = 0, iLen = a.length - 1; i < iLen; i++) {\n                        // Protect against prototype pollution\n                        if (a[i] === '__proto__' || a[i] === 'constructor') {\n                            throw new Error('Cannot set prototype values');\n                        }\n\n                        // Check if we are dealing with an array notation request\n                        arrayNotation = a[i].match(__reArray);\n                        funcNotation = a[i].match(__reFn);\n\n                        if (arrayNotation) {\n                            a[i] = a[i].replace(__reArray, '');\n                            data[a[i]] = [];\n\n                            // Get the remainder of the nested object to set so we can recurse\n                            b = a.slice();\n                            b.splice(0, i + 1);\n                            innerSrc = b.join('.');\n\n                            // Traverse each entry in the array setting the properties requested\n                            if (Array.isArray(val)) {\n                                for (var j = 0, jLen = val.length; j < jLen; j++) {\n                                    o = {};\n                                    setData(o, val[j], innerSrc);\n                                    data[a[i]].push(o);\n                                }\n                            }\n                            else {\n                                // We've been asked to save data to an array, but it\n                                // isn't array data to be saved. Best that can be done\n                                // is to just save the value.\n                                data[a[i]] = val;\n                            }\n\n                            // The inner call to setData has already traversed through the remainder\n                            // of the source and has set the data, thus we can exit here\n                            return;\n                        }\n                        else if (funcNotation) {\n                            // Function call\n                            a[i] = a[i].replace(__reFn, '');\n                            data = data[a[i]](val);\n                        }\n\n                        // If the nested object doesn't currently exist - since we are\n                        // trying to set the value - create it\n                        if (data[a[i]] === null || data[a[i]] === undefined) {\n                            data[a[i]] = {};\n                        }\n                        data = data[a[i]];\n                    }\n\n                    // Last item in the input - i.e, the actual set\n                    if (aLast.match(__reFn)) {\n                        // Function call\n                        data = data[aLast.replace(__reFn, '')](val);\n                    }\n                    else {\n                        // If array notation is used, we just want to strip it and use the property name\n                        // and assign the value. If it isn't used, then we get the result we want anyway\n                        data[aLast.replace(__reArray, '')] = val;\n                    }\n                };\n\n                return function (data, val) { // meta is also passed in, but not used\n                    return setData(data, val, mSource);\n                };\n            }\n            else {\n                /* Array or flat object mapping */\n                return function (data, val) { // meta is also passed in, but not used\n                    data[mSource] = val;\n                };\n            }\n        }\n\n\n        /**\n         * Return an array with the full table data\n         *  @param {object} oSettings dataTables settings object\n         *  @returns array {array} aData Master data array\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetDataMaster(settings) {\n            return _pluck(settings.aoData, '_aData');\n        }\n\n\n        /**\n         * Nuke the table\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnClearTable(settings) {\n            settings.aoData.length = 0;\n            settings.aiDisplayMaster.length = 0;\n            settings.aiDisplay.length = 0;\n            settings.aIds = {};\n        }\n\n\n        /**\n        * Take an array of integers (index array) and remove a target integer (value - not\n        * the key!)\n        *  @param {array} a Index array to target\n        *  @param {int} iTarget value to find\n        *  @memberof DataTable#oApi\n        */\n        function _fnDeleteIndex(a, iTarget, splice) {\n            var iTargetIndex = -1;\n\n            for (var i = 0, iLen = a.length; i < iLen; i++) {\n                if (a[i] == iTarget) {\n                    iTargetIndex = i;\n                }\n                else if (a[i] > iTarget) {\n                    a[i]--;\n                }\n            }\n\n            if (iTargetIndex != -1 && splice === undefined) {\n                a.splice(iTargetIndex, 1);\n            }\n        }\n\n\n        /**\n         * Mark cached data as invalid such that a re-read of the data will occur when\n         * the cached data is next requested. Also update from the data source object.\n         *\n         * @param {object} settings DataTables settings object\n         * @param {int}    rowIdx   Row index to invalidate\n         * @param {string} [src]    Source to invalidate from: undefined, 'auto', 'dom'\n         *     or 'data'\n         * @param {int}    [colIdx] Column index to invalidate. If undefined the whole\n         *     row will be invalidated\n         * @memberof DataTable#oApi\n         *\n         * @todo For the modularisation of v1.11 this will need to become a callback, so\n         *   the sort and filter methods can subscribe to it. That will required\n         *   initialisation options for sorting, which is why it is not already baked in\n         */\n        function _fnInvalidate(settings, rowIdx, src, colIdx) {\n            var row = settings.aoData[rowIdx];\n            var i, ien;\n            var cellWrite = function (cell, col) {\n                // This is very frustrating, but in IE if you just write directly\n                // to innerHTML, and elements that are overwritten are GC'ed,\n                // even if there is a reference to them elsewhere\n                while (cell.childNodes.length) {\n                    cell.removeChild(cell.firstChild);\n                }\n\n                cell.innerHTML = _fnGetCellData(settings, rowIdx, col, 'display');\n            };\n\n            // Are we reading last data from DOM or the data object?\n            if (src === 'dom' || ((!src || src === 'auto') && row.src === 'dom')) {\n                // Read the data from the DOM\n                row._aData = _fnGetRowElements(\n                    settings, row, colIdx, colIdx === undefined ? undefined : row._aData\n                )\n                    .data;\n            }\n            else {\n                // Reading from data object, update the DOM\n                var cells = row.anCells;\n\n                if (cells) {\n                    if (colIdx !== undefined) {\n                        cellWrite(cells[colIdx], colIdx);\n                    }\n                    else {\n                        for (i = 0, ien = cells.length; i < ien; i++) {\n                            cellWrite(cells[i], i);\n                        }\n                    }\n                }\n            }\n\n            // For both row and cell invalidation, the cached data for sorting and\n            // filtering is nulled out\n            row._aSortData = null;\n            row._aFilterData = null;\n\n            // Invalidate the type for a specific column (if given) or all columns since\n            // the data might have changed\n            var cols = settings.aoColumns;\n            if (colIdx !== undefined) {\n                cols[colIdx].sType = null;\n            }\n            else {\n                for (i = 0, ien = cols.length; i < ien; i++) {\n                    cols[i].sType = null;\n                }\n\n                // Update DataTables special `DT_*` attributes for the row\n                _fnRowAttributes(settings, row);\n            }\n        }\n\n\n        /**\n         * Build a data source object from an HTML row, reading the contents of the\n         * cells that are in the row.\n         *\n         * @param {object} settings DataTables settings object\n         * @param {node|object} TR element from which to read data or existing row\n         *   object from which to re-read the data from the cells\n         * @param {int} [colIdx] Optional column index\n         * @param {array|object} [d] Data source object. If `colIdx` is given then this\n         *   parameter should also be given and will be used to write the data into.\n         *   Only the column in question will be written\n         * @returns {object} Object with two parameters: `data` the data read, in\n         *   document order, and `cells` and array of nodes (they can be useful to the\n         *   caller, so rather than needing a second traversal to get them, just return\n         *   them from here).\n         * @memberof DataTable#oApi\n         */\n        function _fnGetRowElements(settings, row, colIdx, d) {\n            var\n                tds = [],\n                td = row.firstChild,\n                name, col, o, i = 0, contents,\n                columns = settings.aoColumns,\n                objectRead = settings._rowReadObject;\n\n            // Allow the data object to be passed in, or construct\n            d = d !== undefined ?\n                d :\n                objectRead ?\n                    {} :\n                    [];\n\n            var attr = function (str, td) {\n                if (typeof str === 'string') {\n                    var idx = str.indexOf('@');\n\n                    if (idx !== -1) {\n                        var attr = str.substring(idx + 1);\n                        var setter = _fnSetObjectDataFn(str);\n                        setter(d, td.getAttribute(attr));\n                    }\n                }\n            };\n\n            // Read data from a cell and store into the data object\n            var cellProcess = function (cell) {\n                if (colIdx === undefined || colIdx === i) {\n                    col = columns[i];\n                    contents = (cell.innerHTML).trim();\n\n                    if (col && col._bAttrSrc) {\n                        var setter = _fnSetObjectDataFn(col.mData._);\n                        setter(d, contents);\n\n                        attr(col.mData.sort, cell);\n                        attr(col.mData.type, cell);\n                        attr(col.mData.filter, cell);\n                    }\n                    else {\n                        // Depending on the `data` option for the columns the data can\n                        // be read to either an object or an array.\n                        if (objectRead) {\n                            if (!col._setter) {\n                                // Cache the setter function\n                                col._setter = _fnSetObjectDataFn(col.mData);\n                            }\n                            col._setter(d, contents);\n                        }\n                        else {\n                            d[i] = contents;\n                        }\n                    }\n                }\n\n                i++;\n            };\n\n            if (td) {\n                // `tr` element was passed in\n                while (td) {\n                    name = td.nodeName.toUpperCase();\n\n                    if (name == \"TD\" || name == \"TH\") {\n                        cellProcess(td);\n                        tds.push(td);\n                    }\n\n                    td = td.nextSibling;\n                }\n            }\n            else {\n                // Existing row object passed in\n                tds = row.anCells;\n\n                for (var j = 0, jen = tds.length; j < jen; j++) {\n                    cellProcess(tds[j]);\n                }\n            }\n\n            // Read the ID from the DOM if present\n            var rowNode = row.firstChild ? row : row.nTr;\n\n            if (rowNode) {\n                var id = rowNode.getAttribute('id');\n\n                if (id) {\n                    _fnSetObjectDataFn(settings.rowId)(d, id);\n                }\n            }\n\n            return {\n                data: d,\n                cells: tds\n            };\n        }\n        /**\n         * Create a new TR element (and it's TD children) for a row\n         *  @param {object} oSettings dataTables settings object\n         *  @param {int} iRow Row to consider\n         *  @param {node} [nTrIn] TR element to add to the table - optional. If not given,\n         *    DataTables will create a row automatically\n         *  @param {array} [anTds] Array of TD|TH elements for the row - must be given\n         *    if nTr is.\n         *  @memberof DataTable#oApi\n         */\n        function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {\n            var\n                row = oSettings.aoData[iRow],\n                rowData = row._aData,\n                cells = [],\n                nTr, nTd, oCol,\n                i, iLen, create;\n\n            if (row.nTr === null) {\n                nTr = nTrIn || document.createElement('tr');\n\n                row.nTr = nTr;\n                row.anCells = cells;\n\n                /* Use a private property on the node to allow reserve mapping from the node\n                 * to the aoData array for fast look up\n                 */\n                nTr._DT_RowIndex = iRow;\n\n                /* Special parameters can be given by the data source to be used on the row */\n                _fnRowAttributes(oSettings, row);\n\n                /* Process each column */\n                for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {\n                    oCol = oSettings.aoColumns[i];\n                    create = nTrIn ? false : true;\n\n                    nTd = create ? document.createElement(oCol.sCellType) : anTds[i];\n                    nTd._DT_CellIndex = {\n                        row: iRow,\n                        column: i\n                    };\n\n                    cells.push(nTd);\n\n                    // Need to create the HTML if new, or if a rendering function is defined\n                    if (create || ((oCol.mRender || oCol.mData !== i) &&\n                        (!$.isPlainObject(oCol.mData) || oCol.mData._ !== i + '.display')\n                    )) {\n                        nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, 'display');\n                    }\n\n                    /* Add user defined class */\n                    if (oCol.sClass) {\n                        nTd.className += ' ' + oCol.sClass;\n                    }\n\n                    // Visibility - add or remove as required\n                    if (oCol.bVisible && !nTrIn) {\n                        nTr.appendChild(nTd);\n                    }\n                    else if (!oCol.bVisible && nTrIn) {\n                        nTd.parentNode.removeChild(nTd);\n                    }\n\n                    if (oCol.fnCreatedCell) {\n                        oCol.fnCreatedCell.call(oSettings.oInstance,\n                            nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i\n                        );\n                    }\n                }\n\n                _fnCallbackFire(oSettings, 'aoRowCreatedCallback', null, [nTr, rowData, iRow, cells]);\n            }\n        }\n\n\n        /**\n         * Add attributes to a row based on the special `DT_*` parameters in a data\n         * source object.\n         *  @param {object} settings DataTables settings object\n         *  @param {object} DataTables row object for the row to be modified\n         *  @memberof DataTable#oApi\n         */\n        function _fnRowAttributes(settings, row) {\n            var tr = row.nTr;\n            var data = row._aData;\n\n            if (tr) {\n                var id = settings.rowIdFn(data);\n\n                if (id) {\n                    tr.id = id;\n                }\n\n                if (data.DT_RowClass) {\n                    // Remove any classes added by DT_RowClass before\n                    var a = data.DT_RowClass.split(' ');\n                    row.__rowc = row.__rowc ?\n                        _unique(row.__rowc.concat(a)) :\n                        a;\n\n                    $(tr)\n                        .removeClass(row.__rowc.join(' '))\n                        .addClass(data.DT_RowClass);\n                }\n\n                if (data.DT_RowAttr) {\n                    $(tr).attr(data.DT_RowAttr);\n                }\n\n                if (data.DT_RowData) {\n                    $(tr).data(data.DT_RowData);\n                }\n            }\n        }\n\n\n        /**\n         * Create the HTML header for the table\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnBuildHead(oSettings) {\n            var i, ien, cell, row, column;\n            var thead = oSettings.nTHead;\n            var tfoot = oSettings.nTFoot;\n            var createHeader = $('th, td', thead).length === 0;\n            var classes = oSettings.oClasses;\n            var columns = oSettings.aoColumns;\n\n            if (createHeader) {\n                row = $('<tr/>').appendTo(thead);\n            }\n\n            for (i = 0, ien = columns.length; i < ien; i++) {\n                column = columns[i];\n                cell = $(column.nTh).addClass(column.sClass);\n\n                if (createHeader) {\n                    cell.appendTo(row);\n                }\n\n                // 1.11 move into sorting\n                if (oSettings.oFeatures.bSort) {\n                    cell.addClass(column.sSortingClass);\n\n                    if (column.bSortable !== false) {\n                        cell\n                            .attr('tabindex', oSettings.iTabIndex)\n                            .attr('aria-controls', oSettings.sTableId);\n\n                        _fnSortAttachListener(oSettings, column.nTh, i);\n                    }\n                }\n\n                if (column.sTitle != cell[0].innerHTML) {\n                    cell.html(column.sTitle);\n                }\n\n                _fnRenderer(oSettings, 'header')(\n                    oSettings, cell, column, classes\n                );\n            }\n\n            if (createHeader) {\n                _fnDetectHeader(oSettings.aoHeader, thead);\n            }\n\n            /* ARIA role for the rows */\n            $(thead).children('tr').attr('role', 'row');\n\n            /* Deal with the footer - add classes if required */\n            $(thead).children('tr').children('th, td').addClass(classes.sHeaderTH);\n            $(tfoot).children('tr').children('th, td').addClass(classes.sFooterTH);\n\n            // Cache the footer cells. Note that we only take the cells from the first\n            // row in the footer. If there is more than one row the user wants to\n            // interact with, they need to use the table().foot() method. Note also this\n            // allows cells to be used for multiple columns using colspan\n            if (tfoot !== null) {\n                var cells = oSettings.aoFooter[0];\n\n                for (i = 0, ien = cells.length; i < ien; i++) {\n                    column = columns[i];\n                    column.nTf = cells[i].cell;\n\n                    if (column.sClass) {\n                        $(column.nTf).addClass(column.sClass);\n                    }\n                }\n            }\n        }\n\n\n        /**\n         * Draw the header (or footer) element based on the column visibility states. The\n         * methodology here is to use the layout array from _fnDetectHeader, modified for\n         * the instantaneous column visibility, to construct the new layout. The grid is\n         * traversed over cell at a time in a rows x columns grid fashion, although each\n         * cell insert can cover multiple elements in the grid - which is tracks using the\n         * aApplied array. Cell inserts in the grid will only occur where there isn't\n         * already a cell in that position.\n         *  @param {object} oSettings dataTables settings object\n         *  @param array {objects} aoSource Layout array from _fnDetectHeader\n         *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc,\n         *  @memberof DataTable#oApi\n         */\n        function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {\n            var i, iLen, j, jLen, k, kLen, n, nLocalTr;\n            var aoLocal = [];\n            var aApplied = [];\n            var iColumns = oSettings.aoColumns.length;\n            var iRowspan, iColspan;\n\n            if (!aoSource) {\n                return;\n            }\n\n            if (bIncludeHidden === undefined) {\n                bIncludeHidden = false;\n            }\n\n            /* Make a copy of the master layout array, but without the visible columns in it */\n            for (i = 0, iLen = aoSource.length; i < iLen; i++) {\n                aoLocal[i] = aoSource[i].slice();\n                aoLocal[i].nTr = aoSource[i].nTr;\n\n                /* Remove any columns which are currently hidden */\n                for (j = iColumns - 1; j >= 0; j--) {\n                    if (!oSettings.aoColumns[j].bVisible && !bIncludeHidden) {\n                        aoLocal[i].splice(j, 1);\n                    }\n                }\n\n                /* Prep the applied array - it needs an element for each row */\n                aApplied.push([]);\n            }\n\n            for (i = 0, iLen = aoLocal.length; i < iLen; i++) {\n                nLocalTr = aoLocal[i].nTr;\n\n                /* All cells are going to be replaced, so empty out the row */\n                if (nLocalTr) {\n                    while ((n = nLocalTr.firstChild)) {\n                        nLocalTr.removeChild(n);\n                    }\n                }\n\n                for (j = 0, jLen = aoLocal[i].length; j < jLen; j++) {\n                    iRowspan = 1;\n                    iColspan = 1;\n\n                    /* Check to see if there is already a cell (row/colspan) covering our target\n                     * insert point. If there is, then there is nothing to do.\n                     */\n                    if (aApplied[i][j] === undefined) {\n                        nLocalTr.appendChild(aoLocal[i][j].cell);\n                        aApplied[i][j] = 1;\n\n                        /* Expand the cell to cover as many rows as needed */\n                        while (aoLocal[i + iRowspan] !== undefined &&\n                            aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell) {\n                            aApplied[i + iRowspan][j] = 1;\n                            iRowspan++;\n                        }\n\n                        /* Expand the cell to cover as many columns as needed */\n                        while (aoLocal[i][j + iColspan] !== undefined &&\n                            aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell) {\n                            /* Must update the applied array over the rows for the columns */\n                            for (k = 0; k < iRowspan; k++) {\n                                aApplied[i + k][j + iColspan] = 1;\n                            }\n                            iColspan++;\n                        }\n\n                        /* Do the actual expansion in the DOM */\n                        $(aoLocal[i][j].cell)\n                            .attr('rowspan', iRowspan)\n                            .attr('colspan', iColspan);\n                    }\n                }\n            }\n        }\n\n\n        /**\n         * Insert the required TR nodes into the table for display\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnDraw(oSettings) {\n            /* Provide a pre-callback function which can be used to cancel the draw is false is returned */\n            var aPreDraw = _fnCallbackFire(oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings]);\n            if ($.inArray(false, aPreDraw) !== -1) {\n                _fnProcessingDisplay(oSettings, false);\n                return;\n            }\n\n            var i, iLen, n;\n            var anRows = [];\n            var iRowCount = 0;\n            var asStripeClasses = oSettings.asStripeClasses;\n            var iStripes = asStripeClasses.length;\n            var iOpenRows = oSettings.aoOpenRows.length;\n            var oLang = oSettings.oLanguage;\n            var iInitDisplayStart = oSettings.iInitDisplayStart;\n            var bServerSide = _fnDataSource(oSettings) == 'ssp';\n            var aiDisplay = oSettings.aiDisplay;\n\n            oSettings.bDrawing = true;\n\n            /* Check and see if we have an initial draw position from state saving */\n            if (iInitDisplayStart !== undefined && iInitDisplayStart !== -1) {\n                oSettings._iDisplayStart = bServerSide ?\n                    iInitDisplayStart :\n                    iInitDisplayStart >= oSettings.fnRecordsDisplay() ?\n                        0 :\n                        iInitDisplayStart;\n\n                oSettings.iInitDisplayStart = -1;\n            }\n\n            var iDisplayStart = oSettings._iDisplayStart;\n            var iDisplayEnd = oSettings.fnDisplayEnd();\n\n            /* Server-side processing draw intercept */\n            if (oSettings.bDeferLoading) {\n                oSettings.bDeferLoading = false;\n                oSettings.iDraw++;\n                _fnProcessingDisplay(oSettings, false);\n            }\n            else if (!bServerSide) {\n                oSettings.iDraw++;\n            }\n            else if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) {\n                return;\n            }\n\n            if (aiDisplay.length !== 0) {\n                var iStart = bServerSide ? 0 : iDisplayStart;\n                var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;\n\n                for (var j = iStart; j < iEnd; j++) {\n                    var iDataIndex = aiDisplay[j];\n                    var aoData = oSettings.aoData[iDataIndex];\n                    if (aoData.nTr === null) {\n                        _fnCreateTr(oSettings, iDataIndex);\n                    }\n\n                    var nRow = aoData.nTr;\n\n                    /* Remove the old striping classes and then add the new one */\n                    if (iStripes !== 0) {\n                        var sStripe = asStripeClasses[iRowCount % iStripes];\n                        if (aoData._sRowStripe != sStripe) {\n                            $(nRow).removeClass(aoData._sRowStripe).addClass(sStripe);\n                            aoData._sRowStripe = sStripe;\n                        }\n                    }\n\n                    // Row callback functions - might want to manipulate the row\n                    // iRowCount and j are not currently documented. Are they at all\n                    // useful?\n                    _fnCallbackFire(oSettings, 'aoRowCallback', null,\n                        [nRow, aoData._aData, iRowCount, j, iDataIndex]);\n\n                    anRows.push(nRow);\n                    iRowCount++;\n                }\n            }\n            else {\n                /* Table is empty - create a row with an empty message in it */\n                var sZero = oLang.sZeroRecords;\n                if (oSettings.iDraw == 1 && _fnDataSource(oSettings) == 'ajax') {\n                    sZero = oLang.sLoadingRecords;\n                }\n                else if (oLang.sEmptyTable && oSettings.fnRecordsTotal() === 0) {\n                    sZero = oLang.sEmptyTable;\n                }\n\n                anRows[0] = $('<tr/>', { 'class': iStripes ? asStripeClasses[0] : '' })\n                    .append($('<td />', {\n                        'valign': 'top',\n                        'colSpan': _fnVisbleColumns(oSettings),\n                        'class': oSettings.oClasses.sRowEmpty\n                    }).html(sZero))[0];\n            }\n\n            /* Header and footer callbacks */\n            _fnCallbackFire(oSettings, 'aoHeaderCallback', 'header', [$(oSettings.nTHead).children('tr')[0],\n            _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);\n\n            _fnCallbackFire(oSettings, 'aoFooterCallback', 'footer', [$(oSettings.nTFoot).children('tr')[0],\n            _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);\n\n            var body = $(oSettings.nTBody);\n\n            body.children().detach();\n            body.append($(anRows));\n\n            /* Call all required callback functions for the end of a draw */\n            _fnCallbackFire(oSettings, 'aoDrawCallback', 'draw', [oSettings]);\n\n            /* Draw is complete, sorting and filtering must be as well */\n            oSettings.bSorted = false;\n            oSettings.bFiltered = false;\n            oSettings.bDrawing = false;\n        }\n\n\n        /**\n         * Redraw the table - taking account of the various features which are enabled\n         *  @param {object} oSettings dataTables settings object\n         *  @param {boolean} [holdPosition] Keep the current paging position. By default\n         *    the paging is reset to the first page\n         *  @memberof DataTable#oApi\n         */\n        function _fnReDraw(settings, holdPosition) {\n            var\n                features = settings.oFeatures,\n                sort = features.bSort,\n                filter = features.bFilter;\n\n            if (sort) {\n                _fnSort(settings);\n            }\n\n            if (filter) {\n                _fnFilterComplete(settings, settings.oPreviousSearch);\n            }\n            else {\n                // No filtering, so we want to just use the display master\n                settings.aiDisplay = settings.aiDisplayMaster.slice();\n            }\n\n            if (holdPosition !== true) {\n                settings._iDisplayStart = 0;\n            }\n\n            // Let any modules know about the draw hold position state (used by\n            // scrolling internally)\n            settings._drawHold = holdPosition;\n\n            _fnDraw(settings);\n\n            settings._drawHold = false;\n        }\n\n\n        /**\n         * Add the options to the page HTML for the table\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnAddOptionsHtml(oSettings) {\n            var classes = oSettings.oClasses;\n            var table = $(oSettings.nTable);\n            var holding = $('<div/>').insertBefore(table); // Holding element for speed\n            var features = oSettings.oFeatures;\n\n            // All DataTables are wrapped in a div\n            var insert = $('<div/>', {\n                id: oSettings.sTableId + '_wrapper',\n                'class': classes.sWrapper + (oSettings.nTFoot ? '' : ' ' + classes.sNoFooter)\n            });\n\n            oSettings.nHolding = holding[0];\n            oSettings.nTableWrapper = insert[0];\n            oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;\n\n            /* Loop over the user set positioning and place the elements as needed */\n            var aDom = oSettings.sDom.split('');\n            var featureNode, cOption, nNewNode, cNext, sAttr, j;\n            for (var i = 0; i < aDom.length; i++) {\n                featureNode = null;\n                cOption = aDom[i];\n\n                if (cOption == '<') {\n                    /* New container div */\n                    nNewNode = $('<div/>')[0];\n\n                    /* Check to see if we should append an id and/or a class name to the container */\n                    cNext = aDom[i + 1];\n                    if (cNext == \"'\" || cNext == '\"') {\n                        sAttr = \"\";\n                        j = 2;\n                        while (aDom[i + j] != cNext) {\n                            sAttr += aDom[i + j];\n                            j++;\n                        }\n\n                        /* Replace jQuery UI constants @todo depreciated */\n                        if (sAttr == \"H\") {\n                            sAttr = classes.sJUIHeader;\n                        }\n                        else if (sAttr == \"F\") {\n                            sAttr = classes.sJUIFooter;\n                        }\n\n                        /* The attribute can be in the format of \"#id.class\", \"#id\" or \"class\" This logic\n                         * breaks the string into parts and applies them as needed\n                         */\n                        if (sAttr.indexOf('.') != -1) {\n                            var aSplit = sAttr.split('.');\n                            nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1);\n                            nNewNode.className = aSplit[1];\n                        }\n                        else if (sAttr.charAt(0) == \"#\") {\n                            nNewNode.id = sAttr.substr(1, sAttr.length - 1);\n                        }\n                        else {\n                            nNewNode.className = sAttr;\n                        }\n\n                        i += j; /* Move along the position array */\n                    }\n\n                    insert.append(nNewNode);\n                    insert = $(nNewNode);\n                }\n                else if (cOption == '>') {\n                    /* End container div */\n                    insert = insert.parent();\n                }\n                // @todo Move options into their own plugins?\n                else if (cOption == 'l' && features.bPaginate && features.bLengthChange) {\n                    /* Length */\n                    featureNode = _fnFeatureHtmlLength(oSettings);\n                }\n                else if (cOption == 'f' && features.bFilter) {\n                    /* Filter */\n                    featureNode = _fnFeatureHtmlFilter(oSettings);\n                }\n                else if (cOption == 'r' && features.bProcessing) {\n                    /* pRocessing */\n                    featureNode = _fnFeatureHtmlProcessing(oSettings);\n                }\n                else if (cOption == 't') {\n                    /* Table */\n                    featureNode = _fnFeatureHtmlTable(oSettings);\n                }\n                else if (cOption == 'i' && features.bInfo) {\n                    /* Info */\n                    featureNode = _fnFeatureHtmlInfo(oSettings);\n                }\n                else if (cOption == 'p' && features.bPaginate) {\n                    /* Pagination */\n                    featureNode = _fnFeatureHtmlPaginate(oSettings);\n                }\n                else if (DataTable.ext.feature.length !== 0) {\n                    /* Plug-in features */\n                    var aoFeatures = DataTable.ext.feature;\n                    for (var k = 0, kLen = aoFeatures.length; k < kLen; k++) {\n                        if (cOption == aoFeatures[k].cFeature) {\n                            featureNode = aoFeatures[k].fnInit(oSettings);\n                            break;\n                        }\n                    }\n                }\n\n                /* Add to the 2D features array */\n                if (featureNode) {\n                    var aanFeatures = oSettings.aanFeatures;\n\n                    if (!aanFeatures[cOption]) {\n                        aanFeatures[cOption] = [];\n                    }\n\n                    aanFeatures[cOption].push(featureNode);\n                    insert.append(featureNode);\n                }\n            }\n\n            /* Built our DOM structure - replace the holding div with what we want */\n            holding.replaceWith(insert);\n            oSettings.nHolding = null;\n        }\n\n\n        /**\n         * Use the DOM source to create up an array of header cells. The idea here is to\n         * create a layout grid (array) of rows x columns, which contains a reference\n         * to the cell that that point in the grid (regardless of col/rowspan), such that\n         * any column / row could be removed and the new grid constructed\n         *  @param array {object} aLayout Array to store the calculated layout in\n         *  @param {node} nThead The header/footer element for the table\n         *  @memberof DataTable#oApi\n         */\n        function _fnDetectHeader(aLayout, nThead) {\n            var nTrs = $(nThead).children('tr');\n            var nTr, nCell;\n            var i, k, l, iLen, jLen, iColShifted, iColumn, iColspan, iRowspan;\n            var bUnique;\n            var fnShiftCol = function (a, i, j) {\n                var k = a[i];\n                while (k[j]) {\n                    j++;\n                }\n                return j;\n            };\n\n            aLayout.splice(0, aLayout.length);\n\n            /* We know how many rows there are in the layout - so prep it */\n            for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n                aLayout.push([]);\n            }\n\n            /* Calculate a layout array */\n            for (i = 0, iLen = nTrs.length; i < iLen; i++) {\n                nTr = nTrs[i];\n                iColumn = 0;\n\n                /* For every cell in the row... */\n                nCell = nTr.firstChild;\n                while (nCell) {\n                    if (nCell.nodeName.toUpperCase() == \"TD\" ||\n                        nCell.nodeName.toUpperCase() == \"TH\") {\n                        /* Get the col and rowspan attributes from the DOM and sanitise them */\n                        iColspan = nCell.getAttribute('colspan') * 1;\n                        iRowspan = nCell.getAttribute('rowspan') * 1;\n                        iColspan = (!iColspan || iColspan === 0 || iColspan === 1) ? 1 : iColspan;\n                        iRowspan = (!iRowspan || iRowspan === 0 || iRowspan === 1) ? 1 : iRowspan;\n\n                        /* There might be colspan cells already in this row, so shift our target\n                         * accordingly\n                         */\n                        iColShifted = fnShiftCol(aLayout, i, iColumn);\n\n                        /* Cache calculation for unique columns */\n                        bUnique = iColspan === 1 ? true : false;\n\n                        /* If there is col / rowspan, copy the information into the layout grid */\n                        for (l = 0; l < iColspan; l++) {\n                            for (k = 0; k < iRowspan; k++) {\n                                aLayout[i + k][iColShifted + l] = {\n                                    \"cell\": nCell,\n                                    \"unique\": bUnique\n                                };\n                                aLayout[i + k].nTr = nTr;\n                            }\n                        }\n                    }\n                    nCell = nCell.nextSibling;\n                }\n            }\n        }\n\n\n        /**\n         * Get an array of unique th elements, one for each column\n         *  @param {object} oSettings dataTables settings object\n         *  @param {node} nHeader automatically detect the layout from this node - optional\n         *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional\n         *  @returns array {node} aReturn list of unique th's\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetUniqueThs(oSettings, nHeader, aLayout) {\n            var aReturn = [];\n            if (!aLayout) {\n                aLayout = oSettings.aoHeader;\n                if (nHeader) {\n                    aLayout = [];\n                    _fnDetectHeader(aLayout, nHeader);\n                }\n            }\n\n            for (var i = 0, iLen = aLayout.length; i < iLen; i++) {\n                for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) {\n                    if (aLayout[i][j].unique &&\n                        (!aReturn[j] || !oSettings.bSortCellsTop)) {\n                        aReturn[j] = aLayout[i][j].cell;\n                    }\n                }\n            }\n\n            return aReturn;\n        }\n\n        /**\n         * Create an Ajax call based on the table's settings, taking into account that\n         * parameters can have multiple forms, and backwards compatibility.\n         *\n         * @param {object} oSettings dataTables settings object\n         * @param {array} data Data to send to the server, required by\n         *     DataTables - may be augmented by developer callbacks\n         * @param {function} fn Callback function to run when data is obtained\n         */\n        function _fnBuildAjax(oSettings, data, fn) {\n            // Compatibility with 1.9-, allow fnServerData and event to manipulate\n            _fnCallbackFire(oSettings, 'aoServerParams', 'serverParams', [data]);\n\n            // Convert to object based for 1.10+ if using the old array scheme which can\n            // come from server-side processing or serverParams\n            if (data && Array.isArray(data)) {\n                var tmp = {};\n                var rbracket = /(.*?)\\[\\]$/;\n\n                $.each(data, function (key, val) {\n                    var match = val.name.match(rbracket);\n\n                    if (match) {\n                        // Support for arrays\n                        var name = match[0];\n\n                        if (!tmp[name]) {\n                            tmp[name] = [];\n                        }\n                        tmp[name].push(val.value);\n                    }\n                    else {\n                        tmp[val.name] = val.value;\n                    }\n                });\n                data = tmp;\n            }\n\n            var ajaxData;\n            var ajax = oSettings.ajax;\n            var instance = oSettings.oInstance;\n            var callback = function (json) {\n                _fnCallbackFire(oSettings, null, 'xhr', [oSettings, json, oSettings.jqXHR]);\n                fn(json);\n            };\n\n            if ($.isPlainObject(ajax) && ajax.data) {\n                ajaxData = ajax.data;\n\n                var newData = typeof ajaxData === 'function' ?\n                    ajaxData(data, oSettings) :  // fn can manipulate data or return\n                    ajaxData;                      // an object object or array to merge\n\n                // If the function returned something, use that alone\n                data = typeof ajaxData === 'function' && newData ?\n                    newData :\n                    $.extend(true, data, newData);\n\n                // Remove the data property as we've resolved it already and don't want\n                // jQuery to do it again (it is restored at the end of the function)\n                delete ajax.data;\n            }\n\n            var baseAjax = {\n                \"data\": data,\n                \"success\": function (json) {\n                    var error = json.error || json.sError;\n                    if (error) {\n                        _fnLog(oSettings, 0, error);\n                    }\n\n                    oSettings.json = json;\n                    callback(json);\n                },\n                \"dataType\": \"json\",\n                \"cache\": false,\n                \"type\": oSettings.sServerMethod,\n                \"error\": function (xhr, error, thrown) {\n                    var ret = _fnCallbackFire(oSettings, null, 'xhr', [oSettings, null, oSettings.jqXHR]);\n\n                    if ($.inArray(true, ret) === -1) {\n                        if (error == \"parsererror\") {\n                            _fnLog(oSettings, 0, 'Invalid JSON response', 1);\n                        }\n                        else if (xhr.readyState === 4) {\n                            _fnLog(oSettings, 0, 'Ajax error', 7);\n                        }\n                    }\n\n                    _fnProcessingDisplay(oSettings, false);\n                }\n            };\n\n            // Store the data submitted for the API\n            oSettings.oAjaxData = data;\n\n            // Allow plug-ins and external processes to modify the data\n            _fnCallbackFire(oSettings, null, 'preXhr', [oSettings, data]);\n\n            if (oSettings.fnServerData) {\n                // DataTables 1.9- compatibility\n                oSettings.fnServerData.call(instance,\n                    oSettings.sAjaxSource,\n                    $.map(data, function (val, key) { // Need to convert back to 1.9 trad format\n                        return { name: key, value: val };\n                    }),\n                    callback,\n                    oSettings\n                );\n            }\n            else if (oSettings.sAjaxSource || typeof ajax === 'string') {\n                // DataTables 1.9- compatibility\n                oSettings.jqXHR = $.ajax($.extend(baseAjax, {\n                    url: ajax || oSettings.sAjaxSource\n                }));\n            }\n            else if (typeof ajax === 'function') {\n                // Is a function - let the caller define what needs to be done\n                oSettings.jqXHR = ajax.call(instance, data, callback, oSettings);\n            }\n            else {\n                // Object to extend the base settings\n                oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax));\n\n                // Restore for next time around\n                ajax.data = ajaxData;\n            }\n        }\n\n\n        /**\n         * Update the table using an Ajax call\n         *  @param {object} settings dataTables settings object\n         *  @returns {boolean} Block the table drawing or not\n         *  @memberof DataTable#oApi\n         */\n        function _fnAjaxUpdate(settings) {\n            if (settings.bAjaxDataGet) {\n                settings.iDraw++;\n                _fnProcessingDisplay(settings, true);\n\n                _fnBuildAjax(\n                    settings,\n                    _fnAjaxParameters(settings),\n                    function (json) {\n                        _fnAjaxUpdateDraw(settings, json);\n                    }\n                );\n\n                return false;\n            }\n            return true;\n        }\n\n\n        /**\n         * Build up the parameters in an object needed for a server-side processing\n         * request. Note that this is basically done twice, is different ways - a modern\n         * method which is used by default in DataTables 1.10 which uses objects and\n         * arrays, or the 1.9- method with is name / value pairs. 1.9 method is used if\n         * the sAjaxSource option is used in the initialisation, or the legacyAjax\n         * option is set.\n         *  @param {object} oSettings dataTables settings object\n         *  @returns {bool} block the table drawing or not\n         *  @memberof DataTable#oApi\n         */\n        function _fnAjaxParameters(settings) {\n            var\n                columns = settings.aoColumns,\n                columnCount = columns.length,\n                features = settings.oFeatures,\n                preSearch = settings.oPreviousSearch,\n                preColSearch = settings.aoPreSearchCols,\n                i, data = [], dataProp, column, columnSearch,\n                sort = _fnSortFlatten(settings),\n                displayStart = settings._iDisplayStart,\n                displayLength = features.bPaginate !== false ?\n                    settings._iDisplayLength :\n                    -1;\n\n            var param = function (name, value) {\n                data.push({ 'name': name, 'value': value });\n            };\n\n            // DataTables 1.9- compatible method\n            param('sEcho', settings.iDraw);\n            param('iColumns', columnCount);\n            param('sColumns', _pluck(columns, 'sName').join(','));\n            param('iDisplayStart', displayStart);\n            param('iDisplayLength', displayLength);\n\n            // DataTables 1.10+ method\n            var d = {\n                draw: settings.iDraw,\n                columns: [],\n                order: [],\n                start: displayStart,\n                length: displayLength,\n                search: {\n                    value: preSearch.sSearch,\n                    regex: preSearch.bRegex\n                }\n            };\n\n            for (i = 0; i < columnCount; i++) {\n                column = columns[i];\n                columnSearch = preColSearch[i];\n                dataProp = typeof column.mData == \"function\" ? 'function' : column.mData;\n\n                d.columns.push({\n                    data: dataProp,\n                    name: column.sName,\n                    searchable: column.bSearchable,\n                    orderable: column.bSortable,\n                    search: {\n                        value: columnSearch.sSearch,\n                        regex: columnSearch.bRegex\n                    }\n                });\n\n                param(\"mDataProp_\" + i, dataProp);\n\n                if (features.bFilter) {\n                    param('sSearch_' + i, columnSearch.sSearch);\n                    param('bRegex_' + i, columnSearch.bRegex);\n                    param('bSearchable_' + i, column.bSearchable);\n                }\n\n                if (features.bSort) {\n                    param('bSortable_' + i, column.bSortable);\n                }\n            }\n\n            if (features.bFilter) {\n                param('sSearch', preSearch.sSearch);\n                param('bRegex', preSearch.bRegex);\n            }\n\n            if (features.bSort) {\n                $.each(sort, function (i, val) {\n                    d.order.push({ column: val.col, dir: val.dir });\n\n                    param('iSortCol_' + i, val.col);\n                    param('sSortDir_' + i, val.dir);\n                });\n\n                param('iSortingCols', sort.length);\n            }\n\n            // If the legacy.ajax parameter is null, then we automatically decide which\n            // form to use, based on sAjaxSource\n            var legacy = DataTable.ext.legacy.ajax;\n            if (legacy === null) {\n                return settings.sAjaxSource ? data : d;\n            }\n\n            // Otherwise, if legacy has been specified then we use that to decide on the\n            // form\n            return legacy ? data : d;\n        }\n\n\n        /**\n         * Data the data from the server (nuking the old) and redraw the table\n         *  @param {object} oSettings dataTables settings object\n         *  @param {object} json json data return from the server.\n         *  @param {string} json.sEcho Tracking flag for DataTables to match requests\n         *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering\n         *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering\n         *  @param {array} json.aaData The data to display on this page\n         *  @param {string} [json.sColumns] Column ordering (sName, comma separated)\n         *  @memberof DataTable#oApi\n         */\n        function _fnAjaxUpdateDraw(settings, json) {\n            // v1.10 uses camelCase variables, while 1.9 uses Hungarian notation.\n            // Support both\n            var compat = function (old, modern) {\n                return json[old] !== undefined ? json[old] : json[modern];\n            };\n\n            var data = _fnAjaxDataSrc(settings, json);\n            var draw = compat('sEcho', 'draw');\n            var recordsTotal = compat('iTotalRecords', 'recordsTotal');\n            var recordsFiltered = compat('iTotalDisplayRecords', 'recordsFiltered');\n\n            if (draw !== undefined) {\n                // Protect against out of sequence returns\n                if (draw * 1 < settings.iDraw) {\n                    return;\n                }\n                settings.iDraw = draw * 1;\n            }\n\n            _fnClearTable(settings);\n            settings._iRecordsTotal = parseInt(recordsTotal, 10);\n            settings._iRecordsDisplay = parseInt(recordsFiltered, 10);\n\n            for (var i = 0, ien = data.length; i < ien; i++) {\n                _fnAddData(settings, data[i]);\n            }\n            settings.aiDisplay = settings.aiDisplayMaster.slice();\n\n            settings.bAjaxDataGet = false;\n            _fnDraw(settings);\n\n            if (!settings._bInitComplete) {\n                _fnInitComplete(settings, json);\n            }\n\n            settings.bAjaxDataGet = true;\n            _fnProcessingDisplay(settings, false);\n        }\n\n\n        /**\n         * Get the data from the JSON data source to use for drawing a table. Using\n         * `_fnGetObjectDataFn` allows the data to be sourced from a property of the\n         * source object, or from a processing function.\n         *  @param {object} oSettings dataTables settings object\n         *  @param  {object} json Data source object / array from the server\n         *  @return {array} Array of data to use\n         */\n        function _fnAjaxDataSrc(oSettings, json) {\n            var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ?\n                oSettings.ajax.dataSrc :\n                oSettings.sAjaxDataProp; // Compatibility with 1.9-.\n\n            // Compatibility with 1.9-. In order to read from aaData, check if the\n            // default has been changed, if not, check for aaData\n            if (dataSrc === 'data') {\n                return json.aaData || json[dataSrc];\n            }\n\n            return dataSrc !== \"\" ?\n                _fnGetObjectDataFn(dataSrc)(json) :\n                json;\n        }\n\n        /**\n         * Generate the node required for filtering text\n         *  @returns {node} Filter control element\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnFeatureHtmlFilter(settings) {\n            var classes = settings.oClasses;\n            var tableId = settings.sTableId;\n            var language = settings.oLanguage;\n            var previousSearch = settings.oPreviousSearch;\n            var features = settings.aanFeatures;\n            var input = '<input type=\"search\" class=\"' + classes.sFilterInput + '\"/>';\n\n            var str = language.sSearch;\n            str = str.match(/_INPUT_/) ?\n                str.replace('_INPUT_', input) :\n                str + input;\n\n            var filter = $('<div/>', {\n                'id': !features.f ? tableId + '_filter' : null,\n                'class': classes.sFilter\n            })\n                .append($('<label/>').append(str));\n\n            var searchFn = function () {\n                /* Update all other filter input elements for the new display */\n                var n = features.f;\n                var val = !this.value ? \"\" : this.value; // mental IE8 fix :-(\n\n                /* Now do the filter */\n                if (val != previousSearch.sSearch) {\n                    _fnFilterComplete(settings, {\n                        \"sSearch\": val,\n                        \"bRegex\": previousSearch.bRegex,\n                        \"bSmart\": previousSearch.bSmart,\n                        \"bCaseInsensitive\": previousSearch.bCaseInsensitive\n                    });\n\n                    // Need to redraw, without resorting\n                    settings._iDisplayStart = 0;\n                    _fnDraw(settings);\n                }\n            };\n\n            var searchDelay = settings.searchDelay !== null ?\n                settings.searchDelay :\n                _fnDataSource(settings) === 'ssp' ?\n                    400 :\n                    0;\n\n            var jqFilter = $('input', filter)\n                .val(previousSearch.sSearch)\n                .attr('placeholder', language.sSearchPlaceholder)\n                .on(\n                    'keyup.DT search.DT input.DT paste.DT cut.DT',\n                    searchDelay ?\n                        _fnThrottle(searchFn, searchDelay) :\n                        searchFn\n                )\n                .on('mouseup', function (e) {\n                    // Edge fix! Edge 17 does not trigger anything other than mouse events when clicking\n                    // on the clear icon (Edge bug 17584515). This is safe in other browsers as `searchFn`\n                    // checks the value to see if it has changed. In other browsers it won't have.\n                    setTimeout(function () {\n                        searchFn.call(jqFilter[0]);\n                    }, 10);\n                })\n                .on('keypress.DT', function (e) {\n                    /* Prevent form submission */\n                    if (e.keyCode == 13) {\n                        return false;\n                    }\n                })\n                .attr('aria-controls', tableId);\n\n            // Update the input elements whenever the table is filtered\n            $(settings.nTable).on('search.dt.DT', function (ev, s) {\n                if (settings === s) {\n                    // IE9 throws an 'unknown error' if document.activeElement is used\n                    // inside an iframe or frame...\n                    try {\n                        if (jqFilter[0] !== document.activeElement) {\n                            jqFilter.val(previousSearch.sSearch);\n                        }\n                    }\n                    catch (e) { }\n                }\n            });\n\n            return filter[0];\n        }\n\n\n        /**\n         * Filter the table using both the global filter and column based filtering\n         *  @param {object} oSettings dataTables settings object\n         *  @param {object} oSearch search information\n         *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)\n         *  @memberof DataTable#oApi\n         */\n        function _fnFilterComplete(oSettings, oInput, iForce) {\n            var oPrevSearch = oSettings.oPreviousSearch;\n            var aoPrevSearch = oSettings.aoPreSearchCols;\n            var fnSaveFilter = function (oFilter) {\n                /* Save the filtering values */\n                oPrevSearch.sSearch = oFilter.sSearch;\n                oPrevSearch.bRegex = oFilter.bRegex;\n                oPrevSearch.bSmart = oFilter.bSmart;\n                oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;\n            };\n            var fnRegex = function (o) {\n                // Backwards compatibility with the bEscapeRegex option\n                return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex;\n            };\n\n            // Resolve any column types that are unknown due to addition or invalidation\n            // @todo As per sort - can this be moved into an event handler?\n            _fnColumnTypes(oSettings);\n\n            /* In server-side processing all filtering is done by the server, so no point hanging around here */\n            if (_fnDataSource(oSettings) != 'ssp') {\n                /* Global filter */\n                _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive);\n                fnSaveFilter(oInput);\n\n                /* Now do the individual column filter */\n                for (var i = 0; i < aoPrevSearch.length; i++) {\n                    _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]),\n                        aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);\n                }\n\n                /* Custom filtering */\n                _fnFilterCustom(oSettings);\n            }\n            else {\n                fnSaveFilter(oInput);\n            }\n\n            /* Tell the draw function we have been filtering */\n            oSettings.bFiltered = true;\n            _fnCallbackFire(oSettings, null, 'search', [oSettings]);\n        }\n\n\n        /**\n         * Apply custom filtering functions\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnFilterCustom(settings) {\n            var filters = DataTable.ext.search;\n            var displayRows = settings.aiDisplay;\n            var row, rowIdx;\n\n            for (var i = 0, ien = filters.length; i < ien; i++) {\n                var rows = [];\n\n                // Loop over each row and see if it should be included\n                for (var j = 0, jen = displayRows.length; j < jen; j++) {\n                    rowIdx = displayRows[j];\n                    row = settings.aoData[rowIdx];\n\n                    if (filters[i](settings, row._aFilterData, rowIdx, row._aData, j)) {\n                        rows.push(rowIdx);\n                    }\n                }\n\n                // So the array reference doesn't break set the results into the\n                // existing array\n                displayRows.length = 0;\n                $.merge(displayRows, rows);\n            }\n        }\n\n\n        /**\n         * Filter the table on a per-column basis\n         *  @param {object} oSettings dataTables settings object\n         *  @param {string} sInput string to filter on\n         *  @param {int} iColumn column to filter\n         *  @param {bool} bRegex treat search string as a regular expression or not\n         *  @param {bool} bSmart use smart filtering or not\n         *  @param {bool} bCaseInsensitive Do case insenstive matching or not\n         *  @memberof DataTable#oApi\n         */\n        function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {\n            if (searchStr === '') {\n                return;\n            }\n\n            var data;\n            var out = [];\n            var display = settings.aiDisplay;\n            var rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive);\n\n            for (var i = 0; i < display.length; i++) {\n                data = settings.aoData[display[i]]._aFilterData[colIdx];\n\n                if (rpSearch.test(data)) {\n                    out.push(display[i]);\n                }\n            }\n\n            settings.aiDisplay = out;\n        }\n\n\n        /**\n         * Filter the data table based on user input and draw the table\n         *  @param {object} settings dataTables settings object\n         *  @param {string} input string to filter on\n         *  @param {int} force optional - force a research of the master array (1) or not (undefined or 0)\n         *  @param {bool} regex treat as a regular expression or not\n         *  @param {bool} smart perform smart filtering or not\n         *  @param {bool} caseInsensitive Do case insenstive matching or not\n         *  @memberof DataTable#oApi\n         */\n        function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {\n            var rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive);\n            var prevSearch = settings.oPreviousSearch.sSearch;\n            var displayMaster = settings.aiDisplayMaster;\n            var display, invalidated, i;\n            var filtered = [];\n\n            // Need to take account of custom filtering functions - always filter\n            if (DataTable.ext.search.length !== 0) {\n                force = true;\n            }\n\n            // Check if any of the rows were invalidated\n            invalidated = _fnFilterData(settings);\n\n            // If the input is blank - we just want the full data set\n            if (input.length <= 0) {\n                settings.aiDisplay = displayMaster.slice();\n            }\n            else {\n                // New search - start from the master array\n                if (invalidated ||\n                    force ||\n                    regex ||\n                    prevSearch.length > input.length ||\n                    input.indexOf(prevSearch) !== 0 ||\n                    settings.bSorted // On resort, the display master needs to be\n                    // re-filtered since indexes will have changed\n                ) {\n                    settings.aiDisplay = displayMaster.slice();\n                }\n\n                // Search the display array\n                display = settings.aiDisplay;\n\n                for (i = 0; i < display.length; i++) {\n                    if (rpSearch.test(settings.aoData[display[i]]._sFilterRow)) {\n                        filtered.push(display[i]);\n                    }\n                }\n\n                settings.aiDisplay = filtered;\n            }\n        }\n\n\n        /**\n         * Build a regular expression object suitable for searching a table\n         *  @param {string} sSearch string to search for\n         *  @param {bool} bRegex treat as a regular expression or not\n         *  @param {bool} bSmart perform smart filtering or not\n         *  @param {bool} bCaseInsensitive Do case insensitive matching or not\n         *  @returns {RegExp} constructed object\n         *  @memberof DataTable#oApi\n         */\n        function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {\n            search = regex ?\n                search :\n                _fnEscapeRegex(search);\n\n            if (smart) {\n                /* For smart filtering we want to allow the search to work regardless of\n                 * word order. We also want double quoted text to be preserved, so word\n                 * order is important - a la google. So this is what we want to\n                 * generate:\n                 *\n                 * ^(?=.*?\\bone\\b)(?=.*?\\btwo three\\b)(?=.*?\\bfour\\b).*$\n                 */\n                var a = $.map(search.match(/\"[^\"]+\"|[^ ]+/g) || [''], function (word) {\n                    if (word.charAt(0) === '\"') {\n                        var m = word.match(/^\"(.*)\"$/);\n                        word = m ? m[1] : word;\n                    }\n\n                    return word.replace('\"', '');\n                });\n\n                search = '^(?=.*?' + a.join(')(?=.*?') + ').*$';\n            }\n\n            return new RegExp(search, caseInsensitive ? 'i' : '');\n        }\n\n\n        /**\n         * Escape a string such that it can be used in a regular expression\n         *  @param {string} sVal string to escape\n         *  @returns {string} escaped string\n         *  @memberof DataTable#oApi\n         */\n        var _fnEscapeRegex = DataTable.util.escapeRegex;\n\n        var __filter_div = $('<div>')[0];\n        var __filter_div_textContent = __filter_div.textContent !== undefined;\n\n        // Update the filtering data for each row if needed (by invalidation or first run)\n        function _fnFilterData(settings) {\n            var columns = settings.aoColumns;\n            var column;\n            var i, j, ien, jen, filterData, cellData, row;\n            var fomatters = DataTable.ext.type.search;\n            var wasInvalidated = false;\n\n            for (i = 0, ien = settings.aoData.length; i < ien; i++) {\n                row = settings.aoData[i];\n\n                if (!row._aFilterData) {\n                    filterData = [];\n\n                    for (j = 0, jen = columns.length; j < jen; j++) {\n                        column = columns[j];\n\n                        if (column.bSearchable) {\n                            cellData = _fnGetCellData(settings, i, j, 'filter');\n\n                            if (fomatters[column.sType]) {\n                                cellData = fomatters[column.sType](cellData);\n                            }\n\n                            // Search in DataTables 1.10 is string based. In 1.11 this\n                            // should be altered to also allow strict type checking.\n                            if (cellData === null) {\n                                cellData = '';\n                            }\n\n                            if (typeof cellData !== 'string' && cellData.toString) {\n                                cellData = cellData.toString();\n                            }\n                        }\n                        else {\n                            cellData = '';\n                        }\n\n                        // If it looks like there is an HTML entity in the string,\n                        // attempt to decode it so sorting works as expected. Note that\n                        // we could use a single line of jQuery to do this, but the DOM\n                        // method used here is much faster http://jsperf.com/html-decode\n                        if (cellData.indexOf && cellData.indexOf('&') !== -1) {\n                            __filter_div.innerHTML = cellData;\n                            cellData = __filter_div_textContent ?\n                                __filter_div.textContent :\n                                __filter_div.innerText;\n                        }\n\n                        if (cellData.replace) {\n                            cellData = cellData.replace(/[\\r\\n\\u2028]/g, '');\n                        }\n\n                        filterData.push(cellData);\n                    }\n\n                    row._aFilterData = filterData;\n                    row._sFilterRow = filterData.join('  ');\n                    wasInvalidated = true;\n                }\n            }\n\n            return wasInvalidated;\n        }\n\n\n        /**\n         * Convert from the internal Hungarian notation to camelCase for external\n         * interaction\n         *  @param {object} obj Object to convert\n         *  @returns {object} Inverted object\n         *  @memberof DataTable#oApi\n         */\n        function _fnSearchToCamel(obj) {\n            return {\n                search: obj.sSearch,\n                smart: obj.bSmart,\n                regex: obj.bRegex,\n                caseInsensitive: obj.bCaseInsensitive\n            };\n        }\n\n\n\n        /**\n         * Convert from camelCase notation to the internal Hungarian. We could use the\n         * Hungarian convert function here, but this is cleaner\n         *  @param {object} obj Object to convert\n         *  @returns {object} Inverted object\n         *  @memberof DataTable#oApi\n         */\n        function _fnSearchToHung(obj) {\n            return {\n                sSearch: obj.search,\n                bSmart: obj.smart,\n                bRegex: obj.regex,\n                bCaseInsensitive: obj.caseInsensitive\n            };\n        }\n\n        /**\n         * Generate the node required for the info display\n         *  @param {object} oSettings dataTables settings object\n         *  @returns {node} Information element\n         *  @memberof DataTable#oApi\n         */\n        function _fnFeatureHtmlInfo(settings) {\n            var\n                tid = settings.sTableId,\n                nodes = settings.aanFeatures.i,\n                n = $('<div/>', {\n                    'class': settings.oClasses.sInfo,\n                    'id': !nodes ? tid + '_info' : null\n                });\n\n            if (!nodes) {\n                // Update display on each draw\n                settings.aoDrawCallback.push({\n                    \"fn\": _fnUpdateInfo,\n                    \"sName\": \"information\"\n                });\n\n                n\n                    .attr('role', 'status')\n                    .attr('aria-live', 'polite');\n\n                // Table is described by our info div\n                $(settings.nTable).attr('aria-describedby', tid + '_info');\n            }\n\n            return n[0];\n        }\n\n\n        /**\n         * Update the information elements in the display\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnUpdateInfo(settings) {\n            /* Show information about the table */\n            var nodes = settings.aanFeatures.i;\n            if (nodes.length === 0) {\n                return;\n            }\n\n            var\n                lang = settings.oLanguage,\n                start = settings._iDisplayStart + 1,\n                end = settings.fnDisplayEnd(),\n                max = settings.fnRecordsTotal(),\n                total = settings.fnRecordsDisplay(),\n                out = total ?\n                    lang.sInfo :\n                    lang.sInfoEmpty;\n\n            if (total !== max) {\n                /* Record set after filtering */\n                out += ' ' + lang.sInfoFiltered;\n            }\n\n            // Convert the macros\n            out += lang.sInfoPostFix;\n            out = _fnInfoMacros(settings, out);\n\n            var callback = lang.fnInfoCallback;\n            if (callback !== null) {\n                out = callback.call(settings.oInstance,\n                    settings, start, end, max, total, out\n                );\n            }\n\n            $(nodes).html(out);\n        }\n\n\n        function _fnInfoMacros(settings, str) {\n            // When infinite scrolling, we are always starting at 1. _iDisplayStart is used only\n            // internally\n            var\n                formatter = settings.fnFormatNumber,\n                start = settings._iDisplayStart + 1,\n                len = settings._iDisplayLength,\n                vis = settings.fnRecordsDisplay(),\n                all = len === -1;\n\n            return str.\n                replace(/_START_/g, formatter.call(settings, start)).\n                replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).\n                replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).\n                replace(/_TOTAL_/g, formatter.call(settings, vis)).\n                replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).\n                replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)));\n        }\n\n\n\n        /**\n         * Draw the table for the first time, adding all required features\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnInitialise(settings) {\n            var i, iLen, iAjaxStart = settings.iInitDisplayStart;\n            var columns = settings.aoColumns, column;\n            var features = settings.oFeatures;\n            var deferLoading = settings.bDeferLoading; // value modified by the draw\n\n            /* Ensure that the table data is fully initialised */\n            if (!settings.bInitialised) {\n                setTimeout(function () { _fnInitialise(settings); }, 200);\n                return;\n            }\n\n            /* Show the display HTML options */\n            _fnAddOptionsHtml(settings);\n\n            /* Build and draw the header / footer for the table */\n            _fnBuildHead(settings);\n            _fnDrawHead(settings, settings.aoHeader);\n            _fnDrawHead(settings, settings.aoFooter);\n\n            /* Okay to show that something is going on now */\n            _fnProcessingDisplay(settings, true);\n\n            /* Calculate sizes for columns */\n            if (features.bAutoWidth) {\n                _fnCalculateColumnWidths(settings);\n            }\n\n            for (i = 0, iLen = columns.length; i < iLen; i++) {\n                column = columns[i];\n\n                if (column.sWidth) {\n                    column.nTh.style.width = _fnStringToCss(column.sWidth);\n                }\n            }\n\n            _fnCallbackFire(settings, null, 'preInit', [settings]);\n\n            // If there is default sorting required - let's do it. The sort function\n            // will do the drawing for us. Otherwise we draw the table regardless of the\n            // Ajax source - this allows the table to look initialised for Ajax sourcing\n            // data (show 'loading' message possibly)\n            _fnReDraw(settings);\n\n            // Server-side processing init complete is done by _fnAjaxUpdateDraw\n            var dataSrc = _fnDataSource(settings);\n            if (dataSrc != 'ssp' || deferLoading) {\n                // if there is an ajax source load the data\n                if (dataSrc == 'ajax') {\n                    _fnBuildAjax(settings, [], function (json) {\n                        var aData = _fnAjaxDataSrc(settings, json);\n\n                        // Got the data - add it to the table\n                        for (i = 0; i < aData.length; i++) {\n                            _fnAddData(settings, aData[i]);\n                        }\n\n                        // Reset the init display for cookie saving. We've already done\n                        // a filter, and therefore cleared it before. So we need to make\n                        // it appear 'fresh'\n                        settings.iInitDisplayStart = iAjaxStart;\n\n                        _fnReDraw(settings);\n\n                        _fnProcessingDisplay(settings, false);\n                        _fnInitComplete(settings, json);\n                    }, settings);\n                }\n                else {\n                    _fnProcessingDisplay(settings, false);\n                    _fnInitComplete(settings);\n                }\n            }\n        }\n\n\n        /**\n         * Draw the table for the first time, adding all required features\n         *  @param {object} oSettings dataTables settings object\n         *  @param {object} [json] JSON from the server that completed the table, if using Ajax source\n         *    with client-side processing (optional)\n         *  @memberof DataTable#oApi\n         */\n        function _fnInitComplete(settings, json) {\n            settings._bInitComplete = true;\n\n            // When data was added after the initialisation (data or Ajax) we need to\n            // calculate the column sizing\n            if (json || settings.oInit.aaData) {\n                _fnAdjustColumnSizing(settings);\n            }\n\n            _fnCallbackFire(settings, null, 'plugin-init', [settings, json]);\n            _fnCallbackFire(settings, 'aoInitComplete', 'init', [settings, json]);\n        }\n\n\n        function _fnLengthChange(settings, val) {\n            var len = parseInt(val, 10);\n            settings._iDisplayLength = len;\n\n            _fnLengthOverflow(settings);\n\n            // Fire length change event\n            _fnCallbackFire(settings, null, 'length', [settings, len]);\n        }\n\n\n        /**\n         * Generate the node required for user display length changing\n         *  @param {object} settings dataTables settings object\n         *  @returns {node} Display length feature node\n         *  @memberof DataTable#oApi\n         */\n        function _fnFeatureHtmlLength(settings) {\n            var\n                classes = settings.oClasses,\n                tableId = settings.sTableId,\n                menu = settings.aLengthMenu,\n                d2 = Array.isArray(menu[0]),\n                lengths = d2 ? menu[0] : menu,\n                language = d2 ? menu[1] : menu;\n\n            var select = $('<select/>', {\n                'name': tableId + '_length',\n                'aria-controls': tableId,\n                'class': classes.sLengthSelect\n            });\n\n            for (var i = 0, ien = lengths.length; i < ien; i++) {\n                select[0][i] = new Option(\n                    typeof language[i] === 'number' ?\n                        settings.fnFormatNumber(language[i]) :\n                        language[i],\n                    lengths[i]\n                );\n            }\n\n            var div = $('<div><label/></div>').addClass(classes.sLength);\n            if (!settings.aanFeatures.l) {\n                div[0].id = tableId + '_length';\n            }\n\n            div.children().append(\n                settings.oLanguage.sLengthMenu.replace('_MENU_', select[0].outerHTML)\n            );\n\n            // Can't use `select` variable as user might provide their own and the\n            // reference is broken by the use of outerHTML\n            $('select', div)\n                .val(settings._iDisplayLength)\n                .on('change.DT', function (e) {\n                    _fnLengthChange(settings, $(this).val());\n                    _fnDraw(settings);\n                });\n\n            // Update node value whenever anything changes the table's length\n            $(settings.nTable).on('length.dt.DT', function (e, s, len) {\n                if (settings === s) {\n                    $('select', div).val(len);\n                }\n            });\n\n            return div[0];\n        }\n\n\n\n        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         * Note that most of the paging logic is done in\n         * DataTable.ext.pager\n         */\n\n        /**\n         * Generate the node required for default pagination\n         *  @param {object} oSettings dataTables settings object\n         *  @returns {node} Pagination feature node\n         *  @memberof DataTable#oApi\n         */\n        function _fnFeatureHtmlPaginate(settings) {\n            var\n                type = settings.sPaginationType,\n                plugin = DataTable.ext.pager[type],\n                modern = typeof plugin === 'function',\n                redraw = function (settings) {\n                    _fnDraw(settings);\n                },\n                node = $('<div/>').addClass(settings.oClasses.sPaging + type)[0],\n                features = settings.aanFeatures;\n\n            if (!modern) {\n                plugin.fnInit(settings, node, redraw);\n            }\n\n            /* Add a draw callback for the pagination on first instance, to update the paging display */\n            if (!features.p) {\n                node.id = settings.sTableId + '_paginate';\n\n                settings.aoDrawCallback.push({\n                    \"fn\": function (settings) {\n                        if (modern) {\n                            var\n                                start = settings._iDisplayStart,\n                                len = settings._iDisplayLength,\n                                visRecords = settings.fnRecordsDisplay(),\n                                all = len === -1,\n                                page = all ? 0 : Math.ceil(start / len),\n                                pages = all ? 1 : Math.ceil(visRecords / len),\n                                buttons = plugin(page, pages),\n                                i, ien;\n\n                            for (i = 0, ien = features.p.length; i < ien; i++) {\n                                _fnRenderer(settings, 'pageButton')(\n                                    settings, features.p[i], i, buttons, page, pages\n                                );\n                            }\n                        }\n                        else {\n                            plugin.fnUpdate(settings, redraw);\n                        }\n                    },\n                    \"sName\": \"pagination\"\n                });\n            }\n\n            return node;\n        }\n\n\n        /**\n         * Alter the display settings to change the page\n         *  @param {object} settings DataTables settings object\n         *  @param {string|int} action Paging action to take: \"first\", \"previous\",\n         *    \"next\" or \"last\" or page number to jump to (integer)\n         *  @param [bool] redraw Automatically draw the update or not\n         *  @returns {bool} true page has changed, false - no change\n         *  @memberof DataTable#oApi\n         */\n        function _fnPageChange(settings, action, redraw) {\n            var\n                start = settings._iDisplayStart,\n                len = settings._iDisplayLength,\n                records = settings.fnRecordsDisplay();\n\n            if (records === 0 || len === -1) {\n                start = 0;\n            }\n            else if (typeof action === \"number\") {\n                start = action * len;\n\n                if (start > records) {\n                    start = 0;\n                }\n            }\n            else if (action == \"first\") {\n                start = 0;\n            }\n            else if (action == \"previous\") {\n                start = len >= 0 ?\n                    start - len :\n                    0;\n\n                if (start < 0) {\n                    start = 0;\n                }\n            }\n            else if (action == \"next\") {\n                if (start + len < records) {\n                    start += len;\n                }\n            }\n            else if (action == \"last\") {\n                start = Math.floor((records - 1) / len) * len;\n            }\n            else {\n                _fnLog(settings, 0, \"Unknown paging action: \" + action, 5);\n            }\n\n            var changed = settings._iDisplayStart !== start;\n            settings._iDisplayStart = start;\n\n            if (changed) {\n                _fnCallbackFire(settings, null, 'page', [settings]);\n\n                if (redraw) {\n                    _fnDraw(settings);\n                }\n            }\n\n            return changed;\n        }\n\n\n\n        /**\n         * Generate the node required for the processing node\n         *  @param {object} settings dataTables settings object\n         *  @returns {node} Processing element\n         *  @memberof DataTable#oApi\n         */\n        function _fnFeatureHtmlProcessing(settings) {\n            return $('<div/>', {\n                'id': !settings.aanFeatures.r ? settings.sTableId + '_processing' : null,\n                'class': settings.oClasses.sProcessing\n            })\n                .html(settings.oLanguage.sProcessing)\n                .insertBefore(settings.nTable)[0];\n        }\n\n\n        /**\n         * Display or hide the processing indicator\n         *  @param {object} settings dataTables settings object\n         *  @param {bool} show Show the processing indicator (true) or not (false)\n         *  @memberof DataTable#oApi\n         */\n        function _fnProcessingDisplay(settings, show) {\n            if (settings.oFeatures.bProcessing) {\n                $(settings.aanFeatures.r).css('display', show ? 'block' : 'none');\n            }\n\n            _fnCallbackFire(settings, null, 'processing', [settings, show]);\n        }\n\n        /**\n         * Add any control elements for the table - specifically scrolling\n         *  @param {object} settings dataTables settings object\n         *  @returns {node} Node to add to the DOM\n         *  @memberof DataTable#oApi\n         */\n        function _fnFeatureHtmlTable(settings) {\n            var table = $(settings.nTable);\n\n            // Add the ARIA grid role to the table\n            table.attr('role', 'grid');\n\n            // Scrolling from here on in\n            var scroll = settings.oScroll;\n\n            if (scroll.sX === '' && scroll.sY === '') {\n                return settings.nTable;\n            }\n\n            var scrollX = scroll.sX;\n            var scrollY = scroll.sY;\n            var classes = settings.oClasses;\n            var caption = table.children('caption');\n            var captionSide = caption.length ? caption[0]._captionSide : null;\n            var headerClone = $(table[0].cloneNode(false));\n            var footerClone = $(table[0].cloneNode(false));\n            var footer = table.children('tfoot');\n            var _div = '<div/>';\n            var size = function (s) {\n                return !s ? null : _fnStringToCss(s);\n            };\n\n            if (!footer.length) {\n                footer = null;\n            }\n\n            /*\n             * The HTML structure that we want to generate in this function is:\n             *  div - scroller\n             *    div - scroll head\n             *      div - scroll head inner\n             *        table - scroll head table\n             *          thead - thead\n             *    div - scroll body\n             *      table - table (master table)\n             *        thead - thead clone for sizing\n             *        tbody - tbody\n             *    div - scroll foot\n             *      div - scroll foot inner\n             *        table - scroll foot table\n             *          tfoot - tfoot\n             */\n            var scroller = $(_div, { 'class': classes.sScrollWrapper })\n                .append(\n                    $(_div, { 'class': classes.sScrollHead })\n                        .css({\n                            overflow: 'hidden',\n                            position: 'relative',\n                            border: 0,\n                            width: scrollX ? size(scrollX) : '100%'\n                        })\n                        .append(\n                            $(_div, { 'class': classes.sScrollHeadInner })\n                                .css({\n                                    'box-sizing': 'content-box',\n                                    width: scroll.sXInner || '100%'\n                                })\n                                .append(\n                                    headerClone\n                                        .removeAttr('id')\n                                        .css('margin-left', 0)\n                                        .append(captionSide === 'top' ? caption : null)\n                                        .append(\n                                            table.children('thead')\n                                        )\n                                )\n                        )\n                )\n                .append(\n                    $(_div, { 'class': classes.sScrollBody })\n                        .css({\n                            position: 'relative',\n                            overflow: 'auto',\n                            width: size(scrollX)\n                        })\n                        .append(table)\n                );\n\n            if (footer) {\n                scroller.append(\n                    $(_div, { 'class': classes.sScrollFoot })\n                        .css({\n                            overflow: 'hidden',\n                            border: 0,\n                            width: scrollX ? size(scrollX) : '100%'\n                        })\n                        .append(\n                            $(_div, { 'class': classes.sScrollFootInner })\n                                .append(\n                                    footerClone\n                                        .removeAttr('id')\n                                        .css('margin-left', 0)\n                                        .append(captionSide === 'bottom' ? caption : null)\n                                        .append(\n                                            table.children('tfoot')\n                                        )\n                                )\n                        )\n                );\n            }\n\n            var children = scroller.children();\n            var scrollHead = children[0];\n            var scrollBody = children[1];\n            var scrollFoot = footer ? children[2] : null;\n\n            // When the body is scrolled, then we also want to scroll the headers\n            if (scrollX) {\n                $(scrollBody).on('scroll.DT', function (e) {\n                    var scrollLeft = this.scrollLeft;\n\n                    scrollHead.scrollLeft = scrollLeft;\n\n                    if (footer) {\n                        scrollFoot.scrollLeft = scrollLeft;\n                    }\n                });\n            }\n\n            $(scrollBody).css('max-height', scrollY);\n            if (!scroll.bCollapse) {\n                $(scrollBody).css('height', scrollY);\n            }\n\n            settings.nScrollHead = scrollHead;\n            settings.nScrollBody = scrollBody;\n            settings.nScrollFoot = scrollFoot;\n\n            // On redraw - align columns\n            settings.aoDrawCallback.push({\n                \"fn\": _fnScrollDraw,\n                \"sName\": \"scrolling\"\n            });\n\n            return scroller[0];\n        }\n\n\n\n        /**\n         * Update the header, footer and body tables for resizing - i.e. column\n         * alignment.\n         *\n         * Welcome to the most horrible function DataTables. The process that this\n         * function follows is basically:\n         *   1. Re-create the table inside the scrolling div\n         *   2. Take live measurements from the DOM\n         *   3. Apply the measurements to align the columns\n         *   4. Clean up\n         *\n         *  @param {object} settings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnScrollDraw(settings) {\n            // Given that this is such a monster function, a lot of variables are use\n            // to try and keep the minimised size as small as possible\n            var\n                scroll = settings.oScroll,\n                scrollX = scroll.sX,\n                scrollXInner = scroll.sXInner,\n                scrollY = scroll.sY,\n                barWidth = scroll.iBarWidth,\n                divHeader = $(settings.nScrollHead),\n                divHeaderStyle = divHeader[0].style,\n                divHeaderInner = divHeader.children('div'),\n                divHeaderInnerStyle = divHeaderInner[0].style,\n                divHeaderTable = divHeaderInner.children('table'),\n                divBodyEl = settings.nScrollBody,\n                divBody = $(divBodyEl),\n                divBodyStyle = divBodyEl.style,\n                divFooter = $(settings.nScrollFoot),\n                divFooterInner = divFooter.children('div'),\n                divFooterTable = divFooterInner.children('table'),\n                header = $(settings.nTHead),\n                table = $(settings.nTable),\n                tableEl = table[0],\n                tableStyle = tableEl.style,\n                footer = settings.nTFoot ? $(settings.nTFoot) : null,\n                browser = settings.oBrowser,\n                ie67 = browser.bScrollOversize,\n                dtHeaderCells = _pluck(settings.aoColumns, 'nTh'),\n                headerTrgEls, footerTrgEls,\n                headerSrcEls, footerSrcEls,\n                headerCopy, footerCopy,\n                headerWidths = [], footerWidths = [],\n                headerContent = [], footerContent = [],\n                idx, correction, sanityWidth,\n                zeroOut = function (nSizer) {\n                    var style = nSizer.style;\n                    style.paddingTop = \"0\";\n                    style.paddingBottom = \"0\";\n                    style.borderTopWidth = \"0\";\n                    style.borderBottomWidth = \"0\";\n                    style.height = 0;\n                };\n\n            // If the scrollbar visibility has changed from the last draw, we need to\n            // adjust the column sizes as the table width will have changed to account\n            // for the scrollbar\n            var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;\n\n            if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) {\n                settings.scrollBarVis = scrollBarVis;\n                _fnAdjustColumnSizing(settings);\n                return; // adjust column sizing will call this function again\n            }\n            else {\n                settings.scrollBarVis = scrollBarVis;\n            }\n\n            /*\n             * 1. Re-create the table inside the scrolling div\n             */\n\n            // Remove the old minimised thead and tfoot elements in the inner table\n            table.children('thead, tfoot').remove();\n\n            if (footer) {\n                footerCopy = footer.clone().prependTo(table);\n                footerTrgEls = footer.find('tr'); // the original tfoot is in its own table and must be sized\n                footerSrcEls = footerCopy.find('tr');\n            }\n\n            // Clone the current header and footer elements and then place it into the inner table\n            headerCopy = header.clone().prependTo(table);\n            headerTrgEls = header.find('tr'); // original header is in its own table\n            headerSrcEls = headerCopy.find('tr');\n            headerCopy.find('th, td').removeAttr('tabindex');\n\n\n            /*\n             * 2. Take live measurements from the DOM - do not alter the DOM itself!\n             */\n\n            // Remove old sizing and apply the calculated column widths\n            // Get the unique column headers in the newly created (cloned) header. We want to apply the\n            // calculated sizes to this header\n            if (!scrollX) {\n                divBodyStyle.width = '100%';\n                divHeader[0].style.width = '100%';\n            }\n\n            $.each(_fnGetUniqueThs(settings, headerCopy), function (i, el) {\n                idx = _fnVisibleToColumnIndex(settings, i);\n                el.style.width = settings.aoColumns[idx].sWidth;\n            });\n\n            if (footer) {\n                _fnApplyToChildren(function (n) {\n                    n.style.width = \"\";\n                }, footerSrcEls);\n            }\n\n            // Size the table as a whole\n            sanityWidth = table.outerWidth();\n            if (scrollX === \"\") {\n                // No x scrolling\n                tableStyle.width = \"100%\";\n\n                // IE7 will make the width of the table when 100% include the scrollbar\n                // - which is shouldn't. When there is a scrollbar we need to take this\n                // into account.\n                if (ie67 && (table.find('tbody').height() > divBodyEl.offsetHeight ||\n                    divBody.css('overflow-y') == \"scroll\")\n                ) {\n                    tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth);\n                }\n\n                // Recalculate the sanity width\n                sanityWidth = table.outerWidth();\n            }\n            else if (scrollXInner !== \"\") {\n                // legacy x scroll inner has been given - use it\n                tableStyle.width = _fnStringToCss(scrollXInner);\n\n                // Recalculate the sanity width\n                sanityWidth = table.outerWidth();\n            }\n\n            // Hidden header should have zero height, so remove padding and borders. Then\n            // set the width based on the real headers\n\n            // Apply all styles in one pass\n            _fnApplyToChildren(zeroOut, headerSrcEls);\n\n            // Read all widths in next pass\n            _fnApplyToChildren(function (nSizer) {\n                headerContent.push(nSizer.innerHTML);\n                headerWidths.push(_fnStringToCss($(nSizer).css('width')));\n            }, headerSrcEls);\n\n            // Apply all widths in final pass\n            _fnApplyToChildren(function (nToSize, i) {\n                // Only apply widths to the DataTables detected header cells - this\n                // prevents complex headers from having contradictory sizes applied\n                if ($.inArray(nToSize, dtHeaderCells) !== -1) {\n                    nToSize.style.width = headerWidths[i];\n                }\n            }, headerTrgEls);\n\n            $(headerSrcEls).height(0);\n\n            /* Same again with the footer if we have one */\n            if (footer) {\n                _fnApplyToChildren(zeroOut, footerSrcEls);\n\n                _fnApplyToChildren(function (nSizer) {\n                    footerContent.push(nSizer.innerHTML);\n                    footerWidths.push(_fnStringToCss($(nSizer).css('width')));\n                }, footerSrcEls);\n\n                _fnApplyToChildren(function (nToSize, i) {\n                    nToSize.style.width = footerWidths[i];\n                }, footerTrgEls);\n\n                $(footerSrcEls).height(0);\n            }\n\n\n            /*\n             * 3. Apply the measurements\n             */\n\n            // \"Hide\" the header and footer that we used for the sizing. We need to keep\n            // the content of the cell so that the width applied to the header and body\n            // both match, but we want to hide it completely. We want to also fix their\n            // width to what they currently are\n            _fnApplyToChildren(function (nSizer, i) {\n                nSizer.innerHTML = '<div class=\"dataTables_sizing\">' + headerContent[i] + '</div>';\n                nSizer.childNodes[0].style.height = \"0\";\n                nSizer.childNodes[0].style.overflow = \"hidden\";\n                nSizer.style.width = headerWidths[i];\n            }, headerSrcEls);\n\n            if (footer) {\n                _fnApplyToChildren(function (nSizer, i) {\n                    nSizer.innerHTML = '<div class=\"dataTables_sizing\">' + footerContent[i] + '</div>';\n                    nSizer.childNodes[0].style.height = \"0\";\n                    nSizer.childNodes[0].style.overflow = \"hidden\";\n                    nSizer.style.width = footerWidths[i];\n                }, footerSrcEls);\n            }\n\n            // Sanity check that the table is of a sensible width. If not then we are going to get\n            // misalignment - try to prevent this by not allowing the table to shrink below its min width\n            if (table.outerWidth() < sanityWidth) {\n                // The min width depends upon if we have a vertical scrollbar visible or not */\n                correction = ((divBodyEl.scrollHeight > divBodyEl.offsetHeight ||\n                    divBody.css('overflow-y') == \"scroll\")) ?\n                    sanityWidth + barWidth :\n                    sanityWidth;\n\n                // IE6/7 are a law unto themselves...\n                if (ie67 && (divBodyEl.scrollHeight >\n                    divBodyEl.offsetHeight || divBody.css('overflow-y') == \"scroll\")\n                ) {\n                    tableStyle.width = _fnStringToCss(correction - barWidth);\n                }\n\n                // And give the user a warning that we've stopped the table getting too small\n                if (scrollX === \"\" || scrollXInner !== \"\") {\n                    _fnLog(settings, 1, 'Possible column misalignment', 6);\n                }\n            }\n            else {\n                correction = '100%';\n            }\n\n            // Apply to the container elements\n            divBodyStyle.width = _fnStringToCss(correction);\n            divHeaderStyle.width = _fnStringToCss(correction);\n\n            if (footer) {\n                settings.nScrollFoot.style.width = _fnStringToCss(correction);\n            }\n\n\n            /*\n             * 4. Clean up\n             */\n            if (!scrollY) {\n                /* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting\n                 * the scrollbar height from the visible display, rather than adding it on. We need to\n                 * set the height in order to sort this. Don't want to do it in any other browsers.\n                 */\n                if (ie67) {\n                    divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth);\n                }\n            }\n\n            /* Finally set the width's of the header and footer tables */\n            var iOuterWidth = table.outerWidth();\n            divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth);\n            divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);\n\n            // Figure out if there are scrollbar present - if so then we need a the header and footer to\n            // provide a bit more space to allow \"overflow\" scrolling (i.e. past the scrollbar)\n            var bScrolling = table.height() > divBodyEl.clientHeight || divBody.css('overflow-y') == \"scroll\";\n            var padding = 'padding' + (browser.bScrollbarLeft ? 'Left' : 'Right');\n            divHeaderInnerStyle[padding] = bScrolling ? barWidth + \"px\" : \"0px\";\n\n            if (footer) {\n                divFooterTable[0].style.width = _fnStringToCss(iOuterWidth);\n                divFooterInner[0].style.width = _fnStringToCss(iOuterWidth);\n                divFooterInner[0].style[padding] = bScrolling ? barWidth + \"px\" : \"0px\";\n            }\n\n            // Correct DOM ordering for colgroup - comes before the thead\n            table.children('colgroup').insertBefore(table.children('thead'));\n\n            /* Adjust the position of the header in case we loose the y-scrollbar */\n            divBody.trigger('scroll');\n\n            // If sorting or filtering has occurred, jump the scrolling back to the top\n            // only if we aren't holding the position\n            if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {\n                divBodyEl.scrollTop = 0;\n            }\n        }\n\n\n\n        /**\n         * Apply a given function to the display child nodes of an element array (typically\n         * TD children of TR rows\n         *  @param {function} fn Method to apply to the objects\n         *  @param array {nodes} an1 List of elements to look through for display children\n         *  @param array {nodes} an2 Another list (identical structure to the first) - optional\n         *  @memberof DataTable#oApi\n         */\n        function _fnApplyToChildren(fn, an1, an2) {\n            var index = 0, i = 0, iLen = an1.length;\n            var nNode1, nNode2;\n\n            while (i < iLen) {\n                nNode1 = an1[i].firstChild;\n                nNode2 = an2 ? an2[i].firstChild : null;\n\n                while (nNode1) {\n                    if (nNode1.nodeType === 1) {\n                        if (an2) {\n                            fn(nNode1, nNode2, index);\n                        }\n                        else {\n                            fn(nNode1, index);\n                        }\n\n                        index++;\n                    }\n\n                    nNode1 = nNode1.nextSibling;\n                    nNode2 = an2 ? nNode2.nextSibling : null;\n                }\n\n                i++;\n            }\n        }\n\n\n\n        var __re_html_remove = /<.*?>/g;\n\n\n        /**\n         * Calculate the width of columns for the table\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnCalculateColumnWidths(oSettings) {\n            var\n                table = oSettings.nTable,\n                columns = oSettings.aoColumns,\n                scroll = oSettings.oScroll,\n                scrollY = scroll.sY,\n                scrollX = scroll.sX,\n                scrollXInner = scroll.sXInner,\n                columnCount = columns.length,\n                visibleColumns = _fnGetColumns(oSettings, 'bVisible'),\n                headerCells = $('th', oSettings.nTHead),\n                tableWidthAttr = table.getAttribute('width'), // from DOM element\n                tableContainer = table.parentNode,\n                userInputs = false,\n                i, column, columnIdx, width, outerWidth,\n                browser = oSettings.oBrowser,\n                ie67 = browser.bScrollOversize;\n\n            var styleWidth = table.style.width;\n            if (styleWidth && styleWidth.indexOf('%') !== -1) {\n                tableWidthAttr = styleWidth;\n            }\n\n            /* Convert any user input sizes into pixel sizes */\n            for (i = 0; i < visibleColumns.length; i++) {\n                column = columns[visibleColumns[i]];\n\n                if (column.sWidth !== null) {\n                    column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer);\n\n                    userInputs = true;\n                }\n            }\n\n            /* If the number of columns in the DOM equals the number that we have to\n             * process in DataTables, then we can use the offsets that are created by\n             * the web- browser. No custom sizes can be set in order for this to happen,\n             * nor scrolling used\n             */\n            if (ie67 || !userInputs && !scrollX && !scrollY &&\n                columnCount == _fnVisbleColumns(oSettings) &&\n                columnCount == headerCells.length\n            ) {\n                for (i = 0; i < columnCount; i++) {\n                    var colIdx = _fnVisibleToColumnIndex(oSettings, i);\n\n                    if (colIdx !== null) {\n                        columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width());\n                    }\n                }\n            }\n            else {\n                // Otherwise construct a single row, worst case, table with the widest\n                // node in the data, assign any user defined widths, then insert it into\n                // the DOM and allow the browser to do all the hard work of calculating\n                // table widths\n                var tmpTable = $(table).clone() // don't use cloneNode - IE8 will remove events on the main table\n                    .css('visibility', 'hidden')\n                    .removeAttr('id');\n\n                // Clean up the table body\n                tmpTable.find('tbody tr').remove();\n                var tr = $('<tr/>').appendTo(tmpTable.find('tbody'));\n\n                // Clone the table header and footer - we can't use the header / footer\n                // from the cloned table, since if scrolling is active, the table's\n                // real header and footer are contained in different table tags\n                tmpTable.find('thead, tfoot').remove();\n                tmpTable\n                    .append($(oSettings.nTHead).clone())\n                    .append($(oSettings.nTFoot).clone());\n\n                // Remove any assigned widths from the footer (from scrolling)\n                tmpTable.find('tfoot th, tfoot td').css('width', '');\n\n                // Apply custom sizing to the cloned header\n                headerCells = _fnGetUniqueThs(oSettings, tmpTable.find('thead')[0]);\n\n                for (i = 0; i < visibleColumns.length; i++) {\n                    column = columns[visibleColumns[i]];\n\n                    headerCells[i].style.width = column.sWidthOrig !== null && column.sWidthOrig !== '' ?\n                        _fnStringToCss(column.sWidthOrig) :\n                        '';\n\n                    // For scrollX we need to force the column width otherwise the\n                    // browser will collapse it. If this width is smaller than the\n                    // width the column requires, then it will have no effect\n                    if (column.sWidthOrig && scrollX) {\n                        $(headerCells[i]).append($('<div/>').css({\n                            width: column.sWidthOrig,\n                            margin: 0,\n                            padding: 0,\n                            border: 0,\n                            height: 1\n                        }));\n                    }\n                }\n\n                // Find the widest cell for each column and put it into the table\n                if (oSettings.aoData.length) {\n                    for (i = 0; i < visibleColumns.length; i++) {\n                        columnIdx = visibleColumns[i];\n                        column = columns[columnIdx];\n\n                        $(_fnGetWidestNode(oSettings, columnIdx))\n                            .clone(false)\n                            .append(column.sContentPadding)\n                            .appendTo(tr);\n                    }\n                }\n\n                // Tidy the temporary table - remove name attributes so there aren't\n                // duplicated in the dom (radio elements for example)\n                $('[name]', tmpTable).removeAttr('name');\n\n                // Table has been built, attach to the document so we can work with it.\n                // A holding element is used, positioned at the top of the container\n                // with minimal height, so it has no effect on if the container scrolls\n                // or not. Otherwise it might trigger scrolling when it actually isn't\n                // needed\n                var holder = $('<div/>').css(scrollX || scrollY ?\n                    {\n                        position: 'absolute',\n                        top: 0,\n                        left: 0,\n                        height: 1,\n                        right: 0,\n                        overflow: 'hidden'\n                    } :\n                    {}\n                )\n                    .append(tmpTable)\n                    .appendTo(tableContainer);\n\n                // When scrolling (X or Y) we want to set the width of the table as\n                // appropriate. However, when not scrolling leave the table width as it\n                // is. This results in slightly different, but I think correct behaviour\n                if (scrollX && scrollXInner) {\n                    tmpTable.width(scrollXInner);\n                }\n                else if (scrollX) {\n                    tmpTable.css('width', 'auto');\n                    tmpTable.removeAttr('width');\n\n                    // If there is no width attribute or style, then allow the table to\n                    // collapse\n                    if (tmpTable.width() < tableContainer.clientWidth && tableWidthAttr) {\n                        tmpTable.width(tableContainer.clientWidth);\n                    }\n                }\n                else if (scrollY) {\n                    tmpTable.width(tableContainer.clientWidth);\n                }\n                else if (tableWidthAttr) {\n                    tmpTable.width(tableWidthAttr);\n                }\n\n                // Get the width of each column in the constructed table - we need to\n                // know the inner width (so it can be assigned to the other table's\n                // cells) and the outer width so we can calculate the full width of the\n                // table. This is safe since DataTables requires a unique cell for each\n                // column, but if ever a header can span multiple columns, this will\n                // need to be modified.\n                var total = 0;\n                for (i = 0; i < visibleColumns.length; i++) {\n                    var cell = $(headerCells[i]);\n                    var border = cell.outerWidth() - cell.width();\n\n                    // Use getBounding... where possible (not IE8-) because it can give\n                    // sub-pixel accuracy, which we then want to round up!\n                    var bounding = browser.bBounding ?\n                        Math.ceil(headerCells[i].getBoundingClientRect().width) :\n                        cell.outerWidth();\n\n                    // Total is tracked to remove any sub-pixel errors as the outerWidth\n                    // of the table might not equal the total given here (IE!).\n                    total += bounding;\n\n                    // Width for each column to use\n                    columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border);\n                }\n\n                table.style.width = _fnStringToCss(total);\n\n                // Finished with the table - ditch it\n                holder.remove();\n            }\n\n            // If there is a width attr, we want to attach an event listener which\n            // allows the table sizing to automatically adjust when the window is\n            // resized. Use the width attr rather than CSS, since we can't know if the\n            // CSS is a relative value or absolute - DOM read is always px.\n            if (tableWidthAttr) {\n                table.style.width = _fnStringToCss(tableWidthAttr);\n            }\n\n            if ((tableWidthAttr || scrollX) && !oSettings._reszEvt) {\n                var bindResize = function () {\n                    $(window).on('resize.DT-' + oSettings.sInstance, _fnThrottle(function () {\n                        _fnAdjustColumnSizing(oSettings);\n                    }));\n                };\n\n                // IE6/7 will crash if we bind a resize event handler on page load.\n                // To be removed in 1.11 which drops IE6/7 support\n                if (ie67) {\n                    setTimeout(bindResize, 1000);\n                }\n                else {\n                    bindResize();\n                }\n\n                oSettings._reszEvt = true;\n            }\n        }\n\n\n        /**\n         * Throttle the calls to a function. Arguments and context are maintained for\n         * the throttled function\n         *  @param {function} fn Function to be called\n         *  @param {int} [freq=200] call frequency in mS\n         *  @returns {function} wrapped function\n         *  @memberof DataTable#oApi\n         */\n        var _fnThrottle = DataTable.util.throttle;\n\n\n        /**\n         * Convert a CSS unit width to pixels (e.g. 2em)\n         *  @param {string} width width to be converted\n         *  @param {node} parent parent to get the with for (required for relative widths) - optional\n         *  @returns {int} width in pixels\n         *  @memberof DataTable#oApi\n         */\n        function _fnConvertToWidth(width, parent) {\n            if (!width) {\n                return 0;\n            }\n\n            var n = $('<div/>')\n                .css('width', _fnStringToCss(width))\n                .appendTo(parent || document.body);\n\n            var val = n[0].offsetWidth;\n            n.remove();\n\n            return val;\n        }\n\n\n        /**\n         * Get the widest node\n         *  @param {object} settings dataTables settings object\n         *  @param {int} colIdx column of interest\n         *  @returns {node} widest table node\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetWidestNode(settings, colIdx) {\n            var idx = _fnGetMaxLenString(settings, colIdx);\n            if (idx < 0) {\n                return null;\n            }\n\n            var data = settings.aoData[idx];\n            return !data.nTr ? // Might not have been created when deferred rendering\n                $('<td/>').html(_fnGetCellData(settings, idx, colIdx, 'display'))[0] :\n                data.anCells[colIdx];\n        }\n\n\n        /**\n         * Get the maximum strlen for each data column\n         *  @param {object} settings dataTables settings object\n         *  @param {int} colIdx column of interest\n         *  @returns {string} max string length for each column\n         *  @memberof DataTable#oApi\n         */\n        function _fnGetMaxLenString(settings, colIdx) {\n            var s, max = -1, maxIdx = -1;\n\n            for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n                s = _fnGetCellData(settings, i, colIdx, 'display') + '';\n                s = s.replace(__re_html_remove, '');\n                s = s.replace(/&nbsp;/g, ' ');\n\n                if (s.length > max) {\n                    max = s.length;\n                    maxIdx = i;\n                }\n            }\n\n            return maxIdx;\n        }\n\n\n        /**\n         * Append a CSS unit (only if required) to a string\n         *  @param {string} value to css-ify\n         *  @returns {string} value with css unit\n         *  @memberof DataTable#oApi\n         */\n        function _fnStringToCss(s) {\n            if (s === null) {\n                return '0px';\n            }\n\n            if (typeof s == 'number') {\n                return s < 0 ?\n                    '0px' :\n                    s + 'px';\n            }\n\n            // Check it has a unit character already\n            return s.match(/\\d$/) ?\n                s + 'px' :\n                s;\n        }\n\n\n\n        function _fnSortFlatten(settings) {\n            var\n                i, iLen, k, kLen,\n                aSort = [],\n                aiOrig = [],\n                aoColumns = settings.aoColumns,\n                aDataSort, iCol, sType, srcCol,\n                fixed = settings.aaSortingFixed,\n                fixedObj = $.isPlainObject(fixed),\n                nestedSort = [],\n                add = function (a) {\n                    if (a.length && !Array.isArray(a[0])) {\n                        // 1D array\n                        nestedSort.push(a);\n                    }\n                    else {\n                        // 2D array\n                        $.merge(nestedSort, a);\n                    }\n                };\n\n            // Build the sort array, with pre-fix and post-fix options if they have been\n            // specified\n            if (Array.isArray(fixed)) {\n                add(fixed);\n            }\n\n            if (fixedObj && fixed.pre) {\n                add(fixed.pre);\n            }\n\n            add(settings.aaSorting);\n\n            if (fixedObj && fixed.post) {\n                add(fixed.post);\n            }\n\n            for (i = 0; i < nestedSort.length; i++) {\n                srcCol = nestedSort[i][0];\n                aDataSort = aoColumns[srcCol].aDataSort;\n\n                for (k = 0, kLen = aDataSort.length; k < kLen; k++) {\n                    iCol = aDataSort[k];\n                    sType = aoColumns[iCol].sType || 'string';\n\n                    if (nestedSort[i]._idx === undefined) {\n                        nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting);\n                    }\n\n                    aSort.push({\n                        src: srcCol,\n                        col: iCol,\n                        dir: nestedSort[i][1],\n                        index: nestedSort[i]._idx,\n                        type: sType,\n                        formatter: DataTable.ext.type.order[sType + \"-pre\"]\n                    });\n                }\n            }\n\n            return aSort;\n        }\n\n        /**\n         * Change the order of the table\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         *  @todo This really needs split up!\n         */\n        function _fnSort(oSettings) {\n            var\n                i, ien, iLen, j, jLen, k, kLen,\n                sDataType, nTh,\n                aiOrig = [],\n                oExtSort = DataTable.ext.type.order,\n                aoData = oSettings.aoData,\n                aoColumns = oSettings.aoColumns,\n                aDataSort, data, iCol, sType, oSort,\n                formatters = 0,\n                sortCol,\n                displayMaster = oSettings.aiDisplayMaster,\n                aSort;\n\n            // Resolve any column types that are unknown due to addition or invalidation\n            // @todo Can this be moved into a 'data-ready' handler which is called when\n            //   data is going to be used in the table?\n            _fnColumnTypes(oSettings);\n\n            aSort = _fnSortFlatten(oSettings);\n\n            for (i = 0, ien = aSort.length; i < ien; i++) {\n                sortCol = aSort[i];\n\n                // Track if we can use the fast sort algorithm\n                if (sortCol.formatter) {\n                    formatters++;\n                }\n\n                // Load the data needed for the sort, for each cell\n                _fnSortData(oSettings, sortCol.col);\n            }\n\n            /* No sorting required if server-side or no sorting array */\n            if (_fnDataSource(oSettings) != 'ssp' && aSort.length !== 0) {\n                // Create a value - key array of the current row positions such that we can use their\n                // current position during the sort, if values match, in order to perform stable sorting\n                for (i = 0, iLen = displayMaster.length; i < iLen; i++) {\n                    aiOrig[displayMaster[i]] = i;\n                }\n\n                /* Do the sort - here we want multi-column sorting based on a given data source (column)\n                 * and sorting function (from oSort) in a certain direction. It's reasonably complex to\n                 * follow on it's own, but this is what we want (example two column sorting):\n                 *  fnLocalSorting = function(a,b){\n                 *    var iTest;\n                 *    iTest = oSort['string-asc']('data11', 'data12');\n                 *      if (iTest !== 0)\n                 *        return iTest;\n                 *    iTest = oSort['numeric-desc']('data21', 'data22');\n                 *    if (iTest !== 0)\n                 *      return iTest;\n                 *    return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );\n                 *  }\n                 * Basically we have a test for each sorting column, if the data in that column is equal,\n                 * test the next column. If all columns match, then we use a numeric sort on the row\n                 * positions in the original data array to provide a stable sort.\n                 *\n                 * Note - I know it seems excessive to have two sorting methods, but the first is around\n                 * 15% faster, so the second is only maintained for backwards compatibility with sorting\n                 * methods which do not have a pre-sort formatting function.\n                 */\n                if (formatters === aSort.length) {\n                    // All sort types have formatting functions\n                    displayMaster.sort(function (a, b) {\n                        var\n                            x, y, k, test, sort,\n                            len = aSort.length,\n                            dataA = aoData[a]._aSortData,\n                            dataB = aoData[b]._aSortData;\n\n                        for (k = 0; k < len; k++) {\n                            sort = aSort[k];\n\n                            x = dataA[sort.col];\n                            y = dataB[sort.col];\n\n                            test = x < y ? -1 : x > y ? 1 : 0;\n                            if (test !== 0) {\n                                return sort.dir === 'asc' ? test : -test;\n                            }\n                        }\n\n                        x = aiOrig[a];\n                        y = aiOrig[b];\n                        return x < y ? -1 : x > y ? 1 : 0;\n                    });\n                }\n                else {\n                    // Depreciated - remove in 1.11 (providing a plug-in option)\n                    // Not all sort types have formatting methods, so we have to call their sorting\n                    // methods.\n                    displayMaster.sort(function (a, b) {\n                        var\n                            x, y, k, l, test, sort, fn,\n                            len = aSort.length,\n                            dataA = aoData[a]._aSortData,\n                            dataB = aoData[b]._aSortData;\n\n                        for (k = 0; k < len; k++) {\n                            sort = aSort[k];\n\n                            x = dataA[sort.col];\n                            y = dataB[sort.col];\n\n                            fn = oExtSort[sort.type + \"-\" + sort.dir] || oExtSort[\"string-\" + sort.dir];\n                            test = fn(x, y);\n                            if (test !== 0) {\n                                return test;\n                            }\n                        }\n\n                        x = aiOrig[a];\n                        y = aiOrig[b];\n                        return x < y ? -1 : x > y ? 1 : 0;\n                    });\n                }\n            }\n\n            /* Tell the draw function that we have sorted the data */\n            oSettings.bSorted = true;\n        }\n\n\n        function _fnSortAria(settings) {\n            var label;\n            var nextSort;\n            var columns = settings.aoColumns;\n            var aSort = _fnSortFlatten(settings);\n            var oAria = settings.oLanguage.oAria;\n\n            // ARIA attributes - need to loop all columns, to update all (removing old\n            // attributes as needed)\n            for (var i = 0, iLen = columns.length; i < iLen; i++) {\n                var col = columns[i];\n                var asSorting = col.asSorting;\n                var sTitle = col.sTitle.replace(/<.*?>/g, \"\");\n                var th = col.nTh;\n\n                // IE7 is throwing an error when setting these properties with jQuery's\n                // attr() and removeAttr() methods...\n                th.removeAttribute('aria-sort');\n\n                /* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */\n                if (col.bSortable) {\n                    if (aSort.length > 0 && aSort[0].col == i) {\n                        th.setAttribute('aria-sort', aSort[0].dir == \"asc\" ? \"ascending\" : \"descending\");\n                        nextSort = asSorting[aSort[0].index + 1] || asSorting[0];\n                    }\n                    else {\n                        nextSort = asSorting[0];\n                    }\n\n                    label = sTitle + (nextSort === \"asc\" ?\n                        oAria.sSortAscending :\n                        oAria.sSortDescending\n                    );\n                }\n                else {\n                    label = sTitle;\n                }\n\n                th.setAttribute('aria-label', label);\n            }\n        }\n\n\n        /**\n         * Function to run on user sort request\n         *  @param {object} settings dataTables settings object\n         *  @param {node} attachTo node to attach the handler to\n         *  @param {int} colIdx column sorting index\n         *  @param {boolean} [append=false] Append the requested sort to the existing\n         *    sort if true (i.e. multi-column sort)\n         *  @param {function} [callback] callback function\n         *  @memberof DataTable#oApi\n         */\n        function _fnSortListener(settings, colIdx, append, callback) {\n            var col = settings.aoColumns[colIdx];\n            var sorting = settings.aaSorting;\n            var asSorting = col.asSorting;\n            var nextSortIdx;\n            var next = function (a, overflow) {\n                var idx = a._idx;\n                if (idx === undefined) {\n                    idx = $.inArray(a[1], asSorting);\n                }\n\n                return idx + 1 < asSorting.length ?\n                    idx + 1 :\n                    overflow ?\n                        null :\n                        0;\n            };\n\n            // Convert to 2D array if needed\n            if (typeof sorting[0] === 'number') {\n                sorting = settings.aaSorting = [sorting];\n            }\n\n            // If appending the sort then we are multi-column sorting\n            if (append && settings.oFeatures.bSortMulti) {\n                // Are we already doing some kind of sort on this column?\n                var sortIdx = $.inArray(colIdx, _pluck(sorting, '0'));\n\n                if (sortIdx !== -1) {\n                    // Yes, modify the sort\n                    nextSortIdx = next(sorting[sortIdx], true);\n\n                    if (nextSortIdx === null && sorting.length === 1) {\n                        nextSortIdx = 0; // can't remove sorting completely\n                    }\n\n                    if (nextSortIdx === null) {\n                        sorting.splice(sortIdx, 1);\n                    }\n                    else {\n                        sorting[sortIdx][1] = asSorting[nextSortIdx];\n                        sorting[sortIdx]._idx = nextSortIdx;\n                    }\n                }\n                else {\n                    // No sort on this column yet\n                    sorting.push([colIdx, asSorting[0], 0]);\n                    sorting[sorting.length - 1]._idx = 0;\n                }\n            }\n            else if (sorting.length && sorting[0][0] == colIdx) {\n                // Single column - already sorting on this column, modify the sort\n                nextSortIdx = next(sorting[0]);\n\n                sorting.length = 1;\n                sorting[0][1] = asSorting[nextSortIdx];\n                sorting[0]._idx = nextSortIdx;\n            }\n            else {\n                // Single column - sort only on this column\n                sorting.length = 0;\n                sorting.push([colIdx, asSorting[0]]);\n                sorting[0]._idx = 0;\n            }\n\n            // Run the sort by calling a full redraw\n            _fnReDraw(settings);\n\n            // callback used for async user interaction\n            if (typeof callback == 'function') {\n                callback(settings);\n            }\n        }\n\n\n        /**\n         * Attach a sort handler (click) to a node\n         *  @param {object} settings dataTables settings object\n         *  @param {node} attachTo node to attach the handler to\n         *  @param {int} colIdx column sorting index\n         *  @param {function} [callback] callback function\n         *  @memberof DataTable#oApi\n         */\n        function _fnSortAttachListener(settings, attachTo, colIdx, callback) {\n            var col = settings.aoColumns[colIdx];\n\n            _fnBindAction(attachTo, {}, function (e) {\n                /* If the column is not sortable - don't to anything */\n                if (col.bSortable === false) {\n                    return;\n                }\n\n                // If processing is enabled use a timeout to allow the processing\n                // display to be shown - otherwise to it synchronously\n                if (settings.oFeatures.bProcessing) {\n                    _fnProcessingDisplay(settings, true);\n\n                    setTimeout(function () {\n                        _fnSortListener(settings, colIdx, e.shiftKey, callback);\n\n                        // In server-side processing, the draw callback will remove the\n                        // processing display\n                        if (_fnDataSource(settings) !== 'ssp') {\n                            _fnProcessingDisplay(settings, false);\n                        }\n                    }, 0);\n                }\n                else {\n                    _fnSortListener(settings, colIdx, e.shiftKey, callback);\n                }\n            });\n        }\n\n\n        /**\n         * Set the sorting classes on table's body, Note: it is safe to call this function\n         * when bSort and bSortClasses are false\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnSortingClasses(settings) {\n            var oldSort = settings.aLastSort;\n            var sortClass = settings.oClasses.sSortColumn;\n            var sort = _fnSortFlatten(settings);\n            var features = settings.oFeatures;\n            var i, ien, colIdx;\n\n            if (features.bSort && features.bSortClasses) {\n                // Remove old sorting classes\n                for (i = 0, ien = oldSort.length; i < ien; i++) {\n                    colIdx = oldSort[i].src;\n\n                    // Remove column sorting\n                    $(_pluck(settings.aoData, 'anCells', colIdx))\n                        .removeClass(sortClass + (i < 2 ? i + 1 : 3));\n                }\n\n                // Add new column sorting\n                for (i = 0, ien = sort.length; i < ien; i++) {\n                    colIdx = sort[i].src;\n\n                    $(_pluck(settings.aoData, 'anCells', colIdx))\n                        .addClass(sortClass + (i < 2 ? i + 1 : 3));\n                }\n            }\n\n            settings.aLastSort = sort;\n        }\n\n\n        // Get the data to sort a column, be it from cache, fresh (populating the\n        // cache), or from a sort formatter\n        function _fnSortData(settings, idx) {\n            // Custom sorting function - provided by the sort data type\n            var column = settings.aoColumns[idx];\n            var customSort = DataTable.ext.order[column.sSortDataType];\n            var customData;\n\n            if (customSort) {\n                customData = customSort.call(settings.oInstance, settings, idx,\n                    _fnColumnIndexToVisible(settings, idx)\n                );\n            }\n\n            // Use / populate cache\n            var row, cellData;\n            var formatter = DataTable.ext.type.order[column.sType + \"-pre\"];\n\n            for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n                row = settings.aoData[i];\n\n                if (!row._aSortData) {\n                    row._aSortData = [];\n                }\n\n                if (!row._aSortData[idx] || customSort) {\n                    cellData = customSort ?\n                        customData[i] : // If there was a custom sort function, use data from there\n                        _fnGetCellData(settings, i, idx, 'sort');\n\n                    row._aSortData[idx] = formatter ?\n                        formatter(cellData) :\n                        cellData;\n                }\n            }\n        }\n\n\n\n        /**\n         * Save the state of a table\n         *  @param {object} oSettings dataTables settings object\n         *  @memberof DataTable#oApi\n         */\n        function _fnSaveState(settings) {\n            if (!settings.oFeatures.bStateSave || settings.bDestroying) {\n                return;\n            }\n\n            /* Store the interesting variables */\n            var state = {\n                time: +new Date(),\n                start: settings._iDisplayStart,\n                length: settings._iDisplayLength,\n                order: $.extend(true, [], settings.aaSorting),\n                search: _fnSearchToCamel(settings.oPreviousSearch),\n                columns: $.map(settings.aoColumns, function (col, i) {\n                    return {\n                        visible: col.bVisible,\n                        search: _fnSearchToCamel(settings.aoPreSearchCols[i])\n                    };\n                })\n            };\n\n            _fnCallbackFire(settings, \"aoStateSaveParams\", 'stateSaveParams', [settings, state]);\n\n            settings.oSavedState = state;\n            settings.fnStateSaveCallback.call(settings.oInstance, settings, state);\n        }\n\n\n        /**\n         * Attempt to load a saved table state\n         *  @param {object} oSettings dataTables settings object\n         *  @param {object} oInit DataTables init object so we can override settings\n         *  @param {function} callback Callback to execute when the state has been loaded\n         *  @memberof DataTable#oApi\n         */\n        function _fnLoadState(settings, oInit, callback) {\n            var i, ien;\n            var columns = settings.aoColumns;\n            var loaded = function (s) {\n                if (!s || !s.time) {\n                    callback();\n                    return;\n                }\n\n                // Allow custom and plug-in manipulation functions to alter the saved data set and\n                // cancelling of loading by returning false\n                var abStateLoad = _fnCallbackFire(settings, 'aoStateLoadParams', 'stateLoadParams', [settings, s]);\n                if ($.inArray(false, abStateLoad) !== -1) {\n                    callback();\n                    return;\n                }\n\n                // Reject old data\n                var duration = settings.iStateDuration;\n                if (duration > 0 && s.time < +new Date() - (duration * 1000)) {\n                    callback();\n                    return;\n                }\n\n                // Number of columns have changed - all bets are off, no restore of settings\n                if (s.columns && columns.length !== s.columns.length) {\n                    callback();\n                    return;\n                }\n\n                // Store the saved state so it might be accessed at any time\n                settings.oLoadedState = $.extend(true, {}, s);\n\n                // Restore key features - todo - for 1.11 this needs to be done by\n                // subscribed events\n                if (s.start !== undefined) {\n                    settings._iDisplayStart = s.start;\n                    settings.iInitDisplayStart = s.start;\n                }\n                if (s.length !== undefined) {\n                    settings._iDisplayLength = s.length;\n                }\n\n                // Order\n                if (s.order !== undefined) {\n                    settings.aaSorting = [];\n                    $.each(s.order, function (i, col) {\n                        settings.aaSorting.push(col[0] >= columns.length ?\n                            [0, col[1]] :\n                            col\n                        );\n                    });\n                }\n\n                // Search\n                if (s.search !== undefined) {\n                    $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search));\n                }\n\n                // Columns\n                //\n                if (s.columns) {\n                    for (i = 0, ien = s.columns.length; i < ien; i++) {\n                        var col = s.columns[i];\n\n                        // Visibility\n                        if (col.visible !== undefined) {\n                            columns[i].bVisible = col.visible;\n                        }\n\n                        // Search\n                        if (col.search !== undefined) {\n                            $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search));\n                        }\n                    }\n                }\n\n                _fnCallbackFire(settings, 'aoStateLoaded', 'stateLoaded', [settings, s]);\n                callback();\n            };\n\n            if (!settings.oFeatures.bStateSave) {\n                callback();\n                return;\n            }\n\n            var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);\n\n            if (state !== undefined) {\n                loaded(state);\n            }\n            // otherwise, wait for the loaded callback to be executed\n        }\n\n\n        /**\n         * Return the settings object for a particular table\n         *  @param {node} table table we are using as a dataTable\n         *  @returns {object} Settings object - or null if not found\n         *  @memberof DataTable#oApi\n         */\n        function _fnSettingsFromNode(table) {\n            var settings = DataTable.settings;\n            var idx = $.inArray(table, _pluck(settings, 'nTable'));\n\n            return idx !== -1 ?\n                settings[idx] :\n                null;\n        }\n\n\n        /**\n         * Log an error message\n         *  @param {object} settings dataTables settings object\n         *  @param {int} level log error messages, or display them to the user\n         *  @param {string} msg error message\n         *  @param {int} tn Technical note id to get more information about the error.\n         *  @memberof DataTable#oApi\n         */\n        function _fnLog(settings, level, msg, tn) {\n            msg = 'DataTables warning: ' +\n                (settings ? 'table id=' + settings.sTableId + ' - ' : '') + msg;\n\n            if (tn) {\n                msg += '. For more information about this error, please see ' +\n                    'http://datatables.net/tn/' + tn;\n            }\n\n            if (!level) {\n                // Backwards compatibility pre 1.10\n                var ext = DataTable.ext;\n                var type = ext.sErrMode || ext.errMode;\n\n                if (settings) {\n                    _fnCallbackFire(settings, null, 'error', [settings, tn, msg]);\n                }\n\n                if (type == 'alert') {\n                    alert(msg);\n                }\n                else if (type == 'throw') {\n                    throw new Error(msg);\n                }\n                else if (typeof type == 'function') {\n                    type(settings, tn, msg);\n                }\n            }\n            else if (window.console && console.log) {\n                console.log(msg);\n            }\n        }\n\n\n        /**\n         * See if a property is defined on one object, if so assign it to the other object\n         *  @param {object} ret target object\n         *  @param {object} src source object\n         *  @param {string} name property\n         *  @param {string} [mappedName] name to map too - optional, name used if not given\n         *  @memberof DataTable#oApi\n         */\n        function _fnMap(ret, src, name, mappedName) {\n            if (Array.isArray(name)) {\n                $.each(name, function (i, val) {\n                    if (Array.isArray(val)) {\n                        _fnMap(ret, src, val[0], val[1]);\n                    }\n                    else {\n                        _fnMap(ret, src, val);\n                    }\n                });\n\n                return;\n            }\n\n            if (mappedName === undefined) {\n                mappedName = name;\n            }\n\n            if (src[name] !== undefined) {\n                ret[mappedName] = src[name];\n            }\n        }\n\n\n        /**\n         * Extend objects - very similar to jQuery.extend, but deep copy objects, and\n         * shallow copy arrays. The reason we need to do this, is that we don't want to\n         * deep copy array init values (such as aaSorting) since the dev wouldn't be\n         * able to override them, but we do want to deep copy arrays.\n         *  @param {object} out Object to extend\n         *  @param {object} extender Object from which the properties will be applied to\n         *      out\n         *  @param {boolean} breakRefs If true, then arrays will be sliced to take an\n         *      independent copy with the exception of the `data` or `aaData` parameters\n         *      if they are present. This is so you can pass in a collection to\n         *      DataTables and have that used as your data source without breaking the\n         *      references\n         *  @returns {object} out Reference, just for convenience - out === the return.\n         *  @memberof DataTable#oApi\n         *  @todo This doesn't take account of arrays inside the deep copied objects.\n         */\n        function _fnExtend(out, extender, breakRefs) {\n            var val;\n\n            for (var prop in extender) {\n                if (extender.hasOwnProperty(prop)) {\n                    val = extender[prop];\n\n                    if ($.isPlainObject(val)) {\n                        if (!$.isPlainObject(out[prop])) {\n                            out[prop] = {};\n                        }\n                        $.extend(true, out[prop], val);\n                    }\n                    else if (breakRefs && prop !== 'data' && prop !== 'aaData' && Array.isArray(val)) {\n                        out[prop] = val.slice();\n                    }\n                    else {\n                        out[prop] = val;\n                    }\n                }\n            }\n\n            return out;\n        }\n\n\n        /**\n         * Bind an event handers to allow a click or return key to activate the callback.\n         * This is good for accessibility since a return on the keyboard will have the\n         * same effect as a click, if the element has focus.\n         *  @param {element} n Element to bind the action to\n         *  @param {object} oData Data object to pass to the triggered function\n         *  @param {function} fn Callback function for when the event is triggered\n         *  @memberof DataTable#oApi\n         */\n        function _fnBindAction(n, oData, fn) {\n            $(n)\n                .on('click.DT', oData, function (e) {\n                    $(n).trigger('blur'); // Remove focus outline for mouse users\n                    fn(e);\n                })\n                .on('keypress.DT', oData, function (e) {\n                    if (e.which === 13) {\n                        e.preventDefault();\n                        fn(e);\n                    }\n                })\n                .on('selectstart.DT', function () {\n                    /* Take the brutal approach to cancelling text selection */\n                    return false;\n                });\n        }\n\n\n        /**\n         * Register a callback function. Easily allows a callback function to be added to\n         * an array store of callback functions that can then all be called together.\n         *  @param {object} oSettings dataTables settings object\n         *  @param {string} sStore Name of the array storage for the callbacks in oSettings\n         *  @param {function} fn Function to be called back\n         *  @param {string} sName Identifying name for the callback (i.e. a label)\n         *  @memberof DataTable#oApi\n         */\n        function _fnCallbackReg(oSettings, sStore, fn, sName) {\n            if (fn) {\n                oSettings[sStore].push({\n                    \"fn\": fn,\n                    \"sName\": sName\n                });\n            }\n        }\n\n\n        /**\n         * Fire callback functions and trigger events. Note that the loop over the\n         * callback array store is done backwards! Further note that you do not want to\n         * fire off triggers in time sensitive applications (for example cell creation)\n         * as its slow.\n         *  @param {object} settings dataTables settings object\n         *  @param {string} callbackArr Name of the array storage for the callbacks in\n         *      oSettings\n         *  @param {string} eventName Name of the jQuery custom event to trigger. If\n         *      null no trigger is fired\n         *  @param {array} args Array of arguments to pass to the callback function /\n         *      trigger\n         *  @memberof DataTable#oApi\n         */\n        function _fnCallbackFire(settings, callbackArr, eventName, args) {\n            var ret = [];\n\n            if (callbackArr) {\n                ret = $.map(settings[callbackArr].slice().reverse(), function (val, i) {\n                    return val.fn.apply(settings.oInstance, args);\n                });\n            }\n\n            if (eventName !== null) {\n                var e = $.Event(eventName + '.dt');\n\n                $(settings.nTable).trigger(e, args);\n\n                ret.push(e.result);\n            }\n\n            return ret;\n        }\n\n\n        function _fnLengthOverflow(settings) {\n            var\n                start = settings._iDisplayStart,\n                end = settings.fnDisplayEnd(),\n                len = settings._iDisplayLength;\n\n            /* If we have space to show extra rows (backing up from the end point - then do so */\n            if (start >= end) {\n                start = end - len;\n            }\n\n            // Keep the start record on the current page\n            start -= (start % len);\n\n            if (len === -1 || start < 0) {\n                start = 0;\n            }\n\n            settings._iDisplayStart = start;\n        }\n\n\n        function _fnRenderer(settings, type) {\n            var renderer = settings.renderer;\n            var host = DataTable.ext.renderer[type];\n\n            if ($.isPlainObject(renderer) && renderer[type]) {\n                // Specific renderer for this type. If available use it, otherwise use\n                // the default.\n                return host[renderer[type]] || host._;\n            }\n            else if (typeof renderer === 'string') {\n                // Common renderer - if there is one available for this type use it,\n                // otherwise use the default\n                return host[renderer] || host._;\n            }\n\n            // Use the default\n            return host._;\n        }\n\n\n        /**\n         * Detect the data source being used for the table. Used to simplify the code\n         * a little (ajax) and to make it compress a little smaller.\n         *\n         *  @param {object} settings dataTables settings object\n         *  @returns {string} Data source\n         *  @memberof DataTable#oApi\n         */\n        function _fnDataSource(settings) {\n            if (settings.oFeatures.bServerSide) {\n                return 'ssp';\n            }\n            else if (settings.ajax || settings.sAjaxSource) {\n                return 'ajax';\n            }\n            return 'dom';\n        }\n\n\n\n\n        /**\n         * Computed structure of the DataTables API, defined by the options passed to\n         * `DataTable.Api.register()` when building the API.\n         *\n         * The structure is built in order to speed creation and extension of the Api\n         * objects since the extensions are effectively pre-parsed.\n         *\n         * The array is an array of objects with the following structure, where this\n         * base array represents the Api prototype base:\n         *\n         *     [\n         *       {\n         *         name:      'data'                -- string   - Property name\n         *         val:       function () {},       -- function - Api method (or undefined if just an object\n         *         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n         *         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n         *       },\n         *       {\n         *         name:     'row'\n         *         val:       {},\n         *         methodExt: [ ... ],\n         *         propExt:   [\n         *           {\n         *             name:      'data'\n         *             val:       function () {},\n         *             methodExt: [ ... ],\n         *             propExt:   [ ... ]\n         *           },\n         *           ...\n         *         ]\n         *       }\n         *     ]\n         *\n         * @type {Array}\n         * @ignore\n         */\n        var __apiStruct = [];\n\n\n        /**\n         * `Array.prototype` reference.\n         *\n         * @type object\n         * @ignore\n         */\n        var __arrayProto = Array.prototype;\n\n\n        /**\n         * Abstraction for `context` parameter of the `Api` constructor to allow it to\n         * take several different forms for ease of use.\n         *\n         * Each of the input parameter types will be converted to a DataTables settings\n         * object where possible.\n         *\n         * @param  {string|node|jQuery|object} mixed DataTable identifier. Can be one\n         *   of:\n         *\n         *   * `string` - jQuery selector. Any DataTables' matching the given selector\n         *     with be found and used.\n         *   * `node` - `TABLE` node which has already been formed into a DataTable.\n         *   * `jQuery` - A jQuery object of `TABLE` nodes.\n         *   * `object` - DataTables settings object\n         *   * `DataTables.Api` - API instance\n         * @return {array|null} Matching DataTables settings objects. `null` or\n         *   `undefined` is returned if no matching DataTable is found.\n         * @ignore\n         */\n        var _toSettings = function (mixed) {\n            var idx, jq;\n            var settings = DataTable.settings;\n            var tables = $.map(settings, function (el, i) {\n                return el.nTable;\n            });\n\n            if (!mixed) {\n                return [];\n            }\n            else if (mixed.nTable && mixed.oApi) {\n                // DataTables settings object\n                return [mixed];\n            }\n            else if (mixed.nodeName && mixed.nodeName.toLowerCase() === 'table') {\n                // Table node\n                idx = $.inArray(mixed, tables);\n                return idx !== -1 ? [settings[idx]] : null;\n            }\n            else if (mixed && typeof mixed.settings === 'function') {\n                return mixed.settings().toArray();\n            }\n            else if (typeof mixed === 'string') {\n                // jQuery selector\n                jq = $(mixed);\n            }\n            else if (mixed instanceof $) {\n                // jQuery object (also DataTables instance)\n                jq = mixed;\n            }\n\n            if (jq) {\n                return jq.map(function (i) {\n                    idx = $.inArray(this, tables);\n                    return idx !== -1 ? settings[idx] : null;\n                }).toArray();\n            }\n        };\n\n\n        /**\n         * DataTables API class - used to control and interface with  one or more\n         * DataTables enhanced tables.\n         *\n         * The API class is heavily based on jQuery, presenting a chainable interface\n         * that you can use to interact with tables. Each instance of the API class has\n         * a \"context\" - i.e. the tables that it will operate on. This could be a single\n         * table, all tables on a page or a sub-set thereof.\n         *\n         * Additionally the API is designed to allow you to easily work with the data in\n         * the tables, retrieving and manipulating it as required. This is done by\n         * presenting the API class as an array like interface. The contents of the\n         * array depend upon the actions requested by each method (for example\n         * `rows().nodes()` will return an array of nodes, while `rows().data()` will\n         * return an array of objects or arrays depending upon your table's\n         * configuration). The API object has a number of array like methods (`push`,\n         * `pop`, `reverse` etc) as well as additional helper methods (`each`, `pluck`,\n         * `unique` etc) to assist your working with the data held in a table.\n         *\n         * Most methods (those which return an Api instance) are chainable, which means\n         * the return from a method call also has all of the methods available that the\n         * top level object had. For example, these two calls are equivalent:\n         *\n         *     // Not chained\n         *     api.row.add( {...} );\n         *     api.draw();\n         *\n         *     // Chained\n         *     api.row.add( {...} ).draw();\n         *\n         * @class DataTable.Api\n         * @param {array|object|string|jQuery} context DataTable identifier. This is\n         *   used to define which DataTables enhanced tables this API will operate on.\n         *   Can be one of:\n         *\n         *   * `string` - jQuery selector. Any DataTables' matching the given selector\n         *     with be found and used.\n         *   * `node` - `TABLE` node which has already been formed into a DataTable.\n         *   * `jQuery` - A jQuery object of `TABLE` nodes.\n         *   * `object` - DataTables settings object\n         * @param {array} [data] Data to initialise the Api instance with.\n         *\n         * @example\n         *   // Direct initialisation during DataTables construction\n         *   var api = $('#example').DataTable();\n         *\n         * @example\n         *   // Initialisation using a DataTables jQuery object\n         *   var api = $('#example').dataTable().api();\n         *\n         * @example\n         *   // Initialisation as a constructor\n         *   var api = new $.fn.DataTable.Api( 'table.dataTable' );\n         */\n        _Api = function (context, data) {\n            if (!(this instanceof _Api)) {\n                return new _Api(context, data);\n            }\n\n            var settings = [];\n            var ctxSettings = function (o) {\n                var a = _toSettings(o);\n                if (a) {\n                    settings.push.apply(settings, a);\n                }\n            };\n\n            if (Array.isArray(context)) {\n                for (var i = 0, ien = context.length; i < ien; i++) {\n                    ctxSettings(context[i]);\n                }\n            }\n            else {\n                ctxSettings(context);\n            }\n\n            // Remove duplicates\n            this.context = _unique(settings);\n\n            // Initial data\n            if (data) {\n                $.merge(this, data);\n            }\n\n            // selector\n            this.selector = {\n                rows: null,\n                cols: null,\n                opts: null\n            };\n\n            _Api.extend(this, this, __apiStruct);\n        };\n\n        DataTable.Api = _Api;\n\n        // Don't destroy the existing prototype, just extend it. Required for jQuery 2's\n        // isPlainObject.\n        $.extend(_Api.prototype, {\n            any: function () {\n                return this.count() !== 0;\n            },\n\n\n            concat: __arrayProto.concat,\n\n\n            context: [], // array of table settings objects\n\n\n            count: function () {\n                return this.flatten().length;\n            },\n\n\n            each: function (fn) {\n                for (var i = 0, ien = this.length; i < ien; i++) {\n                    fn.call(this, this[i], i, this);\n                }\n\n                return this;\n            },\n\n\n            eq: function (idx) {\n                var ctx = this.context;\n\n                return ctx.length > idx ?\n                    new _Api(ctx[idx], this[idx]) :\n                    null;\n            },\n\n\n            filter: function (fn) {\n                var a = [];\n\n                if (__arrayProto.filter) {\n                    a = __arrayProto.filter.call(this, fn, this);\n                }\n                else {\n                    // Compatibility for browsers without EMCA-252-5 (JS 1.6)\n                    for (var i = 0, ien = this.length; i < ien; i++) {\n                        if (fn.call(this, this[i], i, this)) {\n                            a.push(this[i]);\n                        }\n                    }\n                }\n\n                return new _Api(this.context, a);\n            },\n\n\n            flatten: function () {\n                var a = [];\n                return new _Api(this.context, a.concat.apply(a, this.toArray()));\n            },\n\n\n            join: __arrayProto.join,\n\n\n            indexOf: __arrayProto.indexOf || function (obj, start) {\n                for (var i = (start || 0), ien = this.length; i < ien; i++) {\n                    if (this[i] === obj) {\n                        return i;\n                    }\n                }\n                return -1;\n            },\n\n            iterator: function (flatten, type, fn, alwaysNew) {\n                var\n                    a = [], ret,\n                    i, ien, j, jen,\n                    context = this.context,\n                    rows, items, item,\n                    selector = this.selector;\n\n                // Argument shifting\n                if (typeof flatten === 'string') {\n                    alwaysNew = fn;\n                    fn = type;\n                    type = flatten;\n                    flatten = false;\n                }\n\n                for (i = 0, ien = context.length; i < ien; i++) {\n                    var apiInst = new _Api(context[i]);\n\n                    if (type === 'table') {\n                        ret = fn.call(apiInst, context[i], i);\n\n                        if (ret !== undefined) {\n                            a.push(ret);\n                        }\n                    }\n                    else if (type === 'columns' || type === 'rows') {\n                        // this has same length as context - one entry for each table\n                        ret = fn.call(apiInst, context[i], this[i], i);\n\n                        if (ret !== undefined) {\n                            a.push(ret);\n                        }\n                    }\n                    else if (type === 'column' || type === 'column-rows' || type === 'row' || type === 'cell') {\n                        // columns and rows share the same structure.\n                        // 'this' is an array of column indexes for each context\n                        items = this[i];\n\n                        if (type === 'column-rows') {\n                            rows = _selector_row_indexes(context[i], selector.opts);\n                        }\n\n                        for (j = 0, jen = items.length; j < jen; j++) {\n                            item = items[j];\n\n                            if (type === 'cell') {\n                                ret = fn.call(apiInst, context[i], item.row, item.column, i, j);\n                            }\n                            else {\n                                ret = fn.call(apiInst, context[i], item, i, j, rows);\n                            }\n\n                            if (ret !== undefined) {\n                                a.push(ret);\n                            }\n                        }\n                    }\n                }\n\n                if (a.length || alwaysNew) {\n                    var api = new _Api(context, flatten ? a.concat.apply([], a) : a);\n                    var apiSelector = api.selector;\n                    apiSelector.rows = selector.rows;\n                    apiSelector.cols = selector.cols;\n                    apiSelector.opts = selector.opts;\n                    return api;\n                }\n                return this;\n            },\n\n\n            lastIndexOf: __arrayProto.lastIndexOf || function (obj, start) {\n                // Bit cheeky...\n                return this.indexOf.apply(this.toArray.reverse(), arguments);\n            },\n\n\n            length: 0,\n\n\n            map: function (fn) {\n                var a = [];\n\n                if (__arrayProto.map) {\n                    a = __arrayProto.map.call(this, fn, this);\n                }\n                else {\n                    // Compatibility for browsers without EMCA-252-5 (JS 1.6)\n                    for (var i = 0, ien = this.length; i < ien; i++) {\n                        a.push(fn.call(this, this[i], i));\n                    }\n                }\n\n                return new _Api(this.context, a);\n            },\n\n\n            pluck: function (prop) {\n                return this.map(function (el) {\n                    return el[prop];\n                });\n            },\n\n            pop: __arrayProto.pop,\n\n\n            push: __arrayProto.push,\n\n\n            // Does not return an API instance\n            reduce: __arrayProto.reduce || function (fn, init) {\n                return _fnReduce(this, fn, init, 0, this.length, 1);\n            },\n\n\n            reduceRight: __arrayProto.reduceRight || function (fn, init) {\n                return _fnReduce(this, fn, init, this.length - 1, -1, -1);\n            },\n\n\n            reverse: __arrayProto.reverse,\n\n\n            // Object with rows, columns and opts\n            selector: null,\n\n\n            shift: __arrayProto.shift,\n\n\n            slice: function () {\n                return new _Api(this.context, this);\n            },\n\n\n            sort: __arrayProto.sort, // ? name - order?\n\n\n            splice: __arrayProto.splice,\n\n\n            toArray: function () {\n                return __arrayProto.slice.call(this);\n            },\n\n\n            to$: function () {\n                return $(this);\n            },\n\n\n            toJQuery: function () {\n                return $(this);\n            },\n\n\n            unique: function () {\n                return new _Api(this.context, _unique(this));\n            },\n\n\n            unshift: __arrayProto.unshift\n        });\n\n\n        _Api.extend = function (scope, obj, ext) {\n            // Only extend API instances and static properties of the API\n            if (!ext.length || !obj || (!(obj instanceof _Api) && !obj.__dt_wrapper)) {\n                return;\n            }\n\n            var\n                i, ien,\n                struct,\n                methodScoping = function (scope, fn, struc) {\n                    return function () {\n                        var ret = fn.apply(scope, arguments);\n\n                        // Method extension\n                        _Api.extend(ret, ret, struc.methodExt);\n                        return ret;\n                    };\n                };\n\n            for (i = 0, ien = ext.length; i < ien; i++) {\n                struct = ext[i];\n\n                // Value\n                obj[struct.name] = struct.type === 'function' ?\n                    methodScoping(scope, struct.val, struct) :\n                    struct.type === 'object' ?\n                        {} :\n                        struct.val;\n\n                obj[struct.name].__dt_wrapper = true;\n\n                // Property extension\n                _Api.extend(scope, obj[struct.name], struct.propExt);\n            }\n        };\n\n\n        // @todo - Is there need for an augment function?\n        // _Api.augment = function ( inst, name )\n        // {\n        // \t// Find src object in the structure from the name\n        // \tvar parts = name.split('.');\n\n        // \t_Api.extend( inst, obj );\n        // };\n\n\n        //     [\n        //       {\n        //         name:      'data'                -- string   - Property name\n        //         val:       function () {},       -- function - Api method (or undefined if just an object\n        //         methodExt: [ ... ],              -- array    - Array of Api object definitions to extend the method result\n        //         propExt:   [ ... ]               -- array    - Array of Api object definitions to extend the property\n        //       },\n        //       {\n        //         name:     'row'\n        //         val:       {},\n        //         methodExt: [ ... ],\n        //         propExt:   [\n        //           {\n        //             name:      'data'\n        //             val:       function () {},\n        //             methodExt: [ ... ],\n        //             propExt:   [ ... ]\n        //           },\n        //           ...\n        //         ]\n        //       }\n        //     ]\n\n        _Api.register = _api_register = function (name, val) {\n            if (Array.isArray(name)) {\n                for (var j = 0, jen = name.length; j < jen; j++) {\n                    _Api.register(name[j], val);\n                }\n                return;\n            }\n\n            var\n                i, ien,\n                heir = name.split('.'),\n                struct = __apiStruct,\n                key, method;\n\n            var find = function (src, name) {\n                for (var i = 0, ien = src.length; i < ien; i++) {\n                    if (src[i].name === name) {\n                        return src[i];\n                    }\n                }\n                return null;\n            };\n\n            for (i = 0, ien = heir.length; i < ien; i++) {\n                method = heir[i].indexOf('()') !== -1;\n                key = method ?\n                    heir[i].replace('()', '') :\n                    heir[i];\n\n                var src = find(struct, key);\n                if (!src) {\n                    src = {\n                        name: key,\n                        val: {},\n                        methodExt: [],\n                        propExt: [],\n                        type: 'object'\n                    };\n                    struct.push(src);\n                }\n\n                if (i === ien - 1) {\n                    src.val = val;\n                    src.type = typeof val === 'function' ?\n                        'function' :\n                        $.isPlainObject(val) ?\n                            'object' :\n                            'other';\n                }\n                else {\n                    struct = method ?\n                        src.methodExt :\n                        src.propExt;\n                }\n            }\n        };\n\n        _Api.registerPlural = _api_registerPlural = function (pluralName, singularName, val) {\n            _Api.register(pluralName, val);\n\n            _Api.register(singularName, function () {\n                var ret = val.apply(this, arguments);\n\n                if (ret === this) {\n                    // Returned item is the API instance that was passed in, return it\n                    return this;\n                }\n                else if (ret instanceof _Api) {\n                    // New API instance returned, want the value from the first item\n                    // in the returned array for the singular result.\n                    return ret.length ?\n                        Array.isArray(ret[0]) ?\n                            new _Api(ret.context, ret[0]) : // Array results are 'enhanced'\n                            ret[0] :\n                        undefined;\n                }\n\n                // Non-API return - just fire it back\n                return ret;\n            });\n        };\n\n\n        /**\n         * Selector for HTML tables. Apply the given selector to the give array of\n         * DataTables settings objects.\n         *\n         * @param {string|integer} [selector] jQuery selector string or integer\n         * @param  {array} Array of DataTables settings objects to be filtered\n         * @return {array}\n         * @ignore\n         */\n        var __table_selector = function (selector, a) {\n            if (Array.isArray(selector)) {\n                return $.map(selector, function (item) {\n                    return __table_selector(item, a);\n                });\n            }\n\n            // Integer is used to pick out a table by index\n            if (typeof selector === 'number') {\n                return [a[selector]];\n            }\n\n            // Perform a jQuery selector on the table nodes\n            var nodes = $.map(a, function (el, i) {\n                return el.nTable;\n            });\n\n            return $(nodes)\n                .filter(selector)\n                .map(function (i) {\n                    // Need to translate back from the table node to the settings\n                    var idx = $.inArray(this, nodes);\n                    return a[idx];\n                })\n                .toArray();\n        };\n\n\n\n        /**\n         * Context selector for the API's context (i.e. the tables the API instance\n         * refers to.\n         *\n         * @name    DataTable.Api#tables\n         * @param {string|integer} [selector] Selector to pick which tables the iterator\n         *   should operate on. If not given, all tables in the current context are\n         *   used. This can be given as a jQuery selector (for example `':gt(0)'`) to\n         *   select multiple tables or as an integer to select a single table.\n         * @returns {DataTable.Api} Returns a new API instance if a selector is given.\n         */\n        _api_register('tables()', function (selector) {\n            // A new instance is created if there was a selector specified\n            return selector !== undefined && selector !== null ?\n                new _Api(__table_selector(selector, this.context)) :\n                this;\n        });\n\n\n        _api_register('table()', function (selector) {\n            var tables = this.tables(selector);\n            var ctx = tables.context;\n\n            // Truncate to the first matched table\n            return ctx.length ?\n                new _Api(ctx[0]) :\n                tables;\n        });\n\n\n        _api_registerPlural('tables().nodes()', 'table().node()', function () {\n            return this.iterator('table', function (ctx) {\n                return ctx.nTable;\n            }, 1);\n        });\n\n\n        _api_registerPlural('tables().body()', 'table().body()', function () {\n            return this.iterator('table', function (ctx) {\n                return ctx.nTBody;\n            }, 1);\n        });\n\n\n        _api_registerPlural('tables().header()', 'table().header()', function () {\n            return this.iterator('table', function (ctx) {\n                return ctx.nTHead;\n            }, 1);\n        });\n\n\n        _api_registerPlural('tables().footer()', 'table().footer()', function () {\n            return this.iterator('table', function (ctx) {\n                return ctx.nTFoot;\n            }, 1);\n        });\n\n\n        _api_registerPlural('tables().containers()', 'table().container()', function () {\n            return this.iterator('table', function (ctx) {\n                return ctx.nTableWrapper;\n            }, 1);\n        });\n\n\n\n        /**\n         * Redraw the tables in the current context.\n         */\n        _api_register('draw()', function (paging) {\n            return this.iterator('table', function (settings) {\n                if (paging === 'page') {\n                    _fnDraw(settings);\n                }\n                else {\n                    if (typeof paging === 'string') {\n                        paging = paging === 'full-hold' ?\n                            false :\n                            true;\n                    }\n\n                    _fnReDraw(settings, paging === false);\n                }\n            });\n        });\n\n\n\n        /**\n         * Get the current page index.\n         *\n         * @return {integer} Current page index (zero based)\n         *//**\n        * Set the current page.\n        *\n        * Note that if you attempt to show a page which does not exist, DataTables will\n        * not throw an error, but rather reset the paging.\n        *\n        * @param {integer|string} action The paging action to take. This can be one of:\n        *  * `integer` - The page index to jump to\n        *  * `string` - An action to take:\n        *    * `first` - Jump to first page.\n        *    * `next` - Jump to the next page\n        *    * `previous` - Jump to previous page\n        *    * `last` - Jump to the last page.\n        * @returns {DataTables.Api} this\n        */\n        _api_register('page()', function (action) {\n            if (action === undefined) {\n                return this.page.info().page; // not an expensive call\n            }\n\n            // else, have an action to take on all tables\n            return this.iterator('table', function (settings) {\n                _fnPageChange(settings, action);\n            });\n        });\n\n\n        /**\n         * Paging information for the first table in the current context.\n         *\n         * If you require paging information for another table, use the `table()` method\n         * with a suitable selector.\n         *\n         * @return {object} Object with the following properties set:\n         *  * `page` - Current page index (zero based - i.e. the first page is `0`)\n         *  * `pages` - Total number of pages\n         *  * `start` - Display index for the first record shown on the current page\n         *  * `end` - Display index for the last record shown on the current page\n         *  * `length` - Display length (number of records). Note that generally `start\n         *    + length = end`, but this is not always true, for example if there are\n         *    only 2 records to show on the final page, with a length of 10.\n         *  * `recordsTotal` - Full data set length\n         *  * `recordsDisplay` - Data set length once the current filtering criterion\n         *    are applied.\n         */\n        _api_register('page.info()', function (action) {\n            if (this.context.length === 0) {\n                return undefined;\n            }\n\n            var\n                settings = this.context[0],\n                start = settings._iDisplayStart,\n                len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,\n                visRecords = settings.fnRecordsDisplay(),\n                all = len === -1;\n\n            return {\n                \"page\": all ? 0 : Math.floor(start / len),\n                \"pages\": all ? 1 : Math.ceil(visRecords / len),\n                \"start\": start,\n                \"end\": settings.fnDisplayEnd(),\n                \"length\": len,\n                \"recordsTotal\": settings.fnRecordsTotal(),\n                \"recordsDisplay\": visRecords,\n                \"serverSide\": _fnDataSource(settings) === 'ssp'\n            };\n        });\n\n\n        /**\n         * Get the current page length.\n         *\n         * @return {integer} Current page length. Note `-1` indicates that all records\n         *   are to be shown.\n         *//**\n        * Set the current page length.\n        *\n        * @param {integer} Page length to set. Use `-1` to show all records.\n        * @returns {DataTables.Api} this\n        */\n        _api_register('page.len()', function (len) {\n            // Note that we can't call this function 'length()' because `length`\n            // is a Javascript property of functions which defines how many arguments\n            // the function expects.\n            if (len === undefined) {\n                return this.context.length !== 0 ?\n                    this.context[0]._iDisplayLength :\n                    undefined;\n            }\n\n            // else, set the page length\n            return this.iterator('table', function (settings) {\n                _fnLengthChange(settings, len);\n            });\n        });\n\n\n\n        var __reload = function (settings, holdPosition, callback) {\n            // Use the draw event to trigger a callback\n            if (callback) {\n                var api = new _Api(settings);\n\n                api.one('draw', function () {\n                    callback(api.ajax.json());\n                });\n            }\n\n            if (_fnDataSource(settings) == 'ssp') {\n                _fnReDraw(settings, holdPosition);\n            }\n            else {\n                _fnProcessingDisplay(settings, true);\n\n                // Cancel an existing request\n                var xhr = settings.jqXHR;\n                if (xhr && xhr.readyState !== 4) {\n                    xhr.abort();\n                }\n\n                // Trigger xhr\n                _fnBuildAjax(settings, [], function (json) {\n                    _fnClearTable(settings);\n\n                    var data = _fnAjaxDataSrc(settings, json);\n                    for (var i = 0, ien = data.length; i < ien; i++) {\n                        _fnAddData(settings, data[i]);\n                    }\n\n                    _fnReDraw(settings, holdPosition);\n                    _fnProcessingDisplay(settings, false);\n                });\n            }\n        };\n\n\n        /**\n         * Get the JSON response from the last Ajax request that DataTables made to the\n         * server. Note that this returns the JSON from the first table in the current\n         * context.\n         *\n         * @return {object} JSON received from the server.\n         */\n        _api_register('ajax.json()', function () {\n            var ctx = this.context;\n\n            if (ctx.length > 0) {\n                return ctx[0].json;\n            }\n\n            // else return undefined;\n        });\n\n\n        /**\n         * Get the data submitted in the last Ajax request\n         */\n        _api_register('ajax.params()', function () {\n            var ctx = this.context;\n\n            if (ctx.length > 0) {\n                return ctx[0].oAjaxData;\n            }\n\n            // else return undefined;\n        });\n\n\n        /**\n         * Reload tables from the Ajax data source. Note that this function will\n         * automatically re-draw the table when the remote data has been loaded.\n         *\n         * @param {boolean} [reset=true] Reset (default) or hold the current paging\n         *   position. A full re-sort and re-filter is performed when this method is\n         *   called, which is why the pagination reset is the default action.\n         * @returns {DataTables.Api} this\n         */\n        _api_register('ajax.reload()', function (callback, resetPaging) {\n            return this.iterator('table', function (settings) {\n                __reload(settings, resetPaging === false, callback);\n            });\n        });\n\n\n        /**\n         * Get the current Ajax URL. Note that this returns the URL from the first\n         * table in the current context.\n         *\n         * @return {string} Current Ajax source URL\n         *//**\n        * Set the Ajax URL. Note that this will set the URL for all tables in the\n        * current context.\n        *\n        * @param {string} url URL to set.\n        * @returns {DataTables.Api} this\n        */\n        _api_register('ajax.url()', function (url) {\n            var ctx = this.context;\n\n            if (url === undefined) {\n                // get\n                if (ctx.length === 0) {\n                    return undefined;\n                }\n                ctx = ctx[0];\n\n                return ctx.ajax ?\n                    $.isPlainObject(ctx.ajax) ?\n                        ctx.ajax.url :\n                        ctx.ajax :\n                    ctx.sAjaxSource;\n            }\n\n            // set\n            return this.iterator('table', function (settings) {\n                if ($.isPlainObject(settings.ajax)) {\n                    settings.ajax.url = url;\n                }\n                else {\n                    settings.ajax = url;\n                }\n                // No need to consider sAjaxSource here since DataTables gives priority\n                // to `ajax` over `sAjaxSource`. So setting `ajax` here, renders any\n                // value of `sAjaxSource` redundant.\n            });\n        });\n\n\n        /**\n         * Load data from the newly set Ajax URL. Note that this method is only\n         * available when `ajax.url()` is used to set a URL. Additionally, this method\n         * has the same effect as calling `ajax.reload()` but is provided for\n         * convenience when setting a new URL. Like `ajax.reload()` it will\n         * automatically redraw the table once the remote data has been loaded.\n         *\n         * @returns {DataTables.Api} this\n         */\n        _api_register('ajax.url().load()', function (callback, resetPaging) {\n            // Same as a reload, but makes sense to present it for easy access after a\n            // url change\n            return this.iterator('table', function (ctx) {\n                __reload(ctx, resetPaging === false, callback);\n            });\n        });\n\n\n\n\n        var _selector_run = function (type, selector, selectFn, settings, opts) {\n            var\n                out = [], res,\n                a, i, ien, j, jen,\n                selectorType = typeof selector;\n\n            // Can't just check for isArray here, as an API or jQuery instance might be\n            // given with their array like look\n            if (!selector || selectorType === 'string' || selectorType === 'function' || selector.length === undefined) {\n                selector = [selector];\n            }\n\n            for (i = 0, ien = selector.length; i < ien; i++) {\n                // Only split on simple strings - complex expressions will be jQuery selectors\n                a = selector[i] && selector[i].split && !selector[i].match(/[\\[\\(:]/) ?\n                    selector[i].split(',') :\n                    [selector[i]];\n\n                for (j = 0, jen = a.length; j < jen; j++) {\n                    res = selectFn(typeof a[j] === 'string' ? (a[j]).trim() : a[j]);\n\n                    if (res && res.length) {\n                        out = out.concat(res);\n                    }\n                }\n            }\n\n            // selector extensions\n            var ext = _ext.selector[type];\n            if (ext.length) {\n                for (i = 0, ien = ext.length; i < ien; i++) {\n                    out = ext[i](settings, opts, out);\n                }\n            }\n\n            return _unique(out);\n        };\n\n\n        var _selector_opts = function (opts) {\n            if (!opts) {\n                opts = {};\n            }\n\n            // Backwards compatibility for 1.9- which used the terminology filter rather\n            // than search\n            if (opts.filter && opts.search === undefined) {\n                opts.search = opts.filter;\n            }\n\n            return $.extend({\n                search: 'none',\n                order: 'current',\n                page: 'all'\n            }, opts);\n        };\n\n\n        var _selector_first = function (inst) {\n            // Reduce the API instance to the first item found\n            for (var i = 0, ien = inst.length; i < ien; i++) {\n                if (inst[i].length > 0) {\n                    // Assign the first element to the first item in the instance\n                    // and truncate the instance and context\n                    inst[0] = inst[i];\n                    inst[0].length = 1;\n                    inst.length = 1;\n                    inst.context = [inst.context[i]];\n\n                    return inst;\n                }\n            }\n\n            // Not found - return an empty instance\n            inst.length = 0;\n            return inst;\n        };\n\n\n        var _selector_row_indexes = function (settings, opts) {\n            var\n                i, ien, tmp, a = [],\n                displayFiltered = settings.aiDisplay,\n                displayMaster = settings.aiDisplayMaster;\n\n            var\n                search = opts.search,  // none, applied, removed\n                order = opts.order,   // applied, current, index (original - compatibility with 1.9)\n                page = opts.page;    // all, current\n\n            if (_fnDataSource(settings) == 'ssp') {\n                // In server-side processing mode, most options are irrelevant since\n                // rows not shown don't exist and the index order is the applied order\n                // Removed is a special case - for consistency just return an empty\n                // array\n                return search === 'removed' ?\n                    [] :\n                    _range(0, displayMaster.length);\n            }\n            else if (page == 'current') {\n                // Current page implies that order=current and fitler=applied, since it is\n                // fairly senseless otherwise, regardless of what order and search actually\n                // are\n                for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {\n                    a.push(displayFiltered[i]);\n                }\n            }\n            else if (order == 'current' || order == 'applied') {\n                if (search == 'none') {\n                    a = displayMaster.slice();\n                }\n                else if (search == 'applied') {\n                    a = displayFiltered.slice();\n                }\n                else if (search == 'removed') {\n                    // O(n+m) solution by creating a hash map\n                    var displayFilteredMap = {};\n\n                    for (var i = 0, ien = displayFiltered.length; i < ien; i++) {\n                        displayFilteredMap[displayFiltered[i]] = null;\n                    }\n\n                    a = $.map(displayMaster, function (el) {\n                        return !displayFilteredMap.hasOwnProperty(el) ?\n                            el :\n                            null;\n                    });\n                }\n            }\n            else if (order == 'index' || order == 'original') {\n                for (i = 0, ien = settings.aoData.length; i < ien; i++) {\n                    if (search == 'none') {\n                        a.push(i);\n                    }\n                    else { // applied | removed\n                        tmp = $.inArray(i, displayFiltered);\n\n                        if ((tmp === -1 && search == 'removed') ||\n                            (tmp >= 0 && search == 'applied')) {\n                            a.push(i);\n                        }\n                    }\n                }\n            }\n\n            return a;\n        };\n\n\n        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         * Rows\n         *\n         * {}          - no selector - use all available rows\n         * {integer}   - row aoData index\n         * {node}      - TR node\n         * {string}    - jQuery selector to apply to the TR elements\n         * {array}     - jQuery array of nodes, or simply an array of TR nodes\n         *\n         */\n        var __row_selector = function (settings, selector, opts) {\n            var rows;\n            var run = function (sel) {\n                var selInt = _intVal(sel);\n                var i, ien;\n                var aoData = settings.aoData;\n\n                // Short cut - selector is a number and no options provided (default is\n                // all records, so no need to check if the index is in there, since it\n                // must be - dev error if the index doesn't exist).\n                if (selInt !== null && !opts) {\n                    return [selInt];\n                }\n\n                if (!rows) {\n                    rows = _selector_row_indexes(settings, opts);\n                }\n\n                if (selInt !== null && $.inArray(selInt, rows) !== -1) {\n                    // Selector - integer\n                    return [selInt];\n                }\n                else if (sel === null || sel === undefined || sel === '') {\n                    // Selector - none\n                    return rows;\n                }\n\n                // Selector - function\n                if (typeof sel === 'function') {\n                    return $.map(rows, function (idx) {\n                        var row = aoData[idx];\n                        return sel(idx, row._aData, row.nTr) ? idx : null;\n                    });\n                }\n\n                // Selector - node\n                if (sel.nodeName) {\n                    var rowIdx = sel._DT_RowIndex;  // Property added by DT for fast lookup\n                    var cellIdx = sel._DT_CellIndex;\n\n                    if (rowIdx !== undefined) {\n                        // Make sure that the row is actually still present in the table\n                        return aoData[rowIdx] && aoData[rowIdx].nTr === sel ?\n                            [rowIdx] :\n                            [];\n                    }\n                    else if (cellIdx) {\n                        return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ?\n                            [cellIdx.row] :\n                            [];\n                    }\n                    else {\n                        var host = $(sel).closest('*[data-dt-row]');\n                        return host.length ?\n                            [host.data('dt-row')] :\n                            [];\n                    }\n                }\n\n                // ID selector. Want to always be able to select rows by id, regardless\n                // of if the tr element has been created or not, so can't rely upon\n                // jQuery here - hence a custom implementation. This does not match\n                // Sizzle's fast selector or HTML4 - in HTML5 the ID can be anything,\n                // but to select it using a CSS selector engine (like Sizzle or\n                // querySelect) it would need to need to be escaped for some characters.\n                // DataTables simplifies this for row selectors since you can select\n                // only a row. A # indicates an id any anything that follows is the id -\n                // unescaped.\n                if (typeof sel === 'string' && sel.charAt(0) === '#') {\n                    // get row index from id\n                    var rowObj = settings.aIds[sel.replace(/^#/, '')];\n                    if (rowObj !== undefined) {\n                        return [rowObj.idx];\n                    }\n\n                    // need to fall through to jQuery in case there is DOM id that\n                    // matches\n                }\n\n                // Get nodes in the order from the `rows` array with null values removed\n                var nodes = _removeEmpty(\n                    _pluck_order(settings.aoData, rows, 'nTr')\n                );\n\n                // Selector - jQuery selector string, array of nodes or jQuery object/\n                // As jQuery's .filter() allows jQuery objects to be passed in filter,\n                // it also allows arrays, so this will cope with all three options\n                return $(nodes)\n                    .filter(sel)\n                    .map(function () {\n                        return this._DT_RowIndex;\n                    })\n                    .toArray();\n            };\n\n            return _selector_run('row', selector, run, settings, opts);\n        };\n\n\n        _api_register('rows()', function (selector, opts) {\n            // argument shifting\n            if (selector === undefined) {\n                selector = '';\n            }\n            else if ($.isPlainObject(selector)) {\n                opts = selector;\n                selector = '';\n            }\n\n            opts = _selector_opts(opts);\n\n            var inst = this.iterator('table', function (settings) {\n                return __row_selector(settings, selector, opts);\n            }, 1);\n\n            // Want argument shifting here and in __row_selector?\n            inst.selector.rows = selector;\n            inst.selector.opts = opts;\n\n            return inst;\n        });\n\n        _api_register('rows().nodes()', function () {\n            return this.iterator('row', function (settings, row) {\n                return settings.aoData[row].nTr || undefined;\n            }, 1);\n        });\n\n        _api_register('rows().data()', function () {\n            return this.iterator(true, 'rows', function (settings, rows) {\n                return _pluck_order(settings.aoData, rows, '_aData');\n            }, 1);\n        });\n\n        _api_registerPlural('rows().cache()', 'row().cache()', function (type) {\n            return this.iterator('row', function (settings, row) {\n                var r = settings.aoData[row];\n                return type === 'search' ? r._aFilterData : r._aSortData;\n            }, 1);\n        });\n\n        _api_registerPlural('rows().invalidate()', 'row().invalidate()', function (src) {\n            return this.iterator('row', function (settings, row) {\n                _fnInvalidate(settings, row, src);\n            });\n        });\n\n        _api_registerPlural('rows().indexes()', 'row().index()', function () {\n            return this.iterator('row', function (settings, row) {\n                return row;\n            }, 1);\n        });\n\n        _api_registerPlural('rows().ids()', 'row().id()', function (hash) {\n            var a = [];\n            var context = this.context;\n\n            // `iterator` will drop undefined values, but in this case we want them\n            for (var i = 0, ien = context.length; i < ien; i++) {\n                for (var j = 0, jen = this[i].length; j < jen; j++) {\n                    var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);\n                    a.push((hash === true ? '#' : '') + id);\n                }\n            }\n\n            return new _Api(context, a);\n        });\n\n        _api_registerPlural('rows().remove()', 'row().remove()', function () {\n            var that = this;\n\n            this.iterator('row', function (settings, row, thatIdx) {\n                var data = settings.aoData;\n                var rowData = data[row];\n                var i, ien, j, jen;\n                var loopRow, loopCells;\n\n                data.splice(row, 1);\n\n                // Update the cached indexes\n                for (i = 0, ien = data.length; i < ien; i++) {\n                    loopRow = data[i];\n                    loopCells = loopRow.anCells;\n\n                    // Rows\n                    if (loopRow.nTr !== null) {\n                        loopRow.nTr._DT_RowIndex = i;\n                    }\n\n                    // Cells\n                    if (loopCells !== null) {\n                        for (j = 0, jen = loopCells.length; j < jen; j++) {\n                            loopCells[j]._DT_CellIndex.row = i;\n                        }\n                    }\n                }\n\n                // Delete from the display arrays\n                _fnDeleteIndex(settings.aiDisplayMaster, row);\n                _fnDeleteIndex(settings.aiDisplay, row);\n                _fnDeleteIndex(that[thatIdx], row, false); // maintain local indexes\n\n                // For server-side processing tables - subtract the deleted row from the count\n                if (settings._iRecordsDisplay > 0) {\n                    settings._iRecordsDisplay--;\n                }\n\n                // Check for an 'overflow' they case for displaying the table\n                _fnLengthOverflow(settings);\n\n                // Remove the row's ID reference if there is one\n                var id = settings.rowIdFn(rowData._aData);\n                if (id !== undefined) {\n                    delete settings.aIds[id];\n                }\n            });\n\n            this.iterator('table', function (settings) {\n                for (var i = 0, ien = settings.aoData.length; i < ien; i++) {\n                    settings.aoData[i].idx = i;\n                }\n            });\n\n            return this;\n        });\n\n\n        _api_register('rows.add()', function (rows) {\n            var newRows = this.iterator('table', function (settings) {\n                var row, i, ien;\n                var out = [];\n\n                for (i = 0, ien = rows.length; i < ien; i++) {\n                    row = rows[i];\n\n                    if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\n                        out.push(_fnAddTr(settings, row)[0]);\n                    }\n                    else {\n                        out.push(_fnAddData(settings, row));\n                    }\n                }\n\n                return out;\n            }, 1);\n\n            // Return an Api.rows() extended instance, so rows().nodes() etc can be used\n            var modRows = this.rows(-1);\n            modRows.pop();\n            $.merge(modRows, newRows);\n\n            return modRows;\n        });\n\n\n\n\n\n        /**\n         *\n         */\n        _api_register('row()', function (selector, opts) {\n            return _selector_first(this.rows(selector, opts));\n        });\n\n\n        _api_register('row().data()', function (data) {\n            var ctx = this.context;\n\n            if (data === undefined) {\n                // Get\n                return ctx.length && this.length ?\n                    ctx[0].aoData[this[0]]._aData :\n                    undefined;\n            }\n\n            // Set\n            var row = ctx[0].aoData[this[0]];\n            row._aData = data;\n\n            // If the DOM has an id, and the data source is an array\n            if (Array.isArray(data) && row.nTr && row.nTr.id) {\n                _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id);\n            }\n\n            // Automatically invalidate\n            _fnInvalidate(ctx[0], this[0], 'data');\n\n            return this;\n        });\n\n\n        _api_register('row().node()', function () {\n            var ctx = this.context;\n\n            return ctx.length && this.length ?\n                ctx[0].aoData[this[0]].nTr || null :\n                null;\n        });\n\n\n        _api_register('row.add()', function (row) {\n            // Allow a jQuery object to be passed in - only a single row is added from\n            // it though - the first element in the set\n            if (row instanceof $ && row.length) {\n                row = row[0];\n            }\n\n            var rows = this.iterator('table', function (settings) {\n                if (row.nodeName && row.nodeName.toUpperCase() === 'TR') {\n                    return _fnAddTr(settings, row)[0];\n                }\n                return _fnAddData(settings, row);\n            });\n\n            // Return an Api.rows() extended instance, with the newly added row selected\n            return this.row(rows[0]);\n        });\n\n\n\n        var __details_add = function (ctx, row, data, klass) {\n            // Convert to array of TR elements\n            var rows = [];\n            var addRow = function (r, k) {\n                // Recursion to allow for arrays of jQuery objects\n                if (Array.isArray(r) || r instanceof $) {\n                    for (var i = 0, ien = r.length; i < ien; i++) {\n                        addRow(r[i], k);\n                    }\n                    return;\n                }\n\n                // If we get a TR element, then just add it directly - up to the dev\n                // to add the correct number of columns etc\n                if (r.nodeName && r.nodeName.toLowerCase() === 'tr') {\n                    rows.push(r);\n                }\n                else {\n                    // Otherwise create a row with a wrapper\n                    var created = $('<tr><td></td></tr>').addClass(k);\n                    $('td', created)\n                        .addClass(k)\n                        .html(r)\n                    [0].colSpan = _fnVisbleColumns(ctx);\n\n                    rows.push(created[0]);\n                }\n            };\n\n            addRow(data, klass);\n\n            if (row._details) {\n                row._details.detach();\n            }\n\n            row._details = $(rows);\n\n            // If the children were already shown, that state should be retained\n            if (row._detailsShow) {\n                row._details.insertAfter(row.nTr);\n            }\n        };\n\n\n        var __details_remove = function (api, idx) {\n            var ctx = api.context;\n\n            if (ctx.length) {\n                var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];\n\n                if (row && row._details) {\n                    row._details.remove();\n\n                    row._detailsShow = undefined;\n                    row._details = undefined;\n                }\n            }\n        };\n\n\n        var __details_display = function (api, show) {\n            var ctx = api.context;\n\n            if (ctx.length && api.length) {\n                var row = ctx[0].aoData[api[0]];\n\n                if (row._details) {\n                    row._detailsShow = show;\n\n                    if (show) {\n                        row._details.insertAfter(row.nTr);\n                    }\n                    else {\n                        row._details.detach();\n                    }\n\n                    __details_events(ctx[0]);\n                }\n            }\n        };\n\n\n        var __details_events = function (settings) {\n            var api = new _Api(settings);\n            var namespace = '.dt.DT_details';\n            var drawEvent = 'draw' + namespace;\n            var colvisEvent = 'column-visibility' + namespace;\n            var destroyEvent = 'destroy' + namespace;\n            var data = settings.aoData;\n\n            api.off(drawEvent + ' ' + colvisEvent + ' ' + destroyEvent);\n\n            if (_pluck(data, '_details').length > 0) {\n                // On each draw, insert the required elements into the document\n                api.on(drawEvent, function (e, ctx) {\n                    if (settings !== ctx) {\n                        return;\n                    }\n\n                    api.rows({ page: 'current' }).eq(0).each(function (idx) {\n                        // Internal data grab\n                        var row = data[idx];\n\n                        if (row._detailsShow) {\n                            row._details.insertAfter(row.nTr);\n                        }\n                    });\n                });\n\n                // Column visibility change - update the colspan\n                api.on(colvisEvent, function (e, ctx, idx, vis) {\n                    if (settings !== ctx) {\n                        return;\n                    }\n\n                    // Update the colspan for the details rows (note, only if it already has\n                    // a colspan)\n                    var row, visible = _fnVisbleColumns(ctx);\n\n                    for (var i = 0, ien = data.length; i < ien; i++) {\n                        row = data[i];\n\n                        if (row._details) {\n                            row._details.children('td[colspan]').attr('colspan', visible);\n                        }\n                    }\n                });\n\n                // Table destroyed - nuke any child rows\n                api.on(destroyEvent, function (e, ctx) {\n                    if (settings !== ctx) {\n                        return;\n                    }\n\n                    for (var i = 0, ien = data.length; i < ien; i++) {\n                        if (data[i]._details) {\n                            __details_remove(api, i);\n                        }\n                    }\n                });\n            }\n        };\n\n        // Strings for the method names to help minification\n        var _emp = '';\n        var _child_obj = _emp + 'row().child';\n        var _child_mth = _child_obj + '()';\n\n        // data can be:\n        //  tr\n        //  string\n        //  jQuery or array of any of the above\n        _api_register(_child_mth, function (data, klass) {\n            var ctx = this.context;\n\n            if (data === undefined) {\n                // get\n                return ctx.length && this.length ?\n                    ctx[0].aoData[this[0]]._details :\n                    undefined;\n            }\n            else if (data === true) {\n                // show\n                this.child.show();\n            }\n            else if (data === false) {\n                // remove\n                __details_remove(this);\n            }\n            else if (ctx.length && this.length) {\n                // set\n                __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass);\n            }\n\n            return this;\n        });\n\n\n        _api_register([\n            _child_obj + '.show()',\n            _child_mth + '.show()' // only when `child()` was called with parameters (without\n        ], function (show) {   // it returns an object and this method is not executed)\n            __details_display(this, true);\n            return this;\n        });\n\n\n        _api_register([\n            _child_obj + '.hide()',\n            _child_mth + '.hide()' // only when `child()` was called with parameters (without\n        ], function () {         // it returns an object and this method is not executed)\n            __details_display(this, false);\n            return this;\n        });\n\n\n        _api_register([\n            _child_obj + '.remove()',\n            _child_mth + '.remove()' // only when `child()` was called with parameters (without\n        ], function () {           // it returns an object and this method is not executed)\n            __details_remove(this);\n            return this;\n        });\n\n\n        _api_register(_child_obj + '.isShown()', function () {\n            var ctx = this.context;\n\n            if (ctx.length && this.length) {\n                // _detailsShown as false or undefined will fall through to return false\n                return ctx[0].aoData[this[0]]._detailsShow || false;\n            }\n            return false;\n        });\n\n\n\n        /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n         * Columns\n         *\n         * {integer}           - column index (>=0 count from left, <0 count from right)\n         * \"{integer}:visIdx\"  - visible column index (i.e. translate to column index)  (>=0 count from left, <0 count from right)\n         * \"{integer}:visible\" - alias for {integer}:visIdx  (>=0 count from left, <0 count from right)\n         * \"{string}:name\"     - column name\n         * \"{string}\"          - jQuery selector on column header nodes\n         *\n         */\n\n        // can be an array of these items, comma separated list, or an array of comma\n        // separated lists\n\n        var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/;\n\n\n        // r1 and r2 are redundant - but it means that the parameters match for the\n        // iterator callback in columns().data()\n        var __columnData = function (settings, column, r1, r2, rows) {\n            var a = [];\n            for (var row = 0, ien = rows.length; row < ien; row++) {\n                a.push(_fnGetCellData(settings, rows[row], column));\n            }\n            return a;\n        };\n\n\n        var __column_selector = function (settings, selector, opts) {\n            var\n                columns = settings.aoColumns,\n                names = _pluck(columns, 'sName'),\n                nodes = _pluck(columns, 'nTh');\n\n            var run = function (s) {\n                var selInt = _intVal(s);\n\n                // Selector - all\n                if (s === '') {\n                    return _range(columns.length);\n                }\n\n                // Selector - index\n                if (selInt !== null) {\n                    return [selInt >= 0 ?\n                        selInt : // Count from left\n                        columns.length + selInt // Count from right (+ because its a negative value)\n                    ];\n                }\n\n                // Selector = function\n                if (typeof s === 'function') {\n                    var rows = _selector_row_indexes(settings, opts);\n\n                    return $.map(columns, function (col, idx) {\n                        return s(\n                            idx,\n                            __columnData(settings, idx, 0, 0, rows),\n                            nodes[idx]\n                        ) ? idx : null;\n                    });\n                }\n\n                // jQuery or string selector\n                var match = typeof s === 'string' ?\n                    s.match(__re_column_selector) :\n                    '';\n\n                if (match) {\n                    switch (match[2]) {\n                        case 'visIdx':\n                        case 'visible':\n                            var idx = parseInt(match[1], 10);\n                            // Visible index given, convert to column index\n                            if (idx < 0) {\n                                // Counting from the right\n                                var visColumns = $.map(columns, function (col, i) {\n                                    return col.bVisible ? i : null;\n                                });\n                                return [visColumns[visColumns.length + idx]];\n                            }\n                            // Counting from the left\n                            return [_fnVisibleToColumnIndex(settings, idx)];\n\n                        case 'name':\n                            // match by name. `names` is column index complete and in order\n                            return $.map(names, function (name, i) {\n                                return name === match[1] ? i : null;\n                            });\n\n                        default:\n                            return [];\n                    }\n                }\n\n                // Cell in the table body\n                if (s.nodeName && s._DT_CellIndex) {\n                    return [s._DT_CellIndex.column];\n                }\n\n                // jQuery selector on the TH elements for the columns\n                var jqResult = $(nodes)\n                    .filter(s)\n                    .map(function () {\n                        return $.inArray(this, nodes); // `nodes` is column index complete and in order\n                    })\n                    .toArray();\n\n                if (jqResult.length || !s.nodeName) {\n                    return jqResult;\n                }\n\n                // Otherwise a node which might have a `dt-column` data attribute, or be\n                // a child or such an element\n                var host = $(s).closest('*[data-dt-column]');\n                return host.length ?\n                    [host.data('dt-column')] :\n                    [];\n            };\n\n            return _selector_run('column', selector, run, settings, opts);\n        };\n\n\n        var __setColumnVis = function (settings, column, vis) {\n            var\n                cols = settings.aoColumns,\n                col = cols[column],\n                data = settings.aoData,\n                row, cells, i, ien, tr;\n\n            // Get\n            if (vis === undefined) {\n                return col.bVisible;\n            }\n\n            // Set\n            // No change\n            if (col.bVisible === vis) {\n                return;\n            }\n\n            if (vis) {\n                // Insert column\n                // Need to decide if we should use appendChild or insertBefore\n                var insertBefore = $.inArray(true, _pluck(cols, 'bVisible'), column + 1);\n\n                for (i = 0, ien = data.length; i < ien; i++) {\n                    tr = data[i].nTr;\n                    cells = data[i].anCells;\n\n                    if (tr) {\n                        // insertBefore can act like appendChild if 2nd arg is null\n                        tr.insertBefore(cells[column], cells[insertBefore] || null);\n                    }\n                }\n            }\n            else {\n                // Remove column\n                $(_pluck(settings.aoData, 'anCells', column)).detach();\n            }\n\n            // Common actions\n            col.bVisible = vis;\n        };\n\n\n        _api_register('columns()', function (selector, opts) {\n            // argument shifting\n            if (selector === undefined) {\n                selector = '';\n            }\n            else if ($.isPlainObject(selector)) {\n                opts = selector;\n                selector = '';\n            }\n\n            opts = _selector_opts(opts);\n\n            var inst = this.iterator('table', function (settings) {\n                return __column_selector(settings, selector, opts);\n            }, 1);\n\n            // Want argument shifting here and in _row_selector?\n            inst.selector.cols = selector;\n            inst.selector.opts = opts;\n\n            return inst;\n        });\n\n        _api_registerPlural('columns().header()', 'column().header()', function (selector, opts) {\n            return this.iterator('column', function (settings, column) {\n                return settings.aoColumns[column].nTh;\n            }, 1);\n        });\n\n        _api_registerPlural('columns().footer()', 'column().footer()', function (selector, opts) {\n            return this.iterator('column', function (settings, column) {\n                return settings.aoColumns[column].nTf;\n            }, 1);\n        });\n\n        _api_registerPlural('columns().data()', 'column().data()', function () {\n            return this.iterator('column-rows', __columnData, 1);\n        });\n\n        _api_registerPlural('columns().dataSrc()', 'column().dataSrc()', function () {\n            return this.iterator('column', function (settings, column) {\n                return settings.aoColumns[column].mData;\n            }, 1);\n        });\n\n        _api_registerPlural('columns().cache()', 'column().cache()', function (type) {\n            return this.iterator('column-rows', function (settings, column, i, j, rows) {\n                return _pluck_order(settings.aoData, rows,\n                    type === 'search' ? '_aFilterData' : '_aSortData', column\n                );\n            }, 1);\n        });\n\n        _api_registerPlural('columns().nodes()', 'column().nodes()', function () {\n            return this.iterator('column-rows', function (settings, column, i, j, rows) {\n                return _pluck_order(settings.aoData, rows, 'anCells', column);\n            }, 1);\n        });\n\n        _api_registerPlural('columns().visible()', 'column().visible()', function (vis, calc) {\n            var that = this;\n            var ret = this.iterator('column', function (settings, column) {\n                if (vis === undefined) {\n                    return settings.aoColumns[column].bVisible;\n                } // else\n                __setColumnVis(settings, column, vis);\n            });\n\n            // Group the column visibility changes\n            if (vis !== undefined) {\n                this.iterator('table', function (settings) {\n                    // Redraw the header after changes\n                    _fnDrawHead(settings, settings.aoHeader);\n                    _fnDrawHead(settings, settings.aoFooter);\n\n                    // Update colspan for no records display. Child rows and extensions will use their own\n                    // listeners to do this - only need to update the empty table item here\n                    if (!settings.aiDisplay.length) {\n                        $(settings.nTBody).find('td[colspan]').attr('colspan', _fnVisbleColumns(settings));\n                    }\n\n                    _fnSaveState(settings);\n\n                    // Second loop once the first is done for events\n                    that.iterator('column', function (settings, column) {\n                        _fnCallbackFire(settings, null, 'column-visibility', [settings, column, vis, calc]);\n                    });\n\n                    if (calc === undefined || calc) {\n                        that.columns.adjust();\n                    }\n                });\n            }\n\n            return ret;\n        });\n\n        _api_registerPlural('columns().indexes()', 'column().index()', function (type) {\n            return this.iterator('column', function (settings, column) {\n                return type === 'visible' ?\n                    _fnColumnIndexToVisible(settings, column) :\n                    column;\n            }, 1);\n        });\n\n        _api_register('columns.adjust()', function () {\n            return this.iterator('table', function (settings) {\n                _fnAdjustColumnSizing(settings);\n            }, 1);\n        });\n\n        _api_register('column.index()', function (type, idx) {\n            if (this.context.length !== 0) {\n                var ctx = this.context[0];\n\n                if (type === 'fromVisible' || type === 'toData') {\n                    return _fnVisibleToColumnIndex(ctx, idx);\n                }\n                else if (type === 'fromData' || type === 'toVisible') {\n                    return _fnColumnIndexToVisible(ctx, idx);\n                }\n            }\n        });\n\n        _api_register('column()', function (selector, opts) {\n            return _selector_first(this.columns(selector, opts));\n        });\n\n        var __cell_selector = function (settings, selector, opts) {\n            var data = settings.aoData;\n            var rows = _selector_row_indexes(settings, opts);\n            var cells = _removeEmpty(_pluck_order(data, rows, 'anCells'));\n            var allCells = $(_flatten([], cells));\n            var row;\n            var columns = settings.aoColumns.length;\n            var a, i, ien, j, o, host;\n\n            var run = function (s) {\n                var fnSelector = typeof s === 'function';\n\n                if (s === null || s === undefined || fnSelector) {\n                    // All cells and function selectors\n                    a = [];\n\n                    for (i = 0, ien = rows.length; i < ien; i++) {\n                        row = rows[i];\n\n                        for (j = 0; j < columns; j++) {\n                            o = {\n                                row: row,\n                                column: j\n                            };\n\n                            if (fnSelector) {\n                                // Selector - function\n                                host = data[row];\n\n                                if (s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null)) {\n                                    a.push(o);\n                                }\n                            }\n                            else {\n                                // Selector - all\n                                a.push(o);\n                            }\n                        }\n                    }\n\n                    return a;\n                }\n\n                // Selector - index\n                if ($.isPlainObject(s)) {\n                    // Valid cell index and its in the array of selectable rows\n                    return s.column !== undefined && s.row !== undefined && $.inArray(s.row, rows) !== -1 ?\n                        [s] :\n                        [];\n                }\n\n                // Selector - jQuery filtered cells\n                var jqResult = allCells\n                    .filter(s)\n                    .map(function (i, el) {\n                        return { // use a new object, in case someone changes the values\n                            row: el._DT_CellIndex.row,\n                            column: el._DT_CellIndex.column\n                        };\n                    })\n                    .toArray();\n\n                if (jqResult.length || !s.nodeName) {\n                    return jqResult;\n                }\n\n                // Otherwise the selector is a node, and there is one last option - the\n                // element might be a child of an element which has dt-row and dt-column\n                // data attributes\n                host = $(s).closest('*[data-dt-row]');\n                return host.length ?\n                    [{\n                        row: host.data('dt-row'),\n                        column: host.data('dt-column')\n                    }] :\n                    [];\n            };\n\n            return _selector_run('cell', selector, run, settings, opts);\n        };\n\n\n\n\n        _api_register('cells()', function (rowSelector, columnSelector, opts) {\n            // Argument shifting\n            if ($.isPlainObject(rowSelector)) {\n                // Indexes\n                if (rowSelector.row === undefined) {\n                    // Selector options in first parameter\n                    opts = rowSelector;\n                    rowSelector = null;\n                }\n                else {\n                    // Cell index objects in first parameter\n                    opts = columnSelector;\n                    columnSelector = null;\n                }\n            }\n            if ($.isPlainObject(columnSelector)) {\n                opts = columnSelector;\n                columnSelector = null;\n            }\n\n            // Cell selector\n            if (columnSelector === null || columnSelector === undefined) {\n                return this.iterator('table', function (settings) {\n                    return __cell_selector(settings, rowSelector, _selector_opts(opts));\n                });\n            }\n\n            // The default built in options need to apply to row and columns\n            var internalOpts = opts ? {\n                page: opts.page,\n                order: opts.order,\n                search: opts.search\n            } : {};\n\n            // Row + column selector\n            var columns = this.columns(columnSelector, internalOpts);\n            var rows = this.rows(rowSelector, internalOpts);\n            var i, ien, j, jen;\n\n            var cellsNoOpts = this.iterator('table', function (settings, idx) {\n                var a = [];\n\n                for (i = 0, ien = rows[idx].length; i < ien; i++) {\n                    for (j = 0, jen = columns[idx].length; j < jen; j++) {\n                        a.push({\n                            row: rows[idx][i],\n                            column: columns[idx][j]\n                        });\n                    }\n                }\n\n                return a;\n            }, 1);\n\n            // There is currently only one extension which uses a cell selector extension\n            // It is a _major_ performance drag to run this if it isn't needed, so this is\n            // an extension specific check at the moment\n            var cells = opts && opts.selected ?\n                this.cells(cellsNoOpts, opts) :\n                cellsNoOpts;\n\n            $.extend(cells.selector, {\n                cols: columnSelector,\n                rows: rowSelector,\n                opts: opts\n            });\n\n            return cells;\n        });\n\n\n        _api_registerPlural('cells().nodes()', 'cell().node()', function () {\n            return this.iterator('cell', function (settings, row, column) {\n                var data = settings.aoData[row];\n\n                return data && data.anCells ?\n                    data.anCells[column] :\n                    undefined;\n            }, 1);\n        });\n\n\n        _api_register('cells().data()', function () {\n            return this.iterator('cell', function (settings, row, column) {\n                return _fnGetCellData(settings, row, column);\n            }, 1);\n        });\n\n\n        _api_registerPlural('cells().cache()', 'cell().cache()', function (type) {\n            type = type === 'search' ? '_aFilterData' : '_aSortData';\n\n            return this.iterator('cell', function (settings, row, column) {\n                return settings.aoData[row][type][column];\n            }, 1);\n        });\n\n\n        _api_registerPlural('cells().render()', 'cell().render()', function (type) {\n            return this.iterator('cell', function (settings, row, column) {\n                return _fnGetCellData(settings, row, column, type);\n            }, 1);\n        });\n\n\n        _api_registerPlural('cells().indexes()', 'cell().index()', function () {\n            return this.iterator('cell', function (settings, row, column) {\n                return {\n                    row: row,\n                    column: column,\n                    columnVisible: _fnColumnIndexToVisible(settings, column)\n                };\n            }, 1);\n        });\n\n\n        _api_registerPlural('cells().invalidate()', 'cell().invalidate()', function (src) {\n            return this.iterator('cell', function (settings, row, column) {\n                _fnInvalidate(settings, row, src, column);\n            });\n        });\n\n\n\n        _api_register('cell()', function (rowSelector, columnSelector, opts) {\n            return _selector_first(this.cells(rowSelector, columnSelector, opts));\n        });\n\n\n        _api_register('cell().data()', function (data) {\n            var ctx = this.context;\n            var cell = this[0];\n\n            if (data === undefined) {\n                // Get\n                return ctx.length && cell.length ?\n                    _fnGetCellData(ctx[0], cell[0].row, cell[0].column) :\n                    undefined;\n            }\n\n            // Set\n            _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data);\n            _fnInvalidate(ctx[0], cell[0].row, 'data', cell[0].column);\n\n            return this;\n        });\n\n\n\n        /**\n         * Get current ordering (sorting) that has been applied to the table.\n         *\n         * @returns {array} 2D array containing the sorting information for the first\n         *   table in the current context. Each element in the parent array represents\n         *   a column being sorted upon (i.e. multi-sorting with two columns would have\n         *   2 inner arrays). The inner arrays may have 2 or 3 elements. The first is\n         *   the column index that the sorting condition applies to, the second is the\n         *   direction of the sort (`desc` or `asc`) and, optionally, the third is the\n         *   index of the sorting order from the `column.sorting` initialisation array.\n         *//**\n        * Set the ordering for the table.\n        *\n        * @param {integer} order Column index to sort upon.\n        * @param {string} direction Direction of the sort to be applied (`asc` or `desc`)\n        * @returns {DataTables.Api} this\n        *//**\n        * Set the ordering for the table.\n        *\n        * @param {array} order 1D array of sorting information to be applied.\n        * @param {array} [...] Optional additional sorting conditions\n        * @returns {DataTables.Api} this\n        *//**\n        * Set the ordering for the table.\n        *\n        * @param {array} order 2D array of sorting information to be applied.\n        * @returns {DataTables.Api} this\n        */\n        _api_register('order()', function (order, dir) {\n            var ctx = this.context;\n\n            if (order === undefined) {\n                // get\n                return ctx.length !== 0 ?\n                    ctx[0].aaSorting :\n                    undefined;\n            }\n\n            // set\n            if (typeof order === 'number') {\n                // Simple column / direction passed in\n                order = [[order, dir]];\n            }\n            else if (order.length && !Array.isArray(order[0])) {\n                // Arguments passed in (list of 1D arrays)\n                order = Array.prototype.slice.call(arguments);\n            }\n            // otherwise a 2D array was passed in\n\n            return this.iterator('table', function (settings) {\n                settings.aaSorting = order.slice();\n            });\n        });\n\n\n        /**\n         * Attach a sort listener to an element for a given column\n         *\n         * @param {node|jQuery|string} node Identifier for the element(s) to attach the\n         *   listener to. This can take the form of a single DOM node, a jQuery\n         *   collection of nodes or a jQuery selector which will identify the node(s).\n         * @param {integer} column the column that a click on this node will sort on\n         * @param {function} [callback] callback function when sort is run\n         * @returns {DataTables.Api} this\n         */\n        _api_register('order.listener()', function (node, column, callback) {\n            return this.iterator('table', function (settings) {\n                _fnSortAttachListener(settings, node, column, callback);\n            });\n        });\n\n\n        _api_register('order.fixed()', function (set) {\n            if (!set) {\n                var ctx = this.context;\n                var fixed = ctx.length ?\n                    ctx[0].aaSortingFixed :\n                    undefined;\n\n                return Array.isArray(fixed) ?\n                    { pre: fixed } :\n                    fixed;\n            }\n\n            return this.iterator('table', function (settings) {\n                settings.aaSortingFixed = $.extend(true, {}, set);\n            });\n        });\n\n\n        // Order by the selected column(s)\n        _api_register([\n            'columns().order()',\n            'column().order()'\n        ], function (dir) {\n            var that = this;\n\n            return this.iterator('table', function (settings, i) {\n                var sort = [];\n\n                $.each(that[i], function (j, col) {\n                    sort.push([col, dir]);\n                });\n\n                settings.aaSorting = sort;\n            });\n        });\n\n\n\n        _api_register('search()', function (input, regex, smart, caseInsen) {\n            var ctx = this.context;\n\n            if (input === undefined) {\n                // get\n                return ctx.length !== 0 ?\n                    ctx[0].oPreviousSearch.sSearch :\n                    undefined;\n            }\n\n            // set\n            return this.iterator('table', function (settings) {\n                if (!settings.oFeatures.bFilter) {\n                    return;\n                }\n\n                _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {\n                    \"sSearch\": input + \"\",\n                    \"bRegex\": regex === null ? false : regex,\n                    \"bSmart\": smart === null ? true : smart,\n                    \"bCaseInsensitive\": caseInsen === null ? true : caseInsen\n                }), 1);\n            });\n        });\n\n\n        _api_registerPlural(\n            'columns().search()',\n            'column().search()',\n            function (input, regex, smart, caseInsen) {\n                return this.iterator('column', function (settings, column) {\n                    var preSearch = settings.aoPreSearchCols;\n\n                    if (input === undefined) {\n                        // get\n                        return preSearch[column].sSearch;\n                    }\n\n                    // set\n                    if (!settings.oFeatures.bFilter) {\n                        return;\n                    }\n\n                    $.extend(preSearch[column], {\n                        \"sSearch\": input + \"\",\n                        \"bRegex\": regex === null ? false : regex,\n                        \"bSmart\": smart === null ? true : smart,\n                        \"bCaseInsensitive\": caseInsen === null ? true : caseInsen\n                    });\n\n                    _fnFilterComplete(settings, settings.oPreviousSearch, 1);\n                });\n            }\n        );\n\n        /*\n         * State API methods\n         */\n\n        _api_register('state()', function () {\n            return this.context.length ?\n                this.context[0].oSavedState :\n                null;\n        });\n\n\n        _api_register('state.clear()', function () {\n            return this.iterator('table', function (settings) {\n                // Save an empty object\n                settings.fnStateSaveCallback.call(settings.oInstance, settings, {});\n            });\n        });\n\n\n        _api_register('state.loaded()', function () {\n            return this.context.length ?\n                this.context[0].oLoadedState :\n                null;\n        });\n\n\n        _api_register('state.save()', function () {\n            return this.iterator('table', function (settings) {\n                _fnSaveState(settings);\n            });\n        });\n\n\n\n        /**\n         * Provide a common method for plug-ins to check the version of DataTables being\n         * used, in order to ensure compatibility.\n         *\n         *  @param {string} version Version string to check for, in the format \"X.Y.Z\".\n         *    Note that the formats \"X\" and \"X.Y\" are also acceptable.\n         *  @returns {boolean} true if this version of DataTables is greater or equal to\n         *    the required version, or false if this version of DataTales is not\n         *    suitable\n         *  @static\n         *  @dtopt API-Static\n         *\n         *  @example\n         *    alert( $.fn.dataTable.versionCheck( '1.9.0' ) );\n         */\n        DataTable.versionCheck = DataTable.fnVersionCheck = function (version) {\n            var aThis = DataTable.version.split('.');\n            var aThat = version.split('.');\n            var iThis, iThat;\n\n            for (var i = 0, iLen = aThat.length; i < iLen; i++) {\n                iThis = parseInt(aThis[i], 10) || 0;\n                iThat = parseInt(aThat[i], 10) || 0;\n\n                // Parts are the same, keep comparing\n                if (iThis === iThat) {\n                    continue;\n                }\n\n                // Parts are different, return immediately\n                return iThis > iThat;\n            }\n\n            return true;\n        };\n\n\n        /**\n         * Check if a `<table>` node is a DataTable table already or not.\n         *\n         *  @param {node|jquery|string} table Table node, jQuery object or jQuery\n         *      selector for the table to test. Note that if more than more than one\n         *      table is passed on, only the first will be checked\n         *  @returns {boolean} true the table given is a DataTable, or false otherwise\n         *  @static\n         *  @dtopt API-Static\n         *\n         *  @example\n         *    if ( ! $.fn.DataTable.isDataTable( '#example' ) ) {\n         *      $('#example').dataTable();\n         *    }\n         */\n        DataTable.isDataTable = DataTable.fnIsDataTable = function (table) {\n            var t = $(table).get(0);\n            var is = false;\n\n            if (table instanceof DataTable.Api) {\n                return true;\n            }\n\n            $.each(DataTable.settings, function (i, o) {\n                var head = o.nScrollHead ? $('table', o.nScrollHead)[0] : null;\n                var foot = o.nScrollFoot ? $('table', o.nScrollFoot)[0] : null;\n\n                if (o.nTable === t || head === t || foot === t) {\n                    is = true;\n                }\n            });\n\n            return is;\n        };\n\n\n        /**\n         * Get all DataTable tables that have been initialised - optionally you can\n         * select to get only currently visible tables.\n         *\n         *  @param {boolean} [visible=false] Flag to indicate if you want all (default)\n         *    or visible tables only.\n         *  @returns {array} Array of `table` nodes (not DataTable instances) which are\n         *    DataTables\n         *  @static\n         *  @dtopt API-Static\n         *\n         *  @example\n         *    $.each( $.fn.dataTable.tables(true), function () {\n         *      $(table).DataTable().columns.adjust();\n         *    } );\n         */\n        DataTable.tables = DataTable.fnTables = function (visible) {\n            var api = false;\n\n            if ($.isPlainObject(visible)) {\n                api = visible.api;\n                visible = visible.visible;\n            }\n\n            var a = $.map(DataTable.settings, function (o) {\n                if (!visible || (visible && $(o.nTable).is(':visible'))) {\n                    return o.nTable;\n                }\n            });\n\n            return api ?\n                new _Api(a) :\n                a;\n        };\n\n\n        /**\n         * Convert from camel case parameters to Hungarian notation. This is made public\n         * for the extensions to provide the same ability as DataTables core to accept\n         * either the 1.9 style Hungarian notation, or the 1.10+ style camelCase\n         * parameters.\n         *\n         *  @param {object} src The model object which holds all parameters that can be\n         *    mapped.\n         *  @param {object} user The object to convert from camel case to Hungarian.\n         *  @param {boolean} force When set to `true`, properties which already have a\n         *    Hungarian value in the `user` object will be overwritten. Otherwise they\n         *    won't be.\n         */\n        DataTable.camelToHungarian = _fnCamelToHungarian;\n\n\n\n        /**\n         *\n         */\n        _api_register('$()', function (selector, opts) {\n            var\n                rows = this.rows(opts).nodes(), // Get all rows\n                jqRows = $(rows);\n\n            return $([].concat(\n                jqRows.filter(selector).toArray(),\n                jqRows.find(selector).toArray()\n            ));\n        });\n\n\n        // jQuery functions to operate on the tables\n        $.each(['on', 'one', 'off'], function (i, key) {\n            _api_register(key + '()', function ( /* event, handler */) {\n                var args = Array.prototype.slice.call(arguments);\n\n                // Add the `dt` namespace automatically if it isn't already present\n                args[0] = $.map(args[0].split(/\\s/), function (e) {\n                    return !e.match(/\\.dt\\b/) ?\n                        e + '.dt' :\n                        e;\n                }).join(' ');\n\n                var inst = $(this.tables().nodes());\n                inst[key].apply(inst, args);\n                return this;\n            });\n        });\n\n\n        _api_register('clear()', function () {\n            return this.iterator('table', function (settings) {\n                _fnClearTable(settings);\n            });\n        });\n\n\n        _api_register('settings()', function () {\n            return new _Api(this.context, this.context);\n        });\n\n\n        _api_register('init()', function () {\n            var ctx = this.context;\n            return ctx.length ? ctx[0].oInit : null;\n        });\n\n\n        _api_register('data()', function () {\n            return this.iterator('table', function (settings) {\n                return _pluck(settings.aoData, '_aData');\n            }).flatten();\n        });\n\n\n        _api_register('destroy()', function (remove) {\n            remove = remove || false;\n\n            return this.iterator('table', function (settings) {\n                var orig = settings.nTableWrapper.parentNode;\n                var classes = settings.oClasses;\n                var table = settings.nTable;\n                var tbody = settings.nTBody;\n                var thead = settings.nTHead;\n                var tfoot = settings.nTFoot;\n                var jqTable = $(table);\n                var jqTbody = $(tbody);\n                var jqWrapper = $(settings.nTableWrapper);\n                var rows = $.map(settings.aoData, function (r) { return r.nTr; });\n                var i, ien;\n\n                // Flag to note that the table is currently being destroyed - no action\n                // should be taken\n                settings.bDestroying = true;\n\n                // Fire off the destroy callbacks for plug-ins etc\n                _fnCallbackFire(settings, \"aoDestroyCallback\", \"destroy\", [settings]);\n\n                // If not being removed from the document, make all columns visible\n                if (!remove) {\n                    new _Api(settings).columns().visible(true);\n                }\n\n                // Blitz all `DT` namespaced events (these are internal events, the\n                // lowercase, `dt` events are user subscribed and they are responsible\n                // for removing them\n                jqWrapper.off('.DT').find(':not(tbody *)').off('.DT');\n                $(window).off('.DT-' + settings.sInstance);\n\n                // When scrolling we had to break the table up - restore it\n                if (table != thead.parentNode) {\n                    jqTable.children('thead').detach();\n                    jqTable.append(thead);\n                }\n\n                if (tfoot && table != tfoot.parentNode) {\n                    jqTable.children('tfoot').detach();\n                    jqTable.append(tfoot);\n                }\n\n                settings.aaSorting = [];\n                settings.aaSortingFixed = [];\n                _fnSortingClasses(settings);\n\n                $(rows).removeClass(settings.asStripeClasses.join(' '));\n\n                $('th, td', thead).removeClass(classes.sSortable + ' ' +\n                    classes.sSortableAsc + ' ' + classes.sSortableDesc + ' ' + classes.sSortableNone\n                );\n\n                // Add the TR elements back into the table in their original order\n                jqTbody.children().detach();\n                jqTbody.append(rows);\n\n                // Remove the DataTables generated nodes, events and classes\n                var removedMethod = remove ? 'remove' : 'detach';\n                jqTable[removedMethod]();\n                jqWrapper[removedMethod]();\n\n                // If we need to reattach the table to the document\n                if (!remove && orig) {\n                    // insertBefore acts like appendChild if !arg[1]\n                    orig.insertBefore(table, settings.nTableReinsertBefore);\n\n                    // Restore the width of the original table - was read from the style property,\n                    // so we can restore directly to that\n                    jqTable\n                        .css('width', settings.sDestroyWidth)\n                        .removeClass(classes.sTable);\n\n                    // If the were originally stripe classes - then we add them back here.\n                    // Note this is not fool proof (for example if not all rows had stripe\n                    // classes - but it's a good effort without getting carried away\n                    ien = settings.asDestroyStripes.length;\n\n                    if (ien) {\n                        jqTbody.children().each(function (i) {\n                            $(this).addClass(settings.asDestroyStripes[i % ien]);\n                        });\n                    }\n                }\n\n                /* Remove the settings object from the settings array */\n                var idx = $.inArray(settings, DataTable.settings);\n                if (idx !== -1) {\n                    DataTable.settings.splice(idx, 1);\n                }\n            });\n        });\n\n\n        // Add the `every()` method for rows, columns and cells in a compact form\n        $.each(['column', 'row', 'cell'], function (i, type) {\n            _api_register(type + 's().every()', function (fn) {\n                var opts = this.selector.opts;\n                var api = this;\n\n                return this.iterator(type, function (settings, arg1, arg2, arg3, arg4) {\n                    // Rows and columns:\n                    //  arg1 - index\n                    //  arg2 - table counter\n                    //  arg3 - loop counter\n                    //  arg4 - undefined\n                    // Cells:\n                    //  arg1 - row index\n                    //  arg2 - column index\n                    //  arg3 - table counter\n                    //  arg4 - loop counter\n                    fn.call(\n                        api[type](\n                            arg1,\n                            type === 'cell' ? arg2 : opts,\n                            type === 'cell' ? opts : undefined\n                        ),\n                        arg1, arg2, arg3, arg4\n                    );\n                });\n            });\n        });\n\n\n        // i18n method for extensions to be able to use the language object from the\n        // DataTable\n        _api_register('i18n()', function (token, def, plural) {\n            var ctx = this.context[0];\n            var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);\n\n            if (resolved === undefined) {\n                resolved = def;\n            }\n\n            if (plural !== undefined && $.isPlainObject(resolved)) {\n                resolved = resolved[plural] !== undefined ?\n                    resolved[plural] :\n                    resolved._;\n            }\n\n            return resolved.replace('%d', plural); // nb: plural might be undefined,\n        });\n        /**\n         * Version string for plug-ins to check compatibility. Allowed format is\n         * `a.b.c-d` where: a:int, b:int, c:int, d:string(dev|beta|alpha). `d` is used\n         * only for non-release builds. See http://semver.org/ for more information.\n         *  @member\n         *  @type string\n         *  @default Version number\n         */\n        DataTable.version = \"1.10.23\";\n\n        /**\n         * Private data store, containing all of the settings objects that are\n         * created for the tables on a given page.\n         *\n         * Note that the `DataTable.settings` object is aliased to\n         * `jQuery.fn.dataTableExt` through which it may be accessed and\n         * manipulated, or `jQuery.fn.dataTable.settings`.\n         *  @member\n         *  @type array\n         *  @default []\n         *  @private\n         */\n        DataTable.settings = [];\n\n        /**\n         * Object models container, for the various models that DataTables has\n         * available to it. These models define the objects that are used to hold\n         * the active state and configuration of the table.\n         *  @namespace\n         */\n        DataTable.models = {};\n\n\n\n        /**\n         * Template object for the way in which DataTables holds information about\n         * search information for the global filter and individual column filters.\n         *  @namespace\n         */\n        DataTable.models.oSearch = {\n            /**\n             * Flag to indicate if the filtering should be case insensitive or not\n             *  @type boolean\n             *  @default true\n             */\n            \"bCaseInsensitive\": true,\n\n            /**\n             * Applied search term\n             *  @type string\n             *  @default <i>Empty string</i>\n             */\n            \"sSearch\": \"\",\n\n            /**\n             * Flag to indicate if the search term should be interpreted as a\n             * regular expression (true) or not (false) and therefore and special\n             * regex characters escaped.\n             *  @type boolean\n             *  @default false\n             */\n            \"bRegex\": false,\n\n            /**\n             * Flag to indicate if DataTables is to use its smart filtering or not.\n             *  @type boolean\n             *  @default true\n             */\n            \"bSmart\": true\n        };\n\n\n\n\n        /**\n         * Template object for the way in which DataTables holds information about\n         * each individual row. This is the object format used for the settings\n         * aoData array.\n         *  @namespace\n         */\n        DataTable.models.oRow = {\n            /**\n             * TR element for the row\n             *  @type node\n             *  @default null\n             */\n            \"nTr\": null,\n\n            /**\n             * Array of TD elements for each row. This is null until the row has been\n             * created.\n             *  @type array nodes\n             *  @default []\n             */\n            \"anCells\": null,\n\n            /**\n             * Data object from the original data source for the row. This is either\n             * an array if using the traditional form of DataTables, or an object if\n             * using mData options. The exact type will depend on the passed in\n             * data from the data source, or will be an array if using DOM a data\n             * source.\n             *  @type array|object\n             *  @default []\n             */\n            \"_aData\": [],\n\n            /**\n             * Sorting data cache - this array is ostensibly the same length as the\n             * number of columns (although each index is generated only as it is\n             * needed), and holds the data that is used for sorting each column in the\n             * row. We do this cache generation at the start of the sort in order that\n             * the formatting of the sort data need be done only once for each cell\n             * per sort. This array should not be read from or written to by anything\n             * other than the master sorting methods.\n             *  @type array\n             *  @default null\n             *  @private\n             */\n            \"_aSortData\": null,\n\n            /**\n             * Per cell filtering data cache. As per the sort data cache, used to\n             * increase the performance of the filtering in DataTables\n             *  @type array\n             *  @default null\n             *  @private\n             */\n            \"_aFilterData\": null,\n\n            /**\n             * Filtering data cache. This is the same as the cell filtering cache, but\n             * in this case a string rather than an array. This is easily computed with\n             * a join on `_aFilterData`, but is provided as a cache so the join isn't\n             * needed on every search (memory traded for performance)\n             *  @type array\n             *  @default null\n             *  @private\n             */\n            \"_sFilterRow\": null,\n\n            /**\n             * Cache of the class name that DataTables has applied to the row, so we\n             * can quickly look at this variable rather than needing to do a DOM check\n             * on className for the nTr property.\n             *  @type string\n             *  @default <i>Empty string</i>\n             *  @private\n             */\n            \"_sRowStripe\": \"\",\n\n            /**\n             * Denote if the original data source was from the DOM, or the data source\n             * object. This is used for invalidating data, so DataTables can\n             * automatically read data from the original source, unless uninstructed\n             * otherwise.\n             *  @type string\n             *  @default null\n             *  @private\n             */\n            \"src\": null,\n\n            /**\n             * Index in the aoData array. This saves an indexOf lookup when we have the\n             * object, but want to know the index\n             *  @type integer\n             *  @default -1\n             *  @private\n             */\n            \"idx\": -1\n        };\n\n\n        /**\n         * Template object for the column information object in DataTables. This object\n         * is held in the settings aoColumns array and contains all the information that\n         * DataTables needs about each individual column.\n         *\n         * Note that this object is related to {@link DataTable.defaults.column}\n         * but this one is the internal data store for DataTables's cache of columns.\n         * It should NOT be manipulated outside of DataTables. Any configuration should\n         * be done through the initialisation options.\n         *  @namespace\n         */\n        DataTable.models.oColumn = {\n            /**\n             * Column index. This could be worked out on-the-fly with $.inArray, but it\n             * is faster to just hold it as a variable\n             *  @type integer\n             *  @default null\n             */\n            \"idx\": null,\n\n            /**\n             * A list of the columns that sorting should occur on when this column\n             * is sorted. That this property is an array allows multi-column sorting\n             * to be defined for a column (for example first name / last name columns\n             * would benefit from this). The values are integers pointing to the\n             * columns to be sorted on (typically it will be a single integer pointing\n             * at itself, but that doesn't need to be the case).\n             *  @type array\n             */\n            \"aDataSort\": null,\n\n            /**\n             * Define the sorting directions that are applied to the column, in sequence\n             * as the column is repeatedly sorted upon - i.e. the first value is used\n             * as the sorting direction when the column if first sorted (clicked on).\n             * Sort it again (click again) and it will move on to the next index.\n             * Repeat until loop.\n             *  @type array\n             */\n            \"asSorting\": null,\n\n            /**\n             * Flag to indicate if the column is searchable, and thus should be included\n             * in the filtering or not.\n             *  @type boolean\n             */\n            \"bSearchable\": null,\n\n            /**\n             * Flag to indicate if the column is sortable or not.\n             *  @type boolean\n             */\n            \"bSortable\": null,\n\n            /**\n             * Flag to indicate if the column is currently visible in the table or not\n             *  @type boolean\n             */\n            \"bVisible\": null,\n\n            /**\n             * Store for manual type assignment using the `column.type` option. This\n             * is held in store so we can manipulate the column's `sType` property.\n             *  @type string\n             *  @default null\n             *  @private\n             */\n            \"_sManualType\": null,\n\n            /**\n             * Flag to indicate if HTML5 data attributes should be used as the data\n             * source for filtering or sorting. True is either are.\n             *  @type boolean\n             *  @default false\n             *  @private\n             */\n            \"_bAttrSrc\": false,\n\n            /**\n             * Developer definable function that is called whenever a cell is created (Ajax source,\n             * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n             * allowing you to modify the DOM element (add background colour for example) when the\n             * element is available.\n             *  @type function\n             *  @param {element} nTd The TD node that has been created\n             *  @param {*} sData The Data for the cell\n             *  @param {array|object} oData The data for the whole row\n             *  @param {int} iRow The row index for the aoData data store\n             *  @default null\n             */\n            \"fnCreatedCell\": null,\n\n            /**\n             * Function to get data from a cell in a column. You should <b>never</b>\n             * access data directly through _aData internally in DataTables - always use\n             * the method attached to this property. It allows mData to function as\n             * required. This function is automatically assigned by the column\n             * initialisation method\n             *  @type function\n             *  @param {array|object} oData The data array/object for the array\n             *    (i.e. aoData[]._aData)\n             *  @param {string} sSpecific The specific data type you want to get -\n             *    'display', 'type' 'filter' 'sort'\n             *  @returns {*} The data for the cell from the given row's data\n             *  @default null\n             */\n            \"fnGetData\": null,\n\n            /**\n             * Function to set data for a cell in the column. You should <b>never</b>\n             * set the data directly to _aData internally in DataTables - always use\n             * this method. It allows mData to function as required. This function\n             * is automatically assigned by the column initialisation method\n             *  @type function\n             *  @param {array|object} oData The data array/object for the array\n             *    (i.e. aoData[]._aData)\n             *  @param {*} sValue Value to set\n             *  @default null\n             */\n            \"fnSetData\": null,\n\n            /**\n             * Property to read the value for the cells in the column from the data\n             * source array / object. If null, then the default content is used, if a\n             * function is given then the return from the function is used.\n             *  @type function|int|string|null\n             *  @default null\n             */\n            \"mData\": null,\n\n            /**\n             * Partner property to mData which is used (only when defined) to get\n             * the data - i.e. it is basically the same as mData, but without the\n             * 'set' option, and also the data fed to it is the result from mData.\n             * This is the rendering method to match the data method of mData.\n             *  @type function|int|string|null\n             *  @default null\n             */\n            \"mRender\": null,\n\n            /**\n             * Unique header TH/TD element for this column - this is what the sorting\n             * listener is attached to (if sorting is enabled.)\n             *  @type node\n             *  @default null\n             */\n            \"nTh\": null,\n\n            /**\n             * Unique footer TH/TD element for this column (if there is one). Not used\n             * in DataTables as such, but can be used for plug-ins to reference the\n             * footer for each column.\n             *  @type node\n             *  @default null\n             */\n            \"nTf\": null,\n\n            /**\n             * The class to apply to all TD elements in the table's TBODY for the column\n             *  @type string\n             *  @default null\n             */\n            \"sClass\": null,\n\n            /**\n             * When DataTables calculates the column widths to assign to each column,\n             * it finds the longest string in each column and then constructs a\n             * temporary table and reads the widths from that. The problem with this\n             * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n             * string - thus the calculation can go wrong (doing it properly and putting\n             * it into an DOM object and measuring that is horribly(!) slow). Thus as\n             * a \"work around\" we provide this option. It will append its value to the\n             * text that is found to be the longest string for the column - i.e. padding.\n             *  @type string\n             */\n            \"sContentPadding\": null,\n\n            /**\n             * Allows a default value to be given for a column's data, and will be used\n             * whenever a null data source is encountered (this can be because mData\n             * is set to null, or because the data source itself is null).\n             *  @type string\n             *  @default null\n             */\n            \"sDefaultContent\": null,\n\n            /**\n             * Name for the column, allowing reference to the column by name as well as\n             * by index (needs a lookup to work by name).\n             *  @type string\n             */\n            \"sName\": null,\n\n            /**\n             * Custom sorting data type - defines which of the available plug-ins in\n             * afnSortData the custom sorting will use - if any is defined.\n             *  @type string\n             *  @default std\n             */\n            \"sSortDataType\": 'std',\n\n            /**\n             * Class to be applied to the header element when sorting on this column\n             *  @type string\n             *  @default null\n             */\n            \"sSortingClass\": null,\n\n            /**\n             * Class to be applied to the header element when sorting on this column -\n             * when jQuery UI theming is used.\n             *  @type string\n             *  @default null\n             */\n            \"sSortingClassJUI\": null,\n\n            /**\n             * Title of the column - what is seen in the TH element (nTh).\n             *  @type string\n             */\n            \"sTitle\": null,\n\n            /**\n             * Column sorting and filtering type\n             *  @type string\n             *  @default null\n             */\n            \"sType\": null,\n\n            /**\n             * Width of the column\n             *  @type string\n             *  @default null\n             */\n            \"sWidth\": null,\n\n            /**\n             * Width of the column when it was first \"encountered\"\n             *  @type string\n             *  @default null\n             */\n            \"sWidthOrig\": null\n        };\n\n\n        /*\n         * Developer note: The properties of the object below are given in Hungarian\n         * notation, that was used as the interface for DataTables prior to v1.10, however\n         * from v1.10 onwards the primary interface is camel case. In order to avoid\n         * breaking backwards compatibility utterly with this change, the Hungarian\n         * version is still, internally the primary interface, but is is not documented\n         * - hence the @name tags in each doc comment. This allows a Javascript function\n         * to create a map from Hungarian notation to camel case (going the other direction\n         * would require each property to be listed, which would add around 3K to the size\n         * of DataTables, while this method is about a 0.5K hit).\n         *\n         * Ultimately this does pave the way for Hungarian notation to be dropped\n         * completely, but that is a massive amount of work and will break current\n         * installs (therefore is on-hold until v2).\n         */\n\n        /**\n         * Initialisation options that can be given to DataTables at initialisation\n         * time.\n         *  @namespace\n         */\n        DataTable.defaults = {\n            /**\n             * An array of data to use for the table, passed in at initialisation which\n             * will be used in preference to any data which is already in the DOM. This is\n             * particularly useful for constructing tables purely in Javascript, for\n             * example with a custom Ajax call.\n             *  @type array\n             *  @default null\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.data\n             *\n             *  @example\n             *    // Using a 2D array data source\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"data\": [\n             *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],\n             *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],\n             *        ],\n             *        \"columns\": [\n             *          { \"title\": \"Engine\" },\n             *          { \"title\": \"Browser\" },\n             *          { \"title\": \"Platform\" },\n             *          { \"title\": \"Version\" },\n             *          { \"title\": \"Grade\" }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using an array of objects as a data source (`data`)\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"data\": [\n             *          {\n             *            \"engine\":   \"Trident\",\n             *            \"browser\":  \"Internet Explorer 4.0\",\n             *            \"platform\": \"Win 95+\",\n             *            \"version\":  4,\n             *            \"grade\":    \"X\"\n             *          },\n             *          {\n             *            \"engine\":   \"Trident\",\n             *            \"browser\":  \"Internet Explorer 5.0\",\n             *            \"platform\": \"Win 95+\",\n             *            \"version\":  5,\n             *            \"grade\":    \"C\"\n             *          }\n             *        ],\n             *        \"columns\": [\n             *          { \"title\": \"Engine\",   \"data\": \"engine\" },\n             *          { \"title\": \"Browser\",  \"data\": \"browser\" },\n             *          { \"title\": \"Platform\", \"data\": \"platform\" },\n             *          { \"title\": \"Version\",  \"data\": \"version\" },\n             *          { \"title\": \"Grade\",    \"data\": \"grade\" }\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"aaData\": null,\n\n\n            /**\n             * If ordering is enabled, then DataTables will perform a first pass sort on\n             * initialisation. You can define which column(s) the sort is performed\n             * upon, and the sorting direction, with this variable. The `sorting` array\n             * should contain an array for each column to be sorted initially containing\n             * the column's index and a direction string ('asc' or 'desc').\n             *  @type array\n             *  @default [[0,'asc']]\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.order\n             *\n             *  @example\n             *    // Sort by 3rd column first, and then 4th column\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"order\": [[2,'asc'], [3,'desc']]\n             *      } );\n             *    } );\n             *\n             *    // No initial sorting\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"order\": []\n             *      } );\n             *    } );\n             */\n            \"aaSorting\": [[0, 'asc']],\n\n\n            /**\n             * This parameter is basically identical to the `sorting` parameter, but\n             * cannot be overridden by user interaction with the table. What this means\n             * is that you could have a column (visible or hidden) which the sorting\n             * will always be forced on first - any sorting after that (from the user)\n             * will then be performed as required. This can be useful for grouping rows\n             * together.\n             *  @type array\n             *  @default null\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.orderFixed\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"orderFixed\": [[0,'asc']]\n             *      } );\n             *    } )\n             */\n            \"aaSortingFixed\": [],\n\n\n            /**\n             * DataTables can be instructed to load data to display in the table from a\n             * Ajax source. This option defines how that Ajax call is made and where to.\n             *\n             * The `ajax` property has three different modes of operation, depending on\n             * how it is defined. These are:\n             *\n             * * `string` - Set the URL from where the data should be loaded from.\n             * * `object` - Define properties for `jQuery.ajax`.\n             * * `function` - Custom data get function\n             *\n             * `string`\n             * --------\n             *\n             * As a string, the `ajax` property simply defines the URL from which\n             * DataTables will load data.\n             *\n             * `object`\n             * --------\n             *\n             * As an object, the parameters in the object are passed to\n             * [jQuery.ajax](http://api.jquery.com/jQuery.ajax/) allowing fine control\n             * of the Ajax request. DataTables has a number of default parameters which\n             * you can override using this option. Please refer to the jQuery\n             * documentation for a full description of the options available, although\n             * the following parameters provide additional options in DataTables or\n             * require special consideration:\n             *\n             * * `data` - As with jQuery, `data` can be provided as an object, but it\n             *   can also be used as a function to manipulate the data DataTables sends\n             *   to the server. The function takes a single parameter, an object of\n             *   parameters with the values that DataTables has readied for sending. An\n             *   object may be returned which will be merged into the DataTables\n             *   defaults, or you can add the items to the object that was passed in and\n             *   not return anything from the function. This supersedes `fnServerParams`\n             *   from DataTables 1.9-.\n             *\n             * * `dataSrc` - By default DataTables will look for the property `data` (or\n             *   `aaData` for compatibility with DataTables 1.9-) when obtaining data\n             *   from an Ajax source or for server-side processing - this parameter\n             *   allows that property to be changed. You can use Javascript dotted\n             *   object notation to get a data source for multiple levels of nesting, or\n             *   it my be used as a function. As a function it takes a single parameter,\n             *   the JSON returned from the server, which can be manipulated as\n             *   required, with the returned value being that used by DataTables as the\n             *   data source for the table. This supersedes `sAjaxDataProp` from\n             *   DataTables 1.9-.\n             *\n             * * `success` - Should not be overridden it is used internally in\n             *   DataTables. To manipulate / transform the data returned by the server\n             *   use `ajax.dataSrc`, or use `ajax` as a function (see below).\n             *\n             * `function`\n             * ----------\n             *\n             * As a function, making the Ajax call is left up to yourself allowing\n             * complete control of the Ajax request. Indeed, if desired, a method other\n             * than Ajax could be used to obtain the required data, such as Web storage\n             * or an AIR database.\n             *\n             * The function is given four parameters and no return is required. The\n             * parameters are:\n             *\n             * 1. _object_ - Data to send to the server\n             * 2. _function_ - Callback function that must be executed when the required\n             *    data has been obtained. That data should be passed into the callback\n             *    as the only parameter\n             * 3. _object_ - DataTables settings object for the table\n             *\n             * Note that this supersedes `fnServerData` from DataTables 1.9-.\n             *\n             *  @type string|object|function\n             *  @default null\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.ajax\n             *  @since 1.10.0\n             *\n             * @example\n             *   // Get JSON data from a file via Ajax.\n             *   // Note DataTables expects data in the form `{ data: [ ...data... ] }` by default).\n             *   $('#example').dataTable( {\n             *     \"ajax\": \"data.json\"\n             *   } );\n             *\n             * @example\n             *   // Get JSON data from a file via Ajax, using `dataSrc` to change\n             *   // `data` to `tableData` (i.e. `{ tableData: [ ...data... ] }`)\n             *   $('#example').dataTable( {\n             *     \"ajax\": {\n             *       \"url\": \"data.json\",\n             *       \"dataSrc\": \"tableData\"\n             *     }\n             *   } );\n             *\n             * @example\n             *   // Get JSON data from a file via Ajax, using `dataSrc` to read data\n             *   // from a plain array rather than an array in an object\n             *   $('#example').dataTable( {\n             *     \"ajax\": {\n             *       \"url\": \"data.json\",\n             *       \"dataSrc\": \"\"\n             *     }\n             *   } );\n             *\n             * @example\n             *   // Manipulate the data returned from the server - add a link to data\n             *   // (note this can, should, be done using `render` for the column - this\n             *   // is just a simple example of how the data can be manipulated).\n             *   $('#example').dataTable( {\n             *     \"ajax\": {\n             *       \"url\": \"data.json\",\n             *       \"dataSrc\": function ( json ) {\n             *         for ( var i=0, ien=json.length ; i<ien ; i++ ) {\n             *           json[i][0] = '<a href=\"/message/'+json[i][0]+'>View message</a>';\n             *         }\n             *         return json;\n             *       }\n             *     }\n             *   } );\n             *\n             * @example\n             *   // Add data to the request\n             *   $('#example').dataTable( {\n             *     \"ajax\": {\n             *       \"url\": \"data.json\",\n             *       \"data\": function ( d ) {\n             *         return {\n             *           \"extra_search\": $('#extra').val()\n             *         };\n             *       }\n             *     }\n             *   } );\n             *\n             * @example\n             *   // Send request as POST\n             *   $('#example').dataTable( {\n             *     \"ajax\": {\n             *       \"url\": \"data.json\",\n             *       \"type\": \"POST\"\n             *     }\n             *   } );\n             *\n             * @example\n             *   // Get the data from localStorage (could interface with a form for\n             *   // adding, editing and removing rows).\n             *   $('#example').dataTable( {\n             *     \"ajax\": function (data, callback, settings) {\n             *       callback(\n             *         JSON.parse( localStorage.getItem('dataTablesData') )\n             *       );\n             *     }\n             *   } );\n             */\n            \"ajax\": null,\n\n\n            /**\n             * This parameter allows you to readily specify the entries in the length drop\n             * down menu that DataTables shows when pagination is enabled. It can be\n             * either a 1D array of options which will be used for both the displayed\n             * option and the value, or a 2D array which will use the array in the first\n             * position as the value, and the array in the second position as the\n             * displayed options (useful for language strings such as 'All').\n             *\n             * Note that the `pageLength` property will be automatically set to the\n             * first value given in this array, unless `pageLength` is also provided.\n             *  @type array\n             *  @default [ 10, 25, 50, 100 ]\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.lengthMenu\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"lengthMenu\": [[10, 25, 50, -1], [10, 25, 50, \"All\"]]\n             *      } );\n             *    } );\n             */\n            \"aLengthMenu\": [10, 25, 50, 100],\n\n\n            /**\n             * The `columns` option in the initialisation parameter allows you to define\n             * details about the way individual columns behave. For a full list of\n             * column options that can be set, please see\n             * {@link DataTable.defaults.column}. Note that if you use `columns` to\n             * define your columns, you must have an entry in the array for every single\n             * column that you have in your table (these can be null if you don't which\n             * to specify any options).\n             *  @member\n             *\n             *  @name DataTable.defaults.column\n             */\n            \"aoColumns\": null,\n\n            /**\n             * Very similar to `columns`, `columnDefs` allows you to target a specific\n             * column, multiple columns, or all columns, using the `targets` property of\n             * each object in the array. This allows great flexibility when creating\n             * tables, as the `columnDefs` arrays can be of any length, targeting the\n             * columns you specifically want. `columnDefs` may use any of the column\n             * options available: {@link DataTable.defaults.column}, but it _must_\n             * have `targets` defined in each object in the array. Values in the `targets`\n             * array may be:\n             *   <ul>\n             *     <li>a string - class name will be matched on the TH for the column</li>\n             *     <li>0 or a positive integer - column index counting from the left</li>\n             *     <li>a negative integer - column index counting from the right</li>\n             *     <li>the string \"_all\" - all columns (i.e. assign a default)</li>\n             *   </ul>\n             *  @member\n             *\n             *  @name DataTable.defaults.columnDefs\n             */\n            \"aoColumnDefs\": null,\n\n\n            /**\n             * Basically the same as `search`, this parameter defines the individual column\n             * filtering state at initialisation time. The array must be of the same size\n             * as the number of columns, and each element be an object with the parameters\n             * `search` and `escapeRegex` (the latter is optional). 'null' is also\n             * accepted and the default will be used.\n             *  @type array\n             *  @default []\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.searchCols\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"searchCols\": [\n             *          null,\n             *          { \"search\": \"My filter\" },\n             *          null,\n             *          { \"search\": \"^[0-9]\", \"escapeRegex\": false }\n             *        ]\n             *      } );\n             *    } )\n             */\n            \"aoSearchCols\": [],\n\n\n            /**\n             * An array of CSS classes that should be applied to displayed rows. This\n             * array may be of any length, and DataTables will apply each class\n             * sequentially, looping when required.\n             *  @type array\n             *  @default null <i>Will take the values determined by the `oClasses.stripe*`\n             *    options</i>\n             *\n             *  @dtopt Option\n             *  @name DataTable.defaults.stripeClasses\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stripeClasses\": [ 'strip1', 'strip2', 'strip3' ]\n             *      } );\n             *    } )\n             */\n            \"asStripeClasses\": null,\n\n\n            /**\n             * Enable or disable automatic column width calculation. This can be disabled\n             * as an optimisation (it takes some time to calculate the widths) if the\n             * tables widths are passed in using `columns`.\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.autoWidth\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"autoWidth\": false\n             *      } );\n             *    } );\n             */\n            \"bAutoWidth\": true,\n\n\n            /**\n             * Deferred rendering can provide DataTables with a huge speed boost when you\n             * are using an Ajax or JS data source for the table. This option, when set to\n             * true, will cause DataTables to defer the creation of the table elements for\n             * each row until they are needed for a draw - saving a significant amount of\n             * time.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.deferRender\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"ajax\": \"sources/arrays.txt\",\n             *        \"deferRender\": true\n             *      } );\n             *    } );\n             */\n            \"bDeferRender\": false,\n\n\n            /**\n             * Replace a DataTable which matches the given selector and replace it with\n             * one which has the properties of the new initialisation object passed. If no\n             * table matches the selector, then the new DataTable will be constructed as\n             * per normal.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.destroy\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"srollY\": \"200px\",\n             *        \"paginate\": false\n             *      } );\n             *\n             *      // Some time later....\n             *      $('#example').dataTable( {\n             *        \"filter\": false,\n             *        \"destroy\": true\n             *      } );\n             *    } );\n             */\n            \"bDestroy\": false,\n\n\n            /**\n             * Enable or disable filtering of data. Filtering in DataTables is \"smart\" in\n             * that it allows the end user to input multiple words (space separated) and\n             * will match a row containing those words, even if not in the order that was\n             * specified (this allow matching across multiple columns). Note that if you\n             * wish to use filtering in DataTables this must remain 'true' - to remove the\n             * default filtering input box and retain filtering abilities, please use\n             * {@link DataTable.defaults.dom}.\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.searching\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"searching\": false\n             *      } );\n             *    } );\n             */\n            \"bFilter\": true,\n\n\n            /**\n             * Enable or disable the table information display. This shows information\n             * about the data that is currently visible on the page, including information\n             * about filtered data if that action is being performed.\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.info\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"info\": false\n             *      } );\n             *    } );\n             */\n            \"bInfo\": true,\n\n\n            /**\n             * Allows the end user to select the size of a formatted page from a select\n             * menu (sizes are 10, 25, 50 and 100). Requires pagination (`paginate`).\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.lengthChange\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"lengthChange\": false\n             *      } );\n             *    } );\n             */\n            \"bLengthChange\": true,\n\n\n            /**\n             * Enable or disable pagination.\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.paging\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"paging\": false\n             *      } );\n             *    } );\n             */\n            \"bPaginate\": true,\n\n\n            /**\n             * Enable or disable the display of a 'processing' indicator when the table is\n             * being processed (e.g. a sort). This is particularly useful for tables with\n             * large amounts of data where it can take a noticeable amount of time to sort\n             * the entries.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.processing\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"processing\": true\n             *      } );\n             *    } );\n             */\n            \"bProcessing\": false,\n\n\n            /**\n             * Retrieve the DataTables object for the given selector. Note that if the\n             * table has already been initialised, this parameter will cause DataTables\n             * to simply return the object that has already been set up - it will not take\n             * account of any changes you might have made to the initialisation object\n             * passed to DataTables (setting this parameter to true is an acknowledgement\n             * that you understand this). `destroy` can be used to reinitialise a table if\n             * you need.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.retrieve\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      initTable();\n             *      tableActions();\n             *    } );\n             *\n             *    function initTable ()\n             *    {\n             *      return $('#example').dataTable( {\n             *        \"scrollY\": \"200px\",\n             *        \"paginate\": false,\n             *        \"retrieve\": true\n             *      } );\n             *    }\n             *\n             *    function tableActions ()\n             *    {\n             *      var table = initTable();\n             *      // perform API operations with oTable\n             *    }\n             */\n            \"bRetrieve\": false,\n\n\n            /**\n             * When vertical (y) scrolling is enabled, DataTables will force the height of\n             * the table's viewport to the given height at all times (useful for layout).\n             * However, this can look odd when filtering data down to a small data set,\n             * and the footer is left \"floating\" further down. This parameter (when\n             * enabled) will cause DataTables to collapse the table's viewport down when\n             * the result set will fit within the given Y height.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.scrollCollapse\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"scrollY\": \"200\",\n             *        \"scrollCollapse\": true\n             *      } );\n             *    } );\n             */\n            \"bScrollCollapse\": false,\n\n\n            /**\n             * Configure DataTables to use server-side processing. Note that the\n             * `ajax` parameter must also be given in order to give DataTables a\n             * source to obtain the required data for each draw.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Features\n             *  @dtopt Server-side\n             *  @name DataTable.defaults.serverSide\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"serverSide\": true,\n             *        \"ajax\": \"xhr.php\"\n             *      } );\n             *    } );\n             */\n            \"bServerSide\": false,\n\n\n            /**\n             * Enable or disable sorting of columns. Sorting of individual columns can be\n             * disabled by the `sortable` option for each column.\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.ordering\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"ordering\": false\n             *      } );\n             *    } );\n             */\n            \"bSort\": true,\n\n\n            /**\n             * Enable or display DataTables' ability to sort multiple columns at the\n             * same time (activated by shift-click by the user).\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.orderMulti\n             *\n             *  @example\n             *    // Disable multiple column sorting ability\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"orderMulti\": false\n             *      } );\n             *    } );\n             */\n            \"bSortMulti\": true,\n\n\n            /**\n             * Allows control over whether DataTables should use the top (true) unique\n             * cell that is found for a single column, or the bottom (false - default).\n             * This is useful when using complex headers.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.orderCellsTop\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"orderCellsTop\": true\n             *      } );\n             *    } );\n             */\n            \"bSortCellsTop\": false,\n\n\n            /**\n             * Enable or disable the addition of the classes `sorting\\_1`, `sorting\\_2` and\n             * `sorting\\_3` to the columns which are currently being sorted on. This is\n             * presented as a feature switch as it can increase processing time (while\n             * classes are removed and added) so for large data sets you might want to\n             * turn this off.\n             *  @type boolean\n             *  @default true\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.orderClasses\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"orderClasses\": false\n             *      } );\n             *    } );\n             */\n            \"bSortClasses\": true,\n\n\n            /**\n             * Enable or disable state saving. When enabled HTML5 `localStorage` will be\n             * used to save table display information such as pagination information,\n             * display length, filtering and sorting. As such when the end user reloads\n             * the page the display display will match what thy had previously set up.\n             *\n             * Due to the use of `localStorage` the default state saving is not supported\n             * in IE6 or 7. If state saving is required in those browsers, use\n             * `stateSaveCallback` to provide a storage solution such as cookies.\n             *  @type boolean\n             *  @default false\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.stateSave\n             *\n             *  @example\n             *    $(document).ready( function () {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true\n             *      } );\n             *    } );\n             */\n            \"bStateSave\": false,\n\n\n            /**\n             * This function is called when a TR element is created (and all TD child\n             * elements have been inserted), or registered if using a DOM source, allowing\n             * manipulation of the TR element (adding classes etc).\n             *  @type function\n             *  @param {node} row \"TR\" element for the current row\n             *  @param {array} data Raw data array for this row\n             *  @param {int} dataIndex The index of this row in the internal aoData array\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.createdRow\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"createdRow\": function( row, data, dataIndex ) {\n             *          // Bold the grade for all 'A' grade browsers\n             *          if ( data[4] == \"A\" )\n             *          {\n             *            $('td:eq(4)', row).html( '<b>A</b>' );\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnCreatedRow\": null,\n\n\n            /**\n             * This function is called on every 'draw' event, and allows you to\n             * dynamically modify any aspect you want about the created DOM.\n             *  @type function\n             *  @param {object} settings DataTables settings object\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.drawCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"drawCallback\": function( settings ) {\n             *          alert( 'DataTables has redrawn the table' );\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnDrawCallback\": null,\n\n\n            /**\n             * Identical to fnHeaderCallback() but for the table footer this function\n             * allows you to modify the table footer on every 'draw' event.\n             *  @type function\n             *  @param {node} foot \"TR\" element for the footer\n             *  @param {array} data Full table data (as derived from the original HTML)\n             *  @param {int} start Index for the current display starting point in the\n             *    display array\n             *  @param {int} end Index for the current display ending point in the\n             *    display array\n             *  @param {array int} display Index array to translate the visual position\n             *    to the full data array\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.footerCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"footerCallback\": function( tfoot, data, start, end, display ) {\n             *          tfoot.getElementsByTagName('th')[0].innerHTML = \"Starting index is \"+start;\n             *        }\n             *      } );\n             *    } )\n             */\n            \"fnFooterCallback\": null,\n\n\n            /**\n             * When rendering large numbers in the information element for the table\n             * (i.e. \"Showing 1 to 10 of 57 entries\") DataTables will render large numbers\n             * to have a comma separator for the 'thousands' units (e.g. 1 million is\n             * rendered as \"1,000,000\") to help readability for the end user. This\n             * function will override the default method DataTables uses.\n             *  @type function\n             *  @member\n             *  @param {int} toFormat number to be formatted\n             *  @returns {string} formatted string for DataTables to show the number\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.formatNumber\n             *\n             *  @example\n             *    // Format a number using a single quote for the separator (note that\n             *    // this can also be done with the language.thousands option)\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"formatNumber\": function ( toFormat ) {\n             *          return toFormat.toString().replace(\n             *            /\\B(?=(\\d{3})+(?!\\d))/g, \"'\"\n             *          );\n             *        };\n             *      } );\n             *    } );\n             */\n            \"fnFormatNumber\": function (toFormat) {\n                return toFormat.toString().replace(\n                    /\\B(?=(\\d{3})+(?!\\d))/g,\n                    this.oLanguage.sThousands\n                );\n            },\n\n\n            /**\n             * This function is called on every 'draw' event, and allows you to\n             * dynamically modify the header row. This can be used to calculate and\n             * display useful information about the table.\n             *  @type function\n             *  @param {node} head \"TR\" element for the header\n             *  @param {array} data Full table data (as derived from the original HTML)\n             *  @param {int} start Index for the current display starting point in the\n             *    display array\n             *  @param {int} end Index for the current display ending point in the\n             *    display array\n             *  @param {array int} display Index array to translate the visual position\n             *    to the full data array\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.headerCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"fheaderCallback\": function( head, data, start, end, display ) {\n             *          head.getElementsByTagName('th')[0].innerHTML = \"Displaying \"+(end-start)+\" records\";\n             *        }\n             *      } );\n             *    } )\n             */\n            \"fnHeaderCallback\": null,\n\n\n            /**\n             * The information element can be used to convey information about the current\n             * state of the table. Although the internationalisation options presented by\n             * DataTables are quite capable of dealing with most customisations, there may\n             * be times where you wish to customise the string further. This callback\n             * allows you to do exactly that.\n             *  @type function\n             *  @param {object} oSettings DataTables settings object\n             *  @param {int} start Starting position in data for the draw\n             *  @param {int} end End position in data for the draw\n             *  @param {int} max Total number of rows in the table (regardless of\n             *    filtering)\n             *  @param {int} total Total number of rows in the data set, after filtering\n             *  @param {string} pre The string that DataTables has formatted using it's\n             *    own rules\n             *  @returns {string} The string to be displayed in the information element.\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.infoCallback\n             *\n             *  @example\n             *    $('#example').dataTable( {\n             *      \"infoCallback\": function( settings, start, end, max, total, pre ) {\n             *        return start +\" to \"+ end;\n             *      }\n             *    } );\n             */\n            \"fnInfoCallback\": null,\n\n\n            /**\n             * Called when the table has been initialised. Normally DataTables will\n             * initialise sequentially and there will be no need for this function,\n             * however, this does not hold true when using external language information\n             * since that is obtained using an async XHR call.\n             *  @type function\n             *  @param {object} settings DataTables settings object\n             *  @param {object} json The JSON object request from the server - only\n             *    present if client-side Ajax sourced data is used\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.initComplete\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"initComplete\": function(settings, json) {\n             *          alert( 'DataTables has finished its initialisation.' );\n             *        }\n             *      } );\n             *    } )\n             */\n            \"fnInitComplete\": null,\n\n\n            /**\n             * Called at the very start of each table draw and can be used to cancel the\n             * draw by returning false, any other return (including undefined) results in\n             * the full draw occurring).\n             *  @type function\n             *  @param {object} settings DataTables settings object\n             *  @returns {boolean} False will cancel the draw, anything else (including no\n             *    return) will allow it to complete.\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.preDrawCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"preDrawCallback\": function( settings ) {\n             *          if ( $('#test').val() == 1 ) {\n             *            return false;\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnPreDrawCallback\": null,\n\n\n            /**\n             * This function allows you to 'post process' each row after it have been\n             * generated for each table draw, but before it is rendered on screen. This\n             * function might be used for setting the row class name etc.\n             *  @type function\n             *  @param {node} row \"TR\" element for the current row\n             *  @param {array} data Raw data array for this row\n             *  @param {int} displayIndex The display index for the current table draw\n             *  @param {int} displayIndexFull The index of the data in the full list of\n             *    rows (after filtering)\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.rowCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"rowCallback\": function( row, data, displayIndex, displayIndexFull ) {\n             *          // Bold the grade for all 'A' grade browsers\n             *          if ( data[4] == \"A\" ) {\n             *            $('td:eq(4)', row).html( '<b>A</b>' );\n             *          }\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnRowCallback\": null,\n\n\n            /**\n             * __Deprecated__ The functionality provided by this parameter has now been\n             * superseded by that provided through `ajax`, which should be used instead.\n             *\n             * This parameter allows you to override the default function which obtains\n             * the data from the server so something more suitable for your application.\n             * For example you could use POST data, or pull information from a Gears or\n             * AIR database.\n             *  @type function\n             *  @member\n             *  @param {string} source HTTP source to obtain the data from (`ajax`)\n             *  @param {array} data A key/value pair object containing the data to send\n             *    to the server\n             *  @param {function} callback to be called on completion of the data get\n             *    process that will draw the data on the page.\n             *  @param {object} settings DataTables settings object\n             *\n             *  @dtopt Callbacks\n             *  @dtopt Server-side\n             *  @name DataTable.defaults.serverData\n             *\n             *  @deprecated 1.10. Please use `ajax` for this functionality now.\n             */\n            \"fnServerData\": null,\n\n\n            /**\n             * __Deprecated__ The functionality provided by this parameter has now been\n             * superseded by that provided through `ajax`, which should be used instead.\n             *\n             *  It is often useful to send extra data to the server when making an Ajax\n             * request - for example custom filtering information, and this callback\n             * function makes it trivial to send extra information to the server. The\n             * passed in parameter is the data set that has been constructed by\n             * DataTables, and you can add to this or modify it as you require.\n             *  @type function\n             *  @param {array} data Data array (array of objects which are name/value\n             *    pairs) that has been constructed by DataTables and will be sent to the\n             *    server. In the case of Ajax sourced data with server-side processing\n             *    this will be an empty array, for server-side processing there will be a\n             *    significant number of parameters!\n             *  @returns {undefined} Ensure that you modify the data array passed in,\n             *    as this is passed by reference.\n             *\n             *  @dtopt Callbacks\n             *  @dtopt Server-side\n             *  @name DataTable.defaults.serverParams\n             *\n             *  @deprecated 1.10. Please use `ajax` for this functionality now.\n             */\n            \"fnServerParams\": null,\n\n\n            /**\n             * Load the table state. With this function you can define from where, and how, the\n             * state of a table is loaded. By default DataTables will load from `localStorage`\n             * but you might wish to use a server-side database or cookies.\n             *  @type function\n             *  @member\n             *  @param {object} settings DataTables settings object\n             *  @param {object} callback Callback that can be executed when done. It\n             *    should be passed the loaded state object.\n             *  @return {object} The DataTables state object to be loaded\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.stateLoadCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true,\n             *        \"stateLoadCallback\": function (settings, callback) {\n             *          $.ajax( {\n             *            \"url\": \"/state_load\",\n             *            \"dataType\": \"json\",\n             *            \"success\": function (json) {\n             *              callback( json );\n             *            }\n             *          } );\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnStateLoadCallback\": function (settings) {\n                try {\n                    return JSON.parse(\n                        (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(\n                            'DataTables_' + settings.sInstance + '_' + location.pathname\n                        )\n                    );\n                } catch (e) {\n                    return {};\n                }\n            },\n\n\n            /**\n             * Callback which allows modification of the saved state prior to loading that state.\n             * This callback is called when the table is loading state from the stored data, but\n             * prior to the settings object being modified by the saved state. Note that for\n             * plug-in authors, you should use the `stateLoadParams` event to load parameters for\n             * a plug-in.\n             *  @type function\n             *  @param {object} settings DataTables settings object\n             *  @param {object} data The state object that is to be loaded\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.stateLoadParams\n             *\n             *  @example\n             *    // Remove a saved filter, so filtering is never loaded\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true,\n             *        \"stateLoadParams\": function (settings, data) {\n             *          data.oSearch.sSearch = \"\";\n             *        }\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Disallow state loading by returning false\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true,\n             *        \"stateLoadParams\": function (settings, data) {\n             *          return false;\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnStateLoadParams\": null,\n\n\n            /**\n             * Callback that is called when the state has been loaded from the state saving method\n             * and the DataTables settings object has been modified as a result of the loaded state.\n             *  @type function\n             *  @param {object} settings DataTables settings object\n             *  @param {object} data The state object that was loaded\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.stateLoaded\n             *\n             *  @example\n             *    // Show an alert with the filtering value that was saved\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true,\n             *        \"stateLoaded\": function (settings, data) {\n             *          alert( 'Saved filter was: '+data.oSearch.sSearch );\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnStateLoaded\": null,\n\n\n            /**\n             * Save the table state. This function allows you to define where and how the state\n             * information for the table is stored By default DataTables will use `localStorage`\n             * but you might wish to use a server-side database or cookies.\n             *  @type function\n             *  @member\n             *  @param {object} settings DataTables settings object\n             *  @param {object} data The state object to be saved\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.stateSaveCallback\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true,\n             *        \"stateSaveCallback\": function (settings, data) {\n             *          // Send an Ajax request to the server with the state object\n             *          $.ajax( {\n             *            \"url\": \"/state_save\",\n             *            \"data\": data,\n             *            \"dataType\": \"json\",\n             *            \"method\": \"POST\"\n             *            \"success\": function () {}\n             *          } );\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnStateSaveCallback\": function (settings, data) {\n                try {\n                    (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(\n                        'DataTables_' + settings.sInstance + '_' + location.pathname,\n                        JSON.stringify(data)\n                    );\n                } catch (e) { }\n            },\n\n\n            /**\n             * Callback which allows modification of the state to be saved. Called when the table\n             * has changed state a new state save is required. This method allows modification of\n             * the state saving object prior to actually doing the save, including addition or\n             * other state properties or modification. Note that for plug-in authors, you should\n             * use the `stateSaveParams` event to save parameters for a plug-in.\n             *  @type function\n             *  @param {object} settings DataTables settings object\n             *  @param {object} data The state object to be saved\n             *\n             *  @dtopt Callbacks\n             *  @name DataTable.defaults.stateSaveParams\n             *\n             *  @example\n             *    // Remove a saved filter, so filtering is never saved\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateSave\": true,\n             *        \"stateSaveParams\": function (settings, data) {\n             *          data.oSearch.sSearch = \"\";\n             *        }\n             *      } );\n             *    } );\n             */\n            \"fnStateSaveParams\": null,\n\n\n            /**\n             * Duration for which the saved state information is considered valid. After this period\n             * has elapsed the state will be returned to the default.\n             * Value is given in seconds.\n             *  @type int\n             *  @default 7200 <i>(2 hours)</i>\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.stateDuration\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"stateDuration\": 60*60*24; // 1 day\n             *      } );\n             *    } )\n             */\n            \"iStateDuration\": 7200,\n\n\n            /**\n             * When enabled DataTables will not make a request to the server for the first\n             * page draw - rather it will use the data already on the page (no sorting etc\n             * will be applied to it), thus saving on an XHR at load time. `deferLoading`\n             * is used to indicate that deferred loading is required, but it is also used\n             * to tell DataTables how many records there are in the full table (allowing\n             * the information element and pagination to be displayed correctly). In the case\n             * where a filtering is applied to the table on initial load, this can be\n             * indicated by giving the parameter as an array, where the first element is\n             * the number of records available after filtering and the second element is the\n             * number of records without filtering (allowing the table information element\n             * to be shown correctly).\n             *  @type int | array\n             *  @default null\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.deferLoading\n             *\n             *  @example\n             *    // 57 records available in the table, no filtering applied\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"serverSide\": true,\n             *        \"ajax\": \"scripts/server_processing.php\",\n             *        \"deferLoading\": 57\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // 57 records after filtering, 100 without filtering (an initial filter applied)\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"serverSide\": true,\n             *        \"ajax\": \"scripts/server_processing.php\",\n             *        \"deferLoading\": [ 57, 100 ],\n             *        \"search\": {\n             *          \"search\": \"my_filter\"\n             *        }\n             *      } );\n             *    } );\n             */\n            \"iDeferLoading\": null,\n\n\n            /**\n             * Number of rows to display on a single page when using pagination. If\n             * feature enabled (`lengthChange`) then the end user will be able to override\n             * this to a custom setting using a pop-up menu.\n             *  @type int\n             *  @default 10\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.pageLength\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"pageLength\": 50\n             *      } );\n             *    } )\n             */\n            \"iDisplayLength\": 10,\n\n\n            /**\n             * Define the starting point for data display when using DataTables with\n             * pagination. Note that this parameter is the number of records, rather than\n             * the page number, so if you have 10 records per page and want to start on\n             * the third page, it should be \"20\".\n             *  @type int\n             *  @default 0\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.displayStart\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"displayStart\": 20\n             *      } );\n             *    } )\n             */\n            \"iDisplayStart\": 0,\n\n\n            /**\n             * By default DataTables allows keyboard navigation of the table (sorting, paging,\n             * and filtering) by adding a `tabindex` attribute to the required elements. This\n             * allows you to tab through the controls and press the enter key to activate them.\n             * The tabindex is default 0, meaning that the tab follows the flow of the document.\n             * You can overrule this using this parameter if you wish. Use a value of -1 to\n             * disable built-in keyboard navigation.\n             *  @type int\n             *  @default 0\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.tabIndex\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"tabIndex\": 1\n             *      } );\n             *    } );\n             */\n            \"iTabIndex\": 0,\n\n\n            /**\n             * Classes that DataTables assigns to the various components and features\n             * that it adds to the HTML table. This allows classes to be configured\n             * during initialisation in addition to through the static\n             * {@link DataTable.ext.oStdClasses} object).\n             *  @namespace\n             *  @name DataTable.defaults.classes\n             */\n            \"oClasses\": {},\n\n\n            /**\n             * All strings that DataTables uses in the user interface that it creates\n             * are defined in this object, allowing you to modified them individually or\n             * completely replace them all as required.\n             *  @namespace\n             *  @name DataTable.defaults.language\n             */\n            \"oLanguage\": {\n                /**\n                 * Strings that are used for WAI-ARIA labels and controls only (these are not\n                 * actually visible on the page, but will be read by screenreaders, and thus\n                 * must be internationalised as well).\n                 *  @namespace\n                 *  @name DataTable.defaults.language.aria\n                 */\n                \"oAria\": {\n                    /**\n                     * ARIA label that is added to the table headers when the column may be\n                     * sorted ascending by activing the column (click or return when focused).\n                     * Note that the column header is prefixed to this string.\n                     *  @type string\n                     *  @default : activate to sort column ascending\n                     *\n                     *  @dtopt Language\n                     *  @name DataTable.defaults.language.aria.sortAscending\n                     *\n                     *  @example\n                     *    $(document).ready( function() {\n                     *      $('#example').dataTable( {\n                     *        \"language\": {\n                     *          \"aria\": {\n                     *            \"sortAscending\": \" - click/return to sort ascending\"\n                     *          }\n                     *        }\n                     *      } );\n                     *    } );\n                     */\n                    \"sSortAscending\": \": activate to sort column ascending\",\n\n                    /**\n                     * ARIA label that is added to the table headers when the column may be\n                     * sorted descending by activing the column (click or return when focused).\n                     * Note that the column header is prefixed to this string.\n                     *  @type string\n                     *  @default : activate to sort column ascending\n                     *\n                     *  @dtopt Language\n                     *  @name DataTable.defaults.language.aria.sortDescending\n                     *\n                     *  @example\n                     *    $(document).ready( function() {\n                     *      $('#example').dataTable( {\n                     *        \"language\": {\n                     *          \"aria\": {\n                     *            \"sortDescending\": \" - click/return to sort descending\"\n                     *          }\n                     *        }\n                     *      } );\n                     *    } );\n                     */\n                    \"sSortDescending\": \": activate to sort column descending\"\n                },\n\n                /**\n                 * Pagination string used by DataTables for the built-in pagination\n                 * control types.\n                 *  @namespace\n                 *  @name DataTable.defaults.language.paginate\n                 */\n                \"oPaginate\": {\n                    /**\n                     * Text to use when using the 'full_numbers' type of pagination for the\n                     * button to take the user to the first page.\n                     *  @type string\n                     *  @default First\n                     *\n                     *  @dtopt Language\n                     *  @name DataTable.defaults.language.paginate.first\n                     *\n                     *  @example\n                     *    $(document).ready( function() {\n                     *      $('#example').dataTable( {\n                     *        \"language\": {\n                     *          \"paginate\": {\n                     *            \"first\": \"First page\"\n                     *          }\n                     *        }\n                     *      } );\n                     *    } );\n                     */\n                    \"sFirst\": \"First\",\n\n\n                    /**\n                     * Text to use when using the 'full_numbers' type of pagination for the\n                     * button to take the user to the last page.\n                     *  @type string\n                     *  @default Last\n                     *\n                     *  @dtopt Language\n                     *  @name DataTable.defaults.language.paginate.last\n                     *\n                     *  @example\n                     *    $(document).ready( function() {\n                     *      $('#example').dataTable( {\n                     *        \"language\": {\n                     *          \"paginate\": {\n                     *            \"last\": \"Last page\"\n                     *          }\n                     *        }\n                     *      } );\n                     *    } );\n                     */\n                    \"sLast\": \"Last\",\n\n\n                    /**\n                     * Text to use for the 'next' pagination button (to take the user to the\n                     * next page).\n                     *  @type string\n                     *  @default Next\n                     *\n                     *  @dtopt Language\n                     *  @name DataTable.defaults.language.paginate.next\n                     *\n                     *  @example\n                     *    $(document).ready( function() {\n                     *      $('#example').dataTable( {\n                     *        \"language\": {\n                     *          \"paginate\": {\n                     *            \"next\": \"Next page\"\n                     *          }\n                     *        }\n                     *      } );\n                     *    } );\n                     */\n                    \"sNext\": \"Next\",\n\n\n                    /**\n                     * Text to use for the 'previous' pagination button (to take the user to\n                     * the previous page).\n                     *  @type string\n                     *  @default Previous\n                     *\n                     *  @dtopt Language\n                     *  @name DataTable.defaults.language.paginate.previous\n                     *\n                     *  @example\n                     *    $(document).ready( function() {\n                     *      $('#example').dataTable( {\n                     *        \"language\": {\n                     *          \"paginate\": {\n                     *            \"previous\": \"Previous page\"\n                     *          }\n                     *        }\n                     *      } );\n                     *    } );\n                     */\n                    \"sPrevious\": \"Previous\"\n                },\n\n                /**\n                 * This string is shown in preference to `zeroRecords` when the table is\n                 * empty of data (regardless of filtering). Note that this is an optional\n                 * parameter - if it is not given, the value of `zeroRecords` will be used\n                 * instead (either the default or given value).\n                 *  @type string\n                 *  @default No data available in table\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.emptyTable\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"emptyTable\": \"No data available in table\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sEmptyTable\": \"No data available in table\",\n\n\n                /**\n                 * This string gives information to the end user about the information\n                 * that is current on display on the page. The following tokens can be\n                 * used in the string and will be dynamically replaced as the table\n                 * display updates. This tokens can be placed anywhere in the string, or\n                 * removed as needed by the language requires:\n                 *\n                 * * `\\_START\\_` - Display index of the first record on the current page\n                 * * `\\_END\\_` - Display index of the last record on the current page\n                 * * `\\_TOTAL\\_` - Number of records in the table after filtering\n                 * * `\\_MAX\\_` - Number of records in the table without filtering\n                 * * `\\_PAGE\\_` - Current page number\n                 * * `\\_PAGES\\_` - Total number of pages of data in the table\n                 *\n                 *  @type string\n                 *  @default Showing _START_ to _END_ of _TOTAL_ entries\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.info\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"info\": \"Showing page _PAGE_ of _PAGES_\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sInfo\": \"Showing _START_ to _END_ of _TOTAL_ entries\",\n\n\n                /**\n                 * Display information string for when the table is empty. Typically the\n                 * format of this string should match `info`.\n                 *  @type string\n                 *  @default Showing 0 to 0 of 0 entries\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.infoEmpty\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"infoEmpty\": \"No entries to show\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sInfoEmpty\": \"Showing 0 to 0 of 0 entries\",\n\n\n                /**\n                 * When a user filters the information in a table, this string is appended\n                 * to the information (`info`) to give an idea of how strong the filtering\n                 * is. The variable _MAX_ is dynamically updated.\n                 *  @type string\n                 *  @default (filtered from _MAX_ total entries)\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.infoFiltered\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"infoFiltered\": \" - filtering from _MAX_ records\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sInfoFiltered\": \"(filtered from _MAX_ total entries)\",\n\n\n                /**\n                 * If can be useful to append extra information to the info string at times,\n                 * and this variable does exactly that. This information will be appended to\n                 * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are\n                 * being used) at all times.\n                 *  @type string\n                 *  @default <i>Empty string</i>\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.infoPostFix\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"infoPostFix\": \"All records shown are derived from real information.\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sInfoPostFix\": \"\",\n\n\n                /**\n                 * This decimal place operator is a little different from the other\n                 * language options since DataTables doesn't output floating point\n                 * numbers, so it won't ever use this for display of a number. Rather,\n                 * what this parameter does is modify the sort methods of the table so\n                 * that numbers which are in a format which has a character other than\n                 * a period (`.`) as a decimal place will be sorted numerically.\n                 *\n                 * Note that numbers with different decimal places cannot be shown in\n                 * the same table and still be sortable, the table must be consistent.\n                 * However, multiple different tables on the page can use different\n                 * decimal place characters.\n                 *  @type string\n                 *  @default\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.decimal\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"decimal\": \",\"\n                 *          \"thousands\": \".\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sDecimal\": \"\",\n\n\n                /**\n                 * DataTables has a build in number formatter (`formatNumber`) which is\n                 * used to format large numbers that are used in the table information.\n                 * By default a comma is used, but this can be trivially changed to any\n                 * character you wish with this parameter.\n                 *  @type string\n                 *  @default ,\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.thousands\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"thousands\": \"'\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sThousands\": \",\",\n\n\n                /**\n                 * Detail the action that will be taken when the drop down menu for the\n                 * pagination length option is changed. The '_MENU_' variable is replaced\n                 * with a default select list of 10, 25, 50 and 100, and can be replaced\n                 * with a custom select box if required.\n                 *  @type string\n                 *  @default Show _MENU_ entries\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.lengthMenu\n                 *\n                 *  @example\n                 *    // Language change only\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"lengthMenu\": \"Display _MENU_ records\"\n                 *        }\n                 *      } );\n                 *    } );\n                 *\n                 *  @example\n                 *    // Language and options change\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"lengthMenu\": 'Display <select>'+\n                 *            '<option value=\"10\">10</option>'+\n                 *            '<option value=\"20\">20</option>'+\n                 *            '<option value=\"30\">30</option>'+\n                 *            '<option value=\"40\">40</option>'+\n                 *            '<option value=\"50\">50</option>'+\n                 *            '<option value=\"-1\">All</option>'+\n                 *            '</select> records'\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sLengthMenu\": \"Show _MENU_ entries\",\n\n\n                /**\n                 * When using Ajax sourced data and during the first draw when DataTables is\n                 * gathering the data, this message is shown in an empty row in the table to\n                 * indicate to the end user the the data is being loaded. Note that this\n                 * parameter is not used when loading data by server-side processing, just\n                 * Ajax sourced data with client-side processing.\n                 *  @type string\n                 *  @default Loading...\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.loadingRecords\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"loadingRecords\": \"Please wait - loading...\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sLoadingRecords\": \"Loading...\",\n\n\n                /**\n                 * Text which is displayed when the table is processing a user action\n                 * (usually a sort command or similar).\n                 *  @type string\n                 *  @default Processing...\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.processing\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"processing\": \"DataTables is currently busy\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sProcessing\": \"Processing...\",\n\n\n                /**\n                 * Details the actions that will be taken when the user types into the\n                 * filtering input text box. The variable \"_INPUT_\", if used in the string,\n                 * is replaced with the HTML text box for the filtering input allowing\n                 * control over where it appears in the string. If \"_INPUT_\" is not given\n                 * then the input box is appended to the string automatically.\n                 *  @type string\n                 *  @default Search:\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.search\n                 *\n                 *  @example\n                 *    // Input text box will be appended at the end automatically\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"search\": \"Filter records:\"\n                 *        }\n                 *      } );\n                 *    } );\n                 *\n                 *  @example\n                 *    // Specify where the filter should appear\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"search\": \"Apply filter _INPUT_ to table\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sSearch\": \"Search:\",\n\n\n                /**\n                 * Assign a `placeholder` attribute to the search `input` element\n                 *  @type string\n                 *  @default\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.searchPlaceholder\n                 */\n                \"sSearchPlaceholder\": \"\",\n\n\n                /**\n                 * All of the language information can be stored in a file on the\n                 * server-side, which DataTables will look up if this parameter is passed.\n                 * It must store the URL of the language file, which is in a JSON format,\n                 * and the object has the same properties as the oLanguage object in the\n                 * initialiser object (i.e. the above parameters). Please refer to one of\n                 * the example language files to see how this works in action.\n                 *  @type string\n                 *  @default <i>Empty string - i.e. disabled</i>\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.url\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"url\": \"http://www.sprymedia.co.uk/dataTables/lang.txt\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sUrl\": \"\",\n\n\n                /**\n                 * Text shown inside the table records when the is no information to be\n                 * displayed after filtering. `emptyTable` is shown when there is simply no\n                 * information in the table at all (regardless of filtering).\n                 *  @type string\n                 *  @default No matching records found\n                 *\n                 *  @dtopt Language\n                 *  @name DataTable.defaults.language.zeroRecords\n                 *\n                 *  @example\n                 *    $(document).ready( function() {\n                 *      $('#example').dataTable( {\n                 *        \"language\": {\n                 *          \"zeroRecords\": \"No records to display\"\n                 *        }\n                 *      } );\n                 *    } );\n                 */\n                \"sZeroRecords\": \"No matching records found\"\n            },\n\n\n            /**\n             * This parameter allows you to have define the global filtering state at\n             * initialisation time. As an object the `search` parameter must be\n             * defined, but all other parameters are optional. When `regex` is true,\n             * the search string will be treated as a regular expression, when false\n             * (default) it will be treated as a straight string. When `smart`\n             * DataTables will use it's smart filtering methods (to word match at\n             * any point in the data), when false this will not be done.\n             *  @namespace\n             *  @extends DataTable.models.oSearch\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.search\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"search\": {\"search\": \"Initial search\"}\n             *      } );\n             *    } )\n             */\n            \"oSearch\": $.extend({}, DataTable.models.oSearch),\n\n\n            /**\n             * __Deprecated__ The functionality provided by this parameter has now been\n             * superseded by that provided through `ajax`, which should be used instead.\n             *\n             * By default DataTables will look for the property `data` (or `aaData` for\n             * compatibility with DataTables 1.9-) when obtaining data from an Ajax\n             * source or for server-side processing - this parameter allows that\n             * property to be changed. You can use Javascript dotted object notation to\n             * get a data source for multiple levels of nesting.\n             *  @type string\n             *  @default data\n             *\n             *  @dtopt Options\n             *  @dtopt Server-side\n             *  @name DataTable.defaults.ajaxDataProp\n             *\n             *  @deprecated 1.10. Please use `ajax` for this functionality now.\n             */\n            \"sAjaxDataProp\": \"data\",\n\n\n            /**\n             * __Deprecated__ The functionality provided by this parameter has now been\n             * superseded by that provided through `ajax`, which should be used instead.\n             *\n             * You can instruct DataTables to load data from an external\n             * source using this parameter (use aData if you want to pass data in you\n             * already have). Simply provide a url a JSON object can be obtained from.\n             *  @type string\n             *  @default null\n             *\n             *  @dtopt Options\n             *  @dtopt Server-side\n             *  @name DataTable.defaults.ajaxSource\n             *\n             *  @deprecated 1.10. Please use `ajax` for this functionality now.\n             */\n            \"sAjaxSource\": null,\n\n\n            /**\n             * This initialisation variable allows you to specify exactly where in the\n             * DOM you want DataTables to inject the various controls it adds to the page\n             * (for example you might want the pagination controls at the top of the\n             * table). DIV elements (with or without a custom class) can also be added to\n             * aid styling. The follow syntax is used:\n             *   <ul>\n             *     <li>The following options are allowed:\n             *       <ul>\n             *         <li>'l' - Length changing</li>\n             *         <li>'f' - Filtering input</li>\n             *         <li>'t' - The table!</li>\n             *         <li>'i' - Information</li>\n             *         <li>'p' - Pagination</li>\n             *         <li>'r' - pRocessing</li>\n             *       </ul>\n             *     </li>\n             *     <li>The following constants are allowed:\n             *       <ul>\n             *         <li>'H' - jQueryUI theme \"header\" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>\n             *         <li>'F' - jQueryUI theme \"footer\" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>\n             *       </ul>\n             *     </li>\n             *     <li>The following syntax is expected:\n             *       <ul>\n             *         <li>'&lt;' and '&gt;' - div elements</li>\n             *         <li>'&lt;\"class\" and '&gt;' - div with a class</li>\n             *         <li>'&lt;\"#id\" and '&gt;' - div with an ID</li>\n             *       </ul>\n             *     </li>\n             *     <li>Examples:\n             *       <ul>\n             *         <li>'&lt;\"wrapper\"flipt&gt;'</li>\n             *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>\n             *       </ul>\n             *     </li>\n             *   </ul>\n             *  @type string\n             *  @default lfrtip <i>(when `jQueryUI` is false)</i> <b>or</b>\n             *    <\"H\"lfr>t<\"F\"ip> <i>(when `jQueryUI` is true)</i>\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.dom\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"dom\": '&lt;\"top\"i&gt;rt&lt;\"bottom\"flp&gt;&lt;\"clear\"&gt;'\n             *      } );\n             *    } );\n             */\n            \"sDom\": \"lfrtip\",\n\n\n            /**\n             * Search delay option. This will throttle full table searches that use the\n             * DataTables provided search input element (it does not effect calls to\n             * `dt-api search()`, providing a delay before the search is made.\n             *  @type integer\n             *  @default 0\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.searchDelay\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"searchDelay\": 200\n             *      } );\n             *    } )\n             */\n            \"searchDelay\": null,\n\n\n            /**\n             * DataTables features six different built-in options for the buttons to\n             * display for pagination control:\n             *\n             * * `numbers` - Page number buttons only\n             * * `simple` - 'Previous' and 'Next' buttons only\n             * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers\n             * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons\n             * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers\n             * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers\n             *\n             * Further methods can be added using {@link DataTable.ext.oPagination}.\n             *  @type string\n             *  @default simple_numbers\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.pagingType\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"pagingType\": \"full_numbers\"\n             *      } );\n             *    } )\n             */\n            \"sPaginationType\": \"simple_numbers\",\n\n\n            /**\n             * Enable horizontal scrolling. When a table is too wide to fit into a\n             * certain layout, or you have a large number of columns in the table, you\n             * can enable x-scrolling to show the table in a viewport, which can be\n             * scrolled. This property can be `true` which will allow the table to\n             * scroll horizontally when needed, or any CSS unit, or a number (in which\n             * case it will be treated as a pixel measurement). Setting as simply `true`\n             * is recommended.\n             *  @type boolean|string\n             *  @default <i>blank string - i.e. disabled</i>\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.scrollX\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"scrollX\": true,\n             *        \"scrollCollapse\": true\n             *      } );\n             *    } );\n             */\n            \"sScrollX\": \"\",\n\n\n            /**\n             * This property can be used to force a DataTable to use more width than it\n             * might otherwise do when x-scrolling is enabled. For example if you have a\n             * table which requires to be well spaced, this parameter is useful for\n             * \"over-sizing\" the table, and thus forcing scrolling. This property can by\n             * any CSS unit, or a number (in which case it will be treated as a pixel\n             * measurement).\n             *  @type string\n             *  @default <i>blank string - i.e. disabled</i>\n             *\n             *  @dtopt Options\n             *  @name DataTable.defaults.scrollXInner\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"scrollX\": \"100%\",\n             *        \"scrollXInner\": \"110%\"\n             *      } );\n             *    } );\n             */\n            \"sScrollXInner\": \"\",\n\n\n            /**\n             * Enable vertical scrolling. Vertical scrolling will constrain the DataTable\n             * to the given height, and enable scrolling for any data which overflows the\n             * current viewport. This can be used as an alternative to paging to display\n             * a lot of data in a small area (although paging and scrolling can both be\n             * enabled at the same time). This property can be any CSS unit, or a number\n             * (in which case it will be treated as a pixel measurement).\n             *  @type string\n             *  @default <i>blank string - i.e. disabled</i>\n             *\n             *  @dtopt Features\n             *  @name DataTable.defaults.scrollY\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"scrollY\": \"200px\",\n             *        \"paginate\": false\n             *      } );\n             *    } );\n             */\n            \"sScrollY\": \"\",\n\n\n            /**\n             * __Deprecated__ The functionality provided by this parameter has now been\n             * superseded by that provided through `ajax`, which should be used instead.\n             *\n             * Set the HTTP method that is used to make the Ajax call for server-side\n             * processing or Ajax sourced data.\n             *  @type string\n             *  @default GET\n             *\n             *  @dtopt Options\n             *  @dtopt Server-side\n             *  @name DataTable.defaults.serverMethod\n             *\n             *  @deprecated 1.10. Please use `ajax` for this functionality now.\n             */\n            \"sServerMethod\": \"GET\",\n\n\n            /**\n             * DataTables makes use of renderers when displaying HTML elements for\n             * a table. These renderers can be added or modified by plug-ins to\n             * generate suitable mark-up for a site. For example the Bootstrap\n             * integration plug-in for DataTables uses a paging button renderer to\n             * display pagination buttons in the mark-up required by Bootstrap.\n             *\n             * For further information about the renderers available see\n             * DataTable.ext.renderer\n             *  @type string|object\n             *  @default null\n             *\n             *  @name DataTable.defaults.renderer\n             *\n             */\n            \"renderer\": null,\n\n\n            /**\n             * Set the data property name that DataTables should use to get a row's id\n             * to set as the `id` property in the node.\n             *  @type string\n             *  @default DT_RowId\n             *\n             *  @name DataTable.defaults.rowId\n             */\n            \"rowId\": \"DT_RowId\"\n        };\n\n        _fnHungarianMap(DataTable.defaults);\n\n\n\n        /*\n         * Developer note - See note in model.defaults.js about the use of Hungarian\n         * notation and camel case.\n         */\n\n        /**\n         * Column options that can be given to DataTables at initialisation time.\n         *  @namespace\n         */\n        DataTable.defaults.column = {\n            /**\n             * Define which column(s) an order will occur on for this column. This\n             * allows a column's ordering to take multiple columns into account when\n             * doing a sort or use the data from a different column. For example first\n             * name / last name columns make sense to do a multi-column sort over the\n             * two columns.\n             *  @type array|int\n             *  @default null <i>Takes the value of the column index automatically</i>\n             *\n             *  @name DataTable.defaults.column.orderData\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"orderData\": [ 0, 1 ], \"targets\": [ 0 ] },\n             *          { \"orderData\": [ 1, 0 ], \"targets\": [ 1 ] },\n             *          { \"orderData\": 2, \"targets\": [ 2 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"orderData\": [ 0, 1 ] },\n             *          { \"orderData\": [ 1, 0 ] },\n             *          { \"orderData\": 2 },\n             *          null,\n             *          null\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"aDataSort\": null,\n            \"iDataSort\": -1,\n\n\n            /**\n             * You can control the default ordering direction, and even alter the\n             * behaviour of the sort handler (i.e. only allow ascending ordering etc)\n             * using this parameter.\n             *  @type array\n             *  @default [ 'asc', 'desc' ]\n             *\n             *  @name DataTable.defaults.column.orderSequence\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"orderSequence\": [ \"asc\" ], \"targets\": [ 1 ] },\n             *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ], \"targets\": [ 2 ] },\n             *          { \"orderSequence\": [ \"desc\" ], \"targets\": [ 3 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          null,\n             *          { \"orderSequence\": [ \"asc\" ] },\n             *          { \"orderSequence\": [ \"desc\", \"asc\", \"asc\" ] },\n             *          { \"orderSequence\": [ \"desc\" ] },\n             *          null\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"asSorting\": ['asc', 'desc'],\n\n\n            /**\n             * Enable or disable filtering on the data in this column.\n             *  @type boolean\n             *  @default true\n             *\n             *  @name DataTable.defaults.column.searchable\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"searchable\": false, \"targets\": [ 0 ] }\n             *        ] } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"searchable\": false },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ] } );\n             *    } );\n             */\n            \"bSearchable\": true,\n\n\n            /**\n             * Enable or disable ordering on this column.\n             *  @type boolean\n             *  @default true\n             *\n             *  @name DataTable.defaults.column.orderable\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"orderable\": false, \"targets\": [ 0 ] }\n             *        ] } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"orderable\": false },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ] } );\n             *    } );\n             */\n            \"bSortable\": true,\n\n\n            /**\n             * Enable or disable the display of this column.\n             *  @type boolean\n             *  @default true\n             *\n             *  @name DataTable.defaults.column.visible\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"visible\": false, \"targets\": [ 0 ] }\n             *        ] } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"visible\": false },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ] } );\n             *    } );\n             */\n            \"bVisible\": true,\n\n\n            /**\n             * Developer definable function that is called whenever a cell is created (Ajax source,\n             * etc) or processed for input (DOM source). This can be used as a compliment to mRender\n             * allowing you to modify the DOM element (add background colour for example) when the\n             * element is available.\n             *  @type function\n             *  @param {element} td The TD node that has been created\n             *  @param {*} cellData The Data for the cell\n             *  @param {array|object} rowData The data for the whole row\n             *  @param {int} row The row index for the aoData data store\n             *  @param {int} col The column index for aoColumns\n             *\n             *  @name DataTable.defaults.column.createdCell\n             *  @dtopt Columns\n             *\n             *  @example\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [3],\n             *          \"createdCell\": function (td, cellData, rowData, row, col) {\n             *            if ( cellData == \"1.7\" ) {\n             *              $(td).css('color', 'blue')\n             *            }\n             *          }\n             *        } ]\n             *      });\n             *    } );\n             */\n            \"fnCreatedCell\": null,\n\n\n            /**\n             * This parameter has been replaced by `data` in DataTables to ensure naming\n             * consistency. `dataProp` can still be used, as there is backwards\n             * compatibility in DataTables for this option, but it is strongly\n             * recommended that you use `data` in preference to `dataProp`.\n             *  @name DataTable.defaults.column.dataProp\n             */\n\n\n            /**\n             * This property can be used to read data from any data source property,\n             * including deeply nested objects / properties. `data` can be given in a\n             * number of different ways which effect its behaviour:\n             *\n             * * `integer` - treated as an array index for the data source. This is the\n             *   default that DataTables uses (incrementally increased for each column).\n             * * `string` - read an object property from the data source. There are\n             *   three 'special' options that can be used in the string to alter how\n             *   DataTables reads the data from the source object:\n             *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n             *      Javascript to read from nested objects, so to can the options\n             *      specified in `data`. For example: `browser.version` or\n             *      `browser.name`. If your object parameter name contains a period, use\n             *      `\\\\` to escape it - i.e. `first\\\\.name`.\n             *    * `[]` - Array notation. DataTables can automatically combine data\n             *      from and array source, joining the data with the characters provided\n             *      between the two brackets. For example: `name[, ]` would provide a\n             *      comma-space separated list from the source array. If no characters\n             *      are provided between the brackets, the original array source is\n             *      returned.\n             *    * `()` - Function notation. Adding `()` to the end of a parameter will\n             *      execute a function of the name given. For example: `browser()` for a\n             *      simple function on the data source, `browser.version()` for a\n             *      function in a nested property or even `browser().version` to get an\n             *      object property if the function called returns an object. Note that\n             *      function notation is recommended for use in `render` rather than\n             *      `data` as it is much simpler to use as a renderer.\n             * * `null` - use the original data source for the row rather than plucking\n             *   data directly from it. This action has effects on two other\n             *   initialisation options:\n             *    * `defaultContent` - When null is given as the `data` option and\n             *      `defaultContent` is specified for the column, the value defined by\n             *      `defaultContent` will be used for the cell.\n             *    * `render` - When null is used for the `data` option and the `render`\n             *      option is specified for the column, the whole data source for the\n             *      row is used for the renderer.\n             * * `function` - the function given will be executed whenever DataTables\n             *   needs to set or get the data for a cell in the column. The function\n             *   takes three parameters:\n             *    * Parameters:\n             *      * `{array|object}` The data source for the row\n             *      * `{string}` The type call data requested - this will be 'set' when\n             *        setting data or 'filter', 'display', 'type', 'sort' or undefined\n             *        when gathering data. Note that when `undefined` is given for the\n             *        type DataTables expects to get the raw data for the object back<\n             *      * `{*}` Data to set when the second parameter is 'set'.\n             *    * Return:\n             *      * The return value from the function is not required when 'set' is\n             *        the type of call, but otherwise the return is what will be used\n             *        for the data requested.\n             *\n             * Note that `data` is a getter and setter option. If you just require\n             * formatting of data for output, you will likely want to use `render` which\n             * is simply a getter and thus simpler to use.\n             *\n             * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The\n             * name change reflects the flexibility of this property and is consistent\n             * with the naming of mRender. If 'mDataProp' is given, then it will still\n             * be used by DataTables, as it automatically maps the old name to the new\n             * if required.\n             *\n             *  @type string|int|function|null\n             *  @default null <i>Use automatically calculated column index</i>\n             *\n             *  @name DataTable.defaults.column.data\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Read table data from objects\n             *    // JSON structure for each row:\n             *    //   {\n             *    //      \"engine\": {value},\n             *    //      \"browser\": {value},\n             *    //      \"platform\": {value},\n             *    //      \"version\": {value},\n             *    //      \"grade\": {value}\n             *    //   }\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"ajaxSource\": \"sources/objects.txt\",\n             *        \"columns\": [\n             *          { \"data\": \"engine\" },\n             *          { \"data\": \"browser\" },\n             *          { \"data\": \"platform\" },\n             *          { \"data\": \"version\" },\n             *          { \"data\": \"grade\" }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Read information from deeply nested objects\n             *    // JSON structure for each row:\n             *    //   {\n             *    //      \"engine\": {value},\n             *    //      \"browser\": {value},\n             *    //      \"platform\": {\n             *    //         \"inner\": {value}\n             *    //      },\n             *    //      \"details\": [\n             *    //         {value}, {value}\n             *    //      ]\n             *    //   }\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"ajaxSource\": \"sources/deep.txt\",\n             *        \"columns\": [\n             *          { \"data\": \"engine\" },\n             *          { \"data\": \"browser\" },\n             *          { \"data\": \"platform.inner\" },\n             *          { \"data\": \"details.0\" },\n             *          { \"data\": \"details.1\" }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `data` as a function to provide different information for\n             *    // sorting, filtering and display. In this case, currency (price)\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"data\": function ( source, type, val ) {\n             *            if (type === 'set') {\n             *              source.price = val;\n             *              // Store the computed dislay and filter values for efficiency\n             *              source.price_display = val==\"\" ? \"\" : \"$\"+numberFormat(val);\n             *              source.price_filter  = val==\"\" ? \"\" : \"$\"+numberFormat(val)+\" \"+val;\n             *              return;\n             *            }\n             *            else if (type === 'display') {\n             *              return source.price_display;\n             *            }\n             *            else if (type === 'filter') {\n             *              return source.price_filter;\n             *            }\n             *            // 'sort', 'type' and undefined all just use the integer\n             *            return source.price;\n             *          }\n             *        } ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using default content\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"data\": null,\n             *          \"defaultContent\": \"Click to edit\"\n             *        } ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using array notation - outputting a list from an array\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"data\": \"name[, ]\"\n             *        } ]\n             *      } );\n             *    } );\n             *\n             */\n            \"mData\": null,\n\n\n            /**\n             * This property is the rendering partner to `data` and it is suggested that\n             * when you want to manipulate data for display (including filtering,\n             * sorting etc) without altering the underlying data for the table, use this\n             * property. `render` can be considered to be the the read only companion to\n             * `data` which is read / write (then as such more complex). Like `data`\n             * this option can be given in a number of different ways to effect its\n             * behaviour:\n             *\n             * * `integer` - treated as an array index for the data source. This is the\n             *   default that DataTables uses (incrementally increased for each column).\n             * * `string` - read an object property from the data source. There are\n             *   three 'special' options that can be used in the string to alter how\n             *   DataTables reads the data from the source object:\n             *    * `.` - Dotted Javascript notation. Just as you use a `.` in\n             *      Javascript to read from nested objects, so to can the options\n             *      specified in `data`. For example: `browser.version` or\n             *      `browser.name`. If your object parameter name contains a period, use\n             *      `\\\\` to escape it - i.e. `first\\\\.name`.\n             *    * `[]` - Array notation. DataTables can automatically combine data\n             *      from and array source, joining the data with the characters provided\n             *      between the two brackets. For example: `name[, ]` would provide a\n             *      comma-space separated list from the source array. If no characters\n             *      are provided between the brackets, the original array source is\n             *      returned.\n             *    * `()` - Function notation. Adding `()` to the end of a parameter will\n             *      execute a function of the name given. For example: `browser()` for a\n             *      simple function on the data source, `browser.version()` for a\n             *      function in a nested property or even `browser().version` to get an\n             *      object property if the function called returns an object.\n             * * `object` - use different data for the different data types requested by\n             *   DataTables ('filter', 'display', 'type' or 'sort'). The property names\n             *   of the object is the data type the property refers to and the value can\n             *   defined using an integer, string or function using the same rules as\n             *   `render` normally does. Note that an `_` option _must_ be specified.\n             *   This is the default value to use if you haven't specified a value for\n             *   the data type requested by DataTables.\n             * * `function` - the function given will be executed whenever DataTables\n             *   needs to set or get the data for a cell in the column. The function\n             *   takes three parameters:\n             *    * Parameters:\n             *      * {array|object} The data source for the row (based on `data`)\n             *      * {string} The type call data requested - this will be 'filter',\n             *        'display', 'type' or 'sort'.\n             *      * {array|object} The full data source for the row (not based on\n             *        `data`)\n             *    * Return:\n             *      * The return value from the function is what will be used for the\n             *        data requested.\n             *\n             *  @type string|int|function|object|null\n             *  @default null Use the data source value.\n             *\n             *  @name DataTable.defaults.column.render\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Create a comma separated list from an array of objects\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"ajaxSource\": \"sources/deep.txt\",\n             *        \"columns\": [\n             *          { \"data\": \"engine\" },\n             *          { \"data\": \"browser\" },\n             *          {\n             *            \"data\": \"platform\",\n             *            \"render\": \"[, ].name\"\n             *          }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Execute a function to obtain data\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"data\": null, // Use the full data source object for the renderer's source\n             *          \"render\": \"browserName()\"\n             *        } ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // As an object, extracting different data for the different types\n             *    // This would be used with a data source such as:\n             *    //   { \"phone\": 5552368, \"phone_filter\": \"5552368 555-2368\", \"phone_display\": \"555-2368\" }\n             *    // Here the `phone` integer is used for sorting and type detection, while `phone_filter`\n             *    // (which has both forms) is used for filtering for if a user inputs either format, while\n             *    // the formatted phone number is the one that is shown in the table.\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"data\": null, // Use the full data source object for the renderer's source\n             *          \"render\": {\n             *            \"_\": \"phone\",\n             *            \"filter\": \"phone_filter\",\n             *            \"display\": \"phone_display\"\n             *          }\n             *        } ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Use as a function to create a link from the data source\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"data\": \"download_link\",\n             *          \"render\": function ( data, type, full ) {\n             *            return '<a href=\"'+data+'\">Download</a>';\n             *          }\n             *        } ]\n             *      } );\n             *    } );\n             */\n            \"mRender\": null,\n\n\n            /**\n             * Change the cell type created for the column - either TD cells or TH cells. This\n             * can be useful as TH cells have semantic meaning in the table body, allowing them\n             * to act as a header for a row (you may wish to add scope='row' to the TH elements).\n             *  @type string\n             *  @default td\n             *\n             *  @name DataTable.defaults.column.cellType\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Make the first column use TH cells\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [ {\n             *          \"targets\": [ 0 ],\n             *          \"cellType\": \"th\"\n             *        } ]\n             *      } );\n             *    } );\n             */\n            \"sCellType\": \"td\",\n\n\n            /**\n             * Class to give to each cell in this column.\n             *  @type string\n             *  @default <i>Empty string</i>\n             *\n             *  @name DataTable.defaults.column.class\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"class\": \"my_class\", \"targets\": [ 0 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"class\": \"my_class\" },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sClass\": \"\",\n\n            /**\n             * When DataTables calculates the column widths to assign to each column,\n             * it finds the longest string in each column and then constructs a\n             * temporary table and reads the widths from that. The problem with this\n             * is that \"mmm\" is much wider then \"iiii\", but the latter is a longer\n             * string - thus the calculation can go wrong (doing it properly and putting\n             * it into an DOM object and measuring that is horribly(!) slow). Thus as\n             * a \"work around\" we provide this option. It will append its value to the\n             * text that is found to be the longest string for the column - i.e. padding.\n             * Generally you shouldn't need this!\n             *  @type string\n             *  @default <i>Empty string<i>\n             *\n             *  @name DataTable.defaults.column.contentPadding\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          null,\n             *          null,\n             *          null,\n             *          {\n             *            \"contentPadding\": \"mmm\"\n             *          }\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sContentPadding\": \"\",\n\n\n            /**\n             * Allows a default value to be given for a column's data, and will be used\n             * whenever a null data source is encountered (this can be because `data`\n             * is set to null, or because the data source itself is null).\n             *  @type string\n             *  @default null\n             *\n             *  @name DataTable.defaults.column.defaultContent\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          {\n             *            \"data\": null,\n             *            \"defaultContent\": \"Edit\",\n             *            \"targets\": [ -1 ]\n             *          }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          null,\n             *          null,\n             *          null,\n             *          {\n             *            \"data\": null,\n             *            \"defaultContent\": \"Edit\"\n             *          }\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sDefaultContent\": null,\n\n\n            /**\n             * This parameter is only used in DataTables' server-side processing. It can\n             * be exceptionally useful to know what columns are being displayed on the\n             * client side, and to map these to database fields. When defined, the names\n             * also allow DataTables to reorder information from the server if it comes\n             * back in an unexpected order (i.e. if you switch your columns around on the\n             * client-side, your server-side code does not also need updating).\n             *  @type string\n             *  @default <i>Empty string</i>\n             *\n             *  @name DataTable.defaults.column.name\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"name\": \"engine\", \"targets\": [ 0 ] },\n             *          { \"name\": \"browser\", \"targets\": [ 1 ] },\n             *          { \"name\": \"platform\", \"targets\": [ 2 ] },\n             *          { \"name\": \"version\", \"targets\": [ 3 ] },\n             *          { \"name\": \"grade\", \"targets\": [ 4 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"name\": \"engine\" },\n             *          { \"name\": \"browser\" },\n             *          { \"name\": \"platform\" },\n             *          { \"name\": \"version\" },\n             *          { \"name\": \"grade\" }\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sName\": \"\",\n\n\n            /**\n             * Defines a data source type for the ordering which can be used to read\n             * real-time information from the table (updating the internally cached\n             * version) prior to ordering. This allows ordering to occur on user\n             * editable elements such as form inputs.\n             *  @type string\n             *  @default std\n             *\n             *  @name DataTable.defaults.column.orderDataType\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"orderDataType\": \"dom-text\", \"targets\": [ 2, 3 ] },\n             *          { \"type\": \"numeric\", \"targets\": [ 3 ] },\n             *          { \"orderDataType\": \"dom-select\", \"targets\": [ 4 ] },\n             *          { \"orderDataType\": \"dom-checkbox\", \"targets\": [ 5 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          null,\n             *          null,\n             *          { \"orderDataType\": \"dom-text\" },\n             *          { \"orderDataType\": \"dom-text\", \"type\": \"numeric\" },\n             *          { \"orderDataType\": \"dom-select\" },\n             *          { \"orderDataType\": \"dom-checkbox\" }\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sSortDataType\": \"std\",\n\n\n            /**\n             * The title of this column.\n             *  @type string\n             *  @default null <i>Derived from the 'TH' value for this column in the\n             *    original HTML table.</i>\n             *\n             *  @name DataTable.defaults.column.title\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"title\": \"My column title\", \"targets\": [ 0 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"title\": \"My column title\" },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sTitle\": null,\n\n\n            /**\n             * The type allows you to specify how the data for this column will be\n             * ordered. Four types (string, numeric, date and html (which will strip\n             * HTML tags before ordering)) are currently available. Note that only date\n             * formats understood by Javascript's Date() object will be accepted as type\n             * date. For example: \"Mar 26, 2008 5:03 PM\". May take the values: 'string',\n             * 'numeric', 'date' or 'html' (by default). Further types can be adding\n             * through plug-ins.\n             *  @type string\n             *  @default null <i>Auto-detected from raw data</i>\n             *\n             *  @name DataTable.defaults.column.type\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"type\": \"html\", \"targets\": [ 0 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"type\": \"html\" },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sType\": null,\n\n\n            /**\n             * Defining the width of the column, this parameter may take any CSS value\n             * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not\n             * been given a specific width through this interface ensuring that the table\n             * remains readable.\n             *  @type string\n             *  @default null <i>Automatic</i>\n             *\n             *  @name DataTable.defaults.column.width\n             *  @dtopt Columns\n             *\n             *  @example\n             *    // Using `columnDefs`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columnDefs\": [\n             *          { \"width\": \"20%\", \"targets\": [ 0 ] }\n             *        ]\n             *      } );\n             *    } );\n             *\n             *  @example\n             *    // Using `columns`\n             *    $(document).ready( function() {\n             *      $('#example').dataTable( {\n             *        \"columns\": [\n             *          { \"width\": \"20%\" },\n             *          null,\n             *          null,\n             *          null,\n             *          null\n             *        ]\n             *      } );\n             *    } );\n             */\n            \"sWidth\": null\n        };\n\n        _fnHungarianMap(DataTable.defaults.column);\n\n\n\n        /**\n         * DataTables settings object - this holds all the information needed for a\n         * given table, including configuration, data and current application of the\n         * table options. DataTables does not have a single instance for each DataTable\n         * with the settings attached to that instance, but rather instances of the\n         * DataTable \"class\" are created on-the-fly as needed (typically by a\n         * $().dataTable() call) and the settings object is then applied to that\n         * instance.\n         *\n         * Note that this object is related to {@link DataTable.defaults} but this\n         * one is the internal data store for DataTables's cache of columns. It should\n         * NOT be manipulated outside of DataTables. Any configuration should be done\n         * through the initialisation options.\n         *  @namespace\n         *  @todo Really should attach the settings object to individual instances so we\n         *    don't need to create new instances on each $().dataTable() call (if the\n         *    table already exists). It would also save passing oSettings around and\n         *    into every single function. However, this is a very significant\n         *    architecture change for DataTables and will almost certainly break\n         *    backwards compatibility with older installations. This is something that\n         *    will be done in 2.0.\n         */\n        DataTable.models.oSettings = {\n            /**\n             * Primary features of DataTables and their enablement state.\n             *  @namespace\n             */\n            \"oFeatures\": {\n\n                /**\n                 * Flag to say if DataTables should automatically try to calculate the\n                 * optimum table and columns widths (true) or not (false).\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bAutoWidth\": null,\n\n                /**\n                 * Delay the creation of TR and TD elements until they are actually\n                 * needed by a driven page draw. This can give a significant speed\n                 * increase for Ajax source and Javascript source data, but makes no\n                 * difference at all fro DOM and server-side processing tables.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bDeferRender\": null,\n\n                /**\n                 * Enable filtering on the table or not. Note that if this is disabled\n                 * then there is no filtering at all on the table, including fnFilter.\n                 * To just remove the filtering input use sDom and remove the 'f' option.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bFilter\": null,\n\n                /**\n                 * Table information element (the 'Showing x of y records' div) enable\n                 * flag.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bInfo\": null,\n\n                /**\n                 * Present a user control allowing the end user to change the page size\n                 * when pagination is enabled.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bLengthChange\": null,\n\n                /**\n                 * Pagination enabled or not. Note that if this is disabled then length\n                 * changing must also be disabled.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bPaginate\": null,\n\n                /**\n                 * Processing indicator enable flag whenever DataTables is enacting a\n                 * user request - typically an Ajax request for server-side processing.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bProcessing\": null,\n\n                /**\n                 * Server-side processing enabled flag - when enabled DataTables will\n                 * get all data from the server for every draw - there is no filtering,\n                 * sorting or paging done on the client-side.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bServerSide\": null,\n\n                /**\n                 * Sorting enablement flag.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bSort\": null,\n\n                /**\n                 * Multi-column sorting\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bSortMulti\": null,\n\n                /**\n                 * Apply a class to the columns which are being sorted to provide a\n                 * visual highlight or not. This can slow things down when enabled since\n                 * there is a lot of DOM interaction.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bSortClasses\": null,\n\n                /**\n                 * State saving enablement flag.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bStateSave\": null\n            },\n\n\n            /**\n             * Scrolling settings for a table.\n             *  @namespace\n             */\n            \"oScroll\": {\n                /**\n                 * When the table is shorter in height than sScrollY, collapse the\n                 * table container down to the height of the table (when true).\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type boolean\n                 */\n                \"bCollapse\": null,\n\n                /**\n                 * Width of the scrollbar for the web-browser's platform. Calculated\n                 * during table initialisation.\n                 *  @type int\n                 *  @default 0\n                 */\n                \"iBarWidth\": 0,\n\n                /**\n                 * Viewport width for horizontal scrolling. Horizontal scrolling is\n                 * disabled if an empty string.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type string\n                 */\n                \"sX\": null,\n\n                /**\n                 * Width to expand the table to when using x-scrolling. Typically you\n                 * should not need to use this.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type string\n                 *  @deprecated\n                 */\n                \"sXInner\": null,\n\n                /**\n                 * Viewport height for vertical scrolling. Vertical scrolling is disabled\n                 * if an empty string.\n                 * Note that this parameter will be set by the initialisation routine. To\n                 * set a default use {@link DataTable.defaults}.\n                 *  @type string\n                 */\n                \"sY\": null\n            },\n\n            /**\n             * Language information for the table.\n             *  @namespace\n             *  @extends DataTable.defaults.oLanguage\n             */\n            \"oLanguage\": {\n                /**\n                 * Information callback function. See\n                 * {@link DataTable.defaults.fnInfoCallback}\n                 *  @type function\n                 *  @default null\n                 */\n                \"fnInfoCallback\": null\n            },\n\n            /**\n             * Browser support parameters\n             *  @namespace\n             */\n            \"oBrowser\": {\n                /**\n                 * Indicate if the browser incorrectly calculates width:100% inside a\n                 * scrolling element (IE6/7)\n                 *  @type boolean\n                 *  @default false\n                 */\n                \"bScrollOversize\": false,\n\n                /**\n                 * Determine if the vertical scrollbar is on the right or left of the\n                 * scrolling container - needed for rtl language layout, although not\n                 * all browsers move the scrollbar (Safari).\n                 *  @type boolean\n                 *  @default false\n                 */\n                \"bScrollbarLeft\": false,\n\n                /**\n                 * Flag for if `getBoundingClientRect` is fully supported or not\n                 *  @type boolean\n                 *  @default false\n                 */\n                \"bBounding\": false,\n\n                /**\n                 * Browser scrollbar width\n                 *  @type integer\n                 *  @default 0\n                 */\n                \"barWidth\": 0\n            },\n\n\n            \"ajax\": null,\n\n\n            /**\n             * Array referencing the nodes which are used for the features. The\n             * parameters of this object match what is allowed by sDom - i.e.\n             *   <ul>\n             *     <li>'l' - Length changing</li>\n             *     <li>'f' - Filtering input</li>\n             *     <li>'t' - The table!</li>\n             *     <li>'i' - Information</li>\n             *     <li>'p' - Pagination</li>\n             *     <li>'r' - pRocessing</li>\n             *   </ul>\n             *  @type array\n             *  @default []\n             */\n            \"aanFeatures\": [],\n\n            /**\n             * Store data information - see {@link DataTable.models.oRow} for detailed\n             * information.\n             *  @type array\n             *  @default []\n             */\n            \"aoData\": [],\n\n            /**\n             * Array of indexes which are in the current display (after filtering etc)\n             *  @type array\n             *  @default []\n             */\n            \"aiDisplay\": [],\n\n            /**\n             * Array of indexes for display - no filtering\n             *  @type array\n             *  @default []\n             */\n            \"aiDisplayMaster\": [],\n\n            /**\n             * Map of row ids to data indexes\n             *  @type object\n             *  @default {}\n             */\n            \"aIds\": {},\n\n            /**\n             * Store information about each column that is in use\n             *  @type array\n             *  @default []\n             */\n            \"aoColumns\": [],\n\n            /**\n             * Store information about the table's header\n             *  @type array\n             *  @default []\n             */\n            \"aoHeader\": [],\n\n            /**\n             * Store information about the table's footer\n             *  @type array\n             *  @default []\n             */\n            \"aoFooter\": [],\n\n            /**\n             * Store the applied global search information in case we want to force a\n             * research or compare the old search to a new one.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @namespace\n             *  @extends DataTable.models.oSearch\n             */\n            \"oPreviousSearch\": {},\n\n            /**\n             * Store the applied search for each column - see\n             * {@link DataTable.models.oSearch} for the format that is used for the\n             * filtering information for each column.\n             *  @type array\n             *  @default []\n             */\n            \"aoPreSearchCols\": [],\n\n            /**\n             * Sorting that is applied to the table. Note that the inner arrays are\n             * used in the following manner:\n             * <ul>\n             *   <li>Index 0 - column number</li>\n             *   <li>Index 1 - current sorting direction</li>\n             * </ul>\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type array\n             *  @todo These inner arrays should really be objects\n             */\n            \"aaSorting\": null,\n\n            /**\n             * Sorting that is always applied to the table (i.e. prefixed in front of\n             * aaSorting).\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type array\n             *  @default []\n             */\n            \"aaSortingFixed\": [],\n\n            /**\n             * Classes to use for the striping of a table.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type array\n             *  @default []\n             */\n            \"asStripeClasses\": null,\n\n            /**\n             * If restoring a table - we should restore its striping classes as well\n             *  @type array\n             *  @default []\n             */\n            \"asDestroyStripes\": [],\n\n            /**\n             * If restoring a table - we should restore its width\n             *  @type int\n             *  @default 0\n             */\n            \"sDestroyWidth\": 0,\n\n            /**\n             * Callback functions array for every time a row is inserted (i.e. on a draw).\n             *  @type array\n             *  @default []\n             */\n            \"aoRowCallback\": [],\n\n            /**\n             * Callback functions for the header on each draw.\n             *  @type array\n             *  @default []\n             */\n            \"aoHeaderCallback\": [],\n\n            /**\n             * Callback function for the footer on each draw.\n             *  @type array\n             *  @default []\n             */\n            \"aoFooterCallback\": [],\n\n            /**\n             * Array of callback functions for draw callback functions\n             *  @type array\n             *  @default []\n             */\n            \"aoDrawCallback\": [],\n\n            /**\n             * Array of callback functions for row created function\n             *  @type array\n             *  @default []\n             */\n            \"aoRowCreatedCallback\": [],\n\n            /**\n             * Callback functions for just before the table is redrawn. A return of\n             * false will be used to cancel the draw.\n             *  @type array\n             *  @default []\n             */\n            \"aoPreDrawCallback\": [],\n\n            /**\n             * Callback functions for when the table has been initialised.\n             *  @type array\n             *  @default []\n             */\n            \"aoInitComplete\": [],\n\n\n            /**\n             * Callbacks for modifying the settings to be stored for state saving, prior to\n             * saving state.\n             *  @type array\n             *  @default []\n             */\n            \"aoStateSaveParams\": [],\n\n            /**\n             * Callbacks for modifying the settings that have been stored for state saving\n             * prior to using the stored values to restore the state.\n             *  @type array\n             *  @default []\n             */\n            \"aoStateLoadParams\": [],\n\n            /**\n             * Callbacks for operating on the settings object once the saved state has been\n             * loaded\n             *  @type array\n             *  @default []\n             */\n            \"aoStateLoaded\": [],\n\n            /**\n             * Cache the table ID for quick access\n             *  @type string\n             *  @default <i>Empty string</i>\n             */\n            \"sTableId\": \"\",\n\n            /**\n             * The TABLE node for the main table\n             *  @type node\n             *  @default null\n             */\n            \"nTable\": null,\n\n            /**\n             * Permanent ref to the thead element\n             *  @type node\n             *  @default null\n             */\n            \"nTHead\": null,\n\n            /**\n             * Permanent ref to the tfoot element - if it exists\n             *  @type node\n             *  @default null\n             */\n            \"nTFoot\": null,\n\n            /**\n             * Permanent ref to the tbody element\n             *  @type node\n             *  @default null\n             */\n            \"nTBody\": null,\n\n            /**\n             * Cache the wrapper node (contains all DataTables controlled elements)\n             *  @type node\n             *  @default null\n             */\n            \"nTableWrapper\": null,\n\n            /**\n             * Indicate if when using server-side processing the loading of data\n             * should be deferred until the second draw.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type boolean\n             *  @default false\n             */\n            \"bDeferLoading\": false,\n\n            /**\n             * Indicate if all required information has been read in\n             *  @type boolean\n             *  @default false\n             */\n            \"bInitialised\": false,\n\n            /**\n             * Information about open rows. Each object in the array has the parameters\n             * 'nTr' and 'nParent'\n             *  @type array\n             *  @default []\n             */\n            \"aoOpenRows\": [],\n\n            /**\n             * Dictate the positioning of DataTables' control elements - see\n             * {@link DataTable.model.oInit.sDom}.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type string\n             *  @default null\n             */\n            \"sDom\": null,\n\n            /**\n             * Search delay (in mS)\n             *  @type integer\n             *  @default null\n             */\n            \"searchDelay\": null,\n\n            /**\n             * Which type of pagination should be used.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type string\n             *  @default two_button\n             */\n            \"sPaginationType\": \"two_button\",\n\n            /**\n             * The state duration (for `stateSave`) in seconds.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type int\n             *  @default 0\n             */\n            \"iStateDuration\": 0,\n\n            /**\n             * Array of callback functions for state saving. Each array element is an\n             * object with the following parameters:\n             *   <ul>\n             *     <li>function:fn - function to call. Takes two parameters, oSettings\n             *       and the JSON string to save that has been thus far created. Returns\n             *       a JSON string to be inserted into a json object\n             *       (i.e. '\"param\": [ 0, 1, 2]')</li>\n             *     <li>string:sName - name of callback</li>\n             *   </ul>\n             *  @type array\n             *  @default []\n             */\n            \"aoStateSave\": [],\n\n            /**\n             * Array of callback functions for state loading. Each array element is an\n             * object with the following parameters:\n             *   <ul>\n             *     <li>function:fn - function to call. Takes two parameters, oSettings\n             *       and the object stored. May return false to cancel state loading</li>\n             *     <li>string:sName - name of callback</li>\n             *   </ul>\n             *  @type array\n             *  @default []\n             */\n            \"aoStateLoad\": [],\n\n            /**\n             * State that was saved. Useful for back reference\n             *  @type object\n             *  @default null\n             */\n            \"oSavedState\": null,\n\n            /**\n             * State that was loaded. Useful for back reference\n             *  @type object\n             *  @default null\n             */\n            \"oLoadedState\": null,\n\n            /**\n             * Source url for AJAX data for the table.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type string\n             *  @default null\n             */\n            \"sAjaxSource\": null,\n\n            /**\n             * Property from a given object from which to read the table data from. This\n             * can be an empty string (when not server-side processing), in which case\n             * it is  assumed an an array is given directly.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type string\n             */\n            \"sAjaxDataProp\": null,\n\n            /**\n             * Note if draw should be blocked while getting data\n             *  @type boolean\n             *  @default true\n             */\n            \"bAjaxDataGet\": true,\n\n            /**\n             * The last jQuery XHR object that was used for server-side data gathering.\n             * This can be used for working with the XHR information in one of the\n             * callbacks\n             *  @type object\n             *  @default null\n             */\n            \"jqXHR\": null,\n\n            /**\n             * JSON returned from the server in the last Ajax request\n             *  @type object\n             *  @default undefined\n             */\n            \"json\": undefined,\n\n            /**\n             * Data submitted as part of the last Ajax request\n             *  @type object\n             *  @default undefined\n             */\n            \"oAjaxData\": undefined,\n\n            /**\n             * Function to get the server-side data.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type function\n             */\n            \"fnServerData\": null,\n\n            /**\n             * Functions which are called prior to sending an Ajax request so extra\n             * parameters can easily be sent to the server\n             *  @type array\n             *  @default []\n             */\n            \"aoServerParams\": [],\n\n            /**\n             * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if\n             * required).\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type string\n             */\n            \"sServerMethod\": null,\n\n            /**\n             * Format numbers for display.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type function\n             */\n            \"fnFormatNumber\": null,\n\n            /**\n             * List of options that can be used for the user selectable length menu.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type array\n             *  @default []\n             */\n            \"aLengthMenu\": null,\n\n            /**\n             * Counter for the draws that the table does. Also used as a tracker for\n             * server-side processing\n             *  @type int\n             *  @default 0\n             */\n            \"iDraw\": 0,\n\n            /**\n             * Indicate if a redraw is being done - useful for Ajax\n             *  @type boolean\n             *  @default false\n             */\n            \"bDrawing\": false,\n\n            /**\n             * Draw index (iDraw) of the last error when parsing the returned data\n             *  @type int\n             *  @default -1\n             */\n            \"iDrawError\": -1,\n\n            /**\n             * Paging display length\n             *  @type int\n             *  @default 10\n             */\n            \"_iDisplayLength\": 10,\n\n            /**\n             * Paging start point - aiDisplay index\n             *  @type int\n             *  @default 0\n             */\n            \"_iDisplayStart\": 0,\n\n            /**\n             * Server-side processing - number of records in the result set\n             * (i.e. before filtering), Use fnRecordsTotal rather than\n             * this property to get the value of the number of records, regardless of\n             * the server-side processing setting.\n             *  @type int\n             *  @default 0\n             *  @private\n             */\n            \"_iRecordsTotal\": 0,\n\n            /**\n             * Server-side processing - number of records in the current display set\n             * (i.e. after filtering). Use fnRecordsDisplay rather than\n             * this property to get the value of the number of records, regardless of\n             * the server-side processing setting.\n             *  @type boolean\n             *  @default 0\n             *  @private\n             */\n            \"_iRecordsDisplay\": 0,\n\n            /**\n             * The classes to use for the table\n             *  @type object\n             *  @default {}\n             */\n            \"oClasses\": {},\n\n            /**\n             * Flag attached to the settings object so you can check in the draw\n             * callback if filtering has been done in the draw. Deprecated in favour of\n             * events.\n             *  @type boolean\n             *  @default false\n             *  @deprecated\n             */\n            \"bFiltered\": false,\n\n            /**\n             * Flag attached to the settings object so you can check in the draw\n             * callback if sorting has been done in the draw. Deprecated in favour of\n             * events.\n             *  @type boolean\n             *  @default false\n             *  @deprecated\n             */\n            \"bSorted\": false,\n\n            /**\n             * Indicate that if multiple rows are in the header and there is more than\n             * one unique cell per column, if the top one (true) or bottom one (false)\n             * should be used for sorting / title by DataTables.\n             * Note that this parameter will be set by the initialisation routine. To\n             * set a default use {@link DataTable.defaults}.\n             *  @type boolean\n             */\n            \"bSortCellsTop\": null,\n\n            /**\n             * Initialisation object that is used for the table\n             *  @type object\n             *  @default null\n             */\n            \"oInit\": null,\n\n            /**\n             * Destroy callback functions - for plug-ins to attach themselves to the\n             * destroy so they can clean up markup and events.\n             *  @type array\n             *  @default []\n             */\n            \"aoDestroyCallback\": [],\n\n\n            /**\n             * Get the number of records in the current record set, before filtering\n             *  @type function\n             */\n            \"fnRecordsTotal\": function () {\n                return _fnDataSource(this) == 'ssp' ?\n                    this._iRecordsTotal * 1 :\n                    this.aiDisplayMaster.length;\n            },\n\n            /**\n             * Get the number of records in the current record set, after filtering\n             *  @type function\n             */\n            \"fnRecordsDisplay\": function () {\n                return _fnDataSource(this) == 'ssp' ?\n                    this._iRecordsDisplay * 1 :\n                    this.aiDisplay.length;\n            },\n\n            /**\n             * Get the display end point - aiDisplay index\n             *  @type function\n             */\n            \"fnDisplayEnd\": function () {\n                var\n                    len = this._iDisplayLength,\n                    start = this._iDisplayStart,\n                    calc = start + len,\n                    records = this.aiDisplay.length,\n                    features = this.oFeatures,\n                    paginate = features.bPaginate;\n\n                if (features.bServerSide) {\n                    return paginate === false || len === -1 ?\n                        start + records :\n                        Math.min(start + len, this._iRecordsDisplay);\n                }\n                else {\n                    return !paginate || calc > records || len === -1 ?\n                        records :\n                        calc;\n                }\n            },\n\n            /**\n             * The DataTables object for this table\n             *  @type object\n             *  @default null\n             */\n            \"oInstance\": null,\n\n            /**\n             * Unique identifier for each instance of the DataTables object. If there\n             * is an ID on the table node, then it takes that value, otherwise an\n             * incrementing internal counter is used.\n             *  @type string\n             *  @default null\n             */\n            \"sInstance\": null,\n\n            /**\n             * tabindex attribute value that is added to DataTables control elements, allowing\n             * keyboard navigation of the table and its controls.\n             */\n            \"iTabIndex\": 0,\n\n            /**\n             * DIV container for the footer scrolling table if scrolling\n             */\n            \"nScrollHead\": null,\n\n            /**\n             * DIV container for the footer scrolling table if scrolling\n             */\n            \"nScrollFoot\": null,\n\n            /**\n             * Last applied sort\n             *  @type array\n             *  @default []\n             */\n            \"aLastSort\": [],\n\n            /**\n             * Stored plug-in instances\n             *  @type object\n             *  @default {}\n             */\n            \"oPlugins\": {},\n\n            /**\n             * Function used to get a row's id from the row's data\n             *  @type function\n             *  @default null\n             */\n            \"rowIdFn\": null,\n\n            /**\n             * Data location where to store a row's id\n             *  @type string\n             *  @default null\n             */\n            \"rowId\": null\n        };\n\n        /**\n         * Extension object for DataTables that is used to provide all extension\n         * options.\n         *\n         * Note that the `DataTable.ext` object is available through\n         * `jQuery.fn.dataTable.ext` where it may be accessed and manipulated. It is\n         * also aliased to `jQuery.fn.dataTableExt` for historic reasons.\n         *  @namespace\n         *  @extends DataTable.models.ext\n         */\n\n\n        /**\n         * DataTables extensions\n         *\n         * This namespace acts as a collection area for plug-ins that can be used to\n         * extend DataTables capabilities. Indeed many of the build in methods\n         * use this method to provide their own capabilities (sorting methods for\n         * example).\n         *\n         * Note that this namespace is aliased to `jQuery.fn.dataTableExt` for legacy\n         * reasons\n         *\n         *  @namespace\n         */\n        DataTable.ext = _ext = {\n            /**\n             * Buttons. For use with the Buttons extension for DataTables. This is\n             * defined here so other extensions can define buttons regardless of load\n             * order. It is _not_ used by DataTables core.\n             *\n             *  @type object\n             *  @default {}\n             */\n            buttons: {},\n\n\n            /**\n             * Element class names\n             *\n             *  @type object\n             *  @default {}\n             */\n            classes: {},\n\n\n            /**\n             * DataTables build type (expanded by the download builder)\n             *\n             *  @type string\n             */\n            builder: \"-source-\",\n\n\n            /**\n             * Error reporting.\n             *\n             * How should DataTables report an error. Can take the value 'alert',\n             * 'throw', 'none' or a function.\n             *\n             *  @type string|function\n             *  @default alert\n             */\n            errMode: \"alert\",\n\n\n            /**\n             * Feature plug-ins.\n             *\n             * This is an array of objects which describe the feature plug-ins that are\n             * available to DataTables. These feature plug-ins are then available for\n             * use through the `dom` initialisation option.\n             *\n             * Each feature plug-in is described by an object which must have the\n             * following properties:\n             *\n             * * `fnInit` - function that is used to initialise the plug-in,\n             * * `cFeature` - a character so the feature can be enabled by the `dom`\n             *   instillation option. This is case sensitive.\n             *\n             * The `fnInit` function has the following input parameters:\n             *\n             * 1. `{object}` DataTables settings object: see\n             *    {@link DataTable.models.oSettings}\n             *\n             * And the following return is expected:\n             *\n             * * {node|null} The element which contains your feature. Note that the\n             *   return may also be void if your plug-in does not require to inject any\n             *   DOM elements into DataTables control (`dom`) - for example this might\n             *   be useful when developing a plug-in which allows table control via\n             *   keyboard entry\n             *\n             *  @type array\n             *\n             *  @example\n             *    $.fn.dataTable.ext.features.push( {\n             *      \"fnInit\": function( oSettings ) {\n             *        return new TableTools( { \"oDTSettings\": oSettings } );\n             *      },\n             *      \"cFeature\": \"T\"\n             *    } );\n             */\n            feature: [],\n\n\n            /**\n             * Row searching.\n             *\n             * This method of searching is complimentary to the default type based\n             * searching, and a lot more comprehensive as it allows you complete control\n             * over the searching logic. Each element in this array is a function\n             * (parameters described below) that is called for every row in the table,\n             * and your logic decides if it should be included in the searching data set\n             * or not.\n             *\n             * Searching functions have the following input parameters:\n             *\n             * 1. `{object}` DataTables settings object: see\n             *    {@link DataTable.models.oSettings}\n             * 2. `{array|object}` Data for the row to be processed (same as the\n             *    original format that was passed in as the data source, or an array\n             *    from a DOM data source\n             * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which\n             *    can be useful to retrieve the `TR` element if you need DOM interaction.\n             *\n             * And the following return is expected:\n             *\n             * * {boolean} Include the row in the searched result set (true) or not\n             *   (false)\n             *\n             * Note that as with the main search ability in DataTables, technically this\n             * is \"filtering\", since it is subtractive. However, for consistency in\n             * naming we call it searching here.\n             *\n             *  @type array\n             *  @default []\n             *\n             *  @example\n             *    // The following example shows custom search being applied to the\n             *    // fourth column (i.e. the data[3] index) based on two input values\n             *    // from the end-user, matching the data in a certain range.\n             *    $.fn.dataTable.ext.search.push(\n             *      function( settings, data, dataIndex ) {\n             *        var min = document.getElementById('min').value * 1;\n             *        var max = document.getElementById('max').value * 1;\n             *        var version = data[3] == \"-\" ? 0 : data[3]*1;\n             *\n             *        if ( min == \"\" && max == \"\" ) {\n             *          return true;\n             *        }\n             *        else if ( min == \"\" && version < max ) {\n             *          return true;\n             *        }\n             *        else if ( min < version && \"\" == max ) {\n             *          return true;\n             *        }\n             *        else if ( min < version && version < max ) {\n             *          return true;\n             *        }\n             *        return false;\n             *      }\n             *    );\n             */\n            search: [],\n\n\n            /**\n             * Selector extensions\n             *\n             * The `selector` option can be used to extend the options available for the\n             * selector modifier options (`selector-modifier` object data type) that\n             * each of the three built in selector types offer (row, column and cell +\n             * their plural counterparts). For example the Select extension uses this\n             * mechanism to provide an option to select only rows, columns and cells\n             * that have been marked as selected by the end user (`{selected: true}`),\n             * which can be used in conjunction with the existing built in selector\n             * options.\n             *\n             * Each property is an array to which functions can be pushed. The functions\n             * take three attributes:\n             *\n             * * Settings object for the host table\n             * * Options object (`selector-modifier` object type)\n             * * Array of selected item indexes\n             *\n             * The return is an array of the resulting item indexes after the custom\n             * selector has been applied.\n             *\n             *  @type object\n             */\n            selector: {\n                cell: [],\n                column: [],\n                row: []\n            },\n\n\n            /**\n             * Internal functions, exposed for used in plug-ins.\n             *\n             * Please note that you should not need to use the internal methods for\n             * anything other than a plug-in (and even then, try to avoid if possible).\n             * The internal function may change between releases.\n             *\n             *  @type object\n             *  @default {}\n             */\n            internal: {},\n\n\n            /**\n             * Legacy configuration options. Enable and disable legacy options that\n             * are available in DataTables.\n             *\n             *  @type object\n             */\n            legacy: {\n                /**\n                 * Enable / disable DataTables 1.9 compatible server-side processing\n                 * requests\n                 *\n                 *  @type boolean\n                 *  @default null\n                 */\n                ajax: null\n            },\n\n\n            /**\n             * Pagination plug-in methods.\n             *\n             * Each entry in this object is a function and defines which buttons should\n             * be shown by the pagination rendering method that is used for the table:\n             * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the\n             * buttons are displayed in the document, while the functions here tell it\n             * what buttons to display. This is done by returning an array of button\n             * descriptions (what each button will do).\n             *\n             * Pagination types (the four built in options and any additional plug-in\n             * options defined here) can be used through the `paginationType`\n             * initialisation parameter.\n             *\n             * The functions defined take two parameters:\n             *\n             * 1. `{int} page` The current page index\n             * 2. `{int} pages` The number of pages in the table\n             *\n             * Each function is expected to return an array where each element of the\n             * array can be one of:\n             *\n             * * `first` - Jump to first page when activated\n             * * `last` - Jump to last page when activated\n             * * `previous` - Show previous page when activated\n             * * `next` - Show next page when activated\n             * * `{int}` - Show page of the index given\n             * * `{array}` - A nested array containing the above elements to add a\n             *   containing 'DIV' element (might be useful for styling).\n             *\n             * Note that DataTables v1.9- used this object slightly differently whereby\n             * an object with two functions would be defined for each plug-in. That\n             * ability is still supported by DataTables 1.10+ to provide backwards\n             * compatibility, but this option of use is now decremented and no longer\n             * documented in DataTables 1.10+.\n             *\n             *  @type object\n             *  @default {}\n             *\n             *  @example\n             *    // Show previous, next and current page buttons only\n             *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {\n             *      return [ 'previous', page, 'next' ];\n             *    };\n             */\n            pager: {},\n\n\n            renderer: {\n                pageButton: {},\n                header: {}\n            },\n\n\n            /**\n             * Ordering plug-ins - custom data source\n             *\n             * The extension options for ordering of data available here is complimentary\n             * to the default type based ordering that DataTables typically uses. It\n             * allows much greater control over the the data that is being used to\n             * order a column, but is necessarily therefore more complex.\n             *\n             * This type of ordering is useful if you want to do ordering based on data\n             * live from the DOM (for example the contents of an 'input' element) rather\n             * than just the static string that DataTables knows of.\n             *\n             * The way these plug-ins work is that you create an array of the values you\n             * wish to be ordering for the column in question and then return that\n             * array. The data in the array much be in the index order of the rows in\n             * the table (not the currently ordering order!). Which order data gathering\n             * function is run here depends on the `dt-init columns.orderDataType`\n             * parameter that is used for the column (if any).\n             *\n             * The functions defined take two parameters:\n             *\n             * 1. `{object}` DataTables settings object: see\n             *    {@link DataTable.models.oSettings}\n             * 2. `{int}` Target column index\n             *\n             * Each function is expected to return an array:\n             *\n             * * `{array}` Data for the column to be ordering upon\n             *\n             *  @type array\n             *\n             *  @example\n             *    // Ordering using `input` node values\n             *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )\n             *    {\n             *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {\n             *        return $('input', td).val();\n             *      } );\n             *    }\n             */\n            order: {},\n\n\n            /**\n             * Type based plug-ins.\n             *\n             * Each column in DataTables has a type assigned to it, either by automatic\n             * detection or by direct assignment using the `type` option for the column.\n             * The type of a column will effect how it is ordering and search (plug-ins\n             * can also make use of the column type if required).\n             *\n             * @namespace\n             */\n            type: {\n                /**\n                 * Type detection functions.\n                 *\n                 * The functions defined in this object are used to automatically detect\n                 * a column's type, making initialisation of DataTables super easy, even\n                 * when complex data is in the table.\n                 *\n                 * The functions defined take two parameters:\n                 *\n                 *  1. `{*}` Data from the column cell to be analysed\n                 *  2. `{settings}` DataTables settings object. This can be used to\n                 *     perform context specific type detection - for example detection\n                 *     based on language settings such as using a comma for a decimal\n                 *     place. Generally speaking the options from the settings will not\n                 *     be required\n                 *\n                 * Each function is expected to return:\n                 *\n                 * * `{string|null}` Data type detected, or null if unknown (and thus\n                 *   pass it on to the other type detection functions.\n                 *\n                 *  @type array\n                 *\n                 *  @example\n                 *    // Currency type detection plug-in:\n                 *    $.fn.dataTable.ext.type.detect.push(\n                 *      function ( data, settings ) {\n                 *        // Check the numeric part\n                 *        if ( ! data.substring(1).match(/[0-9]/) ) {\n                 *          return null;\n                 *        }\n                 *\n                 *        // Check prefixed by currency\n                 *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {\n                 *          return 'currency';\n                 *        }\n                 *        return null;\n                 *      }\n                 *    );\n                 */\n                detect: [],\n\n\n                /**\n                 * Type based search formatting.\n                 *\n                 * The type based searching functions can be used to pre-format the\n                 * data to be search on. For example, it can be used to strip HTML\n                 * tags or to de-format telephone numbers for numeric only searching.\n                 *\n                 * Note that is a search is not defined for a column of a given type,\n                 * no search formatting will be performed.\n                 *\n                 * Pre-processing of searching data plug-ins - When you assign the sType\n                 * for a column (or have it automatically detected for you by DataTables\n                 * or a type detection plug-in), you will typically be using this for\n                 * custom sorting, but it can also be used to provide custom searching\n                 * by allowing you to pre-processing the data and returning the data in\n                 * the format that should be searched upon. This is done by adding\n                 * functions this object with a parameter name which matches the sType\n                 * for that target column. This is the corollary of <i>afnSortData</i>\n                 * for searching data.\n                 *\n                 * The functions defined take a single parameter:\n                 *\n                 *  1. `{*}` Data from the column cell to be prepared for searching\n                 *\n                 * Each function is expected to return:\n                 *\n                 * * `{string|null}` Formatted string that will be used for the searching.\n                 *\n                 *  @type object\n                 *  @default {}\n                 *\n                 *  @example\n                 *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {\n                 *      return d.replace(/\\n/g,\" \").replace( /<.*?>/g, \"\" );\n                 *    }\n                 */\n                search: {},\n\n\n                /**\n                 * Type based ordering.\n                 *\n                 * The column type tells DataTables what ordering to apply to the table\n                 * when a column is sorted upon. The order for each type that is defined,\n                 * is defined by the functions available in this object.\n                 *\n                 * Each ordering option can be described by three properties added to\n                 * this object:\n                 *\n                 * * `{type}-pre` - Pre-formatting function\n                 * * `{type}-asc` - Ascending order function\n                 * * `{type}-desc` - Descending order function\n                 *\n                 * All three can be used together, only `{type}-pre` or only\n                 * `{type}-asc` and `{type}-desc` together. It is generally recommended\n                 * that only `{type}-pre` is used, as this provides the optimal\n                 * implementation in terms of speed, although the others are provided\n                 * for compatibility with existing Javascript sort functions.\n                 *\n                 * `{type}-pre`: Functions defined take a single parameter:\n                 *\n                 *  1. `{*}` Data from the column cell to be prepared for ordering\n                 *\n                 * And return:\n                 *\n                 * * `{*}` Data to be sorted upon\n                 *\n                 * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort\n                 * functions, taking two parameters:\n                 *\n                 *  1. `{*}` Data to compare to the second parameter\n                 *  2. `{*}` Data to compare to the first parameter\n                 *\n                 * And returning:\n                 *\n                 * * `{*}` Ordering match: <0 if first parameter should be sorted lower\n                 *   than the second parameter, ===0 if the two parameters are equal and\n                 *   >0 if the first parameter should be sorted height than the second\n                 *   parameter.\n                 *\n                 *  @type object\n                 *  @default {}\n                 *\n                 *  @example\n                 *    // Numeric ordering of formatted numbers with a pre-formatter\n                 *    $.extend( $.fn.dataTable.ext.type.order, {\n                 *      \"string-pre\": function(x) {\n                 *        a = (a === \"-\" || a === \"\") ? 0 : a.replace( /[^\\d\\-\\.]/g, \"\" );\n                 *        return parseFloat( a );\n                 *      }\n                 *    } );\n                 *\n                 *  @example\n                 *    // Case-sensitive string ordering, with no pre-formatting method\n                 *    $.extend( $.fn.dataTable.ext.order, {\n                 *      \"string-case-asc\": function(x,y) {\n                 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n                 *      },\n                 *      \"string-case-desc\": function(x,y) {\n                 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n                 *      }\n                 *    } );\n                 */\n                order: {}\n            },\n\n            /**\n             * Unique DataTables instance counter\n             *\n             * @type int\n             * @private\n             */\n            _unique: 0,\n\n\n            //\n            // Depreciated\n            // The following properties are retained for backwards compatiblity only.\n            // The should not be used in new projects and will be removed in a future\n            // version\n            //\n\n            /**\n             * Version check function.\n             *  @type function\n             *  @depreciated Since 1.10\n             */\n            fnVersionCheck: DataTable.fnVersionCheck,\n\n\n            /**\n             * Index for what 'this' index API functions should use\n             *  @type int\n             *  @deprecated Since v1.10\n             */\n            iApiIndex: 0,\n\n\n            /**\n             * jQuery UI class container\n             *  @type object\n             *  @deprecated Since v1.10\n             */\n            oJUIClasses: {},\n\n\n            /**\n             * Software version\n             *  @type string\n             *  @deprecated Since v1.10\n             */\n            sVersion: DataTable.version\n        };\n\n\n        //\n        // Backwards compatibility. Alias to pre 1.10 Hungarian notation counter parts\n        //\n        $.extend(_ext, {\n            afnFiltering: _ext.search,\n            aTypes: _ext.type.detect,\n            ofnSearch: _ext.type.search,\n            oSort: _ext.type.order,\n            afnSortData: _ext.order,\n            aoFeatures: _ext.feature,\n            oApi: _ext.internal,\n            oStdClasses: _ext.classes,\n            oPagination: _ext.pager\n        });\n\n\n        $.extend(DataTable.ext.classes, {\n            \"sTable\": \"dataTable\",\n            \"sNoFooter\": \"no-footer\",\n\n            /* Paging buttons */\n            \"sPageButton\": \"paginate_button\",\n            \"sPageButtonActive\": \"current\",\n            \"sPageButtonDisabled\": \"disabled\",\n\n            /* Striping classes */\n            \"sStripeOdd\": \"odd\",\n            \"sStripeEven\": \"even\",\n\n            /* Empty row */\n            \"sRowEmpty\": \"dataTables_empty\",\n\n            /* Features */\n            \"sWrapper\": \"dataTables_wrapper\",\n            \"sFilter\": \"dataTables_filter\",\n            \"sInfo\": \"dataTables_info\",\n            \"sPaging\": \"dataTables_paginate paging_\", /* Note that the type is postfixed */\n            \"sLength\": \"dataTables_length\",\n            \"sProcessing\": \"dataTables_processing\",\n\n            /* Sorting */\n            \"sSortAsc\": \"sorting_asc\",\n            \"sSortDesc\": \"sorting_desc\",\n            \"sSortable\": \"sorting\", /* Sortable in both directions */\n            \"sSortableAsc\": \"sorting_asc_disabled\",\n            \"sSortableDesc\": \"sorting_desc_disabled\",\n            \"sSortableNone\": \"sorting_disabled\",\n            \"sSortColumn\": \"sorting_\", /* Note that an int is postfixed for the sorting order */\n\n            /* Filtering */\n            \"sFilterInput\": \"\",\n\n            /* Page length */\n            \"sLengthSelect\": \"\",\n\n            /* Scrolling */\n            \"sScrollWrapper\": \"dataTables_scroll\",\n            \"sScrollHead\": \"dataTables_scrollHead\",\n            \"sScrollHeadInner\": \"dataTables_scrollHeadInner\",\n            \"sScrollBody\": \"dataTables_scrollBody\",\n            \"sScrollFoot\": \"dataTables_scrollFoot\",\n            \"sScrollFootInner\": \"dataTables_scrollFootInner\",\n\n            /* Misc */\n            \"sHeaderTH\": \"\",\n            \"sFooterTH\": \"\",\n\n            // Deprecated\n            \"sSortJUIAsc\": \"\",\n            \"sSortJUIDesc\": \"\",\n            \"sSortJUI\": \"\",\n            \"sSortJUIAscAllowed\": \"\",\n            \"sSortJUIDescAllowed\": \"\",\n            \"sSortJUIWrapper\": \"\",\n            \"sSortIcon\": \"\",\n            \"sJUIHeader\": \"\",\n            \"sJUIFooter\": \"\"\n        });\n\n\n        var extPagination = DataTable.ext.pager;\n\n        function _numbers(page, pages) {\n            var\n                numbers = [],\n                buttons = extPagination.numbers_length,\n                half = Math.floor(buttons / 2),\n                i = 1;\n\n            if (pages <= buttons) {\n                numbers = _range(0, pages);\n            }\n            else if (page <= half) {\n                numbers = _range(0, buttons - 2);\n                numbers.push('ellipsis');\n                numbers.push(pages - 1);\n            }\n            else if (page >= pages - 1 - half) {\n                numbers = _range(pages - (buttons - 2), pages);\n                numbers.splice(0, 0, 'ellipsis'); // no unshift in ie6\n                numbers.splice(0, 0, 0);\n            }\n            else {\n                numbers = _range(page - half + 2, page + half - 1);\n                numbers.push('ellipsis');\n                numbers.push(pages - 1);\n                numbers.splice(0, 0, 'ellipsis');\n                numbers.splice(0, 0, 0);\n            }\n\n            numbers.DT_el = 'span';\n            return numbers;\n        }\n\n\n        $.extend(extPagination, {\n            simple: function (page, pages) {\n                return ['previous', 'next'];\n            },\n\n            full: function (page, pages) {\n                return ['first', 'previous', 'next', 'last'];\n            },\n\n            numbers: function (page, pages) {\n                return [_numbers(page, pages)];\n            },\n\n            simple_numbers: function (page, pages) {\n                return ['previous', _numbers(page, pages), 'next'];\n            },\n\n            full_numbers: function (page, pages) {\n                return ['first', 'previous', _numbers(page, pages), 'next', 'last'];\n            },\n\n            first_last_numbers: function (page, pages) {\n                return ['first', _numbers(page, pages), 'last'];\n            },\n\n            // For testing and plug-ins to use\n            _numbers: _numbers,\n\n            // Number of number buttons (including ellipsis) to show. _Must be odd!_\n            numbers_length: 7\n        });\n\n\n        $.extend(true, DataTable.ext.renderer, {\n            pageButton: {\n                _: function (settings, host, idx, buttons, page, pages) {\n                    var classes = settings.oClasses;\n                    var lang = settings.oLanguage.oPaginate;\n                    var aria = settings.oLanguage.oAria.paginate || {};\n                    var btnDisplay, btnClass, counter = 0;\n\n                    var attach = function (container, buttons) {\n                        var i, ien, node, button, tabIndex;\n                        var disabledClass = classes.sPageButtonDisabled;\n                        var clickHandler = function (e) {\n                            _fnPageChange(settings, e.data.action, true);\n                        };\n\n                        for (i = 0, ien = buttons.length; i < ien; i++) {\n                            button = buttons[i];\n\n                            if (Array.isArray(button)) {\n                                var inner = $('<' + (button.DT_el || 'div') + '/>')\n                                    .appendTo(container);\n                                attach(inner, button);\n                            }\n                            else {\n                                btnDisplay = null;\n                                btnClass = button;\n                                tabIndex = settings.iTabIndex;\n\n                                switch (button) {\n                                    case 'ellipsis':\n                                        container.append('<span class=\"ellipsis\">&#x2026;</span>');\n                                        break;\n\n                                    case 'first':\n                                        btnDisplay = lang.sFirst;\n\n                                        if (page === 0) {\n                                            tabIndex = -1;\n                                            btnClass += ' ' + disabledClass;\n                                        }\n                                        break;\n\n                                    case 'previous':\n                                        btnDisplay = lang.sPrevious;\n\n                                        if (page === 0) {\n                                            tabIndex = -1;\n                                            btnClass += ' ' + disabledClass;\n                                        }\n                                        break;\n\n                                    case 'next':\n                                        btnDisplay = lang.sNext;\n\n                                        if (pages === 0 || page === pages - 1) {\n                                            tabIndex = -1;\n                                            btnClass += ' ' + disabledClass;\n                                        }\n                                        break;\n\n                                    case 'last':\n                                        btnDisplay = lang.sLast;\n\n                                        if (pages === 0 || page === pages - 1) {\n                                            tabIndex = -1;\n                                            btnClass += ' ' + disabledClass;\n                                        }\n                                        break;\n\n                                    default:\n                                        btnDisplay = settings.fnFormatNumber(button + 1);\n                                        btnClass = page === button ?\n                                            classes.sPageButtonActive : '';\n                                        break;\n                                }\n\n                                if (btnDisplay !== null) {\n                                    node = $('<a>', {\n                                        'class': classes.sPageButton + ' ' + btnClass,\n                                        'aria-controls': settings.sTableId,\n                                        'aria-label': aria[button],\n                                        'data-dt-idx': counter,\n                                        'tabindex': tabIndex,\n                                        'id': idx === 0 && typeof button === 'string' ?\n                                            settings.sTableId + '_' + button :\n                                            null\n                                    })\n                                        .html(btnDisplay)\n                                        .appendTo(container);\n\n                                    _fnBindAction(\n                                        node, { action: button }, clickHandler\n                                    );\n\n                                    counter++;\n                                }\n                            }\n                        }\n                    };\n\n                    // IE9 throws an 'unknown error' if document.activeElement is used\n                    // inside an iframe or frame. Try / catch the error. Not good for\n                    // accessibility, but neither are frames.\n                    var activeEl;\n\n                    try {\n                        // Because this approach is destroying and recreating the paging\n                        // elements, focus is lost on the select button which is bad for\n                        // accessibility. So we want to restore focus once the draw has\n                        // completed\n                        activeEl = $(host).find(document.activeElement).data('dt-idx');\n                    }\n                    catch (e) { }\n\n                    attach($(host).empty(), buttons);\n\n                    if (activeEl !== undefined) {\n                        $(host).find('[data-dt-idx=' + activeEl + ']').trigger('focus');\n                    }\n                }\n            }\n        });\n\n\n\n        // Built in type detection. See model.ext.aTypes for information about\n        // what is required from this methods.\n        $.extend(DataTable.ext.type.detect, [\n            // Plain numbers - first since V8 detects some plain numbers as dates\n            // e.g. Date.parse('55') (but not all, e.g. Date.parse('22')...).\n            function (d, settings) {\n                var decimal = settings.oLanguage.sDecimal;\n                return _isNumber(d, decimal) ? 'num' + decimal : null;\n            },\n\n            // Dates (only those recognised by the browser's Date.parse)\n            function (d, settings) {\n                // V8 tries _very_ hard to make a string passed into `Date.parse()`\n                // valid, so we need to use a regex to restrict date formats. Use a\n                // plug-in for anything other than ISO8601 style strings\n                if (d && !(d instanceof Date) && !_re_date.test(d)) {\n                    return null;\n                }\n                var parsed = Date.parse(d);\n                return (parsed !== null && !isNaN(parsed)) || _empty(d) ? 'date' : null;\n            },\n\n            // Formatted numbers\n            function (d, settings) {\n                var decimal = settings.oLanguage.sDecimal;\n                return _isNumber(d, decimal, true) ? 'num-fmt' + decimal : null;\n            },\n\n            // HTML numeric\n            function (d, settings) {\n                var decimal = settings.oLanguage.sDecimal;\n                return _htmlNumeric(d, decimal) ? 'html-num' + decimal : null;\n            },\n\n            // HTML numeric, formatted\n            function (d, settings) {\n                var decimal = settings.oLanguage.sDecimal;\n                return _htmlNumeric(d, decimal, true) ? 'html-num-fmt' + decimal : null;\n            },\n\n            // HTML (this is strict checking - there must be html)\n            function (d, settings) {\n                return _empty(d) || (typeof d === 'string' && d.indexOf('<') !== -1) ?\n                    'html' : null;\n            }\n        ]);\n\n\n\n        // Filter formatting functions. See model.ext.ofnSearch for information about\n        // what is required from these methods.\n        //\n        // Note that additional search methods are added for the html numbers and\n        // html formatted numbers by `_addNumericSort()` when we know what the decimal\n        // place is\n\n\n        $.extend(DataTable.ext.type.search, {\n            html: function (data) {\n                return _empty(data) ?\n                    data :\n                    typeof data === 'string' ?\n                        data\n                            .replace(_re_new_lines, \" \")\n                            .replace(_re_html, \"\") :\n                        '';\n            },\n\n            string: function (data) {\n                return _empty(data) ?\n                    data :\n                    typeof data === 'string' ?\n                        data.replace(_re_new_lines, \" \") :\n                        data;\n            }\n        });\n\n\n\n        var __numericReplace = function (d, decimalPlace, re1, re2) {\n            if (d !== 0 && (!d || d === '-')) {\n                return -Infinity;\n            }\n\n            // If a decimal place other than `.` is used, it needs to be given to the\n            // function so we can detect it and replace with a `.` which is the only\n            // decimal place Javascript recognises - it is not locale aware.\n            if (decimalPlace) {\n                d = _numToDecimal(d, decimalPlace);\n            }\n\n            if (d.replace) {\n                if (re1) {\n                    d = d.replace(re1, '');\n                }\n\n                if (re2) {\n                    d = d.replace(re2, '');\n                }\n            }\n\n            return d * 1;\n        };\n\n\n        // Add the numeric 'deformatting' functions for sorting and search. This is done\n        // in a function to provide an easy ability for the language options to add\n        // additional methods if a non-period decimal place is used.\n        function _addNumericSort(decimalPlace) {\n            $.each(\n                {\n                    // Plain numbers\n                    \"num\": function (d) {\n                        return __numericReplace(d, decimalPlace);\n                    },\n\n                    // Formatted numbers\n                    \"num-fmt\": function (d) {\n                        return __numericReplace(d, decimalPlace, _re_formatted_numeric);\n                    },\n\n                    // HTML numeric\n                    \"html-num\": function (d) {\n                        return __numericReplace(d, decimalPlace, _re_html);\n                    },\n\n                    // HTML numeric, formatted\n                    \"html-num-fmt\": function (d) {\n                        return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric);\n                    }\n                },\n                function (key, fn) {\n                    // Add the ordering method\n                    _ext.type.order[key + decimalPlace + '-pre'] = fn;\n\n                    // For HTML types add a search formatter that will strip the HTML\n                    if (key.match(/^html\\-/)) {\n                        _ext.type.search[key + decimalPlace] = _ext.type.search.html;\n                    }\n                }\n            );\n        }\n\n\n        // Default sort methods\n        $.extend(_ext.type.order, {\n            // Dates\n            \"date-pre\": function (d) {\n                var ts = Date.parse(d);\n                return isNaN(ts) ? -Infinity : ts;\n            },\n\n            // html\n            \"html-pre\": function (a) {\n                return _empty(a) ?\n                    '' :\n                    a.replace ?\n                        a.replace(/<.*?>/g, \"\").toLowerCase() :\n                        a + '';\n            },\n\n            // string\n            \"string-pre\": function (a) {\n                // This is a little complex, but faster than always calling toString,\n                // http://jsperf.com/tostring-v-check\n                return _empty(a) ?\n                    '' :\n                    typeof a === 'string' ?\n                        a.toLowerCase() :\n                        !a.toString ?\n                            '' :\n                            a.toString();\n            },\n\n            // string-asc and -desc are retained only for compatibility with the old\n            // sort methods\n            \"string-asc\": function (x, y) {\n                return ((x < y) ? -1 : ((x > y) ? 1 : 0));\n            },\n\n            \"string-desc\": function (x, y) {\n                return ((x < y) ? 1 : ((x > y) ? -1 : 0));\n            }\n        });\n\n\n        // Numeric sorting types - order doesn't matter here\n        _addNumericSort('');\n\n\n        $.extend(true, DataTable.ext.renderer, {\n            header: {\n                _: function (settings, cell, column, classes) {\n                    // No additional mark-up required\n                    // Attach a sort listener to update on sort - note that using the\n                    // `DT` namespace will allow the event to be removed automatically\n                    // on destroy, while the `dt` namespaced event is the one we are\n                    // listening for\n                    $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\n                        if (settings !== ctx) { // need to check this this is the host\n                            return;               // table, not a nested one\n                        }\n\n                        var colIdx = column.idx;\n\n                        cell\n                            .removeClass(\n                                column.sSortingClass + ' ' +\n                                classes.sSortAsc + ' ' +\n                                classes.sSortDesc\n                            )\n                            .addClass(columns[colIdx] == 'asc' ?\n                                classes.sSortAsc : columns[colIdx] == 'desc' ?\n                                    classes.sSortDesc :\n                                    column.sSortingClass\n                            );\n                    });\n                },\n\n                jqueryui: function (settings, cell, column, classes) {\n                    $('<div/>')\n                        .addClass(classes.sSortJUIWrapper)\n                        .append(cell.contents())\n                        .append($('<span/>')\n                            .addClass(classes.sSortIcon + ' ' + column.sSortingClassJUI)\n                        )\n                        .appendTo(cell);\n\n                    // Attach a sort listener to update on sort\n                    $(settings.nTable).on('order.dt.DT', function (e, ctx, sorting, columns) {\n                        if (settings !== ctx) {\n                            return;\n                        }\n\n                        var colIdx = column.idx;\n\n                        cell\n                            .removeClass(classes.sSortAsc + \" \" + classes.sSortDesc)\n                            .addClass(columns[colIdx] == 'asc' ?\n                                classes.sSortAsc : columns[colIdx] == 'desc' ?\n                                    classes.sSortDesc :\n                                    column.sSortingClass\n                            );\n\n                        cell\n                            .find('span.' + classes.sSortIcon)\n                            .removeClass(\n                                classes.sSortJUIAsc + \" \" +\n                                classes.sSortJUIDesc + \" \" +\n                                classes.sSortJUI + \" \" +\n                                classes.sSortJUIAscAllowed + \" \" +\n                                classes.sSortJUIDescAllowed\n                            )\n                            .addClass(columns[colIdx] == 'asc' ?\n                                classes.sSortJUIAsc : columns[colIdx] == 'desc' ?\n                                    classes.sSortJUIDesc :\n                                    column.sSortingClassJUI\n                            );\n                    });\n                }\n            }\n        });\n\n        /*\n         * Public helper functions. These aren't used internally by DataTables, or\n         * called by any of the options passed into DataTables, but they can be used\n         * externally by developers working with DataTables. They are helper functions\n         * to make working with DataTables a little bit easier.\n         */\n\n        var __htmlEscapeEntities = function (d) {\n            return typeof d === 'string' ?\n                d\n                    .replace(/&/g, '&amp;')\n                    .replace(/</g, '&lt;')\n                    .replace(/>/g, '&gt;')\n                    .replace(/\"/g, '&quot;') :\n                d;\n        };\n\n        /**\n         * Helpers for `columns.render`.\n         *\n         * The options defined here can be used with the `columns.render` initialisation\n         * option to provide a display renderer. The following functions are defined:\n         *\n         * * `number` - Will format numeric data (defined by `columns.data`) for\n         *   display, retaining the original unformatted data for sorting and filtering.\n         *   It takes 5 parameters:\n         *   * `string` - Thousands grouping separator\n         *   * `string` - Decimal point indicator\n         *   * `integer` - Number of decimal points to show\n         *   * `string` (optional) - Prefix.\n         *   * `string` (optional) - Postfix (/suffix).\n         * * `text` - Escape HTML to help prevent XSS attacks. It has no optional\n         *   parameters.\n         *\n         * @example\n         *   // Column definition using the number renderer\n         *   {\n         *     data: \"salary\",\n         *     render: $.fn.dataTable.render.number( '\\'', '.', 0, '$' )\n         *   }\n         *\n         * @namespace\n         */\n        DataTable.render = {\n            number: function (thousands, decimal, precision, prefix, postfix) {\n                return {\n                    display: function (d) {\n                        if (typeof d !== 'number' && typeof d !== 'string') {\n                            return d;\n                        }\n\n                        var negative = d < 0 ? '-' : '';\n                        var flo = parseFloat(d);\n\n                        // If NaN then there isn't much formatting that we can do - just\n                        // return immediately, escaping any HTML (this was supposed to\n                        // be a number after all)\n                        if (isNaN(flo)) {\n                            return __htmlEscapeEntities(d);\n                        }\n\n                        flo = flo.toFixed(precision);\n                        d = Math.abs(flo);\n\n                        var intPart = parseInt(d, 10);\n                        var floatPart = precision ?\n                            decimal + (d - intPart).toFixed(precision).substring(2) :\n                            '';\n\n                        return negative + (prefix || '') +\n                            intPart.toString().replace(\n                                /\\B(?=(\\d{3})+(?!\\d))/g, thousands\n                            ) +\n                            floatPart +\n                            (postfix || '');\n                    }\n                };\n            },\n\n            text: function () {\n                return {\n                    display: __htmlEscapeEntities,\n                    filter: __htmlEscapeEntities\n                };\n            }\n        };\n\n\n        /*\n         * This is really a good bit rubbish this method of exposing the internal methods\n         * publicly... - To be fixed in 2.0 using methods on the prototype\n         */\n\n\n        /**\n         * Create a wrapper function for exporting an internal functions to an external API.\n         *  @param {string} fn API function name\n         *  @returns {function} wrapped function\n         *  @memberof DataTable#internal\n         */\n        function _fnExternApiFunc(fn) {\n            return function () {\n                var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(\n                    Array.prototype.slice.call(arguments)\n                );\n                return DataTable.ext.internal[fn].apply(this, args);\n            };\n        }\n\n\n        /**\n         * Reference to internal functions for use by plug-in developers. Note that\n         * these methods are references to internal functions and are considered to be\n         * private. If you use these methods, be aware that they are liable to change\n         * between versions.\n         *  @namespace\n         */\n        $.extend(DataTable.ext.internal, {\n            _fnExternApiFunc: _fnExternApiFunc,\n            _fnBuildAjax: _fnBuildAjax,\n            _fnAjaxUpdate: _fnAjaxUpdate,\n            _fnAjaxParameters: _fnAjaxParameters,\n            _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,\n            _fnAjaxDataSrc: _fnAjaxDataSrc,\n            _fnAddColumn: _fnAddColumn,\n            _fnColumnOptions: _fnColumnOptions,\n            _fnAdjustColumnSizing: _fnAdjustColumnSizing,\n            _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,\n            _fnColumnIndexToVisible: _fnColumnIndexToVisible,\n            _fnVisbleColumns: _fnVisbleColumns,\n            _fnGetColumns: _fnGetColumns,\n            _fnColumnTypes: _fnColumnTypes,\n            _fnApplyColumnDefs: _fnApplyColumnDefs,\n            _fnHungarianMap: _fnHungarianMap,\n            _fnCamelToHungarian: _fnCamelToHungarian,\n            _fnLanguageCompat: _fnLanguageCompat,\n            _fnBrowserDetect: _fnBrowserDetect,\n            _fnAddData: _fnAddData,\n            _fnAddTr: _fnAddTr,\n            _fnNodeToDataIndex: _fnNodeToDataIndex,\n            _fnNodeToColumnIndex: _fnNodeToColumnIndex,\n            _fnGetCellData: _fnGetCellData,\n            _fnSetCellData: _fnSetCellData,\n            _fnSplitObjNotation: _fnSplitObjNotation,\n            _fnGetObjectDataFn: _fnGetObjectDataFn,\n            _fnSetObjectDataFn: _fnSetObjectDataFn,\n            _fnGetDataMaster: _fnGetDataMaster,\n            _fnClearTable: _fnClearTable,\n            _fnDeleteIndex: _fnDeleteIndex,\n            _fnInvalidate: _fnInvalidate,\n            _fnGetRowElements: _fnGetRowElements,\n            _fnCreateTr: _fnCreateTr,\n            _fnBuildHead: _fnBuildHead,\n            _fnDrawHead: _fnDrawHead,\n            _fnDraw: _fnDraw,\n            _fnReDraw: _fnReDraw,\n            _fnAddOptionsHtml: _fnAddOptionsHtml,\n            _fnDetectHeader: _fnDetectHeader,\n            _fnGetUniqueThs: _fnGetUniqueThs,\n            _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,\n            _fnFilterComplete: _fnFilterComplete,\n            _fnFilterCustom: _fnFilterCustom,\n            _fnFilterColumn: _fnFilterColumn,\n            _fnFilter: _fnFilter,\n            _fnFilterCreateSearch: _fnFilterCreateSearch,\n            _fnEscapeRegex: _fnEscapeRegex,\n            _fnFilterData: _fnFilterData,\n            _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,\n            _fnUpdateInfo: _fnUpdateInfo,\n            _fnInfoMacros: _fnInfoMacros,\n            _fnInitialise: _fnInitialise,\n            _fnInitComplete: _fnInitComplete,\n            _fnLengthChange: _fnLengthChange,\n            _fnFeatureHtmlLength: _fnFeatureHtmlLength,\n            _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,\n            _fnPageChange: _fnPageChange,\n            _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,\n            _fnProcessingDisplay: _fnProcessingDisplay,\n            _fnFeatureHtmlTable: _fnFeatureHtmlTable,\n            _fnScrollDraw: _fnScrollDraw,\n            _fnApplyToChildren: _fnApplyToChildren,\n            _fnCalculateColumnWidths: _fnCalculateColumnWidths,\n            _fnThrottle: _fnThrottle,\n            _fnConvertToWidth: _fnConvertToWidth,\n            _fnGetWidestNode: _fnGetWidestNode,\n            _fnGetMaxLenString: _fnGetMaxLenString,\n            _fnStringToCss: _fnStringToCss,\n            _fnSortFlatten: _fnSortFlatten,\n            _fnSort: _fnSort,\n            _fnSortAria: _fnSortAria,\n            _fnSortListener: _fnSortListener,\n            _fnSortAttachListener: _fnSortAttachListener,\n            _fnSortingClasses: _fnSortingClasses,\n            _fnSortData: _fnSortData,\n            _fnSaveState: _fnSaveState,\n            _fnLoadState: _fnLoadState,\n            _fnSettingsFromNode: _fnSettingsFromNode,\n            _fnLog: _fnLog,\n            _fnMap: _fnMap,\n            _fnBindAction: _fnBindAction,\n            _fnCallbackReg: _fnCallbackReg,\n            _fnCallbackFire: _fnCallbackFire,\n            _fnLengthOverflow: _fnLengthOverflow,\n            _fnRenderer: _fnRenderer,\n            _fnDataSource: _fnDataSource,\n            _fnRowAttributes: _fnRowAttributes,\n            _fnExtend: _fnExtend,\n            _fnCalculateEnd: function () { } // Used by a lot of plug-ins, but redundant\n            // in 1.10, so this dead-end function is\n            // added to prevent errors\n        });\n\n\n        // jQuery access\n        $.fn.dataTable = DataTable;\n\n        // Provide access to the host jQuery object (circular reference)\n        DataTable.$ = $;\n\n        // Legacy aliases\n        $.fn.dataTableSettings = DataTable.settings;\n        $.fn.dataTableExt = DataTable.ext;\n\n        // With a capital `D` we return a DataTables API instance rather than a\n        // jQuery object\n        $.fn.DataTable = function (opts) {\n            return $(this).dataTable(opts).api();\n        };\n\n        // All properties that are available to $.fn.dataTable should also be\n        // available on $.fn.DataTable\n        $.each(DataTable, function (prop, val) {\n            $.fn.DataTable[prop] = val;\n        });\n\n\n        // Information about events fired by DataTables - for documentation.\n        /**\n         * Draw event, fired whenever the table is redrawn on the page, at the same\n         * point as fnDrawCallback. This may be useful for binding events or\n         * performing calculations when the table is altered at all.\n         *  @name DataTable#draw.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         */\n\n        /**\n         * Search event, fired when the searching applied to the table (using the\n         * built-in global search, or column filters) is altered.\n         *  @name DataTable#search.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         */\n\n        /**\n         * Page change event, fired when the paging of the table is altered.\n         *  @name DataTable#page.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         */\n\n        /**\n         * Order event, fired when the ordering applied to the table is altered.\n         *  @name DataTable#order.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         */\n\n        /**\n         * DataTables initialisation complete event, fired when the table is fully\n         * drawn, including Ajax data loaded, if Ajax data is required.\n         *  @name DataTable#init.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} oSettings DataTables settings object\n         *  @param {object} json The JSON object request from the server - only\n         *    present if client-side Ajax sourced data is used</li></ol>\n         */\n\n        /**\n         * State save event, fired when the table has changed state a new state save\n         * is required. This event allows modification of the state saving object\n         * prior to actually doing the save, including addition or other state\n         * properties (for plug-ins) or modification of a DataTables core property.\n         *  @name DataTable#stateSaveParams.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} oSettings DataTables settings object\n         *  @param {object} json The state information to be saved\n         */\n\n        /**\n         * State load event, fired when the table is loading state from the stored\n         * data, but prior to the settings object being modified by the saved state\n         * - allowing modification of the saved state is required or loading of\n         * state for a plug-in.\n         *  @name DataTable#stateLoadParams.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} oSettings DataTables settings object\n         *  @param {object} json The saved state information\n         */\n\n        /**\n         * State loaded event, fired when state has been loaded from stored data and\n         * the settings object has been modified by the loaded data.\n         *  @name DataTable#stateLoaded.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} oSettings DataTables settings object\n         *  @param {object} json The saved state information\n         */\n\n        /**\n         * Processing event, fired when DataTables is doing some kind of processing\n         * (be it, order, search or anything else). It can be used to indicate to\n         * the end user that there is something happening, or that something has\n         * finished.\n         *  @name DataTable#processing.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} oSettings DataTables settings object\n         *  @param {boolean} bShow Flag for if DataTables is doing processing or not\n         */\n\n        /**\n         * Ajax (XHR) event, fired whenever an Ajax request is completed from a\n         * request to made to the server for new data. This event is called before\n         * DataTables processed the returned data, so it can also be used to pre-\n         * process the data returned from the server, if needed.\n         *\n         * Note that this trigger is called in `fnServerData`, if you override\n         * `fnServerData` and which to use this event, you need to trigger it in you\n         * success function.\n         *  @name DataTable#xhr.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         *  @param {object} json JSON returned from the server\n         *\n         *  @example\n         *     // Use a custom property returned from the server in another DOM element\n         *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n         *       $('#status').html( json.status );\n         *     } );\n         *\n         *  @example\n         *     // Pre-process the data returned from the server\n         *     $('#table').dataTable().on('xhr.dt', function (e, settings, json) {\n         *       for ( var i=0, ien=json.aaData.length ; i<ien ; i++ ) {\n         *         json.aaData[i].sum = json.aaData[i].one + json.aaData[i].two;\n         *       }\n         *       // Note no return - manipulate the data directly in the JSON object.\n         *     } );\n         */\n\n        /**\n         * Destroy event, fired when the DataTable is destroyed by calling fnDestroy\n         * or passing the bDestroy:true parameter in the initialisation object. This\n         * can be used to remove bound events, added DOM nodes, etc.\n         *  @name DataTable#destroy.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         */\n\n        /**\n         * Page length change event, fired when number of records to show on each\n         * page (the length) is changed.\n         *  @name DataTable#length.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         *  @param {integer} len New length\n         */\n\n        /**\n         * Column sizing has changed.\n         *  @name DataTable#column-sizing.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         */\n\n        /**\n         * Column visibility has changed.\n         *  @name DataTable#column-visibility.dt\n         *  @event\n         *  @param {event} e jQuery event object\n         *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}\n         *  @param {int} column Column index\n         *  @param {bool} vis `false` if column now hidden, or `true` if visible\n         */\n\n        return $.fn.dataTable;\n    }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGF0YXRhYmxlcy5uZXQvanMvanF1ZXJ5LmRhdGFUYWJsZXMuanM/MTY1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFFBQVEsSUFBMEM7QUFDbEQ7QUFDQSxRQUFRLGlDQUFPLENBQUMseUVBQVEsQ0FBQyxtQ0FBRTtBQUMzQjtBQUNBLFNBQVM7QUFBQSxrR0FBQztBQUNWO0FBQ0EsU0FBUyxFQXFCSjtBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTyxTQUFTO0FBQ3BDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0Msd0JBQXdCLE9BQU87QUFDL0Isd0JBQXdCLE9BQU87QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7O0FB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QUFDQSxzREFBc0QsVUFBVTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQ7OztBQUduRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixJQUFJO0FBQ3hCLG9CQUFvQixLQUFLO0FBQ3pCO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsMEJBQTBCLFFBQVE7QUFDbEMsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsVUFBVTtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFELFVBQVU7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGNBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsOENBQThDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QiwwQkFBMEIsTUFBTTtBQUNoQywwQkFBMEIsTUFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7O0FBRUEsb0RBQW9ELFVBQVU7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSwyQ0FBMkMsU0FBUztBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsVUFBVTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFNBQVM7QUFDNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyxTQUFTO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBLGtEQUFrRCxTQUFTO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOzs7QUFHYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjs7O0FBR0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpREFBaUQsU0FBUztBQUMxRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUF1RCxTQUFTO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrREFBa0Q7QUFDbEQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLHdCQUF3QixFQUFFO0FBQzFCLHdCQUF3QixhQUFhO0FBQ3JDLHdCQUF3QixJQUFJO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQSwwQkFBMEIsRUFBRTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFD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Q0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7OztBQUcxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsdUJBQXVCO0FBQ3ZCO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EsYUFBYTs7O0FBR2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0Esa0NBQWtDOzs7QUFHbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVc7QUFDM0MsZ0NBQWdDLGlCQUFpQjtBQUNqRCxnQ0FBZ0MsZUFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQsZ0NBQWdDLE1BQU0sS0FBSyxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVUsTUFBTSxlQUFlLElBQUksV0FBVztBQUNoRixxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0NBQWdDO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixtQkFBbUI7QUFDbkI7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsbUJBQW1CO0FBQ25CO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOzs7QUFHdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOzs7QUFHdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMkJBQTJCO0FBQ3pFLHFCQUFxQjtBQUNyQjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQixtQkFBbUI7QUFDbkIsb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBLG9CQUFvQixJQUFJLGNBQWMsd0NBQXdDO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLGVBQWU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOzs7QUFHYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qjs7O0FBR3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0NBQXdDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEIsb0JBQW9CLElBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixJQUFJO0FBQ3ZCLG1CQUFtQixNQUFNO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7OztBQUdyQjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGFBQWE7OztBQUdiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLG1CQUFtQjtBQUNuQixvQkFBb0IsSUFBSTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsTUFBTTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7OztBQUdyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0IseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixFQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjs7O0FBRzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLEtBQUs7QUFDNUIsdUJBQXVCLEtBQUs7QUFDNUI7QUFDQSwwREFBMEQsS0FBSztBQUMvRCxxQkFBcUIsS0FBSyxZQUFZLEtBQUs7QUFDM0MsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQSx5QkFBeUIsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBLHFCQUFxQixLQUFLLFlBQVksS0FBSztBQUMzQztBQUNBO0FBQ0EseUJBQXlCLEVBQUU7QUFDM0IseUJBQXlCLEVBQUU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7OztBQUczQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlEQUF5RCxTQUFTO0FBQ2xFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7Ozs7QUFJVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7OztBQUlUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0MsbUNBQW1DO0FBQ25DOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHdDQUF3QztBQUN4Qyx3Q0FBd0M7QUFDeEMsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxFQUFFO0FBQzVDO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOzs7QUFHVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCLG9CQUFvQixPQUFPLCtCQUErQjtBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU8sK0JBQStCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU8sK0JBQStCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU8sK0JBQStCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU87QUFDM0Isb0JBQW9CLE9BQU87QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTztBQUMzQixvQkFBb0IsUUFBUTtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU8sK0JBQStCO0FBQzFELG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsUUFBUTtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUIsb0JBQW9CLE9BQU8sK0JBQStCO0FBQzFEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTywrQkFBK0I7QUFDMUQsb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTywrQkFBK0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQixvQkFBb0IsT0FBTywrQkFBK0I7QUFDMUQsb0JBQW9CLElBQUk7QUFDeEIsb0JBQW9CLEtBQUs7QUFDekI7O0FBRUE7QUFDQSxLQUFLIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2RhdGF0YWJsZXMubmV0L2pzL2pxdWVyeS5kYXRhVGFibGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIERhdGFUYWJsZXMgMS4xMC4yM1xuICogwqkyMDA4LTIwMjAgU3ByeU1lZGlhIEx0ZCAtIGRhdGF0YWJsZXMubmV0L2xpY2Vuc2VcbiAqL1xuXG4vKipcbiAqIEBzdW1tYXJ5ICAgICBEYXRhVGFibGVzXG4gKiBAZGVzY3JpcHRpb24gUGFnaW5hdGUsIHNlYXJjaCBhbmQgb3JkZXIgSFRNTCB0YWJsZXNcbiAqIEB2ZXJzaW9uICAgICAxLjEwLjIzXG4gKiBAZmlsZSAgICAgICAganF1ZXJ5LmRhdGFUYWJsZXMuanNcbiAqIEBhdXRob3IgICAgICBTcHJ5TWVkaWEgTHRkXG4gKiBAY29udGFjdCAgICAgd3d3LmRhdGF0YWJsZXMubmV0XG4gKiBAY29weXJpZ2h0ICAgQ29weXJpZ2h0IDIwMDgtMjAyMCBTcHJ5TWVkaWEgTHRkLlxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZnJlZSBzb2Z0d2FyZSwgYXZhaWxhYmxlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbiAqICAgTUlUIGxpY2Vuc2UgLSBodHRwOi8vZGF0YXRhYmxlcy5uZXQvbGljZW5zZVxuICpcbiAqIFRoaXMgc291cmNlIGZpbGUgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0XG4gKiBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mIE1FUkNIQU5UQUJJTElUWVxuICogb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuIFNlZSB0aGUgbGljZW5zZSBmaWxlcyBmb3IgZGV0YWlscy5cbiAqXG4gKiBGb3IgZGV0YWlscyBwbGVhc2UgcmVmZXIgdG86IGh0dHA6Ly93d3cuZGF0YXRhYmxlcy5uZXRcbiAqL1xuXG4vKmpzbGludCBldmlsOiB0cnVlLCB1bmRlZjogdHJ1ZSwgYnJvd3NlcjogdHJ1ZSAqL1xuLypnbG9iYWxzICQscmVxdWlyZSxqUXVlcnksZGVmaW5lLF9zZWxlY3Rvcl9ydW4sX3NlbGVjdG9yX29wdHMsX3NlbGVjdG9yX2ZpcnN0LF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyxfZXh0LF9BcGksX2FwaV9yZWdpc3RlcixfYXBpX3JlZ2lzdGVyUGx1cmFsLF9yZV9uZXdfbGluZXMsX3JlX2h0bWwsX3JlX2Zvcm1hdHRlZF9udW1lcmljLF9yZV9lc2NhcGVfcmVnZXgsX2VtcHR5LF9pbnRWYWwsX251bVRvRGVjaW1hbCxfaXNOdW1iZXIsX2lzSHRtbCxfaHRtbE51bWVyaWMsX3BsdWNrLF9wbHVja19vcmRlcixfcmFuZ2UsX3N0cmlwSHRtbCxfdW5pcXVlLF9mbkJ1aWxkQWpheCxfZm5BamF4VXBkYXRlLF9mbkFqYXhQYXJhbWV0ZXJzLF9mbkFqYXhVcGRhdGVEcmF3LF9mbkFqYXhEYXRhU3JjLF9mbkFkZENvbHVtbixfZm5Db2x1bW5PcHRpb25zLF9mbkFkanVzdENvbHVtblNpemluZyxfZm5WaXNpYmxlVG9Db2x1bW5JbmRleCxfZm5Db2x1bW5JbmRleFRvVmlzaWJsZSxfZm5WaXNibGVDb2x1bW5zLF9mbkdldENvbHVtbnMsX2ZuQ29sdW1uVHlwZXMsX2ZuQXBwbHlDb2x1bW5EZWZzLF9mbkh1bmdhcmlhbk1hcCxfZm5DYW1lbFRvSHVuZ2FyaWFuLF9mbkxhbmd1YWdlQ29tcGF0LF9mbkJyb3dzZXJEZXRlY3QsX2ZuQWRkRGF0YSxfZm5BZGRUcixfZm5Ob2RlVG9EYXRhSW5kZXgsX2ZuTm9kZVRvQ29sdW1uSW5kZXgsX2ZuR2V0Q2VsbERhdGEsX2ZuU2V0Q2VsbERhdGEsX2ZuU3BsaXRPYmpOb3RhdGlvbixfZm5HZXRPYmplY3REYXRhRm4sX2ZuU2V0T2JqZWN0RGF0YUZuLF9mbkdldERhdGFNYXN0ZXIsX2ZuQ2xlYXJUYWJsZSxfZm5EZWxldGVJbmRleCxfZm5JbnZhbGlkYXRlLF9mbkdldFJvd0VsZW1lbnRzLF9mbkNyZWF0ZVRyLF9mbkJ1aWxkSGVhZCxfZm5EcmF3SGVhZCxfZm5EcmF3LF9mblJlRHJhdyxfZm5BZGRPcHRpb25zSHRtbCxfZm5EZXRlY3RIZWFkZXIsX2ZuR2V0VW5pcXVlVGhzLF9mbkZlYXR1cmVIdG1sRmlsdGVyLF9mbkZpbHRlckNvbXBsZXRlLF9mbkZpbHRlckN1c3RvbSxfZm5GaWx0ZXJDb2x1bW4sX2ZuRmlsdGVyLF9mbkZpbHRlckNyZWF0ZVNlYXJjaCxfZm5Fc2NhcGVSZWdleCxfZm5GaWx0ZXJEYXRhLF9mbkZlYXR1cmVIdG1sSW5mbyxfZm5VcGRhdGVJbmZvLF9mbkluZm9NYWNyb3MsX2ZuSW5pdGlhbGlzZSxfZm5Jbml0Q29tcGxldGUsX2ZuTGVuZ3RoQ2hhbmdlLF9mbkZlYXR1cmVIdG1sTGVuZ3RoLF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUsX2ZuUGFnZUNoYW5nZSxfZm5GZWF0dXJlSHRtbFByb2Nlc3NpbmcsX2ZuUHJvY2Vzc2luZ0Rpc3BsYXksX2ZuRmVhdHVyZUh0bWxUYWJsZSxfZm5TY3JvbGxEcmF3LF9mbkFwcGx5VG9DaGlsZHJlbixfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMsX2ZuVGhyb3R0bGUsX2ZuQ29udmVydFRvV2lkdGgsX2ZuR2V0V2lkZXN0Tm9kZSxfZm5HZXRNYXhMZW5TdHJpbmcsX2ZuU3RyaW5nVG9Dc3MsX2ZuU29ydEZsYXR0ZW4sX2ZuU29ydCxfZm5Tb3J0QXJpYSxfZm5Tb3J0TGlzdGVuZXIsX2ZuU29ydEF0dGFjaExpc3RlbmVyLF9mblNvcnRpbmdDbGFzc2VzLF9mblNvcnREYXRhLF9mblNhdmVTdGF0ZSxfZm5Mb2FkU3RhdGUsX2ZuU2V0dGluZ3NGcm9tTm9kZSxfZm5Mb2csX2ZuTWFwLF9mbkJpbmRBY3Rpb24sX2ZuQ2FsbGJhY2tSZWcsX2ZuQ2FsbGJhY2tGaXJlLF9mbkxlbmd0aE92ZXJmbG93LF9mblJlbmRlcmVyLF9mbkRhdGFTb3VyY2UsX2ZuUm93QXR0cmlidXRlcyovXG5cbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTURcbiAgICAgICAgZGVmaW5lKFsnanF1ZXJ5J10sIGZ1bmN0aW9uICgkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFjdG9yeSgkLCB3aW5kb3csIGRvY3VtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBDb21tb25KU1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyb290LCAkKSB7XG4gICAgICAgICAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tb25KUyBlbnZpcm9ubWVudHMgd2l0aG91dCBhIHdpbmRvdyBnbG9iYWwgbXVzdCBwYXNzIGFcbiAgICAgICAgICAgICAgICAvLyByb290LiBUaGlzIHdpbGwgZ2l2ZSBhbiBlcnJvciBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICByb290ID0gd2luZG93O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISQpIHtcbiAgICAgICAgICAgICAgICAkID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyAvLyBqUXVlcnkncyBmYWN0b3J5IGNoZWNrcyBmb3IgYSBnbG9iYWwgd2luZG93XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJ2pxdWVyeScpIDpcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnanF1ZXJ5Jykocm9vdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5KCQsIHJvb3QsIHJvb3QuZG9jdW1lbnQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlclxuICAgICAgICBmYWN0b3J5KGpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XG4gICAgfVxufVxuICAgIChmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEYXRhVGFibGVzIGlzIGEgcGx1Zy1pbiBmb3IgdGhlIGpRdWVyeSBKYXZhc2NyaXB0IGxpYnJhcnkuIEl0IGlzIGEgaGlnaGx5XG4gICAgICAgICAqIGZsZXhpYmxlIHRvb2wsIGJhc2VkIHVwb24gdGhlIGZvdW5kYXRpb25zIG9mIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50LFxuICAgICAgICAgKiB3aGljaCB3aWxsIGFkZCBhZHZhbmNlZCBpbnRlcmFjdGlvbiBjb250cm9scyB0byBhbnkgSFRNTCB0YWJsZS4gRm9yIGFcbiAgICAgICAgICogZnVsbCBsaXN0IG9mIGZlYXR1cmVzIHBsZWFzZSByZWZlciB0b1xuICAgICAgICAgKiBbRGF0YVRhYmxlcy5uZXRdKGhyZWY9XCJodHRwOi8vZGF0YXRhYmxlcy5uZXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGVgIG9iamVjdCBpcyBub3QgYSBnbG9iYWwgdmFyaWFibGUgYnV0IGlzIGFsaWFzZWRcbiAgICAgICAgICogdG8gYGpRdWVyeS5mbi5EYXRhVGFibGVgIGFuZCBgalF1ZXJ5LmZuLmRhdGFUYWJsZWAgdGhyb3VnaCB3aGljaCBpdCBtYXlcbiAgICAgICAgICogYmUgIGFjY2Vzc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgQGNsYXNzXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW2luaXQ9e31dIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBEYXRhVGFibGVzLiBPcHRpb25zXG4gICAgICAgICAqICAgIGFyZSBkZWZpbmVkIGJ5IHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9XG4gICAgICAgICAqICBAcmVxdWlyZXMgalF1ZXJ5IDEuNytcbiAgICAgICAgICpcbiAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAqICAgIC8vIEJhc2ljIGluaXRpYWxpc2F0aW9uXG4gICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiB7XG4gICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICogICAgfSApO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICogICAgLy8gSW5pdGlhbGlzYXRpb24gd2l0aCBjb25maWd1cmF0aW9uIG9wdGlvbnMgLSBpbiB0aGlzIGNhc2UsIGRpc2FibGVcbiAgICAgICAgICogICAgLy8gcGFnaW5hdGlvbiBhbmQgc29ydGluZy5cbiAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uIHtcbiAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZSxcbiAgICAgICAgICogICAgICAgIFwic29ydFwiOiBmYWxzZVxuICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICogICAgfSApO1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIERhdGFUYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcmZvcm0gYSBqUXVlcnkgc2VsZWN0b3IgYWN0aW9uIG9uIHRoZSB0YWJsZSdzIFRSIGVsZW1lbnRzIChmcm9tIHRoZSB0Ym9keSkgYW5kXG4gICAgICAgICAgICAgKiByZXR1cm4gdGhlIHJlc3VsdGluZyBqUXVlcnkgb2JqZWN0LlxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfG5vZGV8alF1ZXJ5fSBzU2VsZWN0b3IgalF1ZXJ5IHNlbGVjdG9yIG9yIG5vZGUgY29sbGVjdGlvbiB0byBhY3Qgb25cbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW29PcHRzXSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciBtb2RpZnlpbmcgdGhlIHJvd3MgdG8gYmUgaW5jbHVkZWRcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLmZpbHRlcj1ub25lXSBTZWxlY3QgVFIgZWxlbWVudHMgdGhhdCBtZWV0IHRoZSBjdXJyZW50IGZpbHRlclxuICAgICAgICAgICAgICogICAgY3JpdGVyaW9uIChcImFwcGxpZWRcIikgb3IgYWxsIFRSIGVsZW1lbnRzIChpLmUuIG5vIGZpbHRlcikuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5vcmRlcj1jdXJyZW50XSBPcmRlciBvZiB0aGUgVFIgZWxlbWVudHMgaW4gdGhlIHByb2Nlc3NlZCBhcnJheS5cbiAgICAgICAgICAgICAqICAgIENhbiBiZSBlaXRoZXIgJ2N1cnJlbnQnLCB3aGVyZWJ5IHRoZSBjdXJyZW50IHNvcnRpbmcgb2YgdGhlIHRhYmxlIGlzIHVzZWQsIG9yXG4gICAgICAgICAgICAgKiAgICAnb3JpZ2luYWwnIHdoZXJlYnkgdGhlIG9yaWdpbmFsIG9yZGVyIHRoZSBkYXRhIHdhcyByZWFkIGludG8gdGhlIHRhYmxlIGlzIHVzZWQuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IFtvT3B0cy5wYWdlPWFsbF0gTGltaXQgdGhlIHNlbGVjdGlvbiB0byB0aGUgY3VycmVudGx5IGRpc3BsYXllZCBwYWdlXG4gICAgICAgICAgICAgKiAgICAoXCJjdXJyZW50XCIpIG9yIG5vdCAoXCJhbGxcIikuIElmICdjdXJyZW50JyBpcyBnaXZlbiwgdGhlbiBvcmRlciBpcyBhc3N1bWVkIHRvIGJlXG4gICAgICAgICAgICAgKiAgICAnY3VycmVudCcgYW5kIGZpbHRlciBpcyAnYXBwbGllZCcsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCB0aGV5IG1pZ2h0IGJlIGdpdmVuIGFzLlxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IGpRdWVyeSBvYmplY3QsIGZpbHRlcmVkIGJ5IHRoZSBnaXZlbiBzZWxlY3Rvci5cbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgIC8vIEhpZ2hsaWdodCBldmVyeSBzZWNvbmQgcm93XG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cjpvZGQnKS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBGaWx0ZXIgdG8gcm93cyB3aXRoICdXZWJraXQnIGluIHRoZW0sIGFkZCBhIGJhY2tncm91bmQgY29sb3VyIGFuZCB0aGVuXG4gICAgICAgICAgICAgKiAgICAgIC8vIHJlbW92ZSB0aGUgZmlsdGVyLCB0aHVzIGhpZ2hsaWdodGluZyB0aGUgJ1dlYmtpdCcgcm93cyBvbmx5LlxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5GaWx0ZXIoJ1dlYmtpdCcpO1xuICAgICAgICAgICAgICogICAgICBvVGFibGUuJCgndHInLCB7XCJzZWFyY2hcIjogXCJhcHBsaWVkXCJ9KS5jc3MoJ2JhY2tncm91bmRDb2xvcicsICdibHVlJyk7XG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignJyk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuJCA9IGZ1bmN0aW9uIChzU2VsZWN0b3IsIG9PcHRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpKHRydWUpLiQoc1NlbGVjdG9yLCBvT3B0cyk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWxtb3N0IGlkZW50aWNhbCB0byAkIGluIG9wZXJhdGlvbiwgYnV0IGluIHRoaXMgY2FzZSByZXR1cm5zIHRoZSBkYXRhIGZvciB0aGUgbWF0Y2hlZFxuICAgICAgICAgICAgICogcm93cyAtIGFzIHN1Y2gsIHRoZSBqUXVlcnkgc2VsZWN0b3IgdXNlZCBzaG91bGQgbWF0Y2ggVFIgcm93IG5vZGVzIG9yIFREL1RIIGNlbGwgbm9kZXNcbiAgICAgICAgICAgICAqIHJhdGhlciB0aGFuIGFueSBkZXNjZW5kYW50cywgc28gdGhlIGRhdGEgY2FuIGJlIG9idGFpbmVkIGZvciB0aGUgcm93L2NlbGwuIElmIG1hdGNoaW5nXG4gICAgICAgICAgICAgKiByb3dzIGFyZSBmb3VuZCwgdGhlIGRhdGEgcmV0dXJuZWQgaXMgdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkvb2JqZWN0IHRoYXQgd2FzIHVzZWQgdG9cbiAgICAgICAgICAgICAqIGNyZWF0ZSB0aGUgcm93IChvciBhIGdlbmVyYXRlZCBhcnJheSBpZiBmcm9tIGEgRE9NIHNvdXJjZSkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBtZXRob2QgaXMgb2Z0ZW4gdXNlZnVsIGluLWNvbWJpbmF0aW9uIHdpdGggJCB3aGVyZSBib3RoIGZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlXG4gICAgICAgICAgICAgKiBzYW1lIHBhcmFtZXRlcnMgYW5kIHRoZSBhcnJheSBpbmRleGVzIHdpbGwgbWF0Y2ggaWRlbnRpY2FsbHkuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd8bm9kZXxqUXVlcnl9IHNTZWxlY3RvciBqUXVlcnkgc2VsZWN0b3Igb3Igbm9kZSBjb2xsZWN0aW9uIHRvIGFjdCBvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBbb09wdHNdIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIG1vZGlmeWluZyB0aGUgcm93cyB0byBiZSBpbmNsdWRlZFxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMuZmlsdGVyPW5vbmVdIFNlbGVjdCBlbGVtZW50cyB0aGF0IG1lZXQgdGhlIGN1cnJlbnQgZmlsdGVyXG4gICAgICAgICAgICAgKiAgICBjcml0ZXJpb24gKFwiYXBwbGllZFwiKSBvciBhbGwgZWxlbWVudHMgKGkuZS4gbm8gZmlsdGVyKS5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW29PcHRzLm9yZGVyPWN1cnJlbnRdIE9yZGVyIG9mIHRoZSBkYXRhIGluIHRoZSBwcm9jZXNzZWQgYXJyYXkuXG4gICAgICAgICAgICAgKiAgICBDYW4gYmUgZWl0aGVyICdjdXJyZW50Jywgd2hlcmVieSB0aGUgY3VycmVudCBzb3J0aW5nIG9mIHRoZSB0YWJsZSBpcyB1c2VkLCBvclxuICAgICAgICAgICAgICogICAgJ29yaWdpbmFsJyB3aGVyZWJ5IHRoZSBvcmlnaW5hbCBvcmRlciB0aGUgZGF0YSB3YXMgcmVhZCBpbnRvIHRoZSB0YWJsZSBpcyB1c2VkLlxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbb09wdHMucGFnZT1hbGxdIExpbWl0IHRoZSBzZWxlY3Rpb24gdG8gdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgcGFnZVxuICAgICAgICAgICAgICogICAgKFwiY3VycmVudFwiKSBvciBub3QgKFwiYWxsXCIpLiBJZiAnY3VycmVudCcgaXMgZ2l2ZW4sIHRoZW4gb3JkZXIgaXMgYXNzdW1lZCB0byBiZVxuICAgICAgICAgICAgICogICAgJ2N1cnJlbnQnIGFuZCBmaWx0ZXIgaXMgJ2FwcGxpZWQnLCByZWdhcmRsZXNzIG9mIHdoYXQgdGhleSBtaWdodCBiZSBnaXZlbiBhcy5cbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IERhdGEgZm9yIHRoZSBtYXRjaGVkIGVsZW1lbnRzLiBJZiBhbnkgZWxlbWVudHMsIGFzIGEgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgICAgICogICAgc2VsZWN0b3IsIHdlcmUgbm90IFRSLCBURCBvciBUSCBlbGVtZW50cyBpbiB0aGUgRGF0YVRhYmxlLCB0aGV5IHdpbGwgaGF2ZSBhIG51bGxcbiAgICAgICAgICAgICAqICAgIGVudHJ5IGluIHRoZSBhcnJheS5cbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgIC8vIEdldCB0aGUgZGF0YSBmcm9tIHRoZSBmaXJzdCByb3cgaW4gdGhlIHRhYmxlXG4gICAgICAgICAgICAgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyOmZpcnN0Jyk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBEbyBzb21ldGhpbmcgdXNlZnVsIHdpdGggdGhlIGRhdGFcbiAgICAgICAgICAgICAqICAgICAgYWxlcnQoIFwiRmlyc3QgY2VsbCBpczogXCIrZGF0YVswXSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgLy8gRmlsdGVyIHRvICdXZWJraXQnIGFuZCBnZXQgYWxsIGRhdGEgZm9yXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkZpbHRlcignV2Via2l0Jyk7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBkYXRhID0gb1RhYmxlLl8oJ3RyJywge1wic2VhcmNoXCI6IFwiYXBwbGllZFwifSk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBEbyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YVxuICAgICAgICAgICAgICogICAgICBhbGVydCggZGF0YS5sZW5ndGgrXCIgcm93cyBtYXRjaGVkIHRoZSBzZWFyY2hcIiApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLl8gPSBmdW5jdGlvbiAoc1NlbGVjdG9yLCBvT3B0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFwaSh0cnVlKS5yb3dzKHNTZWxlY3Rvciwgb09wdHMpLmRhdGEoKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBEYXRhVGFibGVzIEFwaSBpbnN0YW5jZSwgd2l0aCB0aGUgY3VycmVudGx5IHNlbGVjdGVkIHRhYmxlcyBmb3JcbiAgICAgICAgICAgICAqIHRoZSBBcGkncyBjb250ZXh0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbdHJhZGl0aW9uYWw9ZmFsc2VdIFNldCB0aGUgQVBJIGluc3RhbmNlJ3MgY29udGV4dCB0byBiZVxuICAgICAgICAgICAgICogICBvbmx5IHRoZSB0YWJsZSByZWZlcnJlZCB0byBieSB0aGUgYERhdGFUYWJsZS5leHQuaUFwaUluZGV4YCBvcHRpb24sIGFzIHdhc1xuICAgICAgICAgICAgICogICB1c2VkIGluIHRoZSBBUEkgcHJlc2VudGVkIGJ5IERhdGFUYWJsZXMgMS45LSAoaS5lLiB0aGUgdHJhZGl0aW9uYWwgbW9kZSksXG4gICAgICAgICAgICAgKiAgIG9yIGlmIGFsbCB0YWJsZXMgY2FwdHVyZWQgaW4gdGhlIGpRdWVyeSBvYmplY3Qgc2hvdWxkIGJlIHVzZWQuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtEYXRhVGFibGVzLkFwaX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5hcGkgPSBmdW5jdGlvbiAodHJhZGl0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhZGl0aW9uYWwgP1xuICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaShcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mblNldHRpbmdzRnJvbU5vZGUodGhpc1tfZXh0LmlBcGlJbmRleF0pXG4gICAgICAgICAgICAgICAgICAgICkgOlxuICAgICAgICAgICAgICAgICAgICBuZXcgX0FwaSh0aGlzKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYSBzaW5nbGUgbmV3IHJvdyBvciBtdWx0aXBsZSByb3dzIG9mIGRhdGEgdG8gdGhlIHRhYmxlLiBQbGVhc2Ugbm90ZVxuICAgICAgICAgICAgICogdGhhdCB0aGlzIGlzIHN1aXRhYmxlIGZvciBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIG9ubHkgLSBpZiB5b3UgYXJlIHVzaW5nXG4gICAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIChpLmUuIFwiYlNlcnZlclNpZGVcIjogdHJ1ZSksIHRoZW4gdG8gYWRkIGRhdGEsIHlvdVxuICAgICAgICAgICAgICogbXVzdCBhZGQgaXQgdG8gdGhlIGRhdGEgc291cmNlLCBpLmUuIHRoZSBzZXJ2ZXItc2lkZSwgdGhyb3VnaCBhbiBBamF4IGNhbGwuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IGRhdGEgVGhlIGRhdGEgdG8gYmUgYWRkZWQgdG8gdGhlIHRhYmxlLiBUaGlzIGNhbiBiZTpcbiAgICAgICAgICAgICAqICAgIDx1bD5cbiAgICAgICAgICAgICAqICAgICAgPGxpPjFEIGFycmF5IG9mIGRhdGEgLSBhZGQgYSBzaW5nbGUgcm93IHdpdGggdGhlIGRhdGEgcHJvdmlkZWQ8L2xpPlxuICAgICAgICAgICAgICogICAgICA8bGk+MkQgYXJyYXkgb2YgYXJyYXlzIC0gYWRkIG11bHRpcGxlIHJvd3MgaW4gYSBzaW5nbGUgY2FsbDwvbGk+XG4gICAgICAgICAgICAgKiAgICAgIDxsaT5vYmplY3QgLSBkYXRhIG9iamVjdCB3aGVuIHVzaW5nIDxpPm1EYXRhPC9pPjwvbGk+XG4gICAgICAgICAgICAgKiAgICAgIDxsaT5hcnJheSBvZiBvYmplY3RzIC0gbXVsdGlwbGUgZGF0YSBvYmplY3RzIHdoZW4gdXNpbmcgPGk+bURhdGE8L2k+PC9saT5cbiAgICAgICAgICAgICAqICAgIDwvdWw+XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbcmVkcmF3PXRydWVdIHJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBpbnRlZ2VycywgcmVwcmVzZW50aW5nIHRoZSBsaXN0IG9mIGluZGV4ZXMgaW5cbiAgICAgICAgICAgICAqICAgIDxpPmFvRGF0YTwvaT4gKHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc30pIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvXG4gICAgICAgICAgICAgKiAgICB0aGUgdGFibGUuXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBHbG9iYWwgdmFyIGZvciBjb3VudGVyXG4gICAgICAgICAgICAgKiAgICB2YXIgZ2lDb3VudCA9IDI7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgZnVuY3Rpb24gZm5DbGlja0FkZFJvdygpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5mbkFkZERhdGEoIFtcbiAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjFcIixcbiAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjJcIixcbiAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjNcIixcbiAgICAgICAgICAgICAqICAgICAgICBnaUNvdW50K1wiLjRcIiBdXG4gICAgICAgICAgICAgKiAgICAgICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICBnaUNvdW50Kys7XG4gICAgICAgICAgICAgKiAgICB9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm5BZGREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHJlZHJhdykge1xuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8qIENoZWNrIGlmIHdlIHdhbnQgdG8gYWRkIG11bHRpcGxlIHJvd3Mgb3Igbm90ICovXG4gICAgICAgICAgICAgICAgdmFyIHJvd3MgPSBBcnJheS5pc0FycmF5KGRhdGEpICYmIChBcnJheS5pc0FycmF5KGRhdGFbMF0pIHx8ICQuaXNQbGFpbk9iamVjdChkYXRhWzBdKSkgP1xuICAgICAgICAgICAgICAgICAgICBhcGkucm93cy5hZGQoZGF0YSkgOlxuICAgICAgICAgICAgICAgICAgICBhcGkucm93LmFkZChkYXRhKTtcblxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcm93cy5mbGF0dGVuKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBtYWtlIERhdGFUYWJsZXMgcmVjYWxjdWxhdGUgdGhlIGNvbHVtbiBzaXplcywgYmFzZWQgb24gdGhlIGRhdGFcbiAgICAgICAgICAgICAqIGNvbnRhaW5lZCBpbiB0aGUgdGFibGUgYW5kIHRoZSBzaXplcyBhcHBsaWVkIHRvIHRoZSBjb2x1bW5zIChpbiB0aGUgRE9NLCBDU1Mgb3JcbiAgICAgICAgICAgICAqIHRocm91Z2ggdGhlIHNXaWR0aCBwYXJhbWV0ZXIpLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB0aGUgd2lkdGggb2YgdGhlIHRhYmxlJ3NcbiAgICAgICAgICAgICAqIHBhcmVudCBlbGVtZW50IGNoYW5nZXMgKGZvciBleGFtcGxlIGEgd2luZG93IHJlc2l6ZSkuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbYlJlZHJhdz10cnVlXSBSZWRyYXcgdGhlIHRhYmxlIG9yIG5vdCwgeW91IHdpbGwgdHlwaWNhbGx5IHdhbnQgdG9cbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInNTY3JvbGxZXCI6IFwiMjAwcHhcIixcbiAgICAgICAgICAgICAqICAgICAgICBcImJQYWdpbmF0ZVwiOiBmYWxzZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgICBvVGFibGUuZm5BZGp1c3RDb2x1bW5TaXppbmcoKTtcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZuQWRqdXN0Q29sdW1uU2l6aW5nID0gZnVuY3Rpb24gKGJSZWRyYXcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSkuY29sdW1ucy5hZGp1c3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBhcGkuc2V0dGluZ3MoKVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblxuICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbC5zWCAhPT0gXCJcIiB8fCBzY3JvbGwuc1kgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgbm90IHJlZHJhd2luZywgYnV0IHNjcm9sbGluZywgd2Ugd2FudCB0byBhcHBseSB0aGUgbmV3IGNvbHVtbiBzaXplcyBhbnl3YXkgKi9cbiAgICAgICAgICAgICAgICAgICAgX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFF1aWNrbHkgYW5kIHNpbXBseSBjbGVhciBhIHRhYmxlXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZHJhdz10cnVlXSByZWRyYXcgdGhlIHRhYmxlIG9yIG5vdFxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgLy8gSW1tZWRpYXRlbHkgJ251a2UnIHRoZSBjdXJyZW50IHJvd3MgKHBlcmhhcHMgd2FpdGluZyBmb3IgYW4gQWpheCBjYWxsYmFjay4uLilcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuQ2xlYXJUYWJsZSgpO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZuQ2xlYXJUYWJsZSA9IGZ1bmN0aW9uIChiUmVkcmF3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpLmNsZWFyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGV4YWN0IG9wcG9zaXRlIG9mICdvcGVuaW5nJyBhIHJvdywgdGhpcyBmdW5jdGlvbiB3aWxsIGNsb3NlIGFueSByb3dzIHdoaWNoXG4gICAgICAgICAgICAgKiBhcmUgY3VycmVudGx5ICdvcGVuJy5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IG5UciB0aGUgdGFibGUgcm93IHRvICdjbG9zZSdcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7aW50fSAwIG9uIHN1Y2Nlc3MsIG9yIDEgaWYgZmFpbGVkIChjYW4ndCBmaW5kIHRoZSByb3cpXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgIC8vICdvcGVuJyBhbiBpbmZvcm1hdGlvbiByb3cgd2hlbiBhIHJvdyBpcyBjbGlja2VkIG9uXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRyJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgICBpZiAoIG9UYWJsZS5mbklzT3Blbih0aGlzKSApIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbkNsb3NlKCB0aGlzICk7XG4gICAgICAgICAgICAgKiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIG9UYWJsZS5mbk9wZW4oIHRoaXMsIFwiVGVtcG9yYXJ5IHJvdyBvcGVuZWRcIiwgXCJpbmZvX3Jvd1wiICk7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZuQ2xvc2UgPSBmdW5jdGlvbiAoblRyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkucm93KG5UcikuY2hpbGQuaGlkZSgpO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBhIHJvdyBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHttaXhlZH0gdGFyZ2V0IFRoZSBpbmRleCBvZiB0aGUgcm93IGZyb20gYW9EYXRhIHRvIGJlIGRlbGV0ZWQsIG9yXG4gICAgICAgICAgICAgKiAgICB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudCB0byBkZWxldGVcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufG51bGx9IFtjYWxsQmFja10gQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtyZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3RcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IFRoZSByb3cgdGhhdCB3YXMgZGVsZXRlZFxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgLy8gSW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBmaXJzdCByb3dcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRGVsZXRlUm93KCAwICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm5EZWxldGVSb3cgPSBmdW5jdGlvbiAodGFyZ2V0LCBjYWxsYmFjaywgcmVkcmF3KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciByb3dzID0gYXBpLnJvd3ModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSByb3dzLnNldHRpbmdzKClbMF07XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbcm93c1swXVswXV07XG5cbiAgICAgICAgICAgICAgICByb3dzLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgc2V0dGluZ3MsIGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWRyYXcgPT09IHVuZGVmaW5lZCB8fCByZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXN0b3JlIHRoZSB0YWJsZSB0byBpdCdzIG9yaWdpbmFsIHN0YXRlIGluIHRoZSBET00gYnkgcmVtb3ZpbmcgYWxsIG9mIERhdGFUYWJsZXNcbiAgICAgICAgICAgICAqIGVuaGFuY2VtZW50cywgYWx0ZXJhdGlvbnMgdG8gdGhlIERPTSBzdHJ1Y3R1cmUgb2YgdGhlIHRhYmxlIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlPWZhbHNlXSBDb21wbGV0ZWx5IHJlbW92ZSB0aGUgdGFibGUgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgLy8gVGhpcyBleGFtcGxlIGlzIGZhaXJseSBwb2ludGxlc3MgaW4gcmVhbGl0eSwgYnV0IHNob3dzIGhvdyBmbkRlc3Ryb3kgY2FuIGJlIHVzZWRcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mbkRlc3Ryb3koKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mbkRlc3Ryb3kgPSBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkuZGVzdHJveShyZW1vdmUpO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlZHJhdyB0aGUgdGFibGVcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtjb21wbGV0ZT10cnVlXSBSZS1maWx0ZXIgYW5kIHJlc29ydCAoaWYgZW5hYmxlZCkgdGhlIHRhYmxlIGJlZm9yZSB0aGUgZHJhdy5cbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgIC8vIFJlLWRyYXcgdGhlIHRhYmxlIC0geW91IHdvdWxkbid0IHdhbnQgdG8gZG8gaXQgaGVyZSwgYnV0IGl0J3MgYW4gZXhhbXBsZSA6LSlcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRHJhdygpO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZuRHJhdyA9IGZ1bmN0aW9uIChjb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzbid0IGFuIGV4YWN0IG1hdGNoIHRvIHRoZSBvbGQgY2FsbCB0byBfZm5EcmF3IC0gaXQgdGFrZXNcbiAgICAgICAgICAgICAgICAvLyBpbnRvIGFjY291bnQgdGhlIG5ldyBkYXRhLCBidXQgY2FuIGhvbGQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkuZHJhdyhjb21wbGV0ZSk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmlsdGVyIHRoZSBpbnB1dCBiYXNlZCBvbiBkYXRhXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNJbnB1dCBTdHJpbmcgdG8gZmlsdGVyIHRoZSB0YWJsZSBvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fG51bGx9IFtpQ29sdW1uXSBDb2x1bW4gdG8gbGltaXQgZmlsdGVyaW5nIHRvXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlJlZ2V4PWZhbHNlXSBUcmVhdCBhcyByZWd1bGFyIGV4cHJlc3Npb24gb3Igbm90XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYlNtYXJ0PXRydWVdIFBlcmZvcm0gc21hcnQgZmlsdGVyaW5nIG9yIG5vdFxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JTaG93R2xvYmFsPXRydWVdIFNob3cgdGhlIGlucHV0IGdsb2JhbCBmaWx0ZXIgaW4gaXQncyBpbnB1dCBib3goZXMpXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYkNhc2VJbnNlbnNpdGl2ZT10cnVlXSBEbyBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nICh0cnVlKSBvciBub3QgKGZhbHNlKVxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgLy8gU29tZXRpbWUgbGF0ZXIgLSBmaWx0ZXIuLi5cbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuRmlsdGVyKCAndGVzdCBzdHJpbmcnICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm5GaWx0ZXIgPSBmdW5jdGlvbiAoc0lucHV0LCBpQ29sdW1uLCBiUmVnZXgsIGJTbWFydCwgYlNob3dHbG9iYWwsIGJDYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaUNvbHVtbiA9PT0gbnVsbCB8fCBpQ29sdW1uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnNlYXJjaChzSW5wdXQsIGJSZWdleCwgYlNtYXJ0LCBiQ2FzZUluc2Vuc2l0aXZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5jb2x1bW4oaUNvbHVtbikuc2VhcmNoKHNJbnB1dCwgYlJlZ2V4LCBiU21hcnQsIGJDYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFwaS5kcmF3KCk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBkYXRhIGZvciB0aGUgd2hvbGUgdGFibGUsIGFuIGluZGl2aWR1YWwgcm93IG9yIGFuIGluZGl2aWR1YWwgY2VsbCBiYXNlZCBvbiB0aGVcbiAgICAgICAgICAgICAqIHByb3ZpZGVkIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR8bm9kZX0gW3NyY10gQSBUUiByb3cgbm9kZSwgVEQvVEggY2VsbCBub2RlIG9yIGFuIGludGVnZXIuIElmIGdpdmVuIGFzXG4gICAgICAgICAgICAgKiAgICBhIFRSIG5vZGUgdGhlbiB0aGUgZGF0YSBzb3VyY2UgZm9yIHRoZSB3aG9sZSByb3cgd2lsbCBiZSByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYVxuICAgICAgICAgICAgICogICAgVEQvVEggY2VsbCBub2RlIHRoZW4gaUNvbCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY2FsY3VsYXRlZCBhbmQgdGhlIGRhdGEgZm9yIHRoZVxuICAgICAgICAgICAgICogICAgY2VsbCByZXR1cm5lZC4gSWYgZ2l2ZW4gYXMgYW4gaW50ZWdlciwgdGhlbiB0aGlzIGlzIHRyZWF0ZWQgYXMgdGhlIGFvRGF0YSBpbnRlcm5hbFxuICAgICAgICAgICAgICogICAgZGF0YSBpbmRleCBmb3IgdGhlIHJvdyAoc2VlIGZuR2V0UG9zaXRpb24pIGFuZCB0aGUgZGF0YSBmb3IgdGhhdCByb3cgdXNlZC5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gW2NvbF0gT3B0aW9uYWwgY29sdW1uIGluZGV4IHRoYXQgeW91IHdhbnQgdGhlIGRhdGEgb2YuXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fG9iamVjdHxzdHJpbmd9IElmIG1Sb3cgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSBkYXRhIGZvciBhbGwgcm93cyBpc1xuICAgICAgICAgICAgICogICAgcmV0dXJuZWQuIElmIG1Sb3cgaXMgZGVmaW5lZCwganVzdCBkYXRhIGZvciB0aGF0IHJvdywgYW5kIGlzIGlDb2wgaXNcbiAgICAgICAgICAgICAqICAgIGRlZmluZWQsIG9ubHkgZGF0YSBmb3IgdGhlIGRlc2lnbmF0ZWQgY2VsbCBpcyByZXR1cm5lZC5cbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFJvdyBkYXRhXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgdmFyIGRhdGEgPSBvVGFibGUuZm5HZXREYXRhKCB0aGlzICk7XG4gICAgICAgICAgICAgKiAgICAgICAgLy8gLi4uIGRvIHNvbWV0aGluZyB3aXRoIHRoZSBhcnJheSAvIG9iamVjdCBvZiBkYXRhIGZvciB0aGUgcm93XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIEluZGl2aWR1YWwgY2VsbCBkYXRhXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS4kKCd0ZCcpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgdmFyIHNEYXRhID0gb1RhYmxlLmZuR2V0RGF0YSggdGhpcyApO1xuICAgICAgICAgICAgICogICAgICAgIGFsZXJ0KCAnVGhlIGNlbGwgY2xpY2tlZCBvbiBoYWQgdGhlIHZhbHVlIG9mICcrc0RhdGEgKTtcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmZuR2V0RGF0YSA9IGZ1bmN0aW9uIChzcmMsIGNvbCkge1xuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChzcmMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHNyYy5ub2RlTmFtZSA/IHNyYy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIDogJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbCAhPT0gdW5kZWZpbmVkIHx8IHR5cGUgPT0gJ3RkJyB8fCB0eXBlID09ICd0aCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmNlbGwoc3JjLCBjb2wpLmRhdGEoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhcGkucm93KHNyYykuZGF0YSgpIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwaS5kYXRhKCkudG9BcnJheSgpO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbiBhcnJheSBvZiB0aGUgVFIgbm9kZXMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUncyBib2R5LiBOb3RlIHRoYXQgeW91IHdpbGxcbiAgICAgICAgICAgICAqIHR5cGljYWxseSB3YW50IHRvIHVzZSB0aGUgJyQnIEFQSSBtZXRob2QgaW4gcHJlZmVyZW5jZSB0byB0aGlzIGFzIGl0IGlzIG1vcmVcbiAgICAgICAgICAgICAqIGZsZXhpYmxlLlxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBbaVJvd10gT3B0aW9uYWwgcm93IGluZGV4IGZvciB0aGUgVFIgZWxlbWVudCB5b3Ugd2FudFxuICAgICAgICAgICAgICogIEByZXR1cm5zIHthcnJheXxub2RlfSBJZiBpUm93IGlzIHVuZGVmaW5lZCwgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgVFIgZWxlbWVudHNcbiAgICAgICAgICAgICAqICAgIGluIHRoZSB0YWJsZSdzIGJvZHksIG9yIGlSb3cgaXMgZGVmaW5lZCwganVzdCB0aGUgVFIgZWxlbWVudCByZXF1ZXN0ZWQuXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBHZXQgdGhlIG5vZGVzIGZyb20gdGhlIHRhYmxlXG4gICAgICAgICAgICAgKiAgICAgIHZhciBuTm9kZXMgPSBvVGFibGUuZm5HZXROb2RlcyggKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mbkdldE5vZGVzID0gZnVuY3Rpb24gKGlSb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaVJvdyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgYXBpLnJvdyhpUm93KS5ub2RlKCkgOlxuICAgICAgICAgICAgICAgICAgICBhcGkucm93cygpLm5vZGVzKCkuZmxhdHRlbigpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGFycmF5IGluZGV4ZXMgb2YgYSBwYXJ0aWN1bGFyIGNlbGwgZnJvbSBpdCdzIERPTSBlbGVtZW50XG4gICAgICAgICAgICAgKiBhbmQgY29sdW1uIGluZGV4IGluY2x1ZGluZyBoaWRkZW4gY29sdW1uc1xuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbm9kZSB0aGlzIGNhbiBlaXRoZXIgYmUgYSBUUiwgVEQgb3IgVEggaW4gdGhlIHRhYmxlJ3MgYm9keVxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IElmIG5Ob2RlIGlzIGdpdmVuIGFzIGEgVFIsIHRoZW4gYSBzaW5nbGUgaW5kZXggaXMgcmV0dXJuZWQsIG9yXG4gICAgICAgICAgICAgKiAgICBpZiBnaXZlbiBhcyBhIGNlbGwsIGFuIGFycmF5IG9mIFtyb3cgaW5kZXgsIGNvbHVtbiBpbmRleCAodmlzaWJsZSksXG4gICAgICAgICAgICAgKiAgICBjb2x1bW4gaW5kZXggKGFsbCldIGlzIGdpdmVuLlxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlIHRib2R5IHRkJykuY2xpY2soIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgICAvLyBHZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGRhdGEgZnJvbSB0aGUgbm9kZVxuICAgICAgICAgICAgICogICAgICAgIHZhciBhUG9zID0gb1RhYmxlLmZuR2V0UG9zaXRpb24oIHRoaXMgKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgLy8gR2V0IHRoZSBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuICAgICAgICAgICAgICogICAgICAgIHZhciBhRGF0YSA9IG9UYWJsZS5mbkdldERhdGEoIGFQb3NbMF0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICAgICAgLy8gVXBkYXRlIHRoZSBkYXRhIGFycmF5IGFuZCByZXR1cm4gdGhlIHZhbHVlXG4gICAgICAgICAgICAgKiAgICAgICAgYURhdGFbIGFQb3NbMV0gXSA9ICdjbGlja2VkJztcbiAgICAgICAgICAgICAqICAgICAgICB0aGlzLmlubmVySFRNTCA9ICdjbGlja2VkJztcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgLy8gSW5pdCBEYXRhVGFibGVzXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm5HZXRQb3NpdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFwaSA9IHRoaXMuYXBpKHRydWUpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSAnVFInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcGkucm93KG5vZGUpLmluZGV4KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOYW1lID09ICdURCcgfHwgbm9kZU5hbWUgPT0gJ1RIJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2VsbCA9IGFwaS5jZWxsKG5vZGUpLmluZGV4KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwucm93LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb2x1bW5WaXNpYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5jb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgdG8gc2VlIGlmIGEgcm93IGlzICdvcGVuJyBvciBub3QuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVHIgdGhlIHRhYmxlIHJvdyB0byBjaGVja1xuICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZSByb3cgaXMgY3VycmVudGx5IG9wZW4sIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mbklzT3BlbiA9IGZ1bmN0aW9uIChuVHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hcGkodHJ1ZSkucm93KG5UcikuY2hpbGQuaXNTaG93bigpO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBwbGFjZSBhIG5ldyByb3cgZGlyZWN0bHkgYWZ0ZXIgYSByb3cgd2hpY2ggaXMgY3VycmVudGx5XG4gICAgICAgICAgICAgKiBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLCB3aXRoIHRoZSBIVE1MIGNvbnRlbnRzIHRoYXQgaXMgcGFzc2VkIGludG8gdGhlXG4gICAgICAgICAgICAgKiBmdW5jdGlvbi4gVGhpcyBjYW4gYmUgdXNlZCwgZm9yIGV4YW1wbGUsIHRvIGFzayBmb3IgY29uZmlybWF0aW9uIHRoYXQgYVxuICAgICAgICAgICAgICogcGFydGljdWxhciByZWNvcmQgc2hvdWxkIGJlIGRlbGV0ZWQuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVHIgVGhlIHRhYmxlIHJvdyB0byAnb3BlbidcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xub2RlfGpRdWVyeX0gbUh0bWwgVGhlIEhUTUwgdG8gcHV0IGludG8gdGhlIHJvd1xuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzQ2xhc3MgQ2xhc3MgdG8gZ2l2ZSB0aGUgbmV3IFREIGNlbGxcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gVGhlIHJvdyBvcGVuZWQuIE5vdGUgdGhhdCBpZiB0aGUgdGFibGUgcm93IHBhc3NlZCBpbiBhcyB0aGVcbiAgICAgICAgICAgICAqICAgIGZpcnN0IHBhcmFtZXRlciwgaXMgbm90IGZvdW5kIGluIHRoZSB0YWJsZSwgdGhpcyBtZXRob2Qgd2lsbCBzaWxlbnRseVxuICAgICAgICAgICAgICogICAgcmV0dXJuLlxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGU7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyAnb3BlbicgYW4gaW5mb3JtYXRpb24gcm93IHdoZW4gYSByb3cgaXMgY2xpY2tlZCBvblxuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZSB0Ym9keSB0cicpLmNsaWNrKCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgaWYgKCBvVGFibGUuZm5Jc09wZW4odGhpcykgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5DbG9zZSggdGhpcyApO1xuICAgICAgICAgICAgICogICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBvVGFibGUuZm5PcGVuKCB0aGlzLCBcIlRlbXBvcmFyeSByb3cgb3BlbmVkXCIsIFwiaW5mb19yb3dcIiApO1xuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mbk9wZW4gPSBmdW5jdGlvbiAoblRyLCBtSHRtbCwgc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXBpKHRydWUpXG4gICAgICAgICAgICAgICAgICAgIC5yb3coblRyKVxuICAgICAgICAgICAgICAgICAgICAuY2hpbGQobUh0bWwsIHNDbGFzcylcbiAgICAgICAgICAgICAgICAgICAgLnNob3coKVxuICAgICAgICAgICAgICAgICAgICAuY2hpbGQoKVswXTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGFuZ2UgdGhlIHBhZ2luYXRpb24gLSBwcm92aWRlcyB0aGUgaW50ZXJuYWwgbG9naWMgZm9yIHBhZ2luYXRpb24gaW4gYSBzaW1wbGUgQVBJXG4gICAgICAgICAgICAgKiBmdW5jdGlvbi4gV2l0aCB0aGlzIGZ1bmN0aW9uIHlvdSBjYW4gaGF2ZSBhIERhdGFUYWJsZXMgdGFibGUgZ28gdG8gdGhlIG5leHQsXG4gICAgICAgICAgICAgKiBwcmV2aW91cywgZmlyc3Qgb3IgbGFzdCBwYWdlcy5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ3xpbnR9IG1BY3Rpb24gUGFnaW5nIGFjdGlvbiB0byB0YWtlOiBcImZpcnN0XCIsIFwicHJldmlvdXNcIiwgXCJuZXh0XCIgb3IgXCJsYXN0XCJcbiAgICAgICAgICAgICAqICAgIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpLCBub3RlIHRoYXQgcGFnZSAwIGlzIHRoZSBmaXJzdCBwYWdlLlxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gW2JSZWRyYXc9dHJ1ZV0gUmVkcmF3IHRoZSB0YWJsZSBvciBub3RcbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuUGFnZUNoYW5nZSggJ25leHQnICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm5QYWdlQ2hhbmdlID0gZnVuY3Rpb24gKG1BY3Rpb24sIGJSZWRyYXcpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSkucGFnZShtQWN0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChiUmVkcmF3ID09PSB1bmRlZmluZWQgfHwgYlJlZHJhdykge1xuICAgICAgICAgICAgICAgICAgICBhcGkuZHJhdyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNob3cgYSBwYXJ0aWN1bGFyIGNvbHVtblxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpQ29sIFRoZSBjb2x1bW4gd2hvc2UgZGlzcGxheSBzaG91bGQgYmUgY2hhbmdlZFxuICAgICAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYlNob3cgU2hvdyAodHJ1ZSkgb3IgaGlkZSAoZmFsc2UpIHRoZSBjb2x1bW5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBIaWRlIHRoZSBzZWNvbmQgY29sdW1uIGFmdGVyIGluaXRpYWxpc2F0aW9uXG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblNldENvbHVtblZpcyggMSwgZmFsc2UgKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mblNldENvbHVtblZpcyA9IGZ1bmN0aW9uIChpQ29sLCBiU2hvdywgYlJlZHJhdykge1xuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzLmFwaSh0cnVlKS5jb2x1bW4oaUNvbCkudmlzaWJsZShiU2hvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmNvbHVtbnMuYWRqdXN0KCkuZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHNldHRpbmdzIGZvciBhIHBhcnRpY3VsYXIgdGFibGUgZm9yIGV4dGVybmFsIG1hbmlwdWxhdGlvblxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtvYmplY3R9IERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBTZWVcbiAgICAgICAgICAgICAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICAgICAqICBAZHRvcHQgQVBJXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICB2YXIgb1RhYmxlID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKTtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9TZXR0aW5ncyA9IG9UYWJsZS5mblNldHRpbmdzKCk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBTaG93IGFuIGV4YW1wbGUgcGFyYW1ldGVyIGZyb20gdGhlIHNldHRpbmdzXG4gICAgICAgICAgICAgKiAgICAgIGFsZXJ0KCBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mblNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZm5TZXR0aW5nc0Zyb21Ob2RlKHRoaXNbX2V4dC5pQXBpSW5kZXhdKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb3J0IHRoZSB0YWJsZSBieSBhIHBhcnRpY3VsYXIgY29sdW1uXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2wgdGhlIGRhdGEgaW5kZXggdG8gc29ydCBvbi4gTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgbWF0Y2ggdGhlXG4gICAgICAgICAgICAgKiAgICAnZGlzcGxheSBpbmRleCcgaWYgeW91IGhhdmUgaGlkZGVuIGRhdGEgZW50cmllc1xuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgLy8gU29ydCBpbW1lZGlhdGVseSB3aXRoIGNvbHVtbnMgMCBhbmQgMVxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5Tb3J0KCBbIFswLCdhc2MnXSwgWzEsJ2FzYyddIF0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mblNvcnQgPSBmdW5jdGlvbiAoYWFTb3J0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGkodHJ1ZSkub3JkZXIoYWFTb3J0KS5kcmF3KCk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbk5vZGUgdGhlIGVsZW1lbnQgdG8gYXR0YWNoIHRoZSBzb3J0IGxpc3RlbmVyIHRvXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gdGhlIGNvbHVtbiB0aGF0IGEgY2xpY2sgb24gdGhpcyBub2RlIHdpbGwgc29ydCBvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IFtmbkNhbGxiYWNrXSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHNvcnQgaXMgcnVuXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBTb3J0IG9uIGNvbHVtbiAxLCB3aGVuICdzb3J0ZXInIGlzIGNsaWNrZWQgb25cbiAgICAgICAgICAgICAqICAgICAgb1RhYmxlLmZuU29ydExpc3RlbmVyKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc29ydGVyJyksIDEgKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mblNvcnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuTm9kZSwgaUNvbHVtbiwgZm5DYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpKHRydWUpLm9yZGVyLmxpc3RlbmVyKG5Ob2RlLCBpQ29sdW1uLCBmbkNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgYSB0YWJsZSBjZWxsIG9yIHJvdyAtIHRoaXMgbWV0aG9kIHdpbGwgYWNjZXB0IGVpdGhlciBhIHNpbmdsZSB2YWx1ZSB0b1xuICAgICAgICAgICAgICogdXBkYXRlIHRoZSBjZWxsIHdpdGgsIGFuIGFycmF5IG9mIHZhbHVlcyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGNvbHVtbiBvclxuICAgICAgICAgICAgICogYW4gb2JqZWN0IGluIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2UuIFRoZSBmdW5jdGlvbiBpc1xuICAgICAgICAgICAgICogc2VsZi1yZWZlcmVuY2luZyBpbiBvcmRlciB0byBtYWtlIHRoZSBtdWx0aSBjb2x1bW4gdXBkYXRlcyBlYXNpZXIuXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R8YXJyYXl8c3RyaW5nfSBtRGF0YSBEYXRhIHRvIHVwZGF0ZSB0aGUgY2VsbC9yb3cgd2l0aFxuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZXxpbnR9IG1Sb3cgVFIgZWxlbWVudCB5b3Ugd2FudCB0byB1cGRhdGUgb3IgdGhlIGFvRGF0YSBpbmRleFxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBbaUNvbHVtbl0gVGhlIGNvbHVtbiB0byB1cGRhdGUsIGdpdmUgYXMgbnVsbCBvciB1bmRlZmluZWQgdG9cbiAgICAgICAgICAgICAqICAgIHVwZGF0ZSBhIHdob2xlIHJvdy5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IFtiUmVkcmF3PXRydWVdIFJlZHJhdyB0aGUgdGFibGUgb3Igbm90XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBbYkFjdGlvbj10cnVlXSBQZXJmb3JtIHByZS1kcmF3IGFjdGlvbnMgb3Igbm90XG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2ludH0gMCBvbiBzdWNjZXNzLCAxIG9uIGVycm9yXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEFQSVxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIG9UYWJsZSA9ICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAgICAgKiAgICAgIG9UYWJsZS5mblVwZGF0ZSggJ0V4YW1wbGUgdXBkYXRlJywgMCwgMCApOyAvLyBTaW5nbGUgY2VsbFxuICAgICAgICAgICAgICogICAgICBvVGFibGUuZm5VcGRhdGUoIFsnYScsICdiJywgJ2MnLCAnZCcsICdlJ10sICQoJ3Rib2R5IHRyJylbMF0gKTsgLy8gUm93XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuZm5VcGRhdGUgPSBmdW5jdGlvbiAobURhdGEsIG1Sb3csIGlDb2x1bW4sIGJSZWRyYXcsIGJBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB2YXIgYXBpID0gdGhpcy5hcGkodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaUNvbHVtbiA9PT0gdW5kZWZpbmVkIHx8IGlDb2x1bW4gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLnJvdyhtUm93KS5kYXRhKG1EYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFwaS5jZWxsKG1Sb3csIGlDb2x1bW4pLmRhdGEobURhdGEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChiQWN0aW9uID09PSB1bmRlZmluZWQgfHwgYkFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBhcGkuY29sdW1ucy5hZGp1c3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYlJlZHJhdyA9PT0gdW5kZWZpbmVkIHx8IGJSZWRyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBpLmRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmcgdXNlZCwgaW4gb3JkZXJcbiAgICAgICAgICAgICAqIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzVmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLiBOb3RlIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiAgICBmb3JtYXRzIFwiWFwiIGFuZCBcIlguWVwiIGFyZSBhbHNvIGFjY2VwdGFibGUuXG4gICAgICAgICAgICAgKiAgQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhpcyB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgaXMgZ3JlYXRlciBvciBlcXVhbCB0byB0aGUgcmVxdWlyZWRcbiAgICAgICAgICAgICAqICAgIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90IHN1aXRhYmxlXG4gICAgICAgICAgICAgKiAgQG1ldGhvZFxuICAgICAgICAgICAgICogIEBkdG9wdCBBUElcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgIHZhciBvVGFibGUgPSAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgpO1xuICAgICAgICAgICAgICogICAgICBhbGVydCggb1RhYmxlLmZuVmVyc2lvbkNoZWNrKCAnMS45LjAnICkgKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5mblZlcnNpb25DaGVjayA9IF9leHQuZm5WZXJzaW9uQ2hlY2s7XG5cblxuICAgICAgICAgICAgdmFyIF90aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBlbXB0eUluaXQgPSBvcHRpb25zID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChlbXB0eUluaXQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub0FwaSA9IHRoaXMuaW50ZXJuYWwgPSBfZXh0LmludGVybmFsO1xuXG4gICAgICAgICAgICAvLyBFeHRlbmQgd2l0aCBvbGQgc3R5bGUgcGx1Zy1pbiBBUEkgbWV0aG9kc1xuICAgICAgICAgICAgZm9yICh2YXIgZm4gaW4gRGF0YVRhYmxlLmV4dC5pbnRlcm5hbCkge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2ZuXSA9IF9mbkV4dGVybkFwaUZ1bmMoZm4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCBpbml0aWFsaXNhdGlvbiB3ZSB3YW50IHRvIGdpdmUgaXQgYSBjbGVhbiBpbml0aWFsaXNhdGlvblxuICAgICAgICAgICAgICAgIC8vIG9iamVjdCB0aGF0IGNhbiBiZSBiYXNoZWQgYXJvdW5kXG4gICAgICAgICAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgb0luaXQgPSBsZW4gPiAxID8gLy8gb3B0aW1pc2F0aW9uIGZvciBzaW5nbGUgdGFibGUgY2FzZVxuICAgICAgICAgICAgICAgICAgICBfZm5FeHRlbmQobywgb3B0aW9ucywgdHJ1ZSkgOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zO1xuXG4gICAgICAgICAgICAgICAgLypnbG9iYWwgb0luaXQsX3RoYXQsZW1wdHlJbml0Ki9cbiAgICAgICAgICAgICAgICB2YXIgaSA9IDAsIGlMZW4sIGosIGpMZW4sIGssIGtMZW47XG4gICAgICAgICAgICAgICAgdmFyIHNJZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgIHZhciBiSW5pdEhhbmRlZE9mZiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0cyA9IERhdGFUYWJsZS5kZWZhdWx0cztcbiAgICAgICAgICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpO1xuXG5cbiAgICAgICAgICAgICAgICAvKiBTYW5pdHkgY2hlY2sgKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICd0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKG51bGwsIDAsICdOb24tdGFibGUgbm9kZSBpbml0aWFsaXNhdGlvbiAoJyArIHRoaXMubm9kZU5hbWUgKyAnKScsIDIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHRoZSBkZWZhdWx0cyAqL1xuICAgICAgICAgICAgICAgIF9mbkNvbXBhdE9wdHMoZGVmYXVsdHMpO1xuICAgICAgICAgICAgICAgIF9mbkNvbXBhdENvbHMoZGVmYXVsdHMuY29sdW1uKTtcblxuICAgICAgICAgICAgICAgIC8qIENvbnZlcnQgdGhlIGNhbWVsLWNhc2UgZGVmYXVsdHMgdG8gSHVuZ2FyaWFuICovXG4gICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cywgZGVmYXVsdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oZGVmYXVsdHMuY29sdW1uLCBkZWZhdWx0cy5jb2x1bW4sIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLyogU2V0dGluZyB1cCB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0ICovXG4gICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cywgJC5leHRlbmQob0luaXQsICR0aGlzLmRhdGEoKSksIHRydWUpO1xuXG5cblxuICAgICAgICAgICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBhcmUgcmUtaW5pdGlhbGlzaW5nIGEgdGFibGUgKi9cbiAgICAgICAgICAgICAgICB2YXIgYWxsU2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFsbFNldHRpbmdzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IGFsbFNldHRpbmdzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIEJhc2UgY2hlY2sgb24gdGFibGUgbm9kZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBzLm5UYWJsZSA9PSB0aGlzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAocy5uVEhlYWQgJiYgcy5uVEhlYWQucGFyZW50Tm9kZSA9PSB0aGlzKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHMublRGb290ICYmIHMublRGb290LnBhcmVudE5vZGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYlJldHJpZXZlID0gb0luaXQuYlJldHJpZXZlICE9PSB1bmRlZmluZWQgPyBvSW5pdC5iUmV0cmlldmUgOiBkZWZhdWx0cy5iUmV0cmlldmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYkRlc3Ryb3kgPSBvSW5pdC5iRGVzdHJveSAhPT0gdW5kZWZpbmVkID8gb0luaXQuYkRlc3Ryb3kgOiBkZWZhdWx0cy5iRGVzdHJveTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVtcHR5SW5pdCB8fCBiUmV0cmlldmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcy5vSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChiRGVzdHJveSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMub0luc3RhbmNlLmZuRGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKHMsIDAsICdDYW5ub3QgcmVpbml0aWFsaXNlIERhdGFUYWJsZScsIDMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZSBlbGVtZW50IHdlIGFyZSBpbml0aWFsaXNpbmcgaGFzIHRoZSBzYW1lIElEIGFzIGEgdGFibGUgd2hpY2ggd2FzIHByZXZpb3VzbHlcbiAgICAgICAgICAgICAgICAgICAgICogaW5pdGlhbGlzZWQsIGJ1dCB0aGUgdGFibGUgbm9kZXMgZG9uJ3QgbWF0Y2ggKGZyb20gYmVmb3JlKSB0aGVuIHdlIGRlc3Ryb3kgdGhlIG9sZFxuICAgICAgICAgICAgICAgICAgICAgKiBpbnN0YW5jZSBieSBzaW1wbHkgZGVsZXRpbmcgaXQuIFRoaXMgaXMgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGUgdGFibGUgaGFzIGJlZW5cbiAgICAgICAgICAgICAgICAgICAgICogZGVzdHJveWVkIGJ5IG90aGVyIG1ldGhvZHMuIEFueW9uZSB1c2luZyBub24taWQgc2VsZWN0b3JzIHdpbGwgbmVlZCB0byBkbyB0aGlzIG1hbnVhbGx5XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAocy5zVGFibGVJZCA9PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxTZXR0aW5ncy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIEVuc3VyZSB0aGUgdGFibGUgaGFzIGFuIElEIC0gcmVxdWlyZWQgZm9yIGFjY2Vzc2liaWxpdHkgKi9cbiAgICAgICAgICAgICAgICBpZiAoc0lkID09PSBudWxsIHx8IHNJZCA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBzSWQgPSBcIkRhdGFUYWJsZXNfVGFibGVfXCIgKyAoRGF0YVRhYmxlLmV4dC5fdW5pcXVlKyspO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlkID0gc0lkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZvciB0aGlzIHRhYmxlIGFuZCBzZXQgc29tZSBvZiB0aGUgZGVmYXVsdCBwYXJhbWV0ZXJzICovXG4gICAgICAgICAgICAgICAgdmFyIG9TZXR0aW5ncyA9ICQuZXh0ZW5kKHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5ncywge1xuICAgICAgICAgICAgICAgICAgICBcInNEZXN0cm95V2lkdGhcIjogJHRoaXNbMF0uc3R5bGUud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIFwic0luc3RhbmNlXCI6IHNJZCxcbiAgICAgICAgICAgICAgICAgICAgXCJzVGFibGVJZFwiOiBzSWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRhYmxlID0gdGhpcztcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub0FwaSA9IF90aGF0LmludGVybmFsO1xuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5vSW5pdCA9IG9Jbml0O1xuXG4gICAgICAgICAgICAgICAgYWxsU2V0dGluZ3MucHVzaChvU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gTmVlZCB0byBhZGQgdGhlIGluc3RhbmNlIGFmdGVyIHRoZSBpbnN0YW5jZSBhZnRlciB0aGUgc2V0dGluZ3Mgb2JqZWN0IGhhcyBiZWVuIGFkZGVkXG4gICAgICAgICAgICAgICAgLy8gdG8gdGhlIHNldHRpbmdzIGFycmF5LCBzbyB3ZSBjYW4gc2VsZiByZWZlcmVuY2UgdGhlIHRhYmxlIGluc3RhbmNlIGlmIG1vcmUgdGhhbiBvbmVcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3Mub0luc3RhbmNlID0gKF90aGF0Lmxlbmd0aCA9PT0gMSkgPyBfdGhhdCA6ICR0aGlzLmRhdGFUYWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGJlZm9yZSB3ZSBhcHBseSBhbGwgdGhlIGRlZmF1bHRzXG4gICAgICAgICAgICAgICAgX2ZuQ29tcGF0T3B0cyhvSW5pdCk7XG4gICAgICAgICAgICAgICAgX2ZuTGFuZ3VhZ2VDb21wYXQob0luaXQub0xhbmd1YWdlKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBsZW5ndGggbWVudSBpcyBnaXZlbiwgYnV0IHRoZSBpbml0IGRpc3BsYXkgbGVuZ3RoIGlzIG5vdCwgdXNlIHRoZSBsZW5ndGggbWVudVxuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5hTGVuZ3RoTWVudSAmJiAhb0luaXQuaURpc3BsYXlMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb0luaXQuaURpc3BsYXlMZW5ndGggPSBBcnJheS5pc0FycmF5KG9Jbml0LmFMZW5ndGhNZW51WzBdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBvSW5pdC5hTGVuZ3RoTWVudVswXVswXSA6IG9Jbml0LmFMZW5ndGhNZW51WzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBkZWZhdWx0cyBhbmQgaW5pdCBvcHRpb25zIHRvIG1ha2UgYSBzaW5nbGUgaW5pdCBvYmplY3Qgd2lsbCBhbGxcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25zIGRlZmluZWQgZnJvbSBkZWZhdWx0cyBhbmQgaW5zdGFuY2Ugb3B0aW9ucy5cbiAgICAgICAgICAgICAgICBvSW5pdCA9IF9mbkV4dGVuZCgkLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMpLCBvSW5pdCk7XG5cblxuICAgICAgICAgICAgICAgIC8vIE1hcCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucyBvbnRvIHRoZSBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAgICBfZm5NYXAob1NldHRpbmdzLm9GZWF0dXJlcywgb0luaXQsIFtcbiAgICAgICAgICAgICAgICAgICAgXCJiUGFnaW5hdGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiTGVuZ3RoQ2hhbmdlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYkZpbHRlclwiLFxuICAgICAgICAgICAgICAgICAgICBcImJTb3J0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiLFxuICAgICAgICAgICAgICAgICAgICBcImJJbmZvXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiQXV0b1dpZHRoXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYlNvcnRDbGFzc2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYlNlcnZlclNpZGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiRGVmZXJSZW5kZXJcIlxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIF9mbk1hcChvU2V0dGluZ3MsIG9Jbml0LCBbXG4gICAgICAgICAgICAgICAgICAgIFwiYXNTdHJpcGVDbGFzc2VzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYWpheFwiLFxuICAgICAgICAgICAgICAgICAgICBcImZuU2VydmVyRGF0YVwiLFxuICAgICAgICAgICAgICAgICAgICBcImZuRm9ybWF0TnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic1NlcnZlck1ldGhvZFwiLFxuICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiYUxlbmd0aE1lbnVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzUGFnaW5hdGlvblR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzQWpheFNvdXJjZVwiLFxuICAgICAgICAgICAgICAgICAgICBcInNBamF4RGF0YVByb3BcIixcbiAgICAgICAgICAgICAgICAgICAgXCJpU3RhdGVEdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInNEb21cIixcbiAgICAgICAgICAgICAgICAgICAgXCJiU29ydENlbGxzVG9wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiaVRhYkluZGV4XCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiLFxuICAgICAgICAgICAgICAgICAgICBcImZuU3RhdGVTYXZlQ2FsbGJhY2tcIixcbiAgICAgICAgICAgICAgICAgICAgXCJyZW5kZXJlclwiLFxuICAgICAgICAgICAgICAgICAgICBcInNlYXJjaERlbGF5XCIsXG4gICAgICAgICAgICAgICAgICAgIFwicm93SWRcIixcbiAgICAgICAgICAgICAgICAgICAgW1wiaUNvb2tpZUR1cmF0aW9uXCIsIFwiaVN0YXRlRHVyYXRpb25cIl0sIC8vIGJhY2t3YXJkcyBjb21wYXRcbiAgICAgICAgICAgICAgICAgICAgW1wib1NlYXJjaFwiLCBcIm9QcmV2aW91c1NlYXJjaFwiXSxcbiAgICAgICAgICAgICAgICAgICAgW1wiYW9TZWFyY2hDb2xzXCIsIFwiYW9QcmVTZWFyY2hDb2xzXCJdLFxuICAgICAgICAgICAgICAgICAgICBbXCJpRGlzcGxheUxlbmd0aFwiLCBcIl9pRGlzcGxheUxlbmd0aFwiXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIF9mbk1hcChvU2V0dGluZ3Mub1Njcm9sbCwgb0luaXQsIFtcbiAgICAgICAgICAgICAgICAgICAgW1wic1Njcm9sbFhcIiwgXCJzWFwiXSxcbiAgICAgICAgICAgICAgICAgICAgW1wic1Njcm9sbFhJbm5lclwiLCBcInNYSW5uZXJcIl0sXG4gICAgICAgICAgICAgICAgICAgIFtcInNTY3JvbGxZXCIsIFwic1lcIl0sXG4gICAgICAgICAgICAgICAgICAgIFtcImJTY3JvbGxDb2xsYXBzZVwiLCBcImJDb2xsYXBzZVwiXVxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIF9mbk1hcChvU2V0dGluZ3Mub0xhbmd1YWdlLCBvSW5pdCwgXCJmbkluZm9DYWxsYmFja1wiKTtcblxuICAgICAgICAgICAgICAgIC8qIENhbGxiYWNrIGZ1bmN0aW9ucyB3aGljaCBhcmUgYXJyYXkgZHJpdmVuICovXG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBvSW5pdC5mbkRyYXdDYWxsYmFjaywgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsIG9Jbml0LmZuU2VydmVyUGFyYW1zLCAndXNlcicpO1xuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvU3RhdGVTYXZlUGFyYW1zJywgb0luaXQuZm5TdGF0ZVNhdmVQYXJhbXMsICd1c2VyJyk7XG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9TdGF0ZUxvYWRQYXJhbXMnLCBvSW5pdC5mblN0YXRlTG9hZFBhcmFtcywgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1N0YXRlTG9hZGVkJywgb0luaXQuZm5TdGF0ZUxvYWRlZCwgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1Jvd0NhbGxiYWNrJywgb0luaXQuZm5Sb3dDYWxsYmFjaywgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG9Jbml0LmZuQ3JlYXRlZFJvdywgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgb0luaXQuZm5IZWFkZXJDYWxsYmFjaywgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgb0luaXQuZm5Gb290ZXJDYWxsYmFjaywgJ3VzZXInKTtcbiAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0luaXRDb21wbGV0ZScsIG9Jbml0LmZuSW5pdENvbXBsZXRlLCAndXNlcicpO1xuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvUHJlRHJhd0NhbGxiYWNrJywgb0luaXQuZm5QcmVEcmF3Q2FsbGJhY2ssICd1c2VyJyk7XG5cbiAgICAgICAgICAgICAgICBvU2V0dGluZ3Mucm93SWRGbiA9IF9mbkdldE9iamVjdERhdGFGbihvSW5pdC5yb3dJZCk7XG5cbiAgICAgICAgICAgICAgICAvKiBCcm93c2VyIHN1cHBvcnQgZGV0ZWN0aW9uICovXG4gICAgICAgICAgICAgICAgX2ZuQnJvd3NlckRldGVjdChvU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuXG4gICAgICAgICAgICAgICAgJC5leHRlbmQob0NsYXNzZXMsIERhdGFUYWJsZS5leHQuY2xhc3Nlcywgb0luaXQub0NsYXNzZXMpO1xuICAgICAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKG9DbGFzc2VzLnNUYWJsZSk7XG5cblxuICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBEaXNwbGF5IHN0YXJ0IHBvaW50LCB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBzYXZlIHNhdmluZyAqL1xuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuaUluaXREaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBvSW5pdC5pRGlzcGxheVN0YXJ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5pRGVmZXJMb2FkaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IEFycmF5LmlzQXJyYXkob0luaXQuaURlZmVyTG9hZGluZyk7XG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gdG1wID8gb0luaXQuaURlZmVyTG9hZGluZ1swXSA6IG9Jbml0LmlEZWZlckxvYWRpbmc7XG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5faVJlY29yZHNUb3RhbCA9IHRtcCA/IG9Jbml0LmlEZWZlckxvYWRpbmdbMV0gOiBvSW5pdC5pRGVmZXJMb2FkaW5nO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIExhbmd1YWdlIGRlZmluaXRpb25zICovXG4gICAgICAgICAgICAgICAgdmFyIG9MYW5ndWFnZSA9IG9TZXR0aW5ncy5vTGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgJC5leHRlbmQodHJ1ZSwgb0xhbmd1YWdlLCBvSW5pdC5vTGFuZ3VhZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9MYW5ndWFnZS5zVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEdldCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgZnJvbSBhIGZpbGUgLSBiZWNhdXNlIHRoaXMgQWpheCBjYWxsIG1ha2VzIHRoZSBsYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgKiBnZXQgYXN5bmMgdG8gdGhlIHJlbWFpbmRlciBvZiB0aGlzIGZ1bmN0aW9uIHdlIHVzZSBiSW5pdEhhbmRlZE9mZiB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAqIF9mbkluaXRpYWxpc2Ugd2lsbCBiZSBmaXJlZCBieSB0aGUgcmV0dXJuZWQgQWpheCBoYW5kbGVyLCByYXRoZXIgdGhhbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICQuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBvTGFuZ3VhZ2Uuc1VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTGFuZ3VhZ2VDb21wYXQoanNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FtZWxUb0h1bmdhcmlhbihkZWZhdWx0cy5vTGFuZ3VhZ2UsIGpzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG9MYW5ndWFnZSwganNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuSW5pdGlhbGlzZShvU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXJyb3Igb2NjdXJyZWQgbG9hZGluZyBsYW5ndWFnZSBmaWxlLCBjb250aW51ZSBvbiBhcyBiZXN0IHdlIGNhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRpYWxpc2Uob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJJbml0SGFuZGVkT2ZmID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIFN0cmlwZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAob0luaXQuYXNTdHJpcGVDbGFzc2VzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5hc1N0cmlwZUNsYXNzZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBvQ2xhc3Nlcy5zU3RyaXBlT2RkLFxuICAgICAgICAgICAgICAgICAgICAgICAgb0NsYXNzZXMuc1N0cmlwZUV2ZW5cbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKiBSZW1vdmUgcm93IHN0cmlwZSBjbGFzc2VzIGlmIHRoZXkgYXJlIGFscmVhZHkgb24gdGhlIHRhYmxlIHJvdyAqL1xuICAgICAgICAgICAgICAgIHZhciBzdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcztcbiAgICAgICAgICAgICAgICB2YXIgcm93T25lID0gJHRoaXMuY2hpbGRyZW4oJ3Rib2R5JykuZmluZCgndHInKS5lcSgwKTtcbiAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRydWUsICQubWFwKHN0cmlwZUNsYXNzZXMsIGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93T25lLmhhc0NsYXNzKGVsKTtcbiAgICAgICAgICAgICAgICB9KSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJ3Rib2R5IHRyJywgdGhpcykucmVtb3ZlQ2xhc3Moc3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykpO1xuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlcyA9IHN0cmlwZUNsYXNzZXMuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIENvbHVtbnNcbiAgICAgICAgICAgICAgICAgKiBTZWUgaWYgd2Ugc2hvdWxkIGxvYWQgY29sdW1ucyBhdXRvbWF0aWNhbGx5IG9yIHVzZSBkZWZpbmVkIG9uZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgYW5UaHMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYW9Db2x1bW5zSW5pdDtcbiAgICAgICAgICAgICAgICB2YXIgblRoZWFkID0gdGhpcy5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGhlYWQnKTtcbiAgICAgICAgICAgICAgICBpZiAoblRoZWFkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXIob1NldHRpbmdzLmFvSGVhZGVyLCBuVGhlYWRbMF0pO1xuICAgICAgICAgICAgICAgICAgICBhblRocyA9IF9mbkdldFVuaXF1ZVRocyhvU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIElmIG5vdCBnaXZlbiBhIGNvbHVtbiBhcnJheSwgZ2VuZXJhdGUgb25lIHdpdGggbnVsbHMgKi9cbiAgICAgICAgICAgICAgICBpZiAob0luaXQuYW9Db2x1bW5zID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFvQ29sdW1uc0luaXQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaUxlbiA9IGFuVGhzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW9Db2x1bW5zSW5pdC5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhb0NvbHVtbnNJbml0ID0gb0luaXQuYW9Db2x1bW5zO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIEFkZCB0aGUgY29sdW1ucyAqL1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0NvbHVtbnNJbml0Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfZm5BZGRDb2x1bW4ob1NldHRpbmdzLCBhblRocyA/IGFuVGhzW2ldIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogQXBwbHkgdGhlIGNvbHVtbiBkZWZpbml0aW9ucyAqL1xuICAgICAgICAgICAgICAgIF9mbkFwcGx5Q29sdW1uRGVmcyhvU2V0dGluZ3MsIG9Jbml0LmFvQ29sdW1uRGVmcywgYW9Db2x1bW5zSW5pdCwgZnVuY3Rpb24gKGlDb2wsIG9EZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uT3B0aW9ucyhvU2V0dGluZ3MsIGlDb2wsIG9EZWYpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLyogSFRNTDUgYXR0cmlidXRlIGRldGVjdGlvbiAtIGJ1aWxkIGFuIG1EYXRhIG9iamVjdCBhdXRvbWF0aWNhbGx5IGlmIHRoZVxuICAgICAgICAgICAgICAgICAqIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKHJvd09uZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBmdW5jdGlvbiAoY2VsbCwgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlbGwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBuYW1lKSAhPT0gbnVsbCA/IG5hbWUgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICQocm93T25lWzBdKS5jaGlsZHJlbigndGgsIHRkJykuZWFjaChmdW5jdGlvbiAoaSwgY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IG9TZXR0aW5ncy5hb0NvbHVtbnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2wubURhdGEgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc29ydCA9IGEoY2VsbCwgJ3NvcnQnKSB8fCBhKGNlbGwsICdvcmRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBhKGNlbGwsICdmaWx0ZXInKSB8fCBhKGNlbGwsICdzZWFyY2gnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ICE9PSBudWxsIHx8IGZpbHRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wubURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfOiBpICsgJy5kaXNwbGF5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQ6IHNvcnQgIT09IG51bGwgPyBpICsgJy5AZGF0YS0nICsgc29ydCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHNvcnQgIT09IG51bGwgPyBpICsgJy5AZGF0YS0nICsgc29ydCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyICE9PSBudWxsID8gaSArICcuQGRhdGEtJyArIGZpbHRlciA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNvbHVtbk9wdGlvbnMob1NldHRpbmdzLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlcyA9IG9TZXR0aW5ncy5vRmVhdHVyZXM7XG4gICAgICAgICAgICAgICAgdmFyIGxvYWRlZEluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIFNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgICogQHRvZG8gRm9yIG1vZHVsYXJpc2F0aW9uICgxLjExKSB0aGlzIG5lZWRzIHRvIGRvIGludG8gYSBzb3J0IHN0YXJ0IHVwIGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYWFTb3J0aW5nIGlzIG5vdCBkZWZpbmVkLCB0aGVuIHdlIHVzZSB0aGUgZmlyc3QgaW5kaWNhdG9yIGluIGFzU29ydGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoYXQgaGFzIGJlZW4gYWx0ZXJlZCwgc28gdGhlIGRlZmF1bHQgc29ydCByZWZsZWN0cyB0aGF0IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAob0luaXQuYWFTb3J0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0aW5nID0gb1NldHRpbmdzLmFhU29ydGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBzb3J0aW5nLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbaV1bMV0gPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2ldLmFzU29ydGluZ1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIERvIGEgZmlyc3QgcGFzcyBvbiB0aGUgc29ydGluZyBjbGFzc2VzIChhbGxvd3MgYW55IHNpemUgY2hhbmdlcyB0byBiZSB0YWtlbiBpbnRvXG4gICAgICAgICAgICAgICAgICAgICAqIGFjY291bnQsIGFuZCBhbHNvIHdpbGwgYXBwbHkgc29ydGluZyBkaXNhYmxlZCBjbGFzc2VzIGlmIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0aW5nQ2xhc3NlcyhvU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlcy5iU29ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tSZWcob1NldHRpbmdzLCAnYW9EcmF3Q2FsbGJhY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5iU29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhU29ydCA9IF9mblNvcnRGbGF0dGVuKG9TZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRDb2x1bW5zID0ge307XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGFTb3J0LCBmdW5jdGlvbiAoaSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRDb2x1bW5zW3ZhbC5zcmNdID0gdmFsLmRpcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ29yZGVyJywgW29TZXR0aW5ncywgYVNvcnQsIHNvcnRlZENvbHVtbnNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydEFyaWEob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnKG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5iU29ydGVkIHx8IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PT0gJ3NzcCcgfHwgZmVhdHVyZXMuYkRlZmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXMob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgJ3NjJyk7XG5cblxuICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgKiBGaW5hbCBpbml0XG4gICAgICAgICAgICAgICAgICAgICAqIENhY2hlIHRoZSBoZWFkZXIsIGJvZHkgYW5kIGZvb3RlciBhcyByZXF1aXJlZCwgY3JlYXRpbmcgdGhlbSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV29yayBhcm91bmQgZm9yIFdlYmtpdCBidWcgODM4NjcgLSBzdG9yZSB0aGUgY2FwdGlvbi1zaWRlIGJlZm9yZSByZW1vdmluZyBmcm9tIGRvY1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2FwdGlvbnMgPSAkdGhpcy5jaGlsZHJlbignY2FwdGlvbicpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FwdGlvblNpZGUgPSAkKHRoaXMpLmNzcygnY2FwdGlvbi1zaWRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVhZCA9ICR0aGlzLmNoaWxkcmVuKCd0aGVhZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlYWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGVhZCA9ICQoJzx0aGVhZC8+JykuYXBwZW5kVG8oJHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5uVEhlYWQgPSB0aGVhZFswXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgdGJvZHkgPSAkdGhpcy5jaGlsZHJlbigndGJvZHknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRib2R5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGJvZHkgPSAkKCc8dGJvZHkvPicpLmFwcGVuZFRvKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MublRCb2R5ID0gdGJvZHlbMF07XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHRmb290ID0gJHRoaXMuY2hpbGRyZW4oJ3Rmb290Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdC5sZW5ndGggPT09IDAgJiYgY2FwdGlvbnMubGVuZ3RoID4gMCAmJiAob1NldHRpbmdzLm9TY3JvbGwuc1ggIT09IFwiXCIgfHwgb1NldHRpbmdzLm9TY3JvbGwuc1kgIT09IFwiXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYSBzY3JvbGxpbmcgdGFibGUsIGFuZCBubyBmb290ZXIgaGFzIGJlZW4gZ2l2ZW4sIHRoZW4gd2UgbmVlZCB0byBjcmVhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgdGZvb3QgZWxlbWVudCBmb3IgdGhlIGNhcHRpb24gZWxlbWVudCB0byBiZSBhcHBlbmRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgdGZvb3QgPSAkKCc8dGZvb3QvPicpLmFwcGVuZFRvKCR0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0Zm9vdC5sZW5ndGggPT09IDAgfHwgdGZvb3QuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmFkZENsYXNzKG9DbGFzc2VzLnNOb0Zvb3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGZvb3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLm5URm9vdCA9IHRmb290WzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuRGV0ZWN0SGVhZGVyKG9TZXR0aW5ncy5hb0Zvb3Rlciwgb1NldHRpbmdzLm5URm9vdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayBpZiB0aGVyZSBpcyBkYXRhIHBhc3NpbmcgaW50byB0aGUgY29uc3RydWN0b3IgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9Jbml0LmFhRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG9Jbml0LmFhRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkZERhdGEob1NldHRpbmdzLCBvSW5pdC5hYURhdGFbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9TZXR0aW5ncy5iRGVmZXJMb2FkaW5nIHx8IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnZG9tJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogR3JhYiB0aGUgZGF0YSBmcm9tIHRoZSBwYWdlIC0gb25seSBkbyB0aGlzIHdoZW4gZGVmZXJyZWQgbG9hZGluZyBvciBubyBBamF4XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzb3VyY2Ugc2luY2UgdGhlcmUgaXMgbm8gcG9pbnQgaW4gcmVhZGluZyB0aGUgRE9NIGRhdGEgaWYgd2UgYXJlIHRoZW4gZ29pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRvIHJlcGxhY2UgaXQgd2l0aCBBamF4IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuQWRkVHIob1NldHRpbmdzLCAkKG9TZXR0aW5ncy5uVEJvZHkpLmNoaWxkcmVuKCd0cicpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIENvcHkgdGhlIGRhdGEgaW5kZXggYXJyYXkgKi9cbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLmFpRGlzcGxheSA9IG9TZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblxuICAgICAgICAgICAgICAgICAgICAvKiBJbml0aWFsaXNhdGlvbiBjb21wbGV0ZSAtIHRhYmxlIGNhbiBiZSBkcmF3biAqL1xuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkluaXRpYWxpc2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAvKiBDaGVjayBpZiB3ZSBuZWVkIHRvIGluaXRpYWxpc2UgdGhlIHRhYmxlIChpdCBtaWdodCBub3QgaGF2ZSBiZWVuIGhhbmRlZCBvZmYgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIGxhbmd1YWdlIHByb2Nlc3NvcilcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChiSW5pdEhhbmRlZE9mZiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRpYWxpc2Uob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvKiBNdXN0IGJlIGRvbmUgYWZ0ZXIgZXZlcnl0aGluZyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgc3RhdGUgc2F2aW5nISAqL1xuICAgICAgICAgICAgICAgIGlmIChvSW5pdC5iU3RhdGVTYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLmJTdGF0ZVNhdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsICdhb0RyYXdDYWxsYmFjaycsIF9mblNhdmVTdGF0ZSwgJ3N0YXRlX3NhdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgX2ZuTG9hZFN0YXRlKG9TZXR0aW5ncywgb0luaXQsIGxvYWRlZEluaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkSW5pdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhhdCA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEl0IGlzIHVzZWZ1bCB0byBoYXZlIHZhcmlhYmxlcyB3aGljaCBhcmUgc2NvcGVkIGxvY2FsbHkgc28gb25seSB0aGVcbiAgICAgICAgICogRGF0YVRhYmxlcyBmdW5jdGlvbnMgY2FuIGFjY2VzcyB0aGVtIGFuZCB0aGV5IGRvbid0IGxlYWsgaW50byBnbG9iYWwgc3BhY2UuXG4gICAgICAgICAqIEF0IHRoZSBzYW1lIHRpbWUgdGhlc2UgZnVuY3Rpb25zIGFyZSBvZnRlbiB1c2VmdWwgb3ZlciBtdWx0aXBsZSBmaWxlcyBpbiB0aGVcbiAgICAgICAgICogY29yZSBhbmQgQVBJLCBzbyB3ZSBsaXN0LCBvciBhdCBsZWFzdCBkb2N1bWVudCwgYWxsIHZhcmlhYmxlcyB3aGljaCBhcmUgdXNlZFxuICAgICAgICAgKiBieSBEYXRhVGFibGVzIGFzIHByaXZhdGUgdmFyaWFibGVzIGhlcmUuIFRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm9cbiAgICAgICAgICogY2xhc2hpbmcgb2YgdmFyaWFibGUgbmFtZXMgYW5kIHRoYXQgdGhleSBjYW4gZWFzaWx5IHJlZmVyZW5jZWQgZm9yIHJldXNlLlxuICAgICAgICAgKi9cblxuXG4gICAgICAgIC8vIERlZmluZWQgZWxzZSB3aGVyZVxuICAgICAgICAvLyAgX3NlbGVjdG9yX3J1blxuICAgICAgICAvLyAgX3NlbGVjdG9yX29wdHNcbiAgICAgICAgLy8gIF9zZWxlY3Rvcl9maXJzdFxuICAgICAgICAvLyAgX3NlbGVjdG9yX3Jvd19pbmRleGVzXG5cbiAgICAgICAgdmFyIF9leHQ7IC8vIERhdGFUYWJsZS5leHRcbiAgICAgICAgdmFyIF9BcGk7IC8vIERhdGFUYWJsZS5BcGlcbiAgICAgICAgdmFyIF9hcGlfcmVnaXN0ZXI7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJcbiAgICAgICAgdmFyIF9hcGlfcmVnaXN0ZXJQbHVyYWw7IC8vIERhdGFUYWJsZS5BcGkucmVnaXN0ZXJQbHVyYWxcblxuICAgICAgICB2YXIgX3JlX2RpYyA9IHt9O1xuICAgICAgICB2YXIgX3JlX25ld19saW5lcyA9IC9bXFxyXFxuXFx1MjAyOF0vZztcbiAgICAgICAgdmFyIF9yZV9odG1sID0gLzwuKj8+L2c7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBub3Qgc3RyaWN0IElTTzg2MDEgLSBEYXRlLnBhcnNlKCkgaXMgcXVpdGUgbGF4LCBhbHRob3VnaFxuICAgICAgICAvLyBpbXBsZW1lbnRhdGlvbnMgZGlmZmVyIGJldHdlZW4gYnJvd3NlcnMuXG4gICAgICAgIHZhciBfcmVfZGF0ZSA9IC9eXFxkezIsNH1bXFwuXFwvXFwtXVxcZHsxLDJ9W1xcLlxcL1xcLV1cXGR7MSwyfShbVCBdezF9XFxkezEsMn1bOlxcLl1cXGR7Mn0oW1xcLjpdXFxkezJ9KT8pPyQvO1xuXG4gICAgICAgIC8vIEVzY2FwZSByZWd1bGFyIGV4cHJlc3Npb24gc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgICAgIHZhciBfcmVfZXNjYXBlX3JlZ2V4ID0gbmV3IFJlZ0V4cCgnKFxcXFwnICsgWycvJywgJy4nLCAnKicsICcrJywgJz8nLCAnfCcsICcoJywgJyknLCAnWycsICddJywgJ3snLCAnfScsICdcXFxcJywgJyQnLCAnXicsICctJ10uam9pbignfFxcXFwnKSArICcpJywgJ2cnKTtcblxuICAgICAgICAvLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0ZvcmVpZ25fZXhjaGFuZ2VfbWFya2V0XG4gICAgICAgIC8vIC0gXFx1MjBCRCAtIFJ1c3NpYW4gcnVibGUuXG4gICAgICAgIC8vIC0gXFx1MjBhOSAtIFNvdXRoIEtvcmVhbiBXb25cbiAgICAgICAgLy8gLSBcXHUyMEJBIC0gVHVya2lzaCBMaXJhXG4gICAgICAgIC8vIC0gXFx1MjBCOSAtIEluZGlhbiBSdXBlZVxuICAgICAgICAvLyAtIFIgLSBCcmF6aWwgKFIkKSBhbmQgU291dGggQWZyaWNhXG4gICAgICAgIC8vIC0gZnIgLSBTd2lzcyBGcmFuY1xuICAgICAgICAvLyAtIGtyIC0gU3dlZGlzaCBrcm9uYSwgTm9yd2VnaWFuIGtyb25lIGFuZCBEYW5pc2gga3JvbmVcbiAgICAgICAgLy8gLSBcXHUyMDA5IGlzIHRoaW4gc3BhY2UgYW5kIFxcdTIwMkYgaXMgbmFycm93IG5vLWJyZWFrIHNwYWNlLCBib3RoIHVzZWQgaW4gbWFueVxuICAgICAgICAvLyAtIMmDIC0gQml0Y29pblxuICAgICAgICAvLyAtIM6eIC0gRXRoZXJldW1cbiAgICAgICAgLy8gICBzdGFuZGFyZHMgYXMgdGhvdXNhbmRzIHNlcGFyYXRvcnMuXG4gICAgICAgIHZhciBfcmVfZm9ybWF0dGVkX251bWVyaWMgPSAvWydcXHUwMEEwLCTCo+KCrMKlJVxcdTIwMDlcXHUyMDJGXFx1MjBCRFxcdTIwYTlcXHUyMEJBcmZryYPOnl0vZ2k7XG5cblxuICAgICAgICB2YXIgX2VtcHR5ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiAhZCB8fCBkID09PSB0cnVlIHx8IGQgPT09ICctJyA/IHRydWUgOiBmYWxzZTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfaW50VmFsID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIHZhciBpbnRlZ2VyID0gcGFyc2VJbnQocywgMTApO1xuICAgICAgICAgICAgcmV0dXJuICFpc05hTihpbnRlZ2VyKSAmJiBpc0Zpbml0ZShzKSA/IGludGVnZXIgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENvbnZlcnQgZnJvbSBhIGZvcm1hdHRlZCBudW1iZXIgd2l0aCBjaGFyYWN0ZXJzIG90aGVyIHRoYW4gYC5gIGFzIHRoZVxuICAgICAgICAvLyBkZWNpbWFsIHBsYWNlLCB0byBhIEphdmFzY3JpcHQgbnVtYmVyXG4gICAgICAgIHZhciBfbnVtVG9EZWNpbWFsID0gZnVuY3Rpb24gKG51bSwgZGVjaW1hbFBvaW50KSB7XG4gICAgICAgICAgICAvLyBDYWNoZSBjcmVhdGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm9yIHNwZWVkIGFzIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIG9mdGVuXG4gICAgICAgICAgICBpZiAoIV9yZV9kaWNbZGVjaW1hbFBvaW50XSkge1xuICAgICAgICAgICAgICAgIF9yZV9kaWNbZGVjaW1hbFBvaW50XSA9IG5ldyBSZWdFeHAoX2ZuRXNjYXBlUmVnZXgoZGVjaW1hbFBvaW50KSwgJ2cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbnVtID09PSAnc3RyaW5nJyAmJiBkZWNpbWFsUG9pbnQgIT09ICcuJyA/XG4gICAgICAgICAgICAgICAgbnVtLnJlcGxhY2UoL1xcLi9nLCAnJykucmVwbGFjZShfcmVfZGljW2RlY2ltYWxQb2ludF0sICcuJykgOlxuICAgICAgICAgICAgICAgIG51bTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfaXNOdW1iZXIgPSBmdW5jdGlvbiAoZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIHZhciBzdHJUeXBlID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnO1xuXG4gICAgICAgICAgICAvLyBJZiBlbXB0eSByZXR1cm4gaW1tZWRpYXRlbHkgc28gdGhlcmUgbXVzdCBiZSBhIG51bWJlciBpZiBpdCBpcyBhXG4gICAgICAgICAgICAvLyBmb3JtYXR0ZWQgc3RyaW5nICh0aGlzIHN0b3BzIHRoZSBzdHJpbmcgXCJrXCIsIG9yIFwia3JcIiwgZXRjIGJlaW5nIGRldGVjdGVkXG4gICAgICAgICAgICAvLyBhcyBhIGZvcm1hdHRlZCBudW1iZXIgZm9yIGN1cnJlbmN5XG4gICAgICAgICAgICBpZiAoX2VtcHR5KGQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChkZWNpbWFsUG9pbnQgJiYgc3RyVHlwZSkge1xuICAgICAgICAgICAgICAgIGQgPSBfbnVtVG9EZWNpbWFsKGQsIGRlY2ltYWxQb2ludCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmb3JtYXR0ZWQgJiYgc3RyVHlwZSkge1xuICAgICAgICAgICAgICAgIGQgPSBkLnJlcGxhY2UoX3JlX2Zvcm1hdHRlZF9udW1lcmljLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChkKSkgJiYgaXNGaW5pdGUoZCk7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvLyBBIHN0cmluZyB3aXRob3V0IEhUTUwgaW4gaXQgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgSFRNTCBzdGlsbFxuICAgICAgICB2YXIgX2lzSHRtbCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICByZXR1cm4gX2VtcHR5KGQpIHx8IHR5cGVvZiBkID09PSAnc3RyaW5nJztcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfaHRtbE51bWVyaWMgPSBmdW5jdGlvbiAoZCwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQpIHtcbiAgICAgICAgICAgIGlmIChfZW1wdHkoZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGh0bWwgPSBfaXNIdG1sKGQpO1xuICAgICAgICAgICAgcmV0dXJuICFodG1sID9cbiAgICAgICAgICAgICAgICBudWxsIDpcbiAgICAgICAgICAgICAgICBfaXNOdW1iZXIoX3N0cmlwSHRtbChkKSwgZGVjaW1hbFBvaW50LCBmb3JtYXR0ZWQpID9cbiAgICAgICAgICAgICAgICAgICAgdHJ1ZSA6XG4gICAgICAgICAgICAgICAgICAgIG51bGw7XG4gICAgICAgIH07XG5cblxuICAgICAgICB2YXIgX3BsdWNrID0gZnVuY3Rpb24gKGEsIHByb3AsIHByb3AyKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG4gICAgICAgICAgICB2YXIgaSA9IDAsIGllbiA9IGEubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuICAgICAgICAgICAgLy8gaXMgZXNzZW50aWFsIGhlcmVcbiAgICAgICAgICAgIGlmIChwcm9wMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtpXSAmJiBhW2ldW3Byb3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChhW2ldW3Byb3BdW3Byb3AyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChhW2ldW3Byb3BdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8vIEJhc2ljYWxseSB0aGUgc2FtZSBhcyBfcGx1Y2ssIGJ1dCByYXRoZXIgdGhhbiBsb29waW5nIG92ZXIgYGFgIHdlIHVzZSBgb3JkZXJgXG4gICAgICAgIC8vIGFzIHRoZSBpbmRleGVzIHRvIHBpY2sgZnJvbSBgYWBcbiAgICAgICAgdmFyIF9wbHVja19vcmRlciA9IGZ1bmN0aW9uIChhLCBvcmRlciwgcHJvcCwgcHJvcDIpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIHZhciBpID0gMCwgaWVuID0gb3JkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyBDb3VsZCBoYXZlIHRoZSB0ZXN0IGluIHRoZSBsb29wIGZvciBzbGlnaHRseSBzbWFsbGVyIGNvZGUsIGJ1dCBzcGVlZFxuICAgICAgICAgICAgLy8gaXMgZXNzZW50aWFsIGhlcmVcbiAgICAgICAgICAgIGlmIChwcm9wMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVtvcmRlcltpXV1bcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbb3JkZXJbaV1dW3Byb3BdW3Byb3AyXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbb3JkZXJbaV1dW3Byb3BdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG5cblxuICAgICAgICB2YXIgX3JhbmdlID0gZnVuY3Rpb24gKGxlbiwgc3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIHZhciBlbmQ7XG5cbiAgICAgICAgICAgIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgIGVuZCA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbGVuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIF9yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFbaV0pIHsgLy8gY2FyZWZ1bCAtIHdpbGwgcmVtb3ZlIGFsbCBmYWxzeSB2YWx1ZXMhXG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGFbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfc3RyaXBIdG1sID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkLnJlcGxhY2UoX3JlX2h0bWwsICcnKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmUgaWYgYWxsIHZhbHVlcyBpbiB0aGUgYXJyYXkgYXJlIHVuaXF1ZS4gVGhpcyBtZWFucyB3ZSBjYW4gc2hvcnRcbiAgICAgICAgICogY3V0IHRoZSBfdW5pcXVlIG1ldGhvZCBhdCB0aGUgY29zdCBvZiBhIHNpbmdsZSBsb29wLiBBIHNvcnRlZCBhcnJheSBpcyB1c2VkXG4gICAgICAgICAqIHRvIGVhc2lseSBjaGVjayB0aGUgdmFsdWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gc3JjIFNvdXJjZSBhcnJheVxuICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFsbCB1bmlxdWUsIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2FyZUFsbFVuaXF1ZSA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIGlmIChzcmMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc29ydGVkID0gc3JjLnNsaWNlKCkuc29ydCgpO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBzb3J0ZWRbMF07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBpZW4gPSBzb3J0ZWQubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkW2ldID09PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsYXN0ID0gc29ydGVkW2ldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSB1bmlxdWUgZWxlbWVudHMgaW4gYSBzb3VyY2UgYXJyYXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge2FycmF5fSBzcmMgU291cmNlIGFycmF5XG4gICAgICAgICAqIEByZXR1cm4ge2FycmF5fSBBcnJheSBvZiB1bmlxdWUgaXRlbXNcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF91bmlxdWUgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICBpZiAoX2FyZUFsbFVuaXF1ZShzcmMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNyYy5zbGljZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBIGZhc3RlciB1bmlxdWUgbWV0aG9kIGlzIHRvIHVzZSBvYmplY3Qga2V5cyB0byBpZGVudGlmeSB1c2VkIHZhbHVlcyxcbiAgICAgICAgICAgIC8vIGJ1dCB0aGlzIGRvZXNuJ3Qgd29yayB3aXRoIGFycmF5cyBvciBvYmplY3RzLCB3aGljaCB3ZSBtdXN0IGFsc29cbiAgICAgICAgICAgIC8vIGNvbnNpZGVyLiBTZWUganNwZXJmLmNvbS9jb21wYXJlLWFycmF5LXVuaXF1ZS12ZXJzaW9ucy80IGZvciBtb3JlXG4gICAgICAgICAgICAvLyBpbmZvcm1hdGlvbi5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIG91dCA9IFtdLFxuICAgICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgICBpLCBpZW4gPSBzcmMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGosIGsgPSAwO1xuXG4gICAgICAgICAgICBhZ2FpbjogZm9yIChpID0gMDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gc3JjW2ldO1xuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0W2pdID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIGFnYWluO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb3V0LnB1c2godmFsKTtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3VycHJpc2luZ2x5IHRoaXMgaXMgZmFzdGVyIHRoYW4gW10uY29uY2F0LmFwcGx5XG4gICAgICAgIC8vIGh0dHBzOi8vanNwZXJmLmNvbS9mbGF0dGVuLWFuLWFycmF5LWxvb3AtdnMtcmVkdWNlLzJcbiAgICAgICAgdmFyIF9mbGF0dGVuID0gZnVuY3Rpb24gKG91dCwgdmFsKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZsYXR0ZW4ob3V0LCB2YWxbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKHZhbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJheS5pc0FycmF5IHBvbHlmaWxsLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSkge1xuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gLnRyaW0oKSBwb2x5ZmlsbFxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvdHJpbVxuICAgICAgICBpZiAoIVN0cmluZy5wcm90b3R5cGUudHJpbSkge1xuICAgICAgICAgICAgU3RyaW5nLnByb3RvdHlwZS50cmltID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGFUYWJsZXMgdXRpbGl0eSBtZXRob2RzXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBtZXRob2RzIHRoYXQgRGF0YVRhYmxlcyB1c2VzIGludGVybmFsbHkgdG9cbiAgICAgICAgICogY3JlYXRlIGEgRGF0YVRhYmxlLCBidXQgd2hpY2ggYXJlIG5vdCBleGNsdXNpdmVseSB1c2VkIG9ubHkgZm9yIERhdGFUYWJsZXMuXG4gICAgICAgICAqIFRoZXNlIG1ldGhvZHMgY2FuIGJlIHVzZWQgYnkgZXh0ZW5zaW9uIGF1dGhvcnMgdG8gc2F2ZSB0aGUgZHVwbGljYXRpb24gb2ZcbiAgICAgICAgICogY29kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIERhdGFUYWJsZS51dGlsID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaHJvdHRsZSB0aGUgY2FsbHMgdG8gYSBmdW5jdGlvbi4gQXJndW1lbnRzIGFuZCBjb250ZXh0IGFyZSBtYWludGFpbmVkXG4gICAgICAgICAgICAgKiBmb3IgdGhlIHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gZnJlcSBDYWxsIGZyZXF1ZW5jeSBpbiBtU1xuICAgICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb259IFdyYXBwZWQgZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmbiwgZnJlcSkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3kgPSBmcmVxICE9PSB1bmRlZmluZWQgPyBmcmVxIDogMjAwLFxuICAgICAgICAgICAgICAgICAgICBsYXN0LFxuICAgICAgICAgICAgICAgICAgICB0aW1lcjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3cgPSArbmV3IERhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgbm93IDwgbGFzdCArIGZyZXF1ZW5jeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnJlcXVlbmN5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBub3c7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXNjYXBlIGEgc3RyaW5nIHN1Y2ggdGhhdCBpdCBjYW4gYmUgdXNlZCBpbiBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmFsIHN0cmluZyB0byBlc2NhcGVcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBlc2NhcGVkIHN0cmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlc2NhcGVSZWdleDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWwucmVwbGFjZShfcmVfZXNjYXBlX3JlZ2V4LCAnXFxcXCQxJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSBtYXBwaW5nIG9iamVjdCB0aGF0IGFsbG93cyBjYW1lbCBjYXNlIHBhcmFtZXRlcnMgdG8gYmUgbG9va2VkIHVwXG4gICAgICAgICAqIGZvciB0aGVpciBIdW5nYXJpYW4gY291bnRlcnBhcnRzLiBUaGUgbWFwcGluZyBpcyBzdG9yZWQgaW4gYSBwcml2YXRlXG4gICAgICAgICAqIHBhcmFtZXRlciBjYWxsZWQgYF9odW5nYXJpYW5NYXBgIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZCBvbiB0aGUgc291cmNlIG9iamVjdC5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkh1bmdhcmlhbk1hcChvKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBodW5nYXJpYW4gPSAnYSBhYSBhaSBhbyBhcyBiIGZuIGkgbSBvIHMgJyxcbiAgICAgICAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICAgICAgICBuZXdLZXksXG4gICAgICAgICAgICAgICAgbWFwID0ge307XG5cbiAgICAgICAgICAgICQuZWFjaChvLCBmdW5jdGlvbiAoa2V5LCB2YWwpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IGtleS5tYXRjaCgvXihbXkEtWl0rPykoW0EtWl0pLyk7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2ggJiYgaHVuZ2FyaWFuLmluZGV4T2YobWF0Y2hbMV0gKyAnICcpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdLZXkgPSBrZXkucmVwbGFjZShtYXRjaFswXSwgbWF0Y2hbMl0udG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtuZXdLZXldID0ga2V5O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSA9PT0gJ28nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5IdW5nYXJpYW5NYXAob1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvLl9odW5nYXJpYW5NYXAgPSBtYXA7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGZyb20gY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIEh1bmdhcmlhbiwgYmFzZWQgb24gYSBIdW5nYXJpYW4gbWFwXG4gICAgICAgICAqIGNyZWF0ZWQgYnkgX2ZuSHVuZ2FyaWFuTWFwLlxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXG4gICAgICAgICAqICAgIG1hcHBlZC5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcbiAgICAgICAgICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XG4gICAgICAgICAqICAgIHdvbid0IGJlLlxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5DYW1lbFRvSHVuZ2FyaWFuKHNyYywgdXNlciwgZm9yY2UpIHtcbiAgICAgICAgICAgIGlmICghc3JjLl9odW5nYXJpYW5NYXApIHtcbiAgICAgICAgICAgICAgICBfZm5IdW5nYXJpYW5NYXAoc3JjKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGh1bmdhcmlhbktleTtcblxuICAgICAgICAgICAgJC5lYWNoKHVzZXIsIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgICAgICAgICAgICAgIGh1bmdhcmlhbktleSA9IHNyYy5faHVuZ2FyaWFuTWFwW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoaHVuZ2FyaWFuS2V5ICE9PSB1bmRlZmluZWQgJiYgKGZvcmNlIHx8IHVzZXJbaHVuZ2FyaWFuS2V5XSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3Igb2JqZWN0cywgd2UgbmVlZCB0byBidXp6IGRvd24gaW50byB0aGUgb2JqZWN0IHRvIGNvcHkgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHVuZ2FyaWFuS2V5LmNoYXJBdCgwKSA9PT0gJ28nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IHRoZSBjYW1lbENhc2Ugb3B0aW9ucyBvdmVyIHRvIHRoZSBodW5nYXJpYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlcltodW5nYXJpYW5LZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNlcltodW5nYXJpYW5LZXldID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAkLmV4dGVuZCh0cnVlLCB1c2VyW2h1bmdhcmlhbktleV0sIHVzZXJba2V5XSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oc3JjW2h1bmdhcmlhbktleV0sIHVzZXJbaHVuZ2FyaWFuS2V5XSwgZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcltodW5nYXJpYW5LZXldID0gdXNlcltrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMYW5ndWFnZSBjb21wYXRpYmlsaXR5IC0gd2hlbiBjZXJ0YWluIG9wdGlvbnMgYXJlIGdpdmVuLCBhbmQgb3RoZXJzIGFyZW4ndCwgd2VcbiAgICAgICAgICogbmVlZCB0byBkdXBsaWNhdGUgdGhlIHZhbHVlcyBvdmVyLCBpbiBvcmRlciB0byBwcm92aWRlIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAqIHdpdGggb2xkZXIgbGFuZ3VhZ2UgZmlsZXMuXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkxhbmd1YWdlQ29tcGF0KGxhbmcpIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhlIHVzZSBvZiB0aGUgSHVuZ2FyaWFuIG5vdGF0aW9uIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIG1ldGhvZCBhc1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgYWZ0ZXIgdGhlIG1hcHBpbmcgb2YgY2FtZWxDYXNlIHRvIEh1bmdhcmlhblxuICAgICAgICAgICAgdmFyIGRlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLm9MYW5ndWFnZTtcblxuICAgICAgICAgICAgLy8gRGVmYXVsdCBtYXBwaW5nXG4gICAgICAgICAgICB2YXIgZGVmYXVsdERlY2ltYWwgPSBkZWZhdWx0cy5zRGVjaW1hbDtcbiAgICAgICAgICAgIGlmIChkZWZhdWx0RGVjaW1hbCkge1xuICAgICAgICAgICAgICAgIF9hZGROdW1lcmljU29ydChkZWZhdWx0RGVjaW1hbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHplcm9SZWNvcmRzID0gbGFuZy5zWmVyb1JlY29yZHM7XG5cbiAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSAtIGlmIHRoZXJlIGlzIG5vIHNFbXB0eVRhYmxlIGdpdmVuLCB0aGVuIHVzZSB0aGUgc2FtZSBhc1xuICAgICAgICAgICAgICAgIC8vIHNaZXJvUmVjb3JkcyAtIGFzc3VtaW5nIHRoYXQgaXMgZ2l2ZW4uXG4gICAgICAgICAgICAgICAgaWYgKCFsYW5nLnNFbXB0eVRhYmxlICYmIHplcm9SZWNvcmRzICYmXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzLnNFbXB0eVRhYmxlID09PSBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKGxhbmcsIGxhbmcsICdzWmVyb1JlY29yZHMnLCAnc0VtcHR5VGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMaWtld2lzZSB3aXRoIGxvYWRpbmcgcmVjb3Jkc1xuICAgICAgICAgICAgICAgIGlmICghbGFuZy5zTG9hZGluZ1JlY29yZHMgJiYgemVyb1JlY29yZHMgJiZcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHMuc0xvYWRpbmdSZWNvcmRzID09PSBcIkxvYWRpbmcuLi5cIikge1xuICAgICAgICAgICAgICAgICAgICBfZm5NYXAobGFuZywgbGFuZywgJ3NaZXJvUmVjb3JkcycsICdzTG9hZGluZ1JlY29yZHMnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPbGQgcGFyYW1ldGVyIG5hbWUgb2YgdGhlIHRob3VzYW5kcyBzZXBhcmF0b3IgbWFwcGVkIG9udG8gdGhlIG5ld1xuICAgICAgICAgICAgICAgIGlmIChsYW5nLnNJbmZvVGhvdXNhbmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmcuc1Rob3VzYW5kcyA9IGxhbmcuc0luZm9UaG91c2FuZHM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBsYW5nLnNEZWNpbWFsO1xuICAgICAgICAgICAgICAgIGlmIChkZWNpbWFsICYmIGRlZmF1bHREZWNpbWFsICE9PSBkZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hZGROdW1lcmljU29ydChkZWNpbWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgb25lIHBhcmFtZXRlciBvbnRvIGFub3RoZXJcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIE9iamVjdCB0byBtYXBcbiAgICAgICAgICogIEBwYXJhbSB7Kn0ga25ldyBUaGUgbmV3IHBhcmFtZXRlciBuYW1lXG4gICAgICAgICAqICBAcGFyYW0geyp9IG9sZCBUaGUgb2xkIHBhcmFtZXRlciBuYW1lXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2ZuQ29tcGF0TWFwID0gZnVuY3Rpb24gKG8sIGtuZXcsIG9sZCkge1xuICAgICAgICAgICAgaWYgKG9ba25ld10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9bb2xkXSA9IG9ba25ld107XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgdGhlIG1haW4gRFQgb3B0aW9ucy4gTm90ZSB0aGF0IHRoZSBuZXdcbiAgICAgICAgICogb3B0aW9ucyBhcmUgbWFwcGVkIG9udG8gdGhlIG9sZCBwYXJhbWV0ZXJzLCBzbyB0aGlzIGlzIGFuIGV4dGVybmFsIGludGVyZmFjZVxuICAgICAgICAgKiBjaGFuZ2Ugb25seS5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBpbml0IE9iamVjdCB0byBtYXBcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNvbXBhdE9wdHMoaW5pdCkge1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlcmluZycsICdiU29ydCcpO1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlck11bHRpJywgJ2JTb3J0TXVsdGknKTtcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJDbGFzc2VzJywgJ2JTb3J0Q2xhc3NlcycpO1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlckNlbGxzVG9wJywgJ2JTb3J0Q2VsbHNUb3AnKTtcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXInLCAnYWFTb3J0aW5nJyk7XG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyRml4ZWQnLCAnYWFTb3J0aW5nRml4ZWQnKTtcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAncGFnaW5nJywgJ2JQYWdpbmF0ZScpO1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdpbmdUeXBlJywgJ3NQYWdpbmF0aW9uVHlwZScpO1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdwYWdlTGVuZ3RoJywgJ2lEaXNwbGF5TGVuZ3RoJyk7XG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ3NlYXJjaGluZycsICdiRmlsdGVyJyk7XG5cbiAgICAgICAgICAgIC8vIEJvb2xlYW4gaW5pdGlhbGlzYXRpb24gb2YgeC1zY3JvbGxpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdC5zU2Nyb2xsWCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5zU2Nyb2xsWCA9IGluaXQuc1Njcm9sbFggPyAnMTAwJScgOiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdC5zY3JvbGxYID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBpbml0LnNjcm9sbFggPSBpbml0LnNjcm9sbFggPyAnMTAwJScgOiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29sdW1uIHNlYXJjaCBvYmplY3RzIGFyZSBpbiBhbiBhcnJheSwgc28gaXQgbmVlZHMgdG8gYmUgY29udmVydGVkXG4gICAgICAgICAgICAvLyBlbGVtZW50IGJ5IGVsZW1lbnRcbiAgICAgICAgICAgIHZhciBzZWFyY2hDb2xzID0gaW5pdC5hb1NlYXJjaENvbHM7XG5cbiAgICAgICAgICAgIGlmIChzZWFyY2hDb2xzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNlYXJjaENvbHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaENvbHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNhbWVsVG9IdW5nYXJpYW4oRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoLCBzZWFyY2hDb2xzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGNvbHVtbiBvcHRpb25zLiBOb3RlIHRoYXQgdGhlIG5ldyBvcHRpb25zXG4gICAgICAgICAqIGFyZSBtYXBwZWQgb250byB0aGUgb2xkIHBhcmFtZXRlcnMsIHNvIHRoaXMgaXMgYW4gZXh0ZXJuYWwgaW50ZXJmYWNlIGNoYW5nZVxuICAgICAgICAgKiBvbmx5LlxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGluaXQgT2JqZWN0IHRvIG1hcFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQ29tcGF0Q29scyhpbml0KSB7XG4gICAgICAgICAgICBfZm5Db21wYXRNYXAoaW5pdCwgJ29yZGVyYWJsZScsICdiU29ydGFibGUnKTtcbiAgICAgICAgICAgIF9mbkNvbXBhdE1hcChpbml0LCAnb3JkZXJEYXRhJywgJ2FEYXRhU29ydCcpO1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlclNlcXVlbmNlJywgJ2FzU29ydGluZycpO1xuICAgICAgICAgICAgX2ZuQ29tcGF0TWFwKGluaXQsICdvcmRlckRhdGFUeXBlJywgJ3NvcnREYXRhVHlwZScpO1xuXG4gICAgICAgICAgICAvLyBvcmRlckRhdGEgY2FuIGJlIGdpdmVuIGFzIGFuIGludGVnZXJcbiAgICAgICAgICAgIHZhciBkYXRhU29ydCA9IGluaXQuYURhdGFTb3J0O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhU29ydCA9PT0gJ251bWJlcicgJiYgIUFycmF5LmlzQXJyYXkoZGF0YVNvcnQpKSB7XG4gICAgICAgICAgICAgICAgaW5pdC5hRGF0YVNvcnQgPSBbZGF0YVNvcnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnJvd3NlciBmZWF0dXJlIGRldGVjdGlvbiBmb3IgY2FwYWJpbGl0aWVzLCBxdWlya3NcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5Ccm93c2VyRGV0ZWN0KHNldHRpbmdzKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGRvIHRoaXMgZXZlcnkgdGltZSBEYXRhVGFibGVzIGlzIGNvbnN0cnVjdGVkLCB0aGUgdmFsdWVzXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGVkIGFyZSBzcGVjaWZpYyB0byB0aGUgYnJvd3NlciBhbmQgT1MgY29uZmlndXJhdGlvbiB3aGljaCB3ZVxuICAgICAgICAgICAgLy8gZG9uJ3QgZXhwZWN0IHRvIGNoYW5nZSBiZXR3ZWVuIGluaXRpYWxpc2F0aW9uc1xuICAgICAgICAgICAgaWYgKCFEYXRhVGFibGUuX19icm93c2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJyb3dzZXIgPSB7fTtcbiAgICAgICAgICAgICAgICBEYXRhVGFibGUuX19icm93c2VyID0gYnJvd3NlcjtcblxuICAgICAgICAgICAgICAgIC8vIFNjcm9sbGluZyBmZWF0dXJlIC8gcXVpcmtzIGRldGVjdGlvblxuICAgICAgICAgICAgICAgIHZhciBuID0gJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6ICQod2luZG93KS5zY3JvbGxMZWZ0KCkgKiAtMSwgLy8gYWxsb3cgZm9yIHNjcm9sbGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAxMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKCdib2R5Jyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3V0ZXIgPSBuLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICAgICAgdmFyIGlubmVyID0gb3V0ZXIuY2hpbGRyZW4oKTtcblxuICAgICAgICAgICAgICAgIC8vIE51bWJlcnMgYmVsb3csIGluIG9yZGVyLCBhcmU6XG4gICAgICAgICAgICAgICAgLy8gaW5uZXIub2Zmc2V0V2lkdGgsIGlubmVyLmNsaWVudFdpZHRoLCBvdXRlci5vZmZzZXRXaWR0aCwgb3V0ZXIuY2xpZW50V2lkdGhcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vIElFNiBYUDogICAgICAgICAgICAgICAgICAgICAgICAgICAxMDAgMTAwIDEwMCAgODNcbiAgICAgICAgICAgICAgICAvLyBJRTcgVmlzdGE6ICAgICAgICAgICAgICAgICAgICAgICAgMTAwIDEwMCAxMDAgIDgzXG4gICAgICAgICAgICAgICAgLy8gSUUgOCsgV2luZG93czogICAgICAgICAgICAgICAgICAgICA4MyAgODMgMTAwICA4M1xuICAgICAgICAgICAgICAgIC8vIEV2ZXJncmVlbiBXaW5kb3dzOiAgICAgICAgICAgICAgICAgODMgIDgzIDEwMCAgODNcbiAgICAgICAgICAgICAgICAvLyBFdmVyZ3JlZW4gTWFjIHdpdGggc2Nyb2xsYmFyczogICAgIDg1ICA4NSAxMDAgIDg1XG4gICAgICAgICAgICAgICAgLy8gRXZlcmdyZWVuIE1hYyB3aXRob3V0IHNjcm9sbGJhcnM6IDEwMCAxMDAgMTAwIDEwMFxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHNjcm9sbGJhciB3aWR0aFxuICAgICAgICAgICAgICAgIGJyb3dzZXIuYmFyV2lkdGggPSBvdXRlclswXS5vZmZzZXRXaWR0aCAtIG91dGVyWzBdLmNsaWVudFdpZHRoO1xuXG4gICAgICAgICAgICAgICAgLy8gSUU2Lzcgd2lsbCBvdmVyc2l6ZSBhIHdpZHRoIDEwMCUgZWxlbWVudCBpbnNpZGUgYSBzY3JvbGxpbmcgZWxlbWVudCwgdG9cbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRlIHRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsYmFyLCB3aGlsZSBvdGhlciBicm93c2VycyBlbnN1cmUgdGhlIGlubmVyXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBjb250YWluZWQgd2l0aG91dCBmb3JjaW5nIHNjcm9sbGluZ1xuICAgICAgICAgICAgICAgIGJyb3dzZXIuYlNjcm9sbE92ZXJzaXplID0gaW5uZXJbMF0ub2Zmc2V0V2lkdGggPT09IDEwMCAmJiBvdXRlclswXS5jbGllbnRXaWR0aCAhPT0gMTAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSW4gcnRsIHRleHQgbGF5b3V0LCBzb21lIGJyb3dzZXJzIChtb3N0LCBidXQgbm90IGFsbCkgd2lsbCBwbGFjZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBzY3JvbGxiYXIgb24gdGhlIGxlZnQsIHJhdGhlciB0aGFuIHRoZSByaWdodC5cbiAgICAgICAgICAgICAgICBicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID0gTWF0aC5yb3VuZChpbm5lci5vZmZzZXQoKS5sZWZ0KSAhPT0gMTtcblxuICAgICAgICAgICAgICAgIC8vIElFOC0gZG9uJ3QgcHJvdmlkZSBoZWlnaHQgYW5kIHdpZHRoIGZvciBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgICAgICAgICAgICBicm93c2VyLmJCb3VuZGluZyA9IG5bMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkLmV4dGVuZChzZXR0aW5ncy5vQnJvd3NlciwgRGF0YVRhYmxlLl9fYnJvd3Nlcik7XG4gICAgICAgICAgICBzZXR0aW5ncy5vU2Nyb2xsLmlCYXJXaWR0aCA9IERhdGFUYWJsZS5fX2Jyb3dzZXIuYmFyV2lkdGg7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcnJheS5wcm90b3R5cGUgcmVkdWNlW1JpZ2h0XSBtZXRob2QsIHVzZWQgZm9yIGJyb3dzZXJzIHdoaWNoIGRvbid0IHN1cHBvcnRcbiAgICAgICAgICogSlMgMS42LiBEb25lIHRoaXMgd2F5IHRvIHJlZHVjZSBjb2RlIHNpemUsIHNpbmNlIHdlIGl0ZXJhdGUgZWl0aGVyIHdheVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblJlZHVjZSh0aGF0LCBmbiwgaW5pdCwgc3RhcnQsIGVuZCwgaW5jKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBpID0gc3RhcnQsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgaXNTZXQgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gaW5pdDtcbiAgICAgICAgICAgICAgICBpc1NldCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChpICE9PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoYXQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc1NldCA/XG4gICAgICAgICAgICAgICAgICAgIGZuKHZhbHVlLCB0aGF0W2ldLCBpLCB0aGF0KSA6XG4gICAgICAgICAgICAgICAgICAgIHRoYXRbaV07XG5cbiAgICAgICAgICAgICAgICBpc1NldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaSArPSBpbmM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBjb2x1bW4gdG8gdGhlIGxpc3QgdXNlZCBmb3IgdGhlIHRhYmxlIHdpdGggZGVmYXVsdCB2YWx1ZXNcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gblRoIFRoZSB0aCBlbGVtZW50IGZvciB0aGlzIGNvbHVtblxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5BZGRDb2x1bW4ob1NldHRpbmdzLCBuVGgpIHtcbiAgICAgICAgICAgIC8vIEFkZCBjb2x1bW4gdG8gYW9Db2x1bW5zIGFycmF5XG4gICAgICAgICAgICB2YXIgb0RlZmF1bHRzID0gRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbjtcbiAgICAgICAgICAgIHZhciBpQ29sID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgb0NvbCA9ICQuZXh0ZW5kKHt9LCBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4sIG9EZWZhdWx0cywge1xuICAgICAgICAgICAgICAgIFwiblRoXCI6IG5UaCA/IG5UaCA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyksXG4gICAgICAgICAgICAgICAgXCJzVGl0bGVcIjogb0RlZmF1bHRzLnNUaXRsZSA/IG9EZWZhdWx0cy5zVGl0bGUgOiBuVGggPyBuVGguaW5uZXJIVE1MIDogJycsXG4gICAgICAgICAgICAgICAgXCJhRGF0YVNvcnRcIjogb0RlZmF1bHRzLmFEYXRhU29ydCA/IG9EZWZhdWx0cy5hRGF0YVNvcnQgOiBbaUNvbF0sXG4gICAgICAgICAgICAgICAgXCJtRGF0YVwiOiBvRGVmYXVsdHMubURhdGEgPyBvRGVmYXVsdHMubURhdGEgOiBpQ29sLFxuICAgICAgICAgICAgICAgIGlkeDogaUNvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvU2V0dGluZ3MuYW9Db2x1bW5zLnB1c2gob0NvbCk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBzZWFyY2ggb2JqZWN0IGZvciBjb2x1bW4gc3BlY2lmaWMgc2VhcmNoLiBOb3RlIHRoYXQgdGhlIGBzZWFyY2hDb2xzWyBpQ29sIF1gXG4gICAgICAgICAgICAvLyBwYXNzZWQgaW50byBleHRlbmQgY2FuIGJlIHVuZGVmaW5lZC4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZ2l2ZSBhIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIHdpdGggb25seSBzb21lIG9mIHRoZSBwYXJhbWV0ZXJzIGRlZmluZWQsIGFuZCBhbHNvIG5vdCBnaXZlIGEgZGVmYXVsdFxuICAgICAgICAgICAgdmFyIHNlYXJjaENvbHMgPSBvU2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuICAgICAgICAgICAgc2VhcmNoQ29sc1tpQ29sXSA9ICQuZXh0ZW5kKHt9LCBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2gsIHNlYXJjaENvbHNbaUNvbF0pO1xuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHQgY29sdW1uIG9wdGlvbnMgZnVuY3Rpb24gdG8gaW5pdGlhbGlzZSBjbGFzc2VzIGV0Y1xuICAgICAgICAgICAgX2ZuQ29sdW1uT3B0aW9ucyhvU2V0dGluZ3MsIGlDb2wsICQoblRoKS5kYXRhKCkpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHkgb3B0aW9ucyBmb3IgYSBjb2x1bW5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBpQ29sIGNvbHVtbiBpbmRleCB0byBjb25zaWRlclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9PcHRpb25zIG9iamVjdCB3aXRoIHNUeXBlLCBiVmlzaWJsZSBhbmQgYlNlYXJjaGFibGUgZXRjXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNvbHVtbk9wdGlvbnMob1NldHRpbmdzLCBpQ29sLCBvT3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG9Db2wgPSBvU2V0dGluZ3MuYW9Db2x1bW5zW2lDb2xdO1xuICAgICAgICAgICAgdmFyIG9DbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuICAgICAgICAgICAgdmFyIHRoID0gJChvQ29sLm5UaCk7XG5cbiAgICAgICAgICAgIC8vIFRyeSB0byBnZXQgd2lkdGggaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBXZSBjYW4ndCBnZXQgaXQgZnJvbSBDU1NcbiAgICAgICAgICAgIC8vIGFzIHdlJ2QgbmVlZCB0byBwYXJzZSB0aGUgQ1NTIHN0eWxlc2hlZXQuIGB3aWR0aGAgb3B0aW9uIGNhbiBvdmVycmlkZVxuICAgICAgICAgICAgaWYgKCFvQ29sLnNXaWR0aE9yaWcpIHtcbiAgICAgICAgICAgICAgICAvLyBXaWR0aCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICBvQ29sLnNXaWR0aE9yaWcgPSB0aC5hdHRyKCd3aWR0aCcpIHx8IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBTdHlsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB2YXIgdCA9ICh0aC5hdHRyKCdzdHlsZScpIHx8ICcnKS5tYXRjaCgvd2lkdGg6XFxzKihcXGQrW3B4ZW0lXSspLyk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgb0NvbC5zV2lkdGhPcmlnID0gdFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIFVzZXIgc3BlY2lmaWVkIGNvbHVtbiBvcHRpb25zICovXG4gICAgICAgICAgICBpZiAob09wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiBvT3B0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgX2ZuQ29tcGF0Q29scyhvT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvLyBNYXAgY2FtZWwgY2FzZSBwYXJhbWV0ZXJzIHRvIHRoZWlyIEh1bmdhcmlhbiBjb3VudGVycGFydHNcbiAgICAgICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuKERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4sIG9PcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8qIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBtRGF0YVByb3AgKi9cbiAgICAgICAgICAgICAgICBpZiAob09wdGlvbnMubURhdGFQcm9wICE9PSB1bmRlZmluZWQgJiYgIW9PcHRpb25zLm1EYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIG9PcHRpb25zLm1EYXRhID0gb09wdGlvbnMubURhdGFQcm9wO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucy5zVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBvQ29sLl9zTWFudWFsVHlwZSA9IG9PcHRpb25zLnNUeXBlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGBjbGFzc2AgaXMgYSByZXNlcnZlZCB3b3JkIGluIEphdmFzY3JpcHQsIHNvIHdlIG5lZWQgdG8gcHJvdmlkZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBhYmlsaXR5IHRvIHVzZSBhIHZhbGlkIG5hbWUgZm9yIHRoZSBjYW1lbCBjYXNlIGlucHV0XG4gICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLmNsYXNzTmFtZSAmJiAhb09wdGlvbnMuc0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9PcHRpb25zLnNDbGFzcyA9IG9PcHRpb25zLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9PcHRpb25zLnNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICB0aC5hZGRDbGFzcyhvT3B0aW9ucy5zQ2xhc3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICQuZXh0ZW5kKG9Db2wsIG9PcHRpb25zKTtcbiAgICAgICAgICAgICAgICBfZm5NYXAob0NvbCwgb09wdGlvbnMsIFwic1dpZHRoXCIsIFwic1dpZHRoT3JpZ1wiKTtcblxuICAgICAgICAgICAgICAgIC8qIGlEYXRhU29ydCB0byBiZSBhcHBsaWVkIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSksIGJ1dCBhRGF0YVNvcnQgd2lsbCB0YWtlXG4gICAgICAgICAgICAgICAgICogcHJpb3JpdHkgaWYgZGVmaW5lZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChvT3B0aW9ucy5pRGF0YVNvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvQ29sLmFEYXRhU29ydCA9IFtvT3B0aW9ucy5pRGF0YVNvcnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfZm5NYXAob0NvbCwgb09wdGlvbnMsIFwiYURhdGFTb3J0XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBDYWNoZSB0aGUgZGF0YSBnZXQgYW5kIHNldCBmdW5jdGlvbnMgZm9yIHNwZWVkICovXG4gICAgICAgICAgICB2YXIgbURhdGFTcmMgPSBvQ29sLm1EYXRhO1xuICAgICAgICAgICAgdmFyIG1EYXRhID0gX2ZuR2V0T2JqZWN0RGF0YUZuKG1EYXRhU3JjKTtcbiAgICAgICAgICAgIHZhciBtUmVuZGVyID0gb0NvbC5tUmVuZGVyID8gX2ZuR2V0T2JqZWN0RGF0YUZuKG9Db2wubVJlbmRlcikgOiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgYXR0clRlc3QgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnICYmIHNyYy5pbmRleE9mKCdAJykgIT09IC0xO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG9Db2wuX2JBdHRyU3JjID0gJC5pc1BsYWluT2JqZWN0KG1EYXRhU3JjKSAmJiAoXG4gICAgICAgICAgICAgICAgYXR0clRlc3QobURhdGFTcmMuc29ydCkgfHwgYXR0clRlc3QobURhdGFTcmMudHlwZSkgfHwgYXR0clRlc3QobURhdGFTcmMuZmlsdGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG9Db2wuX3NldHRlciA9IG51bGw7XG5cbiAgICAgICAgICAgIG9Db2wuZm5HZXREYXRhID0gZnVuY3Rpb24gKHJvd0RhdGEsIHR5cGUsIG1ldGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJEYXRhID0gbURhdGEocm93RGF0YSwgdHlwZSwgdW5kZWZpbmVkLCBtZXRhKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBtUmVuZGVyICYmIHR5cGUgP1xuICAgICAgICAgICAgICAgICAgICBtUmVuZGVyKGlubmVyRGF0YSwgdHlwZSwgcm93RGF0YSwgbWV0YSkgOlxuICAgICAgICAgICAgICAgICAgICBpbm5lckRhdGE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb0NvbC5mblNldERhdGEgPSBmdW5jdGlvbiAocm93RGF0YSwgdmFsLCBtZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mblNldE9iamVjdERhdGFGbihtRGF0YVNyYykocm93RGF0YSwgdmFsLCBtZXRhKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEluZGljYXRlIGlmIERhdGFUYWJsZXMgc2hvdWxkIHJlYWQgRE9NIGRhdGEgYXMgYW4gb2JqZWN0IG9yIGFycmF5XG4gICAgICAgICAgICAvLyBVc2VkIGluIF9mbkdldFJvd0VsZW1lbnRzXG4gICAgICAgICAgICBpZiAodHlwZW9mIG1EYXRhU3JjICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5fcm93UmVhZE9iamVjdCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIEZlYXR1cmUgc29ydGluZyBvdmVycmlkZXMgY29sdW1uIHNwZWNpZmljIHdoZW4gb2ZmICovXG4gICAgICAgICAgICBpZiAoIW9TZXR0aW5ncy5vRmVhdHVyZXMuYlNvcnQpIHtcbiAgICAgICAgICAgICAgICBvQ29sLmJTb3J0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoLmFkZENsYXNzKG9DbGFzc2VzLnNTb3J0YWJsZU5vbmUpOyAvLyBIYXZlIHRvIGFkZCBjbGFzcyBoZXJlIGFzIG9yZGVyIGV2ZW50IGlzbid0IGNhbGxlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBDaGVjayB0aGF0IHRoZSBjbGFzcyBhc3NpZ25tZW50IGlzIGNvcnJlY3QgZm9yIHNvcnRpbmcgKi9cbiAgICAgICAgICAgIHZhciBiQXNjID0gJC5pbkFycmF5KCdhc2MnLCBvQ29sLmFzU29ydGluZykgIT09IC0xO1xuICAgICAgICAgICAgdmFyIGJEZXNjID0gJC5pbkFycmF5KCdkZXNjJywgb0NvbC5hc1NvcnRpbmcpICE9PSAtMTtcbiAgICAgICAgICAgIGlmICghb0NvbC5iU29ydGFibGUgfHwgKCFiQXNjICYmICFiRGVzYykpIHtcbiAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3MgPSBvQ2xhc3Nlcy5zU29ydGFibGVOb25lO1xuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzc0pVSSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChiQXNjICYmICFiRGVzYykge1xuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZUFzYztcbiAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSUFzY0FsbG93ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghYkFzYyAmJiBiRGVzYykge1xuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZURlc2M7XG4gICAgICAgICAgICAgICAgb0NvbC5zU29ydGluZ0NsYXNzSlVJID0gb0NsYXNzZXMuc1NvcnRKVUlEZXNjQWxsb3dlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9Db2wuc1NvcnRpbmdDbGFzcyA9IG9DbGFzc2VzLnNTb3J0YWJsZTtcbiAgICAgICAgICAgICAgICBvQ29sLnNTb3J0aW5nQ2xhc3NKVUkgPSBvQ2xhc3Nlcy5zU29ydEpVSTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkanVzdCB0aGUgdGFibGUgY29sdW1uIHdpZHRocyBmb3IgbmV3IGRhdGEuIE5vdGU6IHlvdSB3b3VsZCBwcm9iYWJseSB3YW50IHRvXG4gICAgICAgICAqIGRvIGEgcmVkcmF3IGFmdGVyIGNhbGxpbmcgdGhpcyBmdW5jdGlvbiFcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5BZGp1c3RDb2x1bW5TaXppbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIC8qIE5vdCBpbnRlcmVzdGVkIGluIGRvaW5nIGNvbHVtbiB3aWR0aCBjYWxjdWxhdGlvbiBpZiBhdXRvLXdpZHRoIGlzIGRpc2FibGVkICovXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJBdXRvV2lkdGggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG5cbiAgICAgICAgICAgICAgICBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMoc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uc1tpXS5uVGguc3R5bGUud2lkdGggPSBjb2x1bW5zW2ldLnNXaWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY3JvbGwgPSBzZXR0aW5ncy5vU2Nyb2xsO1xuICAgICAgICAgICAgaWYgKHNjcm9sbC5zWSAhPT0gJycgfHwgc2Nyb2xsLnNYICE9PSAnJykge1xuICAgICAgICAgICAgICAgIF9mblNjcm9sbERyYXcoc2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tc2l6aW5nJywgW3NldHRpbmdzXSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb3ZlcnQgdGhlIGluZGV4IG9mIGEgdmlzaWJsZSBjb2x1bW4gdG8gdGhlIGluZGV4IGluIHRoZSBkYXRhIGFycmF5ICh0YWtlIGFjY291bnRcbiAgICAgICAgICogb2YgaGlkZGVuIGNvbHVtbnMpXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gaU1hdGNoIFZpc2libGUgY29sdW1uIGluZGV4IHRvIGxvb2t1cFxuICAgICAgICAgKiAgQHJldHVybnMge2ludH0gaSB0aGUgZGF0YSBpbmRleFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChvU2V0dGluZ3MsIGlNYXRjaCkge1xuICAgICAgICAgICAgdmFyIGFpVmlzID0gX2ZuR2V0Q29sdW1ucyhvU2V0dGluZ3MsICdiVmlzaWJsZScpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGFpVmlzW2lNYXRjaF0gPT09ICdudW1iZXInID9cbiAgICAgICAgICAgICAgICBhaVZpc1tpTWF0Y2hdIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ292ZXJ0IHRoZSBpbmRleCBvZiBhbiBpbmRleCBpbiB0aGUgZGF0YSBhcnJheSBhbmQgY29udmVydCBpdCB0byB0aGUgdmlzaWJsZVxuICAgICAgICAgKiAgIGNvbHVtbiBpbmRleCAodGFrZSBhY2NvdW50IG9mIGhpZGRlbiBjb2x1bW5zKVxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlNYXRjaCBDb2x1bW4gaW5kZXggdG8gbG9va3VwXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpIHRoZSBkYXRhIGluZGV4XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKG9TZXR0aW5ncywgaU1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgYWlWaXMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyk7XG4gICAgICAgICAgICB2YXIgaVBvcyA9ICQuaW5BcnJheShpTWF0Y2gsIGFpVmlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGlQb3MgIT09IC0xID8gaVBvcyA6IG51bGw7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGkgdGhlIG51bWJlciBvZiB2aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuVmlzYmxlQ29sdW1ucyhvU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciB2aXMgPSAwO1xuXG4gICAgICAgICAgICAvLyBObyByZWR1Y2UgaW4gSUU4LCB1c2UgYSBsb29wIGZvciBub3dcbiAgICAgICAgICAgICQuZWFjaChvU2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbiAoaSwgY29sKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbC5iVmlzaWJsZSAmJiAkKGNvbC5uVGgpLmNzcygnZGlzcGxheScpICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlzKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB2aXM7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgdGhhdCBtYXRjaCBhIGdpdmVuIHByb3BlcnR5XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1BhcmFtIFBhcmFtZXRlciBpbiBhb0NvbHVtbnMgdG8gbG9vayBmb3IgLSB0eXBpY2FsbHlcbiAgICAgICAgICogICAgYlZpc2libGUgb3IgYlNlYXJjaGFibGVcbiAgICAgICAgICogIEByZXR1cm5zIHthcnJheX0gQXJyYXkgb2YgaW5kZXhlcyB3aXRoIG1hdGNoZWQgcHJvcGVydGllc1xuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgc1BhcmFtKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuXG4gICAgICAgICAgICAkLm1hcChvU2V0dGluZ3MuYW9Db2x1bW5zLCBmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbFtzUGFyYW1dKSB7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaChpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlICd0eXBlJyBvZiBhIGNvbHVtblxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkNvbHVtblR5cGVzKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuICAgICAgICAgICAgdmFyIHR5cGVzID0gRGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdDtcbiAgICAgICAgICAgIHZhciBpLCBpZW4sIGosIGplbiwgaywga2VuO1xuICAgICAgICAgICAgdmFyIGNvbCwgY2VsbCwgZGV0ZWN0ZWRUeXBlLCBjYWNoZTtcblxuICAgICAgICAgICAgLy8gRm9yIGVhY2ggY29sdW1uLCBzcGluIG92ZXIgdGhlXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFjb2wuc1R5cGUgJiYgY29sLl9zTWFudWFsVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjb2wuc1R5cGUgPSBjb2wuX3NNYW51YWxUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29sLnNUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IHR5cGVzLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwLCBrZW4gPSBkYXRhLmxlbmd0aDsgayA8IGtlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgY2FjaGUgYXJyYXkgc28gd2Ugb25seSBuZWVkIHRvIGdldCB0aGUgdHlwZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgZm9ybWF0dGVyIG9uY2UgKHdoZW4gdXNpbmcgbXVsdGlwbGUgZGV0ZWN0b3JzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZVtrXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlW2tdID0gX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIGssIGksICd0eXBlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRUeXBlID0gdHlwZXNbal0oY2FjaGVba10sIHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG51bGwsIHRoZW4gdGhpcyB0eXBlIGNhbid0IGFwcGx5IHRvIHRoaXMgY29sdW1uLCBzb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhdGhlciB0aGFuIHRlc3RpbmcgYWxsIGNlbGxzLCBicmVhayBvdXQuIFRoZXJlIGlzIGFuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhjZXB0aW9uIGZvciB0aGUgbGFzdCB0eXBlIHdoaWNoIGlzIGBodG1sYC4gV2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNjYW4gYWxsIHJvd3Mgc2luY2UgaXQgaXMgcG9zc2libGUgdG8gbWl4IHN0cmluZyBhbmQgSFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHR5cGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkZXRlY3RlZFR5cGUgJiYgaiAhPT0gdHlwZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGEgc2luZ2xlIG1hdGNoIGlzIG5lZWRlZCBmb3IgaHRtbCB0eXBlIHNpbmNlIGl0IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYm90dG9tIG9mIHRoZSBwaWxlIGFuZCB2ZXJ5IHNpbWlsYXIgdG8gc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldGVjdGVkVHlwZSA9PT0gJ2h0bWwnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHlwZSBpcyB2YWxpZCBmb3IgYWxsIGRhdGEgcG9pbnRzIGluIHRoZSBjb2x1bW4gLSB1c2UgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRldGVjdGVkVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5zVHlwZSA9IGRldGVjdGVkVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgYmFjayAtIGlmIG5vIHR5cGUgd2FzIGRldGVjdGVkLCBhbHdheXMgdXNlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbC5zVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sLnNUeXBlID0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlIHRoZSBjb2x1bW4gZGVmaW5pdGlvbnMgYW5kIHN0YXRpYyBjb2x1bW5zIGFycmF5cyBhbmQgY2FsY3VsYXRlIGhvd1xuICAgICAgICAgKiB0aGV5IHJlbGF0ZSB0byBjb2x1bW4gaW5kZXhlcy4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgdGhlbiBhcHBseSB0aGVcbiAgICAgICAgICogZGVmaW5pdGlvbiBmb3VuZCBmb3IgYSBjb2x1bW4gdG8gYSBzdWl0YWJsZSBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGFvQ29sRGVmcyBUaGUgYW9Db2x1bW5EZWZzIGFycmF5IHRoYXQgaXMgdG8gYmUgYXBwbGllZFxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYW9Db2xzIFRoZSBhb0NvbHVtbnMgYXJyYXkgdGhhdCBkZWZpbmVzIGNvbHVtbnMgaW5kaXZpZHVhbGx5XG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBDYWxsYmFjayBmdW5jdGlvbiAtIHRha2VzIHR3byBwYXJhbWV0ZXJzLCB0aGUgY2FsY3VsYXRlZFxuICAgICAgICAgKiAgICBjb2x1bW4gaW5kZXggYW5kIHRoZSBkZWZpbml0aW9uIGZvciB0aGF0IGNvbHVtbi5cbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQXBwbHlDb2x1bW5EZWZzKG9TZXR0aW5ncywgYW9Db2xEZWZzLCBhb0NvbHMsIGZuKSB7XG4gICAgICAgICAgICB2YXIgaSwgaUxlbiwgaiwgakxlbiwgaywga0xlbiwgZGVmO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXG4gICAgICAgICAgICAvLyBDb2x1bW4gZGVmaW5pdGlvbnMgd2l0aCBhVGFyZ2V0c1xuICAgICAgICAgICAgaWYgKGFvQ29sRGVmcykge1xuICAgICAgICAgICAgICAgIC8qIExvb3Agb3ZlciB0aGUgZGVmaW5pdGlvbnMgYXJyYXkgLSBsb29wIGluIHJldmVyc2Ugc28gZmlyc3QgaW5zdGFuY2UgaGFzIHByaW9yaXR5ICovXG4gICAgICAgICAgICAgICAgZm9yIChpID0gYW9Db2xEZWZzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZiA9IGFvQ29sRGVmc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAvKiBFYWNoIGRlZmluaXRpb24gY2FuIHRhcmdldCBtdWx0aXBsZSBjb2x1bW5zLCBhcyBpdCBpcyBhbiBhcnJheSAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgYVRhcmdldHMgPSBkZWYudGFyZ2V0cyAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZi50YXJnZXRzIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZi5hVGFyZ2V0cztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYVRhcmdldHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhVGFyZ2V0cyA9IFthVGFyZ2V0c107XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqTGVuID0gYVRhcmdldHMubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQWRkIGNvbHVtbnMgdGhhdCB3ZSBkb24ndCB5ZXQga25vdyBhYm91dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChjb2x1bW5zLmxlbmd0aCA8PSBhVGFyZ2V0c1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGRDb2x1bW4ob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJbnRlZ2VyLCBiYXNpYyBpbmRleCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGFUYXJnZXRzW2pdLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFUYXJnZXRzW2pdID09PSAnbnVtYmVyJyAmJiBhVGFyZ2V0c1tqXSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBOZWdhdGl2ZSBpbnRlZ2VyLCByaWdodCB0byBsZWZ0IGNvbHVtbiBjb3VudGluZyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKGNvbHVtbnMubGVuZ3RoICsgYVRhcmdldHNbal0sIGRlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYVRhcmdldHNbal0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogQ2xhc3MgbmFtZSBtYXRjaGluZyBvbiBUSCBlbGVtZW50ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMCwga0xlbiA9IGNvbHVtbnMubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhVGFyZ2V0c1tqXSA9PSBcIl9hbGxcIiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJChjb2x1bW5zW2tdLm5UaCkuaGFzQ2xhc3MoYVRhcmdldHNbal0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihrLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTdGF0aWNhbGx5IGRlZmluZWQgY29sdW1ucyBhcnJheVxuICAgICAgICAgICAgaWYgKGFvQ29scykge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0NvbHMubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuKGksIGFvQ29sc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhIGRhdGEgYXJyYXkgdG8gdGhlIHRhYmxlLCBjcmVhdGluZyBET00gbm9kZSBldGMuIFRoaXMgaXMgdGhlIHBhcmFsbGVsIHRvXG4gICAgICAgICAqIF9mbkdhdGhlckRhdGEsIGJ1dCBmb3IgYWRkaW5nIHJvd3MgZnJvbSBhIEphdmFzY3JpcHQgc291cmNlLCByYXRoZXIgdGhhbiBhXG4gICAgICAgICAqIERPTSBzb3VyY2UuXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhRGF0YSBkYXRhIGFycmF5IHRvIGJlIGFkZGVkXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IFtuVHJdIFRSIGVsZW1lbnQgdG8gYWRkIHRvIHRoZSB0YWJsZSAtIG9wdGlvbmFsLiBJZiBub3QgZ2l2ZW4sXG4gICAgICAgICAqICAgIERhdGFUYWJsZXMgd2lsbCBjcmVhdGUgYSByb3cgYXV0b21hdGljYWxseVxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gW2FuVGRzXSBBcnJheSBvZiBURHxUSCBlbGVtZW50cyBmb3IgdGhlIHJvdyAtIG11c3QgYmUgZ2l2ZW5cbiAgICAgICAgICogICAgaWYgblRyIGlzLlxuICAgICAgICAgKiAgQHJldHVybnMge2ludH0gPj0wIGlmIHN1Y2Nlc3NmdWwgKGluZGV4IG9mIG5ldyBhb0RhdGEgZW50cnkpLCAtMSBpZiBmYWlsZWRcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQWRkRGF0YShvU2V0dGluZ3MsIGFEYXRhSW4sIG5UciwgYW5UZHMpIHtcbiAgICAgICAgICAgIC8qIENyZWF0ZSB0aGUgb2JqZWN0IGZvciBzdG9yaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoaXMgbmV3IHJvdyAqL1xuICAgICAgICAgICAgdmFyIGlSb3cgPSBvU2V0dGluZ3MuYW9EYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBvRGF0YSA9ICQuZXh0ZW5kKHRydWUsIHt9LCBEYXRhVGFibGUubW9kZWxzLm9Sb3csIHtcbiAgICAgICAgICAgICAgICBzcmM6IG5UciA/ICdkb20nIDogJ2RhdGEnLFxuICAgICAgICAgICAgICAgIGlkeDogaVJvd1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIG9EYXRhLl9hRGF0YSA9IGFEYXRhSW47XG4gICAgICAgICAgICBvU2V0dGluZ3MuYW9EYXRhLnB1c2gob0RhdGEpO1xuXG4gICAgICAgICAgICAvKiBDcmVhdGUgdGhlIGNlbGxzICovXG4gICAgICAgICAgICB2YXIgblRkLCBzVGhpc1R5cGU7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnM7XG5cbiAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGNvbHVtbiB0eXBlcyBhcyB0aGUgbmV3IGRhdGEgbmVlZHMgdG8gYmUgcmV2YWxpZGF0ZWRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5zW2ldLnNUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogQWRkIHRvIHRoZSBkaXNwbGF5IGFycmF5ICovXG4gICAgICAgICAgICBvU2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLnB1c2goaVJvdyk7XG5cbiAgICAgICAgICAgIHZhciBpZCA9IG9TZXR0aW5ncy5yb3dJZEZuKGFEYXRhSW4pO1xuICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYUlkc1tpZF0gPSBvRGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogQ3JlYXRlIHRoZSBET00gaW5mb3JtYXRpb24sIG9yIHJlZ2lzdGVyIGl0IGlmIGFscmVhZHkgcHJlc2VudCAqL1xuICAgICAgICAgICAgaWYgKG5UciB8fCAhb1NldHRpbmdzLm9GZWF0dXJlcy5iRGVmZXJSZW5kZXIpIHtcbiAgICAgICAgICAgICAgICBfZm5DcmVhdGVUcihvU2V0dGluZ3MsIGlSb3csIG5UciwgYW5UZHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaVJvdztcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBvbmUgb3IgbW9yZSBUUiBlbGVtZW50cyB0byB0aGUgdGFibGUuIEdlbmVyYWxseSB3ZSdkIGV4cGVjdCB0b1xuICAgICAgICAgKiB1c2UgdGhpcyBmb3IgcmVhZGluZyBkYXRhIGZyb20gYSBET00gc291cmNlZCB0YWJsZSwgYnV0IGl0IGNvdWxkIGJlXG4gICAgICAgICAqIHVzZWQgZm9yIGFuIFRSIGVsZW1lbnQuIE5vdGUgdGhhdCBpZiBhIFRSIGlzIGdpdmVuLCBpdCBpcyB1c2VkIChpLmUuXG4gICAgICAgICAqIGl0IGlzIG5vdCBjbG9uZWQpLlxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2FycmF5fG5vZGV8alF1ZXJ5fSB0cnMgVGhlIFRSIGVsZW1lbnQocykgdG8gYWRkIHRvIHRoZSB0YWJsZVxuICAgICAgICAgKiAgQHJldHVybnMge2FycmF5fSBBcnJheSBvZiBpbmRleGVzIGZvciB0aGUgYWRkZWQgcm93c1xuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5BZGRUcihzZXR0aW5ncywgdHJzKSB7XG4gICAgICAgICAgICB2YXIgcm93O1xuXG4gICAgICAgICAgICAvLyBBbGxvdyBhbiBpbmRpdmlkdWFsIG5vZGUgdG8gYmUgcGFzc2VkIGluXG4gICAgICAgICAgICBpZiAoISh0cnMgaW5zdGFuY2VvZiAkKSkge1xuICAgICAgICAgICAgICAgIHRycyA9ICQodHJzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRycy5tYXAoZnVuY3Rpb24gKGksIGVsKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gX2ZuR2V0Um93RWxlbWVudHMoc2V0dGluZ3MsIGVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQWRkRGF0YShzZXR0aW5ncywgcm93LmRhdGEsIGVsLCByb3cuY2VsbHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlIGEgVFIgZWxlbWVudCBhbmQgY29udmVydCBpdCB0byBhbiBpbmRleCBpbiBhb0RhdGFcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gbiB0aGUgVFIgZWxlbWVudCB0byBmaW5kXG4gICAgICAgICAqICBAcmV0dXJucyB7aW50fSBpbmRleCBpZiB0aGUgbm9kZSBpcyBmb3VuZCwgbnVsbCBpZiBub3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuTm9kZVRvRGF0YUluZGV4KG9TZXR0aW5ncywgbikge1xuICAgICAgICAgICAgcmV0dXJuIChuLl9EVF9Sb3dJbmRleCAhPT0gdW5kZWZpbmVkKSA/IG4uX0RUX1Jvd0luZGV4IDogbnVsbDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2UgYSBURCBlbGVtZW50IGFuZCBjb252ZXJ0IGl0IGludG8gYSBjb2x1bW4gZGF0YSBpbmRleCAobm90IHRoZSB2aXNpYmxlIGluZGV4KVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlSb3cgVGhlIHJvdyBudW1iZXIgdGhlIFREL1RIIGNhbiBiZSBmb3VuZCBpblxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuIFRoZSBURC9USCBlbGVtZW50IHRvIGZpbmRcbiAgICAgICAgICogIEByZXR1cm5zIHtpbnR9IGluZGV4IGlmIHRoZSBub2RlIGlzIGZvdW5kLCAtMSBpZiBub3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuTm9kZVRvQ29sdW1uSW5kZXgob1NldHRpbmdzLCBpUm93LCBuKSB7XG4gICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KG4sIG9TZXR0aW5ncy5hb0RhdGFbaVJvd10uYW5DZWxscyk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGRhdGEgZm9yIGEgZ2l2ZW4gY2VsbCBmcm9tIHRoZSBpbnRlcm5hbCBjYWNoZSwgdGFraW5nIGludG8gYWNjb3VudCBkYXRhIG1hcHBpbmdcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHJvd0lkeCBhb0RhdGEgcm93IGlkXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IENvbHVtbiBpbmRleFxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgZGF0YSBnZXQgdHlwZSAoJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnKVxuICAgICAgICAgKiAgQHJldHVybnMgeyp9IENlbGwgZGF0YVxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93SWR4LCBjb2xJZHgsIHR5cGUpIHtcbiAgICAgICAgICAgIHZhciBkcmF3ID0gc2V0dGluZ3MuaURyYXc7XG4gICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG4gICAgICAgICAgICB2YXIgcm93RGF0YSA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdLl9hRGF0YTtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Q29udGVudCA9IGNvbC5zRGVmYXVsdENvbnRlbnQ7XG4gICAgICAgICAgICB2YXIgY2VsbERhdGEgPSBjb2wuZm5HZXREYXRhKHJvd0RhdGEsIHR5cGUsIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nczogc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgcm93OiByb3dJZHgsXG4gICAgICAgICAgICAgICAgY29sOiBjb2xJZHhcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoY2VsbERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5pRHJhd0Vycm9yICE9IGRyYXcgJiYgZGVmYXVsdENvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKHNldHRpbmdzLCAwLCBcIlJlcXVlc3RlZCB1bmtub3duIHBhcmFtZXRlciBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGNvbC5tRGF0YSA9PSAnZnVuY3Rpb24nID8gJ3tmdW5jdGlvbn0nIDogXCInXCIgKyBjb2wubURhdGEgKyBcIidcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCIgZm9yIHJvdyBcIiArIHJvd0lkeCArIFwiLCBjb2x1bW4gXCIgKyBjb2xJZHgsIDQpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhd0Vycm9yID0gZHJhdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDb250ZW50O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsIGFuZCBhIHNwZWNpZmljIGRhdGEgdHlwZSBpcyByZXF1ZXN0ZWQgKGkuZS5cbiAgICAgICAgICAgIC8vIG5vdCB0aGUgb3JpZ2luYWwgZGF0YSksIHdlIGNhbiB1c2UgZGVmYXVsdCBjb2x1bW4gZGF0YVxuICAgICAgICAgICAgaWYgKChjZWxsRGF0YSA9PT0gcm93RGF0YSB8fCBjZWxsRGF0YSA9PT0gbnVsbCkgJiYgZGVmYXVsdENvbnRlbnQgIT09IG51bGwgJiYgdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY2VsbERhdGEgPSBkZWZhdWx0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjZWxsRGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBkYXRhIHNvdXJjZSBpcyBhIGZ1bmN0aW9uLCB0aGVuIHdlIHJ1biBpdCBhbmQgdXNlIHRoZSByZXR1cm4sXG4gICAgICAgICAgICAgICAgLy8gZXhlY3V0aW5nIGluIHRoZSBzY29wZSBvZiB0aGUgZGF0YSBvYmplY3QgKGZvciBpbnN0YW5jZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxEYXRhLmNhbGwocm93RGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChjZWxsRGF0YSA9PT0gbnVsbCAmJiB0eXBlID09ICdkaXNwbGF5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjZWxsRGF0YTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldCB0aGUgdmFsdWUgZm9yIGEgc3BlY2lmaWMgY2VsbCwgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBjYWNoZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gcm93SWR4IGFvRGF0YSByb3cgaWRcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2xJZHggQ29sdW1uIGluZGV4XG4gICAgICAgICAqICBAcGFyYW0geyp9IHZhbCBWYWx1ZSB0byBzZXRcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd0lkeCwgY29sSWR4LCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcbiAgICAgICAgICAgIHZhciByb3dEYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd0lkeF0uX2FEYXRhO1xuXG4gICAgICAgICAgICBjb2wuZm5TZXREYXRhKHJvd0RhdGEsIHZhbCwge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzOiBzZXR0aW5ncyxcbiAgICAgICAgICAgICAgICByb3c6IHJvd0lkeCxcbiAgICAgICAgICAgICAgICBjb2w6IGNvbElkeFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFByaXZhdGUgdmFyaWFibGUgdGhhdCBpcyB1c2VkIHRvIG1hdGNoIGFjdGlvbiBzeW50YXggaW4gdGhlIGRhdGEgcHJvcGVydHkgb2JqZWN0XG4gICAgICAgIHZhciBfX3JlQXJyYXkgPSAvXFxbLio/XFxdJC87XG4gICAgICAgIHZhciBfX3JlRm4gPSAvXFwoXFwpJC87XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNwbGl0IHN0cmluZyBvbiBwZXJpb2RzLCB0YWtpbmcgaW50byBhY2NvdW50IGVzY2FwZWQgcGVyaW9kc1xuICAgICAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gc3BsaXRcbiAgICAgICAgICogQHJldHVybiB7YXJyYXl9IFNwbGl0IHN0cmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU3BsaXRPYmpOb3RhdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiAkLm1hcChzdHIubWF0Y2goLyhcXFxcLnxbXlxcLl0pKy9nKSB8fCBbJyddLCBmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcXFxcXC4vZywgJy4nKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBnZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG4gICAgICAgICAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3RcbiAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBnZXQgZnVuY3Rpb25cbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuR2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QobVNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAvKiBCdWlsZCBhbiBvYmplY3Qgb2YgZ2V0IGZ1bmN0aW9ucywgYW5kIHdyYXAgdGhlbSBpbiBhIHNpbmdsZSBjYWxsICovXG4gICAgICAgICAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgICAgICAgICAkLmVhY2gobVNvdXJjZSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IF9mbkdldE9iamVjdERhdGFGbih2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUsIHJvdywgbWV0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IG9bdHlwZV0gfHwgby5fO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHQoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtU291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyogR2l2ZSBhbiBlbXB0eSBzdHJpbmcgZm9yIHJlbmRlcmluZyAvIHNvcnRpbmcgZXRjICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7IC8vIHR5cGUsIHJvdyBhbmQgbWV0YSBhbHNvIHBhc3NlZCwgYnV0IG5vdCB1c2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbVNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgcm93LCBtZXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtU291cmNlKGRhdGEsIHR5cGUsIHJvdywgbWV0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnc3RyaW5nJyAmJiAobVNvdXJjZS5pbmRleE9mKCcuJykgIT09IC0xIHx8XG4gICAgICAgICAgICAgICAgbVNvdXJjZS5pbmRleE9mKCdbJykgIT09IC0xIHx8IG1Tb3VyY2UuaW5kZXhPZignKCcpICE9PSAtMSkpIHtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSBpcyBhIC4gaW4gdGhlIHNvdXJjZSBzdHJpbmcgdGhlbiB0aGUgZGF0YSBzb3VyY2UgaXMgaW4gYVxuICAgICAgICAgICAgICAgICAqIG5lc3RlZCBvYmplY3Qgc28gd2UgbG9vcCBvdmVyIHRoZSBkYXRhIGZvciBlYWNoIGxldmVsIHRvIGdldCB0aGUgbmV4dFxuICAgICAgICAgICAgICAgICAqIGxldmVsIGRvd24uIE9uIGVhY2ggbG9vcCB3ZSB0ZXN0IGZvciB1bmRlZmluZWQsIGFuZCBpZiBmb3VuZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAqIHJldHVybi4gVGhpcyBhbGxvd3MgZW50aXJlIG9iamVjdHMgdG8gYmUgbWlzc2luZyBhbmQgc0RlZmF1bHRDb250ZW50IHRvXG4gICAgICAgICAgICAgICAgICogYmUgdXNlZCBpZiBkZWZpbmVkLCByYXRoZXIgdGhhbiB0aHJvd2luZyBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBmZXRjaERhdGEgPSBmdW5jdGlvbiAoZGF0YSwgdHlwZSwgc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG91dCwgaW5uZXJTcmM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyYyAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBfZm5TcGxpdE9iak5vdGF0aW9uKHNyYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYS5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIHNwZWNpYWwgbm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheU5vdGF0aW9uID0gYVtpXS5tYXRjaChfX3JlQXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmNOb3RhdGlvbiA9IGFbaV0ubWF0Y2goX19yZUZuKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheU5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFycmF5IG5vdGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUFycmF5LCAnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uZGl0aW9uIGFsbG93cyBzaW1wbHkgW10gdG8gYmUgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2ldICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQgPSBbXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5zcGxpY2UoMCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclNyYyA9IGEuam9pbignLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYXZlcnNlIGVhY2ggZW50cnkgaW4gdGhlIGFycmF5IGdldHRpbmcgdGhlIHByb3BlcnRpZXMgcmVxdWVzdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goZmV0Y2hEYXRhKGRhdGFbal0sIHR5cGUsIGlubmVyU3JjKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHN0cmluZyBpcyBnaXZlbiBpbiBiZXR3ZWVuIHRoZSBhcnJheSBub3RhdGlvbiBpbmRpY2F0b3JzLCB0aGF0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQgdG8gam9pbiB0aGUgc3RyaW5ncyB0b2dldGhlciwgb3RoZXJ3aXNlIGFuIGFycmF5IGlzIHJldHVybmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqb2luID0gYXJyYXlOb3RhdGlvblswXS5zdWJzdHJpbmcoMSwgYXJyYXlOb3RhdGlvblswXS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IChqb2luID09PSBcIlwiKSA/IG91dCA6IG91dC5qb2luKGpvaW4pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbm5lciBjYWxsIHRvIGZldGNoRGF0YSBoYXMgYWxyZWFkeSB0cmF2ZXJzZWQgdGhyb3VnaCB0aGUgcmVtYWluZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2UgcmVxdWVzdGVkLCBzbyB3ZSBleGl0IGZyb20gdGhlIGxvb3BcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZ1bmNOb3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFbaV0gPSBhW2ldLnJlcGxhY2UoX19yZUZuLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FbaV1dKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGFbYVtpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHR5cGUpIHsgLy8gcm93IGFuZCBtZXRhIGFsc28gcGFzc2VkLCBidXQgbm90IHVzZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGF0YShkYXRhLCB0eXBlLCBtU291cmNlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogQXJyYXkgb3IgZmxhdCBvYmplY3QgbWFwcGluZyAqL1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZGF0YSwgdHlwZSkgeyAvLyByb3cgYW5kIG1ldGEgYWxzbyBwYXNzZWQsIGJ1dCBub3QgdXNlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YVttU291cmNlXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBzZXQgZGF0YSBmcm9tIGEgc291cmNlIG9iamVjdCwgdGFraW5nXG4gICAgICAgICAqIGludG8gYWNjb3VudCB0aGUgYWJpbGl0eSB0byB1c2UgbmVzdGVkIG9iamVjdHMgYXMgYSBzb3VyY2VcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludHxmdW5jdGlvbn0gbVNvdXJjZSBUaGUgZGF0YSBzb3VyY2UgZm9yIHRoZSBvYmplY3RcbiAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gRGF0YSBzZXQgZnVuY3Rpb25cbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QobVNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAvKiBVbmxpa2UgZ2V0LCBvbmx5IHRoZSB1bmRlcnNjb3JlIChnbG9iYWwpIG9wdGlvbiBpcyB1c2VkIGZvciBmb3JcbiAgICAgICAgICAgICAgICAgKiBzZXR0aW5nIGRhdGEgc2luY2Ugd2UgZG9uJ3Qga25vdyB0aGUgdHlwZSBoZXJlLiBUaGlzIGlzIHdoeSBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgKiBvcHRpb24gaXMgbm90IGRvY3VtZW50ZWQgZm9yIGBtRGF0YWAgKHdoaWNoIGlzIHJlYWQvd3JpdGUpLCBidXQgaXQgaXNcbiAgICAgICAgICAgICAgICAgKiBmb3IgYG1SZW5kZXJgIHdoaWNoIGlzIHJlYWQgb25seS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZuU2V0T2JqZWN0RGF0YUZuKG1Tb3VyY2UuXyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtU291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLyogTm90aGluZyB0byBkbyB3aGVuIHRoZSBkYXRhIHNvdXJjZSBpcyBudWxsICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtU291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwsIG1ldGEpIHtcbiAgICAgICAgICAgICAgICAgICAgbVNvdXJjZShkYXRhLCAnc2V0JywgdmFsLCBtZXRhKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1Tb3VyY2UgPT09ICdzdHJpbmcnICYmIChtU291cmNlLmluZGV4T2YoJy4nKSAhPT0gLTEgfHxcbiAgICAgICAgICAgICAgICBtU291cmNlLmluZGV4T2YoJ1snKSAhPT0gLTEgfHwgbVNvdXJjZS5pbmRleE9mKCcoJykgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIC8qIExpa2UgdGhlIGdldCwgd2UgbmVlZCB0byBnZXQgZGF0YSBmcm9tIGEgbmVzdGVkIG9iamVjdCAqL1xuICAgICAgICAgICAgICAgIHZhciBzZXREYXRhID0gZnVuY3Rpb24gKGRhdGEsIHZhbCwgc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gX2ZuU3BsaXRPYmpOb3RhdGlvbihzcmMpLCBiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYUxhc3QgPSBhW2EubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcnJheU5vdGF0aW9uLCBmdW5jTm90YXRpb24sIG8sIGlubmVyU3JjO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYS5sZW5ndGggLSAxOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm90ZWN0IGFnYWluc3QgcHJvdG90eXBlIHBvbGx1dGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbaV0gPT09ICdfX3Byb3RvX18nIHx8IGFbaV0gPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgcHJvdG90eXBlIHZhbHVlcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZGVhbGluZyB3aXRoIGFuIGFycmF5IG5vdGF0aW9uIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5Tm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVBcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jTm90YXRpb24gPSBhW2ldLm1hdGNoKF9fcmVGbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJheU5vdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlQXJyYXksICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2FbaV1dID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlbWFpbmRlciBvZiB0aGUgbmVzdGVkIG9iamVjdCB0byBzZXQgc28gd2UgY2FuIHJlY3Vyc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiID0gYS5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuc3BsaWNlKDAsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclNyYyA9IGIuam9pbignLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJhdmVyc2UgZWFjaCBlbnRyeSBpbiB0aGUgYXJyYXkgc2V0dGluZyB0aGUgcHJvcGVydGllcyByZXF1ZXN0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBqTGVuID0gdmFsLmxlbmd0aDsgaiA8IGpMZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RGF0YShvLCB2YWxbal0sIGlubmVyU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbYVtpXV0ucHVzaChvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UndmUgYmVlbiBhc2tlZCB0byBzYXZlIGRhdGEgdG8gYW4gYXJyYXksIGJ1dCBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpc24ndCBhcnJheSBkYXRhIHRvIGJlIHNhdmVkLiBCZXN0IHRoYXQgY2FuIGJlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgdG8ganVzdCBzYXZlIHRoZSB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVthW2ldXSA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5uZXIgY2FsbCB0byBzZXREYXRhIGhhcyBhbHJlYWR5IHRyYXZlcnNlZCB0aHJvdWdoIHRoZSByZW1haW5kZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgc291cmNlIGFuZCBoYXMgc2V0IHRoZSBkYXRhLCB0aHVzIHdlIGNhbiBleGl0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmdW5jTm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYVtpXSA9IGFbaV0ucmVwbGFjZShfX3JlRm4sICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZGF0YVthW2ldXSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmVzdGVkIG9iamVjdCBkb2Vzbid0IGN1cnJlbnRseSBleGlzdCAtIHNpbmNlIHdlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5aW5nIHRvIHNldCB0aGUgdmFsdWUgLSBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2FbaV1dID09PSBudWxsIHx8IGRhdGFbYVtpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbYVtpXV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FbaV1dO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTGFzdCBpdGVtIGluIHRoZSBpbnB1dCAtIGkuZSwgdGhlIGFjdHVhbCBzZXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFMYXN0Lm1hdGNoKF9fcmVGbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhW2FMYXN0LnJlcGxhY2UoX19yZUZuLCAnJyldKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhcnJheSBub3RhdGlvbiBpcyB1c2VkLCB3ZSBqdXN0IHdhbnQgdG8gc3RyaXAgaXQgYW5kIHVzZSB0aGUgcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGFzc2lnbiB0aGUgdmFsdWUuIElmIGl0IGlzbid0IHVzZWQsIHRoZW4gd2UgZ2V0IHRoZSByZXN1bHQgd2Ugd2FudCBhbnl3YXlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbYUxhc3QucmVwbGFjZShfX3JlQXJyYXksICcnKV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhLCB2YWwpIHsgLy8gbWV0YSBpcyBhbHNvIHBhc3NlZCBpbiwgYnV0IG5vdCB1c2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXREYXRhKGRhdGEsIHZhbCwgbVNvdXJjZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIEFycmF5IG9yIGZsYXQgb2JqZWN0IG1hcHBpbmcgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRhdGEsIHZhbCkgeyAvLyBtZXRhIGlzIGFsc28gcGFzc2VkIGluLCBidXQgbm90IHVzZWRcbiAgICAgICAgICAgICAgICAgICAgZGF0YVttU291cmNlXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIGFuIGFycmF5IHdpdGggdGhlIGZ1bGwgdGFibGUgZGF0YVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHJldHVybnMgYXJyYXkge2FycmF5fSBhRGF0YSBNYXN0ZXIgZGF0YSBhcnJheVxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5HZXREYXRhTWFzdGVyKHNldHRpbmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3BsdWNrKHNldHRpbmdzLmFvRGF0YSwgJ19hRGF0YScpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogTnVrZSB0aGUgdGFibGVcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncykge1xuICAgICAgICAgICAgc2V0dGluZ3MuYW9EYXRhLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgc2V0dGluZ3MuYUlkcyA9IHt9O1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgKiBUYWtlIGFuIGFycmF5IG9mIGludGVnZXJzIChpbmRleCBhcnJheSkgYW5kIHJlbW92ZSBhIHRhcmdldCBpbnRlZ2VyICh2YWx1ZSAtIG5vdFxuICAgICAgICAqIHRoZSBrZXkhKVxuICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhIEluZGV4IGFycmF5IHRvIHRhcmdldFxuICAgICAgICAqICBAcGFyYW0ge2ludH0gaVRhcmdldCB2YWx1ZSB0byBmaW5kXG4gICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5EZWxldGVJbmRleChhLCBpVGFyZ2V0LCBzcGxpY2UpIHtcbiAgICAgICAgICAgIHZhciBpVGFyZ2V0SW5kZXggPSAtMTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlMZW4gPSBhLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhW2ldID09IGlUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgaVRhcmdldEluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYVtpXSA+IGlUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYVtpXS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGlUYXJnZXRJbmRleCAhPSAtMSAmJiBzcGxpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGEuc3BsaWNlKGlUYXJnZXRJbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXJrIGNhY2hlZCBkYXRhIGFzIGludmFsaWQgc3VjaCB0aGF0IGEgcmUtcmVhZCBvZiB0aGUgZGF0YSB3aWxsIG9jY3VyIHdoZW5cbiAgICAgICAgICogdGhlIGNhY2hlZCBkYXRhIGlzIG5leHQgcmVxdWVzdGVkLiBBbHNvIHVwZGF0ZSBmcm9tIHRoZSBkYXRhIHNvdXJjZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gICAgcm93SWR4ICAgUm93IGluZGV4IHRvIGludmFsaWRhdGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IFtzcmNdICAgIFNvdXJjZSB0byBpbnZhbGlkYXRlIGZyb206IHVuZGVmaW5lZCwgJ2F1dG8nLCAnZG9tJ1xuICAgICAgICAgKiAgICAgb3IgJ2RhdGEnXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSAgICBbY29sSWR4XSBDb2x1bW4gaW5kZXggdG8gaW52YWxpZGF0ZS4gSWYgdW5kZWZpbmVkIHRoZSB3aG9sZVxuICAgICAgICAgKiAgICAgcm93IHdpbGwgYmUgaW52YWxpZGF0ZWRcbiAgICAgICAgICogQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0b2RvIEZvciB0aGUgbW9kdWxhcmlzYXRpb24gb2YgdjEuMTEgdGhpcyB3aWxsIG5lZWQgdG8gYmVjb21lIGEgY2FsbGJhY2ssIHNvXG4gICAgICAgICAqICAgdGhlIHNvcnQgYW5kIGZpbHRlciBtZXRob2RzIGNhbiBzdWJzY3JpYmUgdG8gaXQuIFRoYXQgd2lsbCByZXF1aXJlZFxuICAgICAgICAgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMgZm9yIHNvcnRpbmcsIHdoaWNoIGlzIHdoeSBpdCBpcyBub3QgYWxyZWFkeSBiYWtlZCBpblxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuSW52YWxpZGF0ZShzZXR0aW5ncywgcm93SWR4LCBzcmMsIGNvbElkeCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtyb3dJZHhdO1xuICAgICAgICAgICAgdmFyIGksIGllbjtcbiAgICAgICAgICAgIHZhciBjZWxsV3JpdGUgPSBmdW5jdGlvbiAoY2VsbCwgY29sKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB2ZXJ5IGZydXN0cmF0aW5nLCBidXQgaW4gSUUgaWYgeW91IGp1c3Qgd3JpdGUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyB0byBpbm5lckhUTUwsIGFuZCBlbGVtZW50cyB0aGF0IGFyZSBvdmVyd3JpdHRlbiBhcmUgR0MnZWQsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBpZiB0aGVyZSBpcyBhIHJlZmVyZW5jZSB0byB0aGVtIGVsc2V3aGVyZVxuICAgICAgICAgICAgICAgIHdoaWxlIChjZWxsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwucmVtb3ZlQ2hpbGQoY2VsbC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjZWxsLmlubmVySFRNTCA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3dJZHgsIGNvbCwgJ2Rpc3BsYXknKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIEFyZSB3ZSByZWFkaW5nIGxhc3QgZGF0YSBmcm9tIERPTSBvciB0aGUgZGF0YSBvYmplY3Q/XG4gICAgICAgICAgICBpZiAoc3JjID09PSAnZG9tJyB8fCAoKCFzcmMgfHwgc3JjID09PSAnYXV0bycpICYmIHJvdy5zcmMgPT09ICdkb20nKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlYWQgdGhlIGRhdGEgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgcm93Ll9hRGF0YSA9IF9mbkdldFJvd0VsZW1lbnRzKFxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncywgcm93LCBjb2xJZHgsIGNvbElkeCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogcm93Ll9hRGF0YVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFkaW5nIGZyb20gZGF0YSBvYmplY3QsIHVwZGF0ZSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gcm93LmFuQ2VsbHM7XG5cbiAgICAgICAgICAgICAgICBpZiAoY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsV3JpdGUoY2VsbHNbY29sSWR4XSwgY29sSWR4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNlbGxzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFdyaXRlKGNlbGxzW2ldLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRm9yIGJvdGggcm93IGFuZCBjZWxsIGludmFsaWRhdGlvbiwgdGhlIGNhY2hlZCBkYXRhIGZvciBzb3J0aW5nIGFuZFxuICAgICAgICAgICAgLy8gZmlsdGVyaW5nIGlzIG51bGxlZCBvdXRcbiAgICAgICAgICAgIHJvdy5fYVNvcnREYXRhID0gbnVsbDtcbiAgICAgICAgICAgIHJvdy5fYUZpbHRlckRhdGEgPSBudWxsO1xuXG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIHRoZSB0eXBlIGZvciBhIHNwZWNpZmljIGNvbHVtbiAoaWYgZ2l2ZW4pIG9yIGFsbCBjb2x1bW5zIHNpbmNlXG4gICAgICAgICAgICAvLyB0aGUgZGF0YSBtaWdodCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgIHZhciBjb2xzID0gc2V0dGluZ3MuYW9Db2x1bW5zO1xuICAgICAgICAgICAgaWYgKGNvbElkeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29sc1tjb2xJZHhdLnNUeXBlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNvbHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sc1tpXS5zVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIERhdGFUYWJsZXMgc3BlY2lhbCBgRFRfKmAgYXR0cmlidXRlcyBmb3IgdGhlIHJvd1xuICAgICAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXMoc2V0dGluZ3MsIHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCdWlsZCBhIGRhdGEgc291cmNlIG9iamVjdCBmcm9tIGFuIEhUTUwgcm93LCByZWFkaW5nIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAgICAgICogY2VsbHMgdGhhdCBhcmUgaW4gdGhlIHJvdy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7bm9kZXxvYmplY3R9IFRSIGVsZW1lbnQgZnJvbSB3aGljaCB0byByZWFkIGRhdGEgb3IgZXhpc3Rpbmcgcm93XG4gICAgICAgICAqICAgb2JqZWN0IGZyb20gd2hpY2ggdG8gcmUtcmVhZCB0aGUgZGF0YSBmcm9tIHRoZSBjZWxsc1xuICAgICAgICAgKiBAcGFyYW0ge2ludH0gW2NvbElkeF0gT3B0aW9uYWwgY29sdW1uIGluZGV4XG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBbZF0gRGF0YSBzb3VyY2Ugb2JqZWN0LiBJZiBgY29sSWR4YCBpcyBnaXZlbiB0aGVuIHRoaXNcbiAgICAgICAgICogICBwYXJhbWV0ZXIgc2hvdWxkIGFsc28gYmUgZ2l2ZW4gYW5kIHdpbGwgYmUgdXNlZCB0byB3cml0ZSB0aGUgZGF0YSBpbnRvLlxuICAgICAgICAgKiAgIE9ubHkgdGhlIGNvbHVtbiBpbiBxdWVzdGlvbiB3aWxsIGJlIHdyaXR0ZW5cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gT2JqZWN0IHdpdGggdHdvIHBhcmFtZXRlcnM6IGBkYXRhYCB0aGUgZGF0YSByZWFkLCBpblxuICAgICAgICAgKiAgIGRvY3VtZW50IG9yZGVyLCBhbmQgYGNlbGxzYCBhbmQgYXJyYXkgb2Ygbm9kZXMgKHRoZXkgY2FuIGJlIHVzZWZ1bCB0byB0aGVcbiAgICAgICAgICogICBjYWxsZXIsIHNvIHJhdGhlciB0aGFuIG5lZWRpbmcgYSBzZWNvbmQgdHJhdmVyc2FsIHRvIGdldCB0aGVtLCBqdXN0IHJldHVyblxuICAgICAgICAgKiAgIHRoZW0gZnJvbSBoZXJlKS5cbiAgICAgICAgICogQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5HZXRSb3dFbGVtZW50cyhzZXR0aW5ncywgcm93LCBjb2xJZHgsIGQpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHRkcyA9IFtdLFxuICAgICAgICAgICAgICAgIHRkID0gcm93LmZpcnN0Q2hpbGQsXG4gICAgICAgICAgICAgICAgbmFtZSwgY29sLCBvLCBpID0gMCwgY29udGVudHMsXG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcbiAgICAgICAgICAgICAgICBvYmplY3RSZWFkID0gc2V0dGluZ3MuX3Jvd1JlYWRPYmplY3Q7XG5cbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBkYXRhIG9iamVjdCB0byBiZSBwYXNzZWQgaW4sIG9yIGNvbnN0cnVjdFxuICAgICAgICAgICAgZCA9IGQgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgZCA6XG4gICAgICAgICAgICAgICAgb2JqZWN0UmVhZCA/XG4gICAgICAgICAgICAgICAgICAgIHt9IDpcbiAgICAgICAgICAgICAgICAgICAgW107XG5cbiAgICAgICAgICAgIHZhciBhdHRyID0gZnVuY3Rpb24gKHN0ciwgdGQpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IHN0ci5pbmRleE9mKCdAJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gc3RyLnN1YnN0cmluZyhpZHggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXR0ZXIgPSBfZm5TZXRPYmplY3REYXRhRm4oc3RyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcihkLCB0ZC5nZXRBdHRyaWJ1dGUoYXR0cikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUmVhZCBkYXRhIGZyb20gYSBjZWxsIGFuZCBzdG9yZSBpbnRvIHRoZSBkYXRhIG9iamVjdFxuICAgICAgICAgICAgdmFyIGNlbGxQcm9jZXNzID0gZnVuY3Rpb24gKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sSWR4ID09PSB1bmRlZmluZWQgfHwgY29sSWR4ID09PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IGNvbHVtbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gKGNlbGwuaW5uZXJIVE1MKS50cmltKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbCAmJiBjb2wuX2JBdHRyU3JjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKGNvbC5tRGF0YS5fKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRlcihkLCBjb250ZW50cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIoY29sLm1EYXRhLnNvcnQsIGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cihjb2wubURhdGEudHlwZSwgY2VsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyKGNvbC5tRGF0YS5maWx0ZXIsIGNlbGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVwZW5kaW5nIG9uIHRoZSBgZGF0YWAgb3B0aW9uIGZvciB0aGUgY29sdW1ucyB0aGUgZGF0YSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlIHJlYWQgdG8gZWl0aGVyIGFuIG9iamVjdCBvciBhbiBhcnJheS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RSZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb2wuX3NldHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0aGUgc2V0dGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5fc2V0dGVyID0gX2ZuU2V0T2JqZWN0RGF0YUZuKGNvbC5tRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbC5fc2V0dGVyKGQsIGNvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRbaV0gPSBjb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0ZCkge1xuICAgICAgICAgICAgICAgIC8vIGB0cmAgZWxlbWVudCB3YXMgcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSB0ZC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiVERcIiB8fCBuYW1lID09IFwiVEhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFByb2Nlc3ModGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGRzLnB1c2godGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGQgPSB0ZC5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFeGlzdGluZyByb3cgb2JqZWN0IHBhc3NlZCBpblxuICAgICAgICAgICAgICAgIHRkcyA9IHJvdy5hbkNlbGxzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IHRkcy5sZW5ndGg7IGogPCBqZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsUHJvY2Vzcyh0ZHNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVhZCB0aGUgSUQgZnJvbSB0aGUgRE9NIGlmIHByZXNlbnRcbiAgICAgICAgICAgIHZhciByb3dOb2RlID0gcm93LmZpcnN0Q2hpbGQgPyByb3cgOiByb3cublRyO1xuXG4gICAgICAgICAgICBpZiAocm93Tm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHJvd05vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mblNldE9iamVjdERhdGFGbihzZXR0aW5ncy5yb3dJZCkoZCwgaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgICAgICAgIGNlbGxzOiB0ZHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhIG5ldyBUUiBlbGVtZW50IChhbmQgaXQncyBURCBjaGlsZHJlbikgZm9yIGEgcm93XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gaVJvdyBSb3cgdG8gY29uc2lkZXJcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gW25UckluXSBUUiBlbGVtZW50IHRvIGFkZCB0byB0aGUgdGFibGUgLSBvcHRpb25hbC4gSWYgbm90IGdpdmVuLFxuICAgICAgICAgKiAgICBEYXRhVGFibGVzIHdpbGwgY3JlYXRlIGEgcm93IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IFthblRkc10gQXJyYXkgb2YgVER8VEggZWxlbWVudHMgZm9yIHRoZSByb3cgLSBtdXN0IGJlIGdpdmVuXG4gICAgICAgICAqICAgIGlmIG5UciBpcy5cbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQ3JlYXRlVHIob1NldHRpbmdzLCBpUm93LCBuVHJJbiwgYW5UZHMpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHJvdyA9IG9TZXR0aW5ncy5hb0RhdGFbaVJvd10sXG4gICAgICAgICAgICAgICAgcm93RGF0YSA9IHJvdy5fYURhdGEsXG4gICAgICAgICAgICAgICAgY2VsbHMgPSBbXSxcbiAgICAgICAgICAgICAgICBuVHIsIG5UZCwgb0NvbCxcbiAgICAgICAgICAgICAgICBpLCBpTGVuLCBjcmVhdGU7XG5cbiAgICAgICAgICAgIGlmIChyb3cublRyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgblRyID0gblRySW4gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblxuICAgICAgICAgICAgICAgIHJvdy5uVHIgPSBuVHI7XG4gICAgICAgICAgICAgICAgcm93LmFuQ2VsbHMgPSBjZWxscztcblxuICAgICAgICAgICAgICAgIC8qIFVzZSBhIHByaXZhdGUgcHJvcGVydHkgb24gdGhlIG5vZGUgdG8gYWxsb3cgcmVzZXJ2ZSBtYXBwaW5nIGZyb20gdGhlIG5vZGVcbiAgICAgICAgICAgICAgICAgKiB0byB0aGUgYW9EYXRhIGFycmF5IGZvciBmYXN0IGxvb2sgdXBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBuVHIuX0RUX1Jvd0luZGV4ID0gaVJvdztcblxuICAgICAgICAgICAgICAgIC8qIFNwZWNpYWwgcGFyYW1ldGVycyBjYW4gYmUgZ2l2ZW4gYnkgdGhlIGRhdGEgc291cmNlIHRvIGJlIHVzZWQgb24gdGhlIHJvdyAqL1xuICAgICAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXMob1NldHRpbmdzLCByb3cpO1xuXG4gICAgICAgICAgICAgICAgLyogUHJvY2VzcyBlYWNoIGNvbHVtbiAqL1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBvU2V0dGluZ3MuYW9Db2x1bW5zLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvQ29sID0gb1NldHRpbmdzLmFvQ29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlID0gblRySW4gPyBmYWxzZSA6IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgblRkID0gY3JlYXRlID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChvQ29sLnNDZWxsVHlwZSkgOiBhblRkc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgblRkLl9EVF9DZWxsSW5kZXggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IGlSb3csXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGlcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBjZWxscy5wdXNoKG5UZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byBjcmVhdGUgdGhlIEhUTUwgaWYgbmV3LCBvciBpZiBhIHJlbmRlcmluZyBmdW5jdGlvbiBpcyBkZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChjcmVhdGUgfHwgKChvQ29sLm1SZW5kZXIgfHwgb0NvbC5tRGF0YSAhPT0gaSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghJC5pc1BsYWluT2JqZWN0KG9Db2wubURhdGEpIHx8IG9Db2wubURhdGEuXyAhPT0gaSArICcuZGlzcGxheScpXG4gICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5UZC5pbm5lckhUTUwgPSBfZm5HZXRDZWxsRGF0YShvU2V0dGluZ3MsIGlSb3csIGksICdkaXNwbGF5Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvKiBBZGQgdXNlciBkZWZpbmVkIGNsYXNzICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChvQ29sLnNDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgblRkLmNsYXNzTmFtZSArPSAnICcgKyBvQ29sLnNDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFZpc2liaWxpdHkgLSBhZGQgb3IgcmVtb3ZlIGFzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChvQ29sLmJWaXNpYmxlICYmICFuVHJJbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgblRyLmFwcGVuZENoaWxkKG5UZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIW9Db2wuYlZpc2libGUgJiYgblRySW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5UZC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5UZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAob0NvbC5mbkNyZWF0ZWRDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvQ29sLmZuQ3JlYXRlZENlbGwuY2FsbChvU2V0dGluZ3Mub0luc3RhbmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5UZCwgX2ZuR2V0Q2VsbERhdGEob1NldHRpbmdzLCBpUm93LCBpKSwgcm93RGF0YSwgaVJvdywgaVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1Jvd0NyZWF0ZWRDYWxsYmFjaycsIG51bGwsIFtuVHIsIHJvd0RhdGEsIGlSb3csIGNlbGxzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYXR0cmlidXRlcyB0byBhIHJvdyBiYXNlZCBvbiB0aGUgc3BlY2lhbCBgRFRfKmAgcGFyYW1ldGVycyBpbiBhIGRhdGFcbiAgICAgICAgICogc291cmNlIG9iamVjdC5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IERhdGFUYWJsZXMgcm93IG9iamVjdCBmb3IgdGhlIHJvdyB0byBiZSBtb2RpZmllZFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5Sb3dBdHRyaWJ1dGVzKHNldHRpbmdzLCByb3cpIHtcbiAgICAgICAgICAgIHZhciB0ciA9IHJvdy5uVHI7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHJvdy5fYURhdGE7XG5cbiAgICAgICAgICAgIGlmICh0cikge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHNldHRpbmdzLnJvd0lkRm4oZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuaWQgPSBpZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5EVF9Sb3dDbGFzcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGNsYXNzZXMgYWRkZWQgYnkgRFRfUm93Q2xhc3MgYmVmb3JlXG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gZGF0YS5EVF9Sb3dDbGFzcy5zcGxpdCgnICcpO1xuICAgICAgICAgICAgICAgICAgICByb3cuX19yb3djID0gcm93Ll9fcm93YyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfdW5pcXVlKHJvdy5fX3Jvd2MuY29uY2F0KGEpKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBhO1xuXG4gICAgICAgICAgICAgICAgICAgICQodHIpXG4gICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3Mocm93Ll9fcm93Yy5qb2luKCcgJykpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoZGF0YS5EVF9Sb3dDbGFzcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuRFRfUm93QXR0cikge1xuICAgICAgICAgICAgICAgICAgICAkKHRyKS5hdHRyKGRhdGEuRFRfUm93QXR0cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuRFRfUm93RGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAkKHRyKS5kYXRhKGRhdGEuRFRfUm93RGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIHRoZSBIVE1MIGhlYWRlciBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkJ1aWxkSGVhZChvU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBpLCBpZW4sIGNlbGwsIHJvdywgY29sdW1uO1xuICAgICAgICAgICAgdmFyIHRoZWFkID0gb1NldHRpbmdzLm5USGVhZDtcbiAgICAgICAgICAgIHZhciB0Zm9vdCA9IG9TZXR0aW5ncy5uVEZvb3Q7XG4gICAgICAgICAgICB2YXIgY3JlYXRlSGVhZGVyID0gJCgndGgsIHRkJywgdGhlYWQpLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBvU2V0dGluZ3MuYW9Db2x1bW5zO1xuXG4gICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gJCgnPHRyLz4nKS5hcHBlbmRUbyh0aGVhZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGNvbHVtbnMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW2ldO1xuICAgICAgICAgICAgICAgIGNlbGwgPSAkKGNvbHVtbi5uVGgpLmFkZENsYXNzKGNvbHVtbi5zQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNyZWF0ZUhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBjZWxsLmFwcGVuZFRvKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gMS4xMSBtb3ZlIGludG8gc29ydGluZ1xuICAgICAgICAgICAgICAgIGlmIChvU2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuYWRkQ2xhc3MoY29sdW1uLnNTb3J0aW5nQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uYlNvcnRhYmxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hdHRyKCd0YWJpbmRleCcsIG9TZXR0aW5ncy5pVGFiSW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBvU2V0dGluZ3Muc1RhYmxlSWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0QXR0YWNoTGlzdGVuZXIob1NldHRpbmdzLCBjb2x1bW4ublRoLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc1RpdGxlICE9IGNlbGxbMF0uaW5uZXJIVE1MKSB7XG4gICAgICAgICAgICAgICAgICAgIGNlbGwuaHRtbChjb2x1bW4uc1RpdGxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfZm5SZW5kZXJlcihvU2V0dGluZ3MsICdoZWFkZXInKShcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY3JlYXRlSGVhZGVyKSB7XG4gICAgICAgICAgICAgICAgX2ZuRGV0ZWN0SGVhZGVyKG9TZXR0aW5ncy5hb0hlYWRlciwgdGhlYWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBBUklBIHJvbGUgZm9yIHRoZSByb3dzICovXG4gICAgICAgICAgICAkKHRoZWFkKS5jaGlsZHJlbigndHInKS5hdHRyKCdyb2xlJywgJ3JvdycpO1xuXG4gICAgICAgICAgICAvKiBEZWFsIHdpdGggdGhlIGZvb3RlciAtIGFkZCBjbGFzc2VzIGlmIHJlcXVpcmVkICovXG4gICAgICAgICAgICAkKHRoZWFkKS5jaGlsZHJlbigndHInKS5jaGlsZHJlbigndGgsIHRkJykuYWRkQ2xhc3MoY2xhc3Nlcy5zSGVhZGVyVEgpO1xuICAgICAgICAgICAgJCh0Zm9vdCkuY2hpbGRyZW4oJ3RyJykuY2hpbGRyZW4oJ3RoLCB0ZCcpLmFkZENsYXNzKGNsYXNzZXMuc0Zvb3RlclRIKTtcblxuICAgICAgICAgICAgLy8gQ2FjaGUgdGhlIGZvb3RlciBjZWxscy4gTm90ZSB0aGF0IHdlIG9ubHkgdGFrZSB0aGUgY2VsbHMgZnJvbSB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIHJvdyBpbiB0aGUgZm9vdGVyLiBJZiB0aGVyZSBpcyBtb3JlIHRoYW4gb25lIHJvdyB0aGUgdXNlciB3YW50cyB0b1xuICAgICAgICAgICAgLy8gaW50ZXJhY3Qgd2l0aCwgdGhleSBuZWVkIHRvIHVzZSB0aGUgdGFibGUoKS5mb290KCkgbWV0aG9kLiBOb3RlIGFsc28gdGhpc1xuICAgICAgICAgICAgLy8gYWxsb3dzIGNlbGxzIHRvIGJlIHVzZWQgZm9yIG11bHRpcGxlIGNvbHVtbnMgdXNpbmcgY29sc3BhblxuICAgICAgICAgICAgaWYgKHRmb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNlbGxzID0gb1NldHRpbmdzLmFvRm9vdGVyWzBdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY2VsbHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uLm5UZiA9IGNlbGxzW2ldLmNlbGw7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbHVtbi5zQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoY29sdW1uLm5UZikuYWRkQ2xhc3MoY29sdW1uLnNDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEcmF3IHRoZSBoZWFkZXIgKG9yIGZvb3RlcikgZWxlbWVudCBiYXNlZCBvbiB0aGUgY29sdW1uIHZpc2liaWxpdHkgc3RhdGVzLiBUaGVcbiAgICAgICAgICogbWV0aG9kb2xvZ3kgaGVyZSBpcyB0byB1c2UgdGhlIGxheW91dCBhcnJheSBmcm9tIF9mbkRldGVjdEhlYWRlciwgbW9kaWZpZWQgZm9yXG4gICAgICAgICAqIHRoZSBpbnN0YW50YW5lb3VzIGNvbHVtbiB2aXNpYmlsaXR5LCB0byBjb25zdHJ1Y3QgdGhlIG5ldyBsYXlvdXQuIFRoZSBncmlkIGlzXG4gICAgICAgICAqIHRyYXZlcnNlZCBvdmVyIGNlbGwgYXQgYSB0aW1lIGluIGEgcm93cyB4IGNvbHVtbnMgZ3JpZCBmYXNoaW9uLCBhbHRob3VnaCBlYWNoXG4gICAgICAgICAqIGNlbGwgaW5zZXJ0IGNhbiBjb3ZlciBtdWx0aXBsZSBlbGVtZW50cyBpbiB0aGUgZ3JpZCAtIHdoaWNoIGlzIHRyYWNrcyB1c2luZyB0aGVcbiAgICAgICAgICogYUFwcGxpZWQgYXJyYXkuIENlbGwgaW5zZXJ0cyBpbiB0aGUgZ3JpZCB3aWxsIG9ubHkgb2NjdXIgd2hlcmUgdGhlcmUgaXNuJ3RcbiAgICAgICAgICogYWxyZWFkeSBhIGNlbGwgaW4gdGhhdCBwb3NpdGlvbi5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSBhcnJheSB7b2JqZWN0c30gYW9Tb3VyY2UgTGF5b3V0IGFycmF5IGZyb20gX2ZuRGV0ZWN0SGVhZGVyXG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2xlYW59IFtiSW5jbHVkZUhpZGRlbj1mYWxzZV0gSWYgdHJ1ZSB0aGVuIGluY2x1ZGUgdGhlIGhpZGRlbiBjb2x1bW5zIGluIHRoZSBjYWxjLFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5EcmF3SGVhZChvU2V0dGluZ3MsIGFvU291cmNlLCBiSW5jbHVkZUhpZGRlbikge1xuICAgICAgICAgICAgdmFyIGksIGlMZW4sIGosIGpMZW4sIGssIGtMZW4sIG4sIG5Mb2NhbFRyO1xuICAgICAgICAgICAgdmFyIGFvTG9jYWwgPSBbXTtcbiAgICAgICAgICAgIHZhciBhQXBwbGllZCA9IFtdO1xuICAgICAgICAgICAgdmFyIGlDb2x1bW5zID0gb1NldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaVJvd3NwYW4sIGlDb2xzcGFuO1xuXG4gICAgICAgICAgICBpZiAoIWFvU291cmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYkluY2x1ZGVIaWRkZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGJJbmNsdWRlSGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIE1ha2UgYSBjb3B5IG9mIHRoZSBtYXN0ZXIgbGF5b3V0IGFycmF5LCBidXQgd2l0aG91dCB0aGUgdmlzaWJsZSBjb2x1bW5zIGluIGl0ICovXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gYW9Tb3VyY2UubGVuZ3RoOyBpIDwgaUxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYW9Mb2NhbFtpXSA9IGFvU291cmNlW2ldLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYW9Mb2NhbFtpXS5uVHIgPSBhb1NvdXJjZVtpXS5uVHI7XG5cbiAgICAgICAgICAgICAgICAvKiBSZW1vdmUgYW55IGNvbHVtbnMgd2hpY2ggYXJlIGN1cnJlbnRseSBoaWRkZW4gKi9cbiAgICAgICAgICAgICAgICBmb3IgKGogPSBpQ29sdW1ucyAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghb1NldHRpbmdzLmFvQ29sdW1uc1tqXS5iVmlzaWJsZSAmJiAhYkluY2x1ZGVIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFvTG9jYWxbaV0uc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogUHJlcCB0aGUgYXBwbGllZCBhcnJheSAtIGl0IG5lZWRzIGFuIGVsZW1lbnQgZm9yIGVhY2ggcm93ICovXG4gICAgICAgICAgICAgICAgYUFwcGxpZWQucHVzaChbXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBhb0xvY2FsLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG5Mb2NhbFRyID0gYW9Mb2NhbFtpXS5uVHI7XG5cbiAgICAgICAgICAgICAgICAvKiBBbGwgY2VsbHMgYXJlIGdvaW5nIHRvIGJlIHJlcGxhY2VkLCBzbyBlbXB0eSBvdXQgdGhlIHJvdyAqL1xuICAgICAgICAgICAgICAgIGlmIChuTG9jYWxUcikge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG4gPSBuTG9jYWxUci5maXJzdENoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbkxvY2FsVHIucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqTGVuID0gYW9Mb2NhbFtpXS5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaVJvd3NwYW4gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpQ29sc3BhbiA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgLyogQ2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBjZWxsIChyb3cvY29sc3BhbikgY292ZXJpbmcgb3VyIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgKiBpbnNlcnQgcG9pbnQuIElmIHRoZXJlIGlzLCB0aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gZG8uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoYUFwcGxpZWRbaV1bal0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbkxvY2FsVHIuYXBwZW5kQ2hpbGQoYW9Mb2NhbFtpXVtqXS5jZWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkW2ldW2pdID0gMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXhwYW5kIHRoZSBjZWxsIHRvIGNvdmVyIGFzIG1hbnkgcm93cyBhcyBuZWVkZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChhb0xvY2FsW2kgKyBpUm93c3Bhbl0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFvTG9jYWxbaV1bal0uY2VsbCA9PSBhb0xvY2FsW2kgKyBpUm93c3Bhbl1bal0uY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkW2kgKyBpUm93c3Bhbl1bal0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlSb3dzcGFuKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEV4cGFuZCB0aGUgY2VsbCB0byBjb3ZlciBhcyBtYW55IGNvbHVtbnMgYXMgbmVlZGVkICovXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYW9Mb2NhbFtpXVtqICsgaUNvbHNwYW5dICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhb0xvY2FsW2ldW2pdLmNlbGwgPT0gYW9Mb2NhbFtpXVtqICsgaUNvbHNwYW5dLmNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBNdXN0IHVwZGF0ZSB0aGUgYXBwbGllZCBhcnJheSBvdmVyIHRoZSByb3dzIGZvciB0aGUgY29sdW1ucyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBpUm93c3BhbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFBcHBsaWVkW2kgKyBrXVtqICsgaUNvbHNwYW5dID0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaUNvbHNwYW4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRG8gdGhlIGFjdHVhbCBleHBhbnNpb24gaW4gdGhlIERPTSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgJChhb0xvY2FsW2ldW2pdLmNlbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3Jvd3NwYW4nLCBpUm93c3BhbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cignY29sc3BhbicsIGlDb2xzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc2VydCB0aGUgcmVxdWlyZWQgVFIgbm9kZXMgaW50byB0aGUgdGFibGUgZm9yIGRpc3BsYXlcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuRHJhdyhvU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIC8qIFByb3ZpZGUgYSBwcmUtY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3IGlzIGZhbHNlIGlzIHJldHVybmVkICovXG4gICAgICAgICAgICB2YXIgYVByZURyYXcgPSBfZm5DYWxsYmFja0ZpcmUob1NldHRpbmdzLCAnYW9QcmVEcmF3Q2FsbGJhY2snLCAncHJlRHJhdycsIFtvU2V0dGluZ3NdKTtcbiAgICAgICAgICAgIGlmICgkLmluQXJyYXkoZmFsc2UsIGFQcmVEcmF3KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShvU2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpLCBpTGVuLCBuO1xuICAgICAgICAgICAgdmFyIGFuUm93cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGlSb3dDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgYXNTdHJpcGVDbGFzc2VzID0gb1NldHRpbmdzLmFzU3RyaXBlQ2xhc3NlcztcbiAgICAgICAgICAgIHZhciBpU3RyaXBlcyA9IGFzU3RyaXBlQ2xhc3Nlcy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgaU9wZW5Sb3dzID0gb1NldHRpbmdzLmFvT3BlblJvd3MubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG9MYW5nID0gb1NldHRpbmdzLm9MYW5ndWFnZTtcbiAgICAgICAgICAgIHZhciBpSW5pdERpc3BsYXlTdGFydCA9IG9TZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcbiAgICAgICAgICAgIHZhciBiU2VydmVyU2lkZSA9IF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnc3NwJztcbiAgICAgICAgICAgIHZhciBhaURpc3BsYXkgPSBvU2V0dGluZ3MuYWlEaXNwbGF5O1xuXG4gICAgICAgICAgICBvU2V0dGluZ3MuYkRyYXdpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKiBDaGVjayBhbmQgc2VlIGlmIHdlIGhhdmUgYW4gaW5pdGlhbCBkcmF3IHBvc2l0aW9uIGZyb20gc3RhdGUgc2F2aW5nICovXG4gICAgICAgICAgICBpZiAoaUluaXREaXNwbGF5U3RhcnQgIT09IHVuZGVmaW5lZCAmJiBpSW5pdERpc3BsYXlTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBiU2VydmVyU2lkZSA/XG4gICAgICAgICAgICAgICAgICAgIGlJbml0RGlzcGxheVN0YXJ0IDpcbiAgICAgICAgICAgICAgICAgICAgaUluaXREaXNwbGF5U3RhcnQgPj0gb1NldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlJbml0RGlzcGxheVN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpRGlzcGxheVN0YXJ0ID0gb1NldHRpbmdzLl9pRGlzcGxheVN0YXJ0O1xuICAgICAgICAgICAgdmFyIGlEaXNwbGF5RW5kID0gb1NldHRpbmdzLmZuRGlzcGxheUVuZCgpO1xuXG4gICAgICAgICAgICAvKiBTZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGRyYXcgaW50ZXJjZXB0ICovXG4gICAgICAgICAgICBpZiAob1NldHRpbmdzLmJEZWZlckxvYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuYkRlZmVyTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5pRHJhdysrO1xuICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KG9TZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWJTZXJ2ZXJTaWRlKSB7XG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmlEcmF3Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghb1NldHRpbmdzLmJEZXN0cm95aW5nICYmICFfZm5BamF4VXBkYXRlKG9TZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChhaURpc3BsYXkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlTdGFydCA9IGJTZXJ2ZXJTaWRlID8gMCA6IGlEaXNwbGF5U3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGlFbmQgPSBiU2VydmVyU2lkZSA/IG9TZXR0aW5ncy5hb0RhdGEubGVuZ3RoIDogaURpc3BsYXlFbmQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaVN0YXJ0OyBqIDwgaUVuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpRGF0YUluZGV4ID0gYWlEaXNwbGF5W2pdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW9EYXRhID0gb1NldHRpbmdzLmFvRGF0YVtpRGF0YUluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFvRGF0YS5uVHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkNyZWF0ZVRyKG9TZXR0aW5ncywgaURhdGFJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgblJvdyA9IGFvRGF0YS5uVHI7XG5cbiAgICAgICAgICAgICAgICAgICAgLyogUmVtb3ZlIHRoZSBvbGQgc3RyaXBpbmcgY2xhc3NlcyBhbmQgdGhlbiBhZGQgdGhlIG5ldyBvbmUgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlTdHJpcGVzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc1N0cmlwZSA9IGFzU3RyaXBlQ2xhc3Nlc1tpUm93Q291bnQgJSBpU3RyaXBlc107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW9EYXRhLl9zUm93U3RyaXBlICE9IHNTdHJpcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKG5Sb3cpLnJlbW92ZUNsYXNzKGFvRGF0YS5fc1Jvd1N0cmlwZSkuYWRkQ2xhc3Moc1N0cmlwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW9EYXRhLl9zUm93U3RyaXBlID0gc1N0cmlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdyBjYWxsYmFjayBmdW5jdGlvbnMgLSBtaWdodCB3YW50IHRvIG1hbmlwdWxhdGUgdGhlIHJvd1xuICAgICAgICAgICAgICAgICAgICAvLyBpUm93Q291bnQgYW5kIGogYXJlIG5vdCBjdXJyZW50bHkgZG9jdW1lbnRlZC4gQXJlIHRoZXkgYXQgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZWZ1bD9cbiAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgJ2FvUm93Q2FsbGJhY2snLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgW25Sb3csIGFvRGF0YS5fYURhdGEsIGlSb3dDb3VudCwgaiwgaURhdGFJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGFuUm93cy5wdXNoKG5Sb3cpO1xuICAgICAgICAgICAgICAgICAgICBpUm93Q291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBUYWJsZSBpcyBlbXB0eSAtIGNyZWF0ZSBhIHJvdyB3aXRoIGFuIGVtcHR5IG1lc3NhZ2UgaW4gaXQgKi9cbiAgICAgICAgICAgICAgICB2YXIgc1plcm8gPSBvTGFuZy5zWmVyb1JlY29yZHM7XG4gICAgICAgICAgICAgICAgaWYgKG9TZXR0aW5ncy5pRHJhdyA9PSAxICYmIF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSA9PSAnYWpheCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc1plcm8gPSBvTGFuZy5zTG9hZGluZ1JlY29yZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9MYW5nLnNFbXB0eVRhYmxlICYmIG9TZXR0aW5ncy5mblJlY29yZHNUb3RhbCgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNaZXJvID0gb0xhbmcuc0VtcHR5VGFibGU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYW5Sb3dzWzBdID0gJCgnPHRyLz4nLCB7ICdjbGFzcyc6IGlTdHJpcGVzID8gYXNTdHJpcGVDbGFzc2VzWzBdIDogJycgfSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8dGQgLz4nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndmFsaWduJzogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAnY29sU3Bhbic6IF9mblZpc2JsZUNvbHVtbnMob1NldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IG9TZXR0aW5ncy5vQ2xhc3Nlcy5zUm93RW1wdHlcbiAgICAgICAgICAgICAgICAgICAgfSkuaHRtbChzWmVybykpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBIZWFkZXIgYW5kIGZvb3RlciBjYWxsYmFja3MgKi9cbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb0hlYWRlckNhbGxiYWNrJywgJ2hlYWRlcicsIFskKG9TZXR0aW5ncy5uVEhlYWQpLmNoaWxkcmVuKCd0cicpWzBdLFxuICAgICAgICAgICAgX2ZuR2V0RGF0YU1hc3RlcihvU2V0dGluZ3MpLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5XSk7XG5cbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb0Zvb3RlckNhbGxiYWNrJywgJ2Zvb3RlcicsIFskKG9TZXR0aW5ncy5uVEZvb3QpLmNoaWxkcmVuKCd0cicpWzBdLFxuICAgICAgICAgICAgX2ZuR2V0RGF0YU1hc3RlcihvU2V0dGluZ3MpLCBpRGlzcGxheVN0YXJ0LCBpRGlzcGxheUVuZCwgYWlEaXNwbGF5XSk7XG5cbiAgICAgICAgICAgIHZhciBib2R5ID0gJChvU2V0dGluZ3MublRCb2R5KTtcblxuICAgICAgICAgICAgYm9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmQoJChhblJvd3MpKTtcblxuICAgICAgICAgICAgLyogQ2FsbCBhbGwgcmVxdWlyZWQgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgZW5kIG9mIGEgZHJhdyAqL1xuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgJ2FvRHJhd0NhbGxiYWNrJywgJ2RyYXcnLCBbb1NldHRpbmdzXSk7XG5cbiAgICAgICAgICAgIC8qIERyYXcgaXMgY29tcGxldGUsIHNvcnRpbmcgYW5kIGZpbHRlcmluZyBtdXN0IGJlIGFzIHdlbGwgKi9cbiAgICAgICAgICAgIG9TZXR0aW5ncy5iU29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICBvU2V0dGluZ3MuYkZpbHRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBvU2V0dGluZ3MuYkRyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZHJhdyB0aGUgdGFibGUgLSB0YWtpbmcgYWNjb3VudCBvZiB0aGUgdmFyaW91cyBmZWF0dXJlcyB3aGljaCBhcmUgZW5hYmxlZFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbaG9sZFBvc2l0aW9uXSBLZWVwIHRoZSBjdXJyZW50IHBhZ2luZyBwb3NpdGlvbi4gQnkgZGVmYXVsdFxuICAgICAgICAgKiAgICB0aGUgcGFnaW5nIGlzIHJlc2V0IHRvIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblJlRHJhdyhzZXR0aW5ncywgaG9sZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcbiAgICAgICAgICAgICAgICBzb3J0ID0gZmVhdHVyZXMuYlNvcnQsXG4gICAgICAgICAgICAgICAgZmlsdGVyID0gZmVhdHVyZXMuYkZpbHRlcjtcblxuICAgICAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgICAgICBfZm5Tb3J0KHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlKHNldHRpbmdzLCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gZmlsdGVyaW5nLCBzbyB3ZSB3YW50IHRvIGp1c3QgdXNlIHRoZSBkaXNwbGF5IG1hc3RlclxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IHNldHRpbmdzLmFpRGlzcGxheU1hc3Rlci5zbGljZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaG9sZFBvc2l0aW9uICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBMZXQgYW55IG1vZHVsZXMga25vdyBhYm91dCB0aGUgZHJhdyBob2xkIHBvc2l0aW9uIHN0YXRlICh1c2VkIGJ5XG4gICAgICAgICAgICAvLyBzY3JvbGxpbmcgaW50ZXJuYWxseSlcbiAgICAgICAgICAgIHNldHRpbmdzLl9kcmF3SG9sZCA9IGhvbGRQb3NpdGlvbjtcblxuICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIHNldHRpbmdzLl9kcmF3SG9sZCA9IGZhbHNlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIHRoZSBvcHRpb25zIHRvIHRoZSBwYWdlIEhUTUwgZm9yIHRoZSB0YWJsZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5BZGRPcHRpb25zSHRtbChvU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gb1NldHRpbmdzLm9DbGFzc2VzO1xuICAgICAgICAgICAgdmFyIHRhYmxlID0gJChvU2V0dGluZ3MublRhYmxlKTtcbiAgICAgICAgICAgIHZhciBob2xkaW5nID0gJCgnPGRpdi8+JykuaW5zZXJ0QmVmb3JlKHRhYmxlKTsgLy8gSG9sZGluZyBlbGVtZW50IGZvciBzcGVlZFxuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gb1NldHRpbmdzLm9GZWF0dXJlcztcblxuICAgICAgICAgICAgLy8gQWxsIERhdGFUYWJsZXMgYXJlIHdyYXBwZWQgaW4gYSBkaXZcbiAgICAgICAgICAgIHZhciBpbnNlcnQgPSAkKCc8ZGl2Lz4nLCB7XG4gICAgICAgICAgICAgICAgaWQ6IG9TZXR0aW5ncy5zVGFibGVJZCArICdfd3JhcHBlcicsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zV3JhcHBlciArIChvU2V0dGluZ3MublRGb290ID8gJycgOiAnICcgKyBjbGFzc2VzLnNOb0Zvb3RlcilcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBvU2V0dGluZ3MubkhvbGRpbmcgPSBob2xkaW5nWzBdO1xuICAgICAgICAgICAgb1NldHRpbmdzLm5UYWJsZVdyYXBwZXIgPSBpbnNlcnRbMF07XG4gICAgICAgICAgICBvU2V0dGluZ3MublRhYmxlUmVpbnNlcnRCZWZvcmUgPSBvU2V0dGluZ3MublRhYmxlLm5leHRTaWJsaW5nO1xuXG4gICAgICAgICAgICAvKiBMb29wIG92ZXIgdGhlIHVzZXIgc2V0IHBvc2l0aW9uaW5nIGFuZCBwbGFjZSB0aGUgZWxlbWVudHMgYXMgbmVlZGVkICovXG4gICAgICAgICAgICB2YXIgYURvbSA9IG9TZXR0aW5ncy5zRG9tLnNwbGl0KCcnKTtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlTm9kZSwgY09wdGlvbiwgbk5ld05vZGUsIGNOZXh0LCBzQXR0ciwgajtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYURvbS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjT3B0aW9uID0gYURvbVtpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjT3B0aW9uID09ICc8Jykge1xuICAgICAgICAgICAgICAgICAgICAvKiBOZXcgY29udGFpbmVyIGRpdiAqL1xuICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZSA9ICQoJzxkaXYvPicpWzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8qIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYXBwZW5kIGFuIGlkIGFuZC9vciBhIGNsYXNzIG5hbWUgdG8gdGhlIGNvbnRhaW5lciAqL1xuICAgICAgICAgICAgICAgICAgICBjTmV4dCA9IGFEb21baSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY05leHQgPT0gXCInXCIgfHwgY05leHQgPT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc0F0dHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoYURvbVtpICsgal0gIT0gY05leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzQXR0ciArPSBhRG9tW2kgKyBqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlcGxhY2UgalF1ZXJ5IFVJIGNvbnN0YW50cyBAdG9kbyBkZXByZWNpYXRlZCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNBdHRyID09IFwiSFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc0F0dHIgPSBjbGFzc2VzLnNKVUlIZWFkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzQXR0ciA9PSBcIkZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNBdHRyID0gY2xhc3Nlcy5zSlVJRm9vdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgYXR0cmlidXRlIGNhbiBiZSBpbiB0aGUgZm9ybWF0IG9mIFwiI2lkLmNsYXNzXCIsIFwiI2lkXCIgb3IgXCJjbGFzc1wiIFRoaXMgbG9naWNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGJyZWFrcyB0aGUgc3RyaW5nIGludG8gcGFydHMgYW5kIGFwcGxpZXMgdGhlbSBhcyBuZWVkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNBdHRyLmluZGV4T2YoJy4nKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhU3BsaXQgPSBzQXR0ci5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5OZXdOb2RlLmlkID0gYVNwbGl0WzBdLnN1YnN0cigxLCBhU3BsaXRbMF0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUuY2xhc3NOYW1lID0gYVNwbGl0WzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc0F0dHIuY2hhckF0KDApID09IFwiI1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbk5ld05vZGUuaWQgPSBzQXR0ci5zdWJzdHIoMSwgc0F0dHIubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuTmV3Tm9kZS5jbGFzc05hbWUgPSBzQXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBqOyAvKiBNb3ZlIGFsb25nIHRoZSBwb3NpdGlvbiBhcnJheSAqL1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0LmFwcGVuZChuTmV3Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9ICQobk5ld05vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICc+Jykge1xuICAgICAgICAgICAgICAgICAgICAvKiBFbmQgY29udGFpbmVyIGRpdiAqL1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBpbnNlcnQucGFyZW50KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEB0b2RvIE1vdmUgb3B0aW9ucyBpbnRvIHRoZWlyIG93biBwbHVnaW5zP1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ2wnICYmIGZlYXR1cmVzLmJQYWdpbmF0ZSAmJiBmZWF0dXJlcy5iTGVuZ3RoQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIExlbmd0aCAqL1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sTGVuZ3RoKG9TZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNPcHRpb24gPT0gJ2YnICYmIGZlYXR1cmVzLmJGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogRmlsdGVyICovXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVOb2RlID0gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAncicgJiYgZmVhdHVyZXMuYlByb2Nlc3NpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogcFJvY2Vzc2luZyAqL1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyhvU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICd0Jykge1xuICAgICAgICAgICAgICAgICAgICAvKiBUYWJsZSAqL1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sVGFibGUob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY09wdGlvbiA9PSAnaScgJiYgZmVhdHVyZXMuYkluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSW5mbyAqL1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sSW5mbyhvU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjT3B0aW9uID09ICdwJyAmJiBmZWF0dXJlcy5iUGFnaW5hdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogUGFnaW5hdGlvbiAqL1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlTm9kZSA9IF9mbkZlYXR1cmVIdG1sUGFnaW5hdGUob1NldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoRGF0YVRhYmxlLmV4dC5mZWF0dXJlLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBQbHVnLWluIGZlYXR1cmVzICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBhb0ZlYXR1cmVzID0gRGF0YVRhYmxlLmV4dC5mZWF0dXJlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwga0xlbiA9IGFvRmVhdHVyZXMubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY09wdGlvbiA9PSBhb0ZlYXR1cmVzW2tdLmNGZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZU5vZGUgPSBhb0ZlYXR1cmVzW2tdLmZuSW5pdChvU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyogQWRkIHRvIHRoZSAyRCBmZWF0dXJlcyBhcnJheSAqL1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWFuRmVhdHVyZXMgPSBvU2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhYW5GZWF0dXJlc1tjT3B0aW9uXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFuRmVhdHVyZXNbY09wdGlvbl0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFhbkZlYXR1cmVzW2NPcHRpb25dLnB1c2goZmVhdHVyZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQuYXBwZW5kKGZlYXR1cmVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIEJ1aWx0IG91ciBET00gc3RydWN0dXJlIC0gcmVwbGFjZSB0aGUgaG9sZGluZyBkaXYgd2l0aCB3aGF0IHdlIHdhbnQgKi9cbiAgICAgICAgICAgIGhvbGRpbmcucmVwbGFjZVdpdGgoaW5zZXJ0KTtcbiAgICAgICAgICAgIG9TZXR0aW5ncy5uSG9sZGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhlIERPTSBzb3VyY2UgdG8gY3JlYXRlIHVwIGFuIGFycmF5IG9mIGhlYWRlciBjZWxscy4gVGhlIGlkZWEgaGVyZSBpcyB0b1xuICAgICAgICAgKiBjcmVhdGUgYSBsYXlvdXQgZ3JpZCAoYXJyYXkpIG9mIHJvd3MgeCBjb2x1bW5zLCB3aGljaCBjb250YWlucyBhIHJlZmVyZW5jZVxuICAgICAgICAgKiB0byB0aGUgY2VsbCB0aGF0IHRoYXQgcG9pbnQgaW4gdGhlIGdyaWQgKHJlZ2FyZGxlc3Mgb2YgY29sL3Jvd3NwYW4pLCBzdWNoIHRoYXRcbiAgICAgICAgICogYW55IGNvbHVtbiAvIHJvdyBjb3VsZCBiZSByZW1vdmVkIGFuZCB0aGUgbmV3IGdyaWQgY29uc3RydWN0ZWRcbiAgICAgICAgICogIEBwYXJhbSBhcnJheSB7b2JqZWN0fSBhTGF5b3V0IEFycmF5IHRvIHN0b3JlIHRoZSBjYWxjdWxhdGVkIGxheW91dCBpblxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuVGhlYWQgVGhlIGhlYWRlci9mb290ZXIgZWxlbWVudCBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkRldGVjdEhlYWRlcihhTGF5b3V0LCBuVGhlYWQpIHtcbiAgICAgICAgICAgIHZhciBuVHJzID0gJChuVGhlYWQpLmNoaWxkcmVuKCd0cicpO1xuICAgICAgICAgICAgdmFyIG5UciwgbkNlbGw7XG4gICAgICAgICAgICB2YXIgaSwgaywgbCwgaUxlbiwgakxlbiwgaUNvbFNoaWZ0ZWQsIGlDb2x1bW4sIGlDb2xzcGFuLCBpUm93c3BhbjtcbiAgICAgICAgICAgIHZhciBiVW5pcXVlO1xuICAgICAgICAgICAgdmFyIGZuU2hpZnRDb2wgPSBmdW5jdGlvbiAoYSwgaSwgaikge1xuICAgICAgICAgICAgICAgIHZhciBrID0gYVtpXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoa1tqXSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBqO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYUxheW91dC5zcGxpY2UoMCwgYUxheW91dC5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvKiBXZSBrbm93IGhvdyBtYW55IHJvd3MgdGhlcmUgYXJlIGluIHRoZSBsYXlvdXQgLSBzbyBwcmVwIGl0ICovXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpTGVuID0gblRycy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhTGF5b3V0LnB1c2goW10pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBDYWxjdWxhdGUgYSBsYXlvdXQgYXJyYXkgKi9cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBuVHJzLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG5UciA9IG5UcnNbaV07XG4gICAgICAgICAgICAgICAgaUNvbHVtbiA9IDA7XG5cbiAgICAgICAgICAgICAgICAvKiBGb3IgZXZlcnkgY2VsbCBpbiB0aGUgcm93Li4uICovXG4gICAgICAgICAgICAgICAgbkNlbGwgPSBuVHIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobkNlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5DZWxsLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgPT0gXCJURFwiIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuQ2VsbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09IFwiVEhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogR2V0IHRoZSBjb2wgYW5kIHJvd3NwYW4gYXR0cmlidXRlcyBmcm9tIHRoZSBET00gYW5kIHNhbml0aXNlIHRoZW0gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlDb2xzcGFuID0gbkNlbGwuZ2V0QXR0cmlidXRlKCdjb2xzcGFuJykgKiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaVJvd3NwYW4gPSBuQ2VsbC5nZXRBdHRyaWJ1dGUoJ3Jvd3NwYW4nKSAqIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpQ29sc3BhbiA9ICghaUNvbHNwYW4gfHwgaUNvbHNwYW4gPT09IDAgfHwgaUNvbHNwYW4gPT09IDEpID8gMSA6IGlDb2xzcGFuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaVJvd3NwYW4gPSAoIWlSb3dzcGFuIHx8IGlSb3dzcGFuID09PSAwIHx8IGlSb3dzcGFuID09PSAxKSA/IDEgOiBpUm93c3BhbjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlcmUgbWlnaHQgYmUgY29sc3BhbiBjZWxscyBhbHJlYWR5IGluIHRoaXMgcm93LCBzbyBzaGlmdCBvdXIgdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBpQ29sU2hpZnRlZCA9IGZuU2hpZnRDb2woYUxheW91dCwgaSwgaUNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIENhY2hlIGNhbGN1bGF0aW9uIGZvciB1bmlxdWUgY29sdW1ucyAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgYlVuaXF1ZSA9IGlDb2xzcGFuID09PSAxID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGVyZSBpcyBjb2wgLyByb3dzcGFuLCBjb3B5IHRoZSBpbmZvcm1hdGlvbiBpbnRvIHRoZSBsYXlvdXQgZ3JpZCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGlDb2xzcGFuOyBsKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaVJvd3NwYW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0W2kgKyBrXVtpQ29sU2hpZnRlZCArIGxdID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjZWxsXCI6IG5DZWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ1bmlxdWVcIjogYlVuaXF1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhTGF5b3V0W2kgKyBrXS5uVHIgPSBuVHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5DZWxsID0gbkNlbGwubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIGFycmF5IG9mIHVuaXF1ZSB0aCBlbGVtZW50cywgb25lIGZvciBlYWNoIGNvbHVtblxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBuSGVhZGVyIGF1dG9tYXRpY2FsbHkgZGV0ZWN0IHRoZSBsYXlvdXQgZnJvbSB0aGlzIG5vZGUgLSBvcHRpb25hbFxuICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gYUxheW91dCB0aGVhZC90Zm9vdCBsYXlvdXQgZnJvbSBfZm5EZXRlY3RIZWFkZXIgLSBvcHRpb25hbFxuICAgICAgICAgKiAgQHJldHVybnMgYXJyYXkge25vZGV9IGFSZXR1cm4gbGlzdCBvZiB1bmlxdWUgdGgnc1xuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5HZXRVbmlxdWVUaHMob1NldHRpbmdzLCBuSGVhZGVyLCBhTGF5b3V0KSB7XG4gICAgICAgICAgICB2YXIgYVJldHVybiA9IFtdO1xuICAgICAgICAgICAgaWYgKCFhTGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgYUxheW91dCA9IG9TZXR0aW5ncy5hb0hlYWRlcjtcbiAgICAgICAgICAgICAgICBpZiAobkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBhTGF5b3V0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIF9mbkRldGVjdEhlYWRlcihhTGF5b3V0LCBuSGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gYUxheW91dC5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgakxlbiA9IGFMYXlvdXRbaV0ubGVuZ3RoOyBqIDwgakxlbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhTGF5b3V0W2ldW2pdLnVuaXF1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFhUmV0dXJuW2pdIHx8ICFvU2V0dGluZ3MuYlNvcnRDZWxsc1RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFSZXR1cm5bal0gPSBhTGF5b3V0W2ldW2pdLmNlbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhUmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZSBhbiBBamF4IGNhbGwgYmFzZWQgb24gdGhlIHRhYmxlJ3Mgc2V0dGluZ3MsIHRha2luZyBpbnRvIGFjY291bnQgdGhhdFxuICAgICAgICAgKiBwYXJhbWV0ZXJzIGNhbiBoYXZlIG11bHRpcGxlIGZvcm1zLCBhbmQgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gZGF0YSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlciwgcmVxdWlyZWQgYnlcbiAgICAgICAgICogICAgIERhdGFUYWJsZXMgLSBtYXkgYmUgYXVnbWVudGVkIGJ5IGRldmVsb3BlciBjYWxsYmFja3NcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuIHdoZW4gZGF0YSBpcyBvYnRhaW5lZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQnVpbGRBamF4KG9TZXR0aW5ncywgZGF0YSwgZm4pIHtcbiAgICAgICAgICAgIC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLCBhbGxvdyBmblNlcnZlckRhdGEgYW5kIGV2ZW50IHRvIG1hbmlwdWxhdGVcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsICdhb1NlcnZlclBhcmFtcycsICdzZXJ2ZXJQYXJhbXMnLCBbZGF0YV0pO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIG9iamVjdCBiYXNlZCBmb3IgMS4xMCsgaWYgdXNpbmcgdGhlIG9sZCBhcnJheSBzY2hlbWUgd2hpY2ggY2FuXG4gICAgICAgICAgICAvLyBjb21lIGZyb20gc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBvciBzZXJ2ZXJQYXJhbXNcbiAgICAgICAgICAgIGlmIChkYXRhICYmIEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0ge307XG4gICAgICAgICAgICAgICAgdmFyIHJicmFja2V0ID0gLyguKj8pXFxbXFxdJC87XG5cbiAgICAgICAgICAgICAgICAkLmVhY2goZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHZhbC5uYW1lLm1hdGNoKHJicmFja2V0KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvcnQgZm9yIGFycmF5c1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBtYXRjaFswXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0bXBbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBbbmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcFtuYW1lXS5wdXNoKHZhbC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXBbdmFsLm5hbWVdID0gdmFsLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFqYXhEYXRhO1xuICAgICAgICAgICAgdmFyIGFqYXggPSBvU2V0dGluZ3MuYWpheDtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG9TZXR0aW5ncy5vSW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBqc29uLCBvU2V0dGluZ3MuanFYSFJdKTtcbiAgICAgICAgICAgICAgICBmbihqc29uKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoYWpheCkgJiYgYWpheC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgYWpheERhdGEgPSBhamF4LmRhdGE7XG5cbiAgICAgICAgICAgICAgICB2YXIgbmV3RGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgICAgIGFqYXhEYXRhKGRhdGEsIG9TZXR0aW5ncykgOiAgLy8gZm4gY2FuIG1hbmlwdWxhdGUgZGF0YSBvciByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgYWpheERhdGE7ICAgICAgICAgICAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvYmplY3Qgb3IgYXJyYXkgdG8gbWVyZ2VcblxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBzb21ldGhpbmcsIHVzZSB0aGF0IGFsb25lXG4gICAgICAgICAgICAgICAgZGF0YSA9IHR5cGVvZiBhamF4RGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiBuZXdEYXRhID9cbiAgICAgICAgICAgICAgICAgICAgbmV3RGF0YSA6XG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIGRhdGEsIG5ld0RhdGEpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBkYXRhIHByb3BlcnR5IGFzIHdlJ3ZlIHJlc29sdmVkIGl0IGFscmVhZHkgYW5kIGRvbid0IHdhbnRcbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgdG8gZG8gaXQgYWdhaW4gKGl0IGlzIHJlc3RvcmVkIGF0IHRoZSBlbmQgb2YgdGhlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBhamF4LmRhdGE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBiYXNlQWpheCA9IHtcbiAgICAgICAgICAgICAgICBcImRhdGFcIjogZGF0YSxcbiAgICAgICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yID0ganNvbi5lcnJvciB8fCBqc29uLnNFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cob1NldHRpbmdzLCAwLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBvU2V0dGluZ3MuanNvbiA9IGpzb247XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGpzb24pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJkYXRhVHlwZVwiOiBcImpzb25cIixcbiAgICAgICAgICAgICAgICBcImNhY2hlXCI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIFwidHlwZVwiOiBvU2V0dGluZ3Muc1NlcnZlck1ldGhvZCxcbiAgICAgICAgICAgICAgICBcImVycm9yXCI6IGZ1bmN0aW9uICh4aHIsIGVycm9yLCB0aHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICd4aHInLCBbb1NldHRpbmdzLCBudWxsLCBvU2V0dGluZ3MuanFYSFJdKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KHRydWUsIHJldCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgPT0gXCJwYXJzZXJlcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKG9TZXR0aW5ncywgMCwgJ0ludmFsaWQgSlNPTiByZXNwb25zZScsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5Mb2cob1NldHRpbmdzLCAwLCAnQWpheCBlcnJvcicsIDcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkob1NldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGRhdGEgc3VibWl0dGVkIGZvciB0aGUgQVBJXG4gICAgICAgICAgICBvU2V0dGluZ3Mub0FqYXhEYXRhID0gZGF0YTtcblxuICAgICAgICAgICAgLy8gQWxsb3cgcGx1Zy1pbnMgYW5kIGV4dGVybmFsIHByb2Nlc3NlcyB0byBtb2RpZnkgdGhlIGRhdGFcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShvU2V0dGluZ3MsIG51bGwsICdwcmVYaHInLCBbb1NldHRpbmdzLCBkYXRhXSk7XG5cbiAgICAgICAgICAgIGlmIChvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyAxLjktIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3MuZm5TZXJ2ZXJEYXRhLmNhbGwoaW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5zQWpheFNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgJC5tYXAoZGF0YSwgZnVuY3Rpb24gKHZhbCwga2V5KSB7IC8vIE5lZWQgdG8gY29udmVydCBiYWNrIHRvIDEuOSB0cmFkIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZToga2V5LCB2YWx1ZTogdmFsIH07XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgb1NldHRpbmdzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9TZXR0aW5ncy5zQWpheFNvdXJjZSB8fCB0eXBlb2YgYWpheCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRhVGFibGVzIDEuOS0gY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qcVhIUiA9ICQuYWpheCgkLmV4dGVuZChiYXNlQWpheCwge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IGFqYXggfHwgb1NldHRpbmdzLnNBamF4U291cmNlXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFqYXggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAvLyBJcyBhIGZ1bmN0aW9uIC0gbGV0IHRoZSBjYWxsZXIgZGVmaW5lIHdoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAgICAgICAgICAgICAgIG9TZXR0aW5ncy5qcVhIUiA9IGFqYXguY2FsbChpbnN0YW5jZSwgZGF0YSwgY2FsbGJhY2ssIG9TZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPYmplY3QgdG8gZXh0ZW5kIHRoZSBiYXNlIHNldHRpbmdzXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmpxWEhSID0gJC5hamF4KCQuZXh0ZW5kKGJhc2VBamF4LCBhamF4KSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGZvciBuZXh0IHRpbWUgYXJvdW5kXG4gICAgICAgICAgICAgICAgYWpheC5kYXRhID0gYWpheERhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHRhYmxlIHVzaW5nIGFuIEFqYXggY2FsbFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gQmxvY2sgdGhlIHRhYmxlIGRyYXdpbmcgb3Igbm90XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhVcGRhdGUoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5iQWpheERhdGFHZXQpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhdysrO1xuICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIF9mbkJ1aWxkQWpheChcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgICAgIF9mbkFqYXhQYXJhbWV0ZXJzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFqYXhVcGRhdGVEcmF3KHNldHRpbmdzLCBqc29uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1aWxkIHVwIHRoZSBwYXJhbWV0ZXJzIGluIGFuIG9iamVjdCBuZWVkZWQgZm9yIGEgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuICAgICAgICAgKiByZXF1ZXN0LiBOb3RlIHRoYXQgdGhpcyBpcyBiYXNpY2FsbHkgZG9uZSB0d2ljZSwgaXMgZGlmZmVyZW50IHdheXMgLSBhIG1vZGVyblxuICAgICAgICAgKiBtZXRob2Qgd2hpY2ggaXMgdXNlZCBieSBkZWZhdWx0IGluIERhdGFUYWJsZXMgMS4xMCB3aGljaCB1c2VzIG9iamVjdHMgYW5kXG4gICAgICAgICAqIGFycmF5cywgb3IgdGhlIDEuOS0gbWV0aG9kIHdpdGggaXMgbmFtZSAvIHZhbHVlIHBhaXJzLiAxLjkgbWV0aG9kIGlzIHVzZWQgaWZcbiAgICAgICAgICogdGhlIHNBamF4U291cmNlIG9wdGlvbiBpcyB1c2VkIGluIHRoZSBpbml0aWFsaXNhdGlvbiwgb3IgdGhlIGxlZ2FjeUFqYXhcbiAgICAgICAgICogb3B0aW9uIGlzIHNldC5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEByZXR1cm5zIHtib29sfSBibG9jayB0aGUgdGFibGUgZHJhd2luZyBvciBub3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQWpheFBhcmFtZXRlcnMoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPSBjb2x1bW5zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IHNldHRpbmdzLm9GZWF0dXJlcyxcbiAgICAgICAgICAgICAgICBwcmVTZWFyY2ggPSBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsXG4gICAgICAgICAgICAgICAgcHJlQ29sU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzLFxuICAgICAgICAgICAgICAgIGksIGRhdGEgPSBbXSwgZGF0YVByb3AsIGNvbHVtbiwgY29sdW1uU2VhcmNoLFxuICAgICAgICAgICAgICAgIHNvcnQgPSBfZm5Tb3J0RmxhdHRlbihzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgZGlzcGxheVN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG4gICAgICAgICAgICAgICAgZGlzcGxheUxlbmd0aCA9IGZlYXR1cmVzLmJQYWdpbmF0ZSAhPT0gZmFsc2UgP1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAtMTtcblxuICAgICAgICAgICAgdmFyIHBhcmFtID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHsgJ25hbWUnOiBuYW1lLCAndmFsdWUnOiB2YWx1ZSB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgMS45LSBjb21wYXRpYmxlIG1ldGhvZFxuICAgICAgICAgICAgcGFyYW0oJ3NFY2hvJywgc2V0dGluZ3MuaURyYXcpO1xuICAgICAgICAgICAgcGFyYW0oJ2lDb2x1bW5zJywgY29sdW1uQ291bnQpO1xuICAgICAgICAgICAgcGFyYW0oJ3NDb2x1bW5zJywgX3BsdWNrKGNvbHVtbnMsICdzTmFtZScpLmpvaW4oJywnKSk7XG4gICAgICAgICAgICBwYXJhbSgnaURpc3BsYXlTdGFydCcsIGRpc3BsYXlTdGFydCk7XG4gICAgICAgICAgICBwYXJhbSgnaURpc3BsYXlMZW5ndGgnLCBkaXNwbGF5TGVuZ3RoKTtcblxuICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyAxLjEwKyBtZXRob2RcbiAgICAgICAgICAgIHZhciBkID0ge1xuICAgICAgICAgICAgICAgIGRyYXc6IHNldHRpbmdzLmlEcmF3LFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IFtdLFxuICAgICAgICAgICAgICAgIG9yZGVyOiBbXSxcbiAgICAgICAgICAgICAgICBzdGFydDogZGlzcGxheVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogZGlzcGxheUxlbmd0aCxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHByZVNlYXJjaC5zU2VhcmNoLFxuICAgICAgICAgICAgICAgICAgICByZWdleDogcHJlU2VhcmNoLmJSZWdleFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICBjb2x1bW5TZWFyY2ggPSBwcmVDb2xTZWFyY2hbaV07XG4gICAgICAgICAgICAgICAgZGF0YVByb3AgPSB0eXBlb2YgY29sdW1uLm1EYXRhID09IFwiZnVuY3Rpb25cIiA/ICdmdW5jdGlvbicgOiBjb2x1bW4ubURhdGE7XG5cbiAgICAgICAgICAgICAgICBkLmNvbHVtbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFQcm9wLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBjb2x1bW4uc05hbWUsXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaGFibGU6IGNvbHVtbi5iU2VhcmNoYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJhYmxlOiBjb2x1bW4uYlNvcnRhYmxlLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2g6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjb2x1bW5TZWFyY2guc1NlYXJjaCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBjb2x1bW5TZWFyY2guYlJlZ2V4XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHBhcmFtKFwibURhdGFQcm9wX1wiICsgaSwgZGF0YVByb3ApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NTZWFyY2hfJyArIGksIGNvbHVtblNlYXJjaC5zU2VhcmNoKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2JSZWdleF8nICsgaSwgY29sdW1uU2VhcmNoLmJSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtKCdiU2VhcmNoYWJsZV8nICsgaSwgY29sdW1uLmJTZWFyY2hhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2JTb3J0YWJsZV8nICsgaSwgY29sdW1uLmJTb3J0YWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMuYkZpbHRlcikge1xuICAgICAgICAgICAgICAgIHBhcmFtKCdzU2VhcmNoJywgcHJlU2VhcmNoLnNTZWFyY2gpO1xuICAgICAgICAgICAgICAgIHBhcmFtKCdiUmVnZXgnLCBwcmVTZWFyY2guYlJlZ2V4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJTb3J0KSB7XG4gICAgICAgICAgICAgICAgJC5lYWNoKHNvcnQsIGZ1bmN0aW9uIChpLCB2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5vcmRlci5wdXNoKHsgY29sdW1uOiB2YWwuY29sLCBkaXI6IHZhbC5kaXIgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ2lTb3J0Q29sXycgKyBpLCB2YWwuY29sKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0oJ3NTb3J0RGlyXycgKyBpLCB2YWwuZGlyKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHBhcmFtKCdpU29ydGluZ0NvbHMnLCBzb3J0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBsZWdhY3kuYWpheCBwYXJhbWV0ZXIgaXMgbnVsbCwgdGhlbiB3ZSBhdXRvbWF0aWNhbGx5IGRlY2lkZSB3aGljaFxuICAgICAgICAgICAgLy8gZm9ybSB0byB1c2UsIGJhc2VkIG9uIHNBamF4U291cmNlXG4gICAgICAgICAgICB2YXIgbGVnYWN5ID0gRGF0YVRhYmxlLmV4dC5sZWdhY3kuYWpheDtcbiAgICAgICAgICAgIGlmIChsZWdhY3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3Muc0FqYXhTb3VyY2UgPyBkYXRhIDogZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiBsZWdhY3kgaGFzIGJlZW4gc3BlY2lmaWVkIHRoZW4gd2UgdXNlIHRoYXQgdG8gZGVjaWRlIG9uIHRoZVxuICAgICAgICAgICAgLy8gZm9ybVxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FjeSA/IGRhdGEgOiBkO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YSB0aGUgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIgKG51a2luZyB0aGUgb2xkKSBhbmQgcmVkcmF3IHRoZSB0YWJsZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24ganNvbiBkYXRhIHJldHVybiBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30ganNvbi5zRWNobyBUcmFja2luZyBmbGFnIGZvciBEYXRhVGFibGVzIHRvIG1hdGNoIHJlcXVlc3RzXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0ganNvbi5pVG90YWxSZWNvcmRzIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSBkYXRhIHNldCwgbm90IGFjY291bnRpbmcgZm9yIGZpbHRlcmluZ1xuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGpzb24uaVRvdGFsRGlzcGxheVJlY29yZHMgTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIGRhdGEgc2V0LCBhY2NvdW50aW5nIGZvciBmaWx0ZXJpbmdcbiAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGpzb24uYWFEYXRhIFRoZSBkYXRhIHRvIGRpc3BsYXkgb24gdGhpcyBwYWdlXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gW2pzb24uc0NvbHVtbnNdIENvbHVtbiBvcmRlcmluZyAoc05hbWUsIGNvbW1hIHNlcGFyYXRlZClcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQWpheFVwZGF0ZURyYXcoc2V0dGluZ3MsIGpzb24pIHtcbiAgICAgICAgICAgIC8vIHYxLjEwIHVzZXMgY2FtZWxDYXNlIHZhcmlhYmxlcywgd2hpbGUgMS45IHVzZXMgSHVuZ2FyaWFuIG5vdGF0aW9uLlxuICAgICAgICAgICAgLy8gU3VwcG9ydCBib3RoXG4gICAgICAgICAgICB2YXIgY29tcGF0ID0gZnVuY3Rpb24gKG9sZCwgbW9kZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25bb2xkXSAhPT0gdW5kZWZpbmVkID8ganNvbltvbGRdIDoganNvblttb2Rlcm5dO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyhzZXR0aW5ncywganNvbik7XG4gICAgICAgICAgICB2YXIgZHJhdyA9IGNvbXBhdCgnc0VjaG8nLCAnZHJhdycpO1xuICAgICAgICAgICAgdmFyIHJlY29yZHNUb3RhbCA9IGNvbXBhdCgnaVRvdGFsUmVjb3JkcycsICdyZWNvcmRzVG90YWwnKTtcbiAgICAgICAgICAgIHZhciByZWNvcmRzRmlsdGVyZWQgPSBjb21wYXQoJ2lUb3RhbERpc3BsYXlSZWNvcmRzJywgJ3JlY29yZHNGaWx0ZXJlZCcpO1xuXG4gICAgICAgICAgICBpZiAoZHJhdyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJvdGVjdCBhZ2FpbnN0IG91dCBvZiBzZXF1ZW5jZSByZXR1cm5zXG4gICAgICAgICAgICAgICAgaWYgKGRyYXcgKiAxIDwgc2V0dGluZ3MuaURyYXcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5pRHJhdyA9IGRyYXcgKiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZm5DbGVhclRhYmxlKHNldHRpbmdzKTtcbiAgICAgICAgICAgIHNldHRpbmdzLl9pUmVjb3Jkc1RvdGFsID0gcGFyc2VJbnQocmVjb3Jkc1RvdGFsLCAxMCk7XG4gICAgICAgICAgICBzZXR0aW5ncy5faVJlY29yZHNEaXNwbGF5ID0gcGFyc2VJbnQocmVjb3Jkc0ZpbHRlcmVkLCAxMCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2ZuQWRkRGF0YShzZXR0aW5ncywgZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR0aW5ncy5haURpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcblxuICAgICAgICAgICAgc2V0dGluZ3MuYkFqYXhEYXRhR2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcblxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIF9mbkluaXRDb21wbGV0ZShzZXR0aW5ncywganNvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRpbmdzLmJBamF4RGF0YUdldCA9IHRydWU7XG4gICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgZmFsc2UpO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkYXRhIGZyb20gdGhlIEpTT04gZGF0YSBzb3VyY2UgdG8gdXNlIGZvciBkcmF3aW5nIGEgdGFibGUuIFVzaW5nXG4gICAgICAgICAqIGBfZm5HZXRPYmplY3REYXRhRm5gIGFsbG93cyB0aGUgZGF0YSB0byBiZSBzb3VyY2VkIGZyb20gYSBwcm9wZXJ0eSBvZiB0aGVcbiAgICAgICAgICogc291cmNlIG9iamVjdCwgb3IgZnJvbSBhIHByb2Nlc3NpbmcgZnVuY3Rpb24uXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0gIHtvYmplY3R9IGpzb24gRGF0YSBzb3VyY2Ugb2JqZWN0IC8gYXJyYXkgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAqICBAcmV0dXJuIHthcnJheX0gQXJyYXkgb2YgZGF0YSB0byB1c2VcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkFqYXhEYXRhU3JjKG9TZXR0aW5ncywganNvbikge1xuICAgICAgICAgICAgdmFyIGRhdGFTcmMgPSAkLmlzUGxhaW5PYmplY3Qob1NldHRpbmdzLmFqYXgpICYmIG9TZXR0aW5ncy5hamF4LmRhdGFTcmMgIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLmFqYXguZGF0YVNyYyA6XG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLnNBamF4RGF0YVByb3A7IC8vIENvbXBhdGliaWxpdHkgd2l0aCAxLjktLlxuXG4gICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IHdpdGggMS45LS4gSW4gb3JkZXIgdG8gcmVhZCBmcm9tIGFhRGF0YSwgY2hlY2sgaWYgdGhlXG4gICAgICAgICAgICAvLyBkZWZhdWx0IGhhcyBiZWVuIGNoYW5nZWQsIGlmIG5vdCwgY2hlY2sgZm9yIGFhRGF0YVxuICAgICAgICAgICAgaWYgKGRhdGFTcmMgPT09ICdkYXRhJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uLmFhRGF0YSB8fCBqc29uW2RhdGFTcmNdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZGF0YVNyYyAhPT0gXCJcIiA/XG4gICAgICAgICAgICAgICAgX2ZuR2V0T2JqZWN0RGF0YUZuKGRhdGFTcmMpKGpzb24pIDpcbiAgICAgICAgICAgICAgICBqc29uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBmaWx0ZXJpbmcgdGV4dFxuICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IEZpbHRlciBjb250cm9sIGVsZW1lbnRcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuRmVhdHVyZUh0bWxGaWx0ZXIoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG4gICAgICAgICAgICB2YXIgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkO1xuICAgICAgICAgICAgdmFyIGxhbmd1YWdlID0gc2V0dGluZ3Mub0xhbmd1YWdlO1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2VhcmNoID0gc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoO1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSAnPGlucHV0IHR5cGU9XCJzZWFyY2hcIiBjbGFzcz1cIicgKyBjbGFzc2VzLnNGaWx0ZXJJbnB1dCArICdcIi8+JztcblxuICAgICAgICAgICAgdmFyIHN0ciA9IGxhbmd1YWdlLnNTZWFyY2g7XG4gICAgICAgICAgICBzdHIgPSBzdHIubWF0Y2goL19JTlBVVF8vKSA/XG4gICAgICAgICAgICAgICAgc3RyLnJlcGxhY2UoJ19JTlBVVF8nLCBpbnB1dCkgOlxuICAgICAgICAgICAgICAgIHN0ciArIGlucHV0O1xuXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gJCgnPGRpdi8+Jywge1xuICAgICAgICAgICAgICAgICdpZCc6ICFmZWF0dXJlcy5mID8gdGFibGVJZCArICdfZmlsdGVyJyA6IG51bGwsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zRmlsdGVyXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoJCgnPGxhYmVsLz4nKS5hcHBlbmQoc3RyKSk7XG5cbiAgICAgICAgICAgIHZhciBzZWFyY2hGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvKiBVcGRhdGUgYWxsIG90aGVyIGZpbHRlciBpbnB1dCBlbGVtZW50cyBmb3IgdGhlIG5ldyBkaXNwbGF5ICovXG4gICAgICAgICAgICAgICAgdmFyIG4gPSBmZWF0dXJlcy5mO1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSAhdGhpcy52YWx1ZSA/IFwiXCIgOiB0aGlzLnZhbHVlOyAvLyBtZW50YWwgSUU4IGZpeCA6LShcblxuICAgICAgICAgICAgICAgIC8qIE5vdyBkbyB0aGUgZmlsdGVyICovXG4gICAgICAgICAgICAgICAgaWYgKHZhbCAhPSBwcmV2aW91c1NlYXJjaC5zU2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbkZpbHRlckNvbXBsZXRlKHNldHRpbmdzLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogdmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogcHJldmlvdXNTZWFyY2guYlJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiU21hcnRcIjogcHJldmlvdXNTZWFyY2guYlNtYXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IHByZXZpb3VzU2VhcmNoLmJDYXNlSW5zZW5zaXRpdmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byByZWRyYXcsIHdpdGhvdXQgcmVzb3J0aW5nXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNlYXJjaERlbGF5ID0gc2V0dGluZ3Muc2VhcmNoRGVsYXkgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLnNlYXJjaERlbGF5IDpcbiAgICAgICAgICAgICAgICBfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PT0gJ3NzcCcgP1xuICAgICAgICAgICAgICAgICAgICA0MDAgOlxuICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICB2YXIganFGaWx0ZXIgPSAkKCdpbnB1dCcsIGZpbHRlcilcbiAgICAgICAgICAgICAgICAudmFsKHByZXZpb3VzU2VhcmNoLnNTZWFyY2gpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3BsYWNlaG9sZGVyJywgbGFuZ3VhZ2Uuc1NlYXJjaFBsYWNlaG9sZGVyKVxuICAgICAgICAgICAgICAgIC5vbihcbiAgICAgICAgICAgICAgICAgICAgJ2tleXVwLkRUIHNlYXJjaC5EVCBpbnB1dC5EVCBwYXN0ZS5EVCBjdXQuRFQnLFxuICAgICAgICAgICAgICAgICAgICBzZWFyY2hEZWxheSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5UaHJvdHRsZShzZWFyY2hGbiwgc2VhcmNoRGVsYXkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEZuXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5vbignbW91c2V1cCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2UgZml4ISBFZGdlIDE3IGRvZXMgbm90IHRyaWdnZXIgYW55dGhpbmcgb3RoZXIgdGhhbiBtb3VzZSBldmVudHMgd2hlbiBjbGlja2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyBvbiB0aGUgY2xlYXIgaWNvbiAoRWRnZSBidWcgMTc1ODQ1MTUpLiBUaGlzIGlzIHNhZmUgaW4gb3RoZXIgYnJvd3NlcnMgYXMgYHNlYXJjaEZuYFxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVja3MgdGhlIHZhbHVlIHRvIHNlZSBpZiBpdCBoYXMgY2hhbmdlZC4gSW4gb3RoZXIgYnJvd3NlcnMgaXQgd29uJ3QgaGF2ZS5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGbi5jYWxsKGpxRmlsdGVyWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdrZXlwcmVzcy5EVCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFByZXZlbnQgZm9ybSBzdWJtaXNzaW9uICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtY29udHJvbHMnLCB0YWJsZUlkKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBlbGVtZW50cyB3aGVuZXZlciB0aGUgdGFibGUgaXMgZmlsdGVyZWRcbiAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5vbignc2VhcmNoLmR0LkRUJywgZnVuY3Rpb24gKGV2LCBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElFOSB0aHJvd3MgYW4gJ3Vua25vd24gZXJyb3InIGlmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbnNpZGUgYW4gaWZyYW1lIG9yIGZyYW1lLi4uXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoanFGaWx0ZXJbMF0gIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqcUZpbHRlci52YWwocHJldmlvdXNTZWFyY2guc1NlYXJjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyWzBdO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlsdGVyIHRoZSB0YWJsZSB1c2luZyBib3RoIHRoZSBnbG9iYWwgZmlsdGVyIGFuZCBjb2x1bW4gYmFzZWQgZmlsdGVyaW5nXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NlYXJjaCBzZWFyY2ggaW5mb3JtYXRpb25cbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBbaUZvcmNlXSBmb3JjZSBhIHJlc2VhcmNoIG9mIHRoZSBtYXN0ZXIgYXJyYXkgKDEpIG9yIG5vdCAodW5kZWZpbmVkIG9yIDApXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckNvbXBsZXRlKG9TZXR0aW5ncywgb0lucHV0LCBpRm9yY2UpIHtcbiAgICAgICAgICAgIHZhciBvUHJldlNlYXJjaCA9IG9TZXR0aW5ncy5vUHJldmlvdXNTZWFyY2g7XG4gICAgICAgICAgICB2YXIgYW9QcmV2U2VhcmNoID0gb1NldHRpbmdzLmFvUHJlU2VhcmNoQ29scztcbiAgICAgICAgICAgIHZhciBmblNhdmVGaWx0ZXIgPSBmdW5jdGlvbiAob0ZpbHRlcikge1xuICAgICAgICAgICAgICAgIC8qIFNhdmUgdGhlIGZpbHRlcmluZyB2YWx1ZXMgKi9cbiAgICAgICAgICAgICAgICBvUHJldlNlYXJjaC5zU2VhcmNoID0gb0ZpbHRlci5zU2VhcmNoO1xuICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJSZWdleCA9IG9GaWx0ZXIuYlJlZ2V4O1xuICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJTbWFydCA9IG9GaWx0ZXIuYlNtYXJ0O1xuICAgICAgICAgICAgICAgIG9QcmV2U2VhcmNoLmJDYXNlSW5zZW5zaXRpdmUgPSBvRmlsdGVyLmJDYXNlSW5zZW5zaXRpdmU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGZuUmVnZXggPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIGJFc2NhcGVSZWdleCBvcHRpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gby5iRXNjYXBlUmVnZXggIT09IHVuZGVmaW5lZCA/ICFvLmJFc2NhcGVSZWdleCA6IG8uYlJlZ2V4O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbnkgY29sdW1uIHR5cGVzIHRoYXQgYXJlIHVua25vd24gZHVlIHRvIGFkZGl0aW9uIG9yIGludmFsaWRhdGlvblxuICAgICAgICAgICAgLy8gQHRvZG8gQXMgcGVyIHNvcnQgLSBjYW4gdGhpcyBiZSBtb3ZlZCBpbnRvIGFuIGV2ZW50IGhhbmRsZXI/XG4gICAgICAgICAgICBfZm5Db2x1bW5UeXBlcyhvU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvKiBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIGFsbCBmaWx0ZXJpbmcgaXMgZG9uZSBieSB0aGUgc2VydmVyLCBzbyBubyBwb2ludCBoYW5naW5nIGFyb3VuZCBoZXJlICovXG4gICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShvU2V0dGluZ3MpICE9ICdzc3AnKSB7XG4gICAgICAgICAgICAgICAgLyogR2xvYmFsIGZpbHRlciAqL1xuICAgICAgICAgICAgICAgIF9mbkZpbHRlcihvU2V0dGluZ3MsIG9JbnB1dC5zU2VhcmNoLCBpRm9yY2UsIGZuUmVnZXgob0lucHV0KSwgb0lucHV0LmJTbWFydCwgb0lucHV0LmJDYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICAgICAgICAgIGZuU2F2ZUZpbHRlcihvSW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgLyogTm93IGRvIHRoZSBpbmRpdmlkdWFsIGNvbHVtbiBmaWx0ZXIgKi9cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFvUHJldlNlYXJjaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb2x1bW4ob1NldHRpbmdzLCBhb1ByZXZTZWFyY2hbaV0uc1NlYXJjaCwgaSwgZm5SZWdleChhb1ByZXZTZWFyY2hbaV0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW9QcmV2U2VhcmNoW2ldLmJTbWFydCwgYW9QcmV2U2VhcmNoW2ldLmJDYXNlSW5zZW5zaXRpdmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIEN1c3RvbSBmaWx0ZXJpbmcgKi9cbiAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDdXN0b20ob1NldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuU2F2ZUZpbHRlcihvSW5wdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBUZWxsIHRoZSBkcmF3IGZ1bmN0aW9uIHdlIGhhdmUgYmVlbiBmaWx0ZXJpbmcgKi9cbiAgICAgICAgICAgIG9TZXR0aW5ncy5iRmlsdGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKG9TZXR0aW5ncywgbnVsbCwgJ3NlYXJjaCcsIFtvU2V0dGluZ3NdKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGN1c3RvbSBmaWx0ZXJpbmcgZnVuY3Rpb25zXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlckN1c3RvbShzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIGZpbHRlcnMgPSBEYXRhVGFibGUuZXh0LnNlYXJjaDtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5Um93cyA9IHNldHRpbmdzLmFpRGlzcGxheTtcbiAgICAgICAgICAgIHZhciByb3csIHJvd0lkeDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGZpbHRlcnMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gTG9vcCBvdmVyIGVhY2ggcm93IGFuZCBzZWUgaWYgaXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IGRpc3BsYXlSb3dzLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0lkeCA9IGRpc3BsYXlSb3dzW2pdO1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBzZXR0aW5ncy5hb0RhdGFbcm93SWR4XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZmlsdGVyc1tpXShzZXR0aW5ncywgcm93Ll9hRmlsdGVyRGF0YSwgcm93SWR4LCByb3cuX2FEYXRhLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93cy5wdXNoKHJvd0lkeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTbyB0aGUgYXJyYXkgcmVmZXJlbmNlIGRvZXNuJ3QgYnJlYWsgc2V0IHRoZSByZXN1bHRzIGludG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gZXhpc3RpbmcgYXJyYXlcbiAgICAgICAgICAgICAgICBkaXNwbGF5Um93cy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICQubWVyZ2UoZGlzcGxheVJvd3MsIHJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlsdGVyIHRoZSB0YWJsZSBvbiBhIHBlci1jb2x1bW4gYmFzaXNcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzSW5wdXQgc3RyaW5nIHRvIGZpbHRlciBvblxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGlDb2x1bW4gY29sdW1uIHRvIGZpbHRlclxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiUmVnZXggdHJlYXQgc2VhcmNoIHN0cmluZyBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYlNtYXJ0IHVzZSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnN0aXZlIG1hdGNoaW5nIG9yIG5vdFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDb2x1bW4oc2V0dGluZ3MsIHNlYXJjaFN0ciwgY29sSWR4LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgaWYgKHNlYXJjaFN0ciA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXkgPSBzZXR0aW5ncy5haURpc3BsYXk7XG4gICAgICAgICAgICB2YXIgcnBTZWFyY2ggPSBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goc2VhcmNoU3RyLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGxheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGFbZGlzcGxheVtpXV0uX2FGaWx0ZXJEYXRhW2NvbElkeF07XG5cbiAgICAgICAgICAgICAgICBpZiAocnBTZWFyY2gudGVzdChkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChkaXNwbGF5W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IG91dDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbHRlciB0aGUgZGF0YSB0YWJsZSBiYXNlZCBvbiB1c2VyIGlucHV0IGFuZCBkcmF3IHRoZSB0YWJsZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gaW5wdXQgc3RyaW5nIHRvIGZpbHRlciBvblxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGZvcmNlIG9wdGlvbmFsIC0gZm9yY2UgYSByZXNlYXJjaCBvZiB0aGUgbWFzdGVyIGFycmF5ICgxKSBvciBub3QgKHVuZGVmaW5lZCBvciAwKVxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSByZWdleCB0cmVhdCBhcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBvciBub3RcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gc21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGNhc2VJbnNlbnNpdGl2ZSBEbyBjYXNlIGluc2Vuc3RpdmUgbWF0Y2hpbmcgb3Igbm90XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZpbHRlcihzZXR0aW5ncywgaW5wdXQsIGZvcmNlLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgdmFyIHJwU2VhcmNoID0gX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoKGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSk7XG4gICAgICAgICAgICB2YXIgcHJldlNlYXJjaCA9IHNldHRpbmdzLm9QcmV2aW91c1NlYXJjaC5zU2VhcmNoO1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG4gICAgICAgICAgICB2YXIgZGlzcGxheSwgaW52YWxpZGF0ZWQsIGk7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBbXTtcblxuICAgICAgICAgICAgLy8gTmVlZCB0byB0YWtlIGFjY291bnQgb2YgY3VzdG9tIGZpbHRlcmluZyBmdW5jdGlvbnMgLSBhbHdheXMgZmlsdGVyXG4gICAgICAgICAgICBpZiAoRGF0YVRhYmxlLmV4dC5zZWFyY2gubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgb2YgdGhlIHJvd3Mgd2VyZSBpbnZhbGlkYXRlZFxuICAgICAgICAgICAgaW52YWxpZGF0ZWQgPSBfZm5GaWx0ZXJEYXRhKHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGJsYW5rIC0gd2UganVzdCB3YW50IHRoZSBmdWxsIGRhdGEgc2V0XG4gICAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5haURpc3BsYXkgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBOZXcgc2VhcmNoIC0gc3RhcnQgZnJvbSB0aGUgbWFzdGVyIGFycmF5XG4gICAgICAgICAgICAgICAgaWYgKGludmFsaWRhdGVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlZ2V4IHx8XG4gICAgICAgICAgICAgICAgICAgIHByZXZTZWFyY2gubGVuZ3RoID4gaW5wdXQubGVuZ3RoIHx8XG4gICAgICAgICAgICAgICAgICAgIGlucHV0LmluZGV4T2YocHJldlNlYXJjaCkgIT09IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYlNvcnRlZCAvLyBPbiByZXNvcnQsIHRoZSBkaXNwbGF5IG1hc3RlciBuZWVkcyB0byBiZVxuICAgICAgICAgICAgICAgICAgICAvLyByZS1maWx0ZXJlZCBzaW5jZSBpbmRleGVzIHdpbGwgaGF2ZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGRpc3BsYXlNYXN0ZXIuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZWFyY2ggdGhlIGRpc3BsYXkgYXJyYXlcbiAgICAgICAgICAgICAgICBkaXNwbGF5ID0gc2V0dGluZ3MuYWlEaXNwbGF5O1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRpc3BsYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJwU2VhcmNoLnRlc3Qoc2V0dGluZ3MuYW9EYXRhW2Rpc3BsYXlbaV1dLl9zRmlsdGVyUm93KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWQucHVzaChkaXNwbGF5W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFpRGlzcGxheSA9IGZpbHRlcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnVpbGQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IHN1aXRhYmxlIGZvciBzZWFyY2hpbmcgYSB0YWJsZVxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNTZWFyY2ggc3RyaW5nIHRvIHNlYXJjaCBmb3JcbiAgICAgICAgICogIEBwYXJhbSB7Ym9vbH0gYlJlZ2V4IHRyZWF0IGFzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBiU21hcnQgcGVyZm9ybSBzbWFydCBmaWx0ZXJpbmcgb3Igbm90XG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IGJDYXNlSW5zZW5zaXRpdmUgRG8gY2FzZSBpbnNlbnNpdGl2ZSBtYXRjaGluZyBvciBub3RcbiAgICAgICAgICogIEByZXR1cm5zIHtSZWdFeHB9IGNvbnN0cnVjdGVkIG9iamVjdFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2goc2VhcmNoLCByZWdleCwgc21hcnQsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgICAgICAgICAgc2VhcmNoID0gcmVnZXggP1xuICAgICAgICAgICAgICAgIHNlYXJjaCA6XG4gICAgICAgICAgICAgICAgX2ZuRXNjYXBlUmVnZXgoc2VhcmNoKTtcblxuICAgICAgICAgICAgaWYgKHNtYXJ0KSB7XG4gICAgICAgICAgICAgICAgLyogRm9yIHNtYXJ0IGZpbHRlcmluZyB3ZSB3YW50IHRvIGFsbG93IHRoZSBzZWFyY2ggdG8gd29yayByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAgICAgICogd29yZCBvcmRlci4gV2UgYWxzbyB3YW50IGRvdWJsZSBxdW90ZWQgdGV4dCB0byBiZSBwcmVzZXJ2ZWQsIHNvIHdvcmRcbiAgICAgICAgICAgICAgICAgKiBvcmRlciBpcyBpbXBvcnRhbnQgLSBhIGxhIGdvb2dsZS4gU28gdGhpcyBpcyB3aGF0IHdlIHdhbnQgdG9cbiAgICAgICAgICAgICAgICAgKiBnZW5lcmF0ZTpcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIF4oPz0uKj9cXGJvbmVcXGIpKD89Lio/XFxidHdvIHRocmVlXFxiKSg/PS4qP1xcYmZvdXJcXGIpLiokXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGEgPSAkLm1hcChzZWFyY2gubWF0Y2goL1wiW15cIl0rXCJ8W14gXSsvZykgfHwgWycnXSwgZnVuY3Rpb24gKHdvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQuY2hhckF0KDApID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IHdvcmQubWF0Y2goL15cIiguKilcIiQvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmQgPSBtID8gbVsxXSA6IHdvcmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29yZC5yZXBsYWNlKCdcIicsICcnKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHNlYXJjaCA9ICdeKD89Lio/JyArIGEuam9pbignKSg/PS4qPycpICsgJykuKiQnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChzZWFyY2gsIGNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6ICcnKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVzY2FwZSBhIHN0cmluZyBzdWNoIHRoYXQgaXQgY2FuIGJlIHVzZWQgaW4gYSByZWd1bGFyIGV4cHJlc3Npb25cbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzVmFsIHN0cmluZyB0byBlc2NhcGVcbiAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IGVzY2FwZWQgc3RyaW5nXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfZm5Fc2NhcGVSZWdleCA9IERhdGFUYWJsZS51dGlsLmVzY2FwZVJlZ2V4O1xuXG4gICAgICAgIHZhciBfX2ZpbHRlcl9kaXYgPSAkKCc8ZGl2PicpWzBdO1xuICAgICAgICB2YXIgX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID0gX19maWx0ZXJfZGl2LnRleHRDb250ZW50ICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBmaWx0ZXJpbmcgZGF0YSBmb3IgZWFjaCByb3cgaWYgbmVlZGVkIChieSBpbnZhbGlkYXRpb24gb3IgZmlyc3QgcnVuKVxuICAgICAgICBmdW5jdGlvbiBfZm5GaWx0ZXJEYXRhKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucztcbiAgICAgICAgICAgIHZhciBjb2x1bW47XG4gICAgICAgICAgICB2YXIgaSwgaiwgaWVuLCBqZW4sIGZpbHRlckRhdGEsIGNlbGxEYXRhLCByb3c7XG4gICAgICAgICAgICB2YXIgZm9tYXR0ZXJzID0gRGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaDtcbiAgICAgICAgICAgIHZhciB3YXNJbnZhbGlkYXRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICByb3cgPSBzZXR0aW5ncy5hb0RhdGFbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYUZpbHRlckRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyRGF0YSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGNvbHVtbnMubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uYlNlYXJjaGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpLCBqLCAnZmlsdGVyJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9tYXR0ZXJzW2NvbHVtbi5zVHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBmb21hdHRlcnNbY29sdW1uLnNUeXBlXShjZWxsRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VhcmNoIGluIERhdGFUYWJsZXMgMS4xMCBpcyBzdHJpbmcgYmFzZWQuIEluIDEuMTEgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhbHRlcmVkIHRvIGFsc28gYWxsb3cgc3RyaWN0IHR5cGUgY2hlY2tpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsRGF0YSAhPT0gJ3N0cmluZycgJiYgY2VsbERhdGEudG9TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbERhdGEgPSBjZWxsRGF0YS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGxvb2tzIGxpa2UgdGhlcmUgaXMgYW4gSFRNTCBlbnRpdHkgaW4gdGhlIHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGF0dGVtcHQgdG8gZGVjb2RlIGl0IHNvIHNvcnRpbmcgd29ya3MgYXMgZXhwZWN0ZWQuIE5vdGUgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY291bGQgdXNlIGEgc2luZ2xlIGxpbmUgb2YgalF1ZXJ5IHRvIGRvIHRoaXMsIGJ1dCB0aGUgRE9NXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXRob2QgdXNlZCBoZXJlIGlzIG11Y2ggZmFzdGVyIGh0dHA6Ly9qc3BlcmYuY29tL2h0bWwtZGVjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbERhdGEuaW5kZXhPZiAmJiBjZWxsRGF0YS5pbmRleE9mKCcmJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19maWx0ZXJfZGl2LmlubmVySFRNTCA9IGNlbGxEYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxEYXRhID0gX19maWx0ZXJfZGl2X3RleHRDb250ZW50ID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19maWx0ZXJfZGl2LnRleHRDb250ZW50IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX19maWx0ZXJfZGl2LmlubmVyVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxEYXRhLnJlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGNlbGxEYXRhLnJlcGxhY2UoL1tcXHJcXG5cXHUyMDI4XS9nLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlckRhdGEucHVzaChjZWxsRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByb3cuX2FGaWx0ZXJEYXRhID0gZmlsdGVyRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9zRmlsdGVyUm93ID0gZmlsdGVyRGF0YS5qb2luKCcgICcpO1xuICAgICAgICAgICAgICAgICAgICB3YXNJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gd2FzSW52YWxpZGF0ZWQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGZyb20gdGhlIGludGVybmFsIEh1bmdhcmlhbiBub3RhdGlvbiB0byBjYW1lbENhc2UgZm9yIGV4dGVybmFsXG4gICAgICAgICAqIGludGVyYWN0aW9uXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb2JqIE9iamVjdCB0byBjb252ZXJ0XG4gICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBJbnZlcnRlZCBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU2VhcmNoVG9DYW1lbChvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2VhcmNoOiBvYmouc1NlYXJjaCxcbiAgICAgICAgICAgICAgICBzbWFydDogb2JqLmJTbWFydCxcbiAgICAgICAgICAgICAgICByZWdleDogb2JqLmJSZWdleCxcbiAgICAgICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IG9iai5iQ2FzZUluc2Vuc2l0aXZlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGZyb20gY2FtZWxDYXNlIG5vdGF0aW9uIHRvIHRoZSBpbnRlcm5hbCBIdW5nYXJpYW4uIFdlIGNvdWxkIHVzZSB0aGVcbiAgICAgICAgICogSHVuZ2FyaWFuIGNvbnZlcnQgZnVuY3Rpb24gaGVyZSwgYnV0IHRoaXMgaXMgY2xlYW5lclxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9iaiBPYmplY3QgdG8gY29udmVydFxuICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gSW52ZXJ0ZWQgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblNlYXJjaFRvSHVuZyhvYmopIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc1NlYXJjaDogb2JqLnNlYXJjaCxcbiAgICAgICAgICAgICAgICBiU21hcnQ6IG9iai5zbWFydCxcbiAgICAgICAgICAgICAgICBiUmVnZXg6IG9iai5yZWdleCxcbiAgICAgICAgICAgICAgICBiQ2FzZUluc2Vuc2l0aXZlOiBvYmouY2FzZUluc2Vuc2l0aXZlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciB0aGUgaW5mbyBkaXNwbGF5XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gSW5mb3JtYXRpb24gZWxlbWVudFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbEluZm8oc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHRpZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXMuaSxcbiAgICAgICAgICAgICAgICBuID0gJCgnPGRpdi8+Jywge1xuICAgICAgICAgICAgICAgICAgICAnY2xhc3MnOiBzZXR0aW5ncy5vQ2xhc3Nlcy5zSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgJ2lkJzogIW5vZGVzID8gdGlkICsgJ19pbmZvJyA6IG51bGxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFub2Rlcykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBkaXNwbGF5IG9uIGVhY2ggZHJhd1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFvRHJhd0NhbGxiYWNrLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBcImZuXCI6IF9mblVwZGF0ZUluZm8sXG4gICAgICAgICAgICAgICAgICAgIFwic05hbWVcIjogXCJpbmZvcm1hdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBuXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdyb2xlJywgJ3N0YXR1cycpXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBpcyBkZXNjcmliZWQgYnkgb3VyIGluZm8gZGl2XG4gICAgICAgICAgICAgICAgJChzZXR0aW5ncy5uVGFibGUpLmF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aWQgKyAnX2luZm8nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5bMF07XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIGluZm9ybWF0aW9uIGVsZW1lbnRzIGluIHRoZSBkaXNwbGF5XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuVXBkYXRlSW5mbyhzZXR0aW5ncykge1xuICAgICAgICAgICAgLyogU2hvdyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdGFibGUgKi9cbiAgICAgICAgICAgIHZhciBub2RlcyA9IHNldHRpbmdzLmFhbkZlYXR1cmVzLmk7XG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsYW5nID0gc2V0dGluZ3Mub0xhbmd1YWdlLFxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgKyAxLFxuICAgICAgICAgICAgICAgIGVuZCA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpLFxuICAgICAgICAgICAgICAgIG1heCA9IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG4gICAgICAgICAgICAgICAgdG90YWwgPSBzZXR0aW5ncy5mblJlY29yZHNEaXNwbGF5KCksXG4gICAgICAgICAgICAgICAgb3V0ID0gdG90YWwgP1xuICAgICAgICAgICAgICAgICAgICBsYW5nLnNJbmZvIDpcbiAgICAgICAgICAgICAgICAgICAgbGFuZy5zSW5mb0VtcHR5O1xuXG4gICAgICAgICAgICBpZiAodG90YWwgIT09IG1heCkge1xuICAgICAgICAgICAgICAgIC8qIFJlY29yZCBzZXQgYWZ0ZXIgZmlsdGVyaW5nICovXG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgJyArIGxhbmcuc0luZm9GaWx0ZXJlZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgbWFjcm9zXG4gICAgICAgICAgICBvdXQgKz0gbGFuZy5zSW5mb1Bvc3RGaXg7XG4gICAgICAgICAgICBvdXQgPSBfZm5JbmZvTWFjcm9zKHNldHRpbmdzLCBvdXQpO1xuXG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBsYW5nLmZuSW5mb0NhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgb3V0ID0gY2FsbGJhY2suY2FsbChzZXR0aW5ncy5vSW5zdGFuY2UsXG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBvdXRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkKG5vZGVzKS5odG1sKG91dCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZ1bmN0aW9uIF9mbkluZm9NYWNyb3Moc2V0dGluZ3MsIHN0cikge1xuICAgICAgICAgICAgLy8gV2hlbiBpbmZpbml0ZSBzY3JvbGxpbmcsIHdlIGFyZSBhbHdheXMgc3RhcnRpbmcgYXQgMS4gX2lEaXNwbGF5U3RhcnQgaXMgdXNlZCBvbmx5XG4gICAgICAgICAgICAvLyBpbnRlcm5hbGx5XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZXIgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcixcbiAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICBsZW4gPSBzZXR0aW5ncy5faURpc3BsYXlMZW5ndGgsXG4gICAgICAgICAgICAgICAgdmlzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpLFxuICAgICAgICAgICAgICAgIGFsbCA9IGxlbiA9PT0gLTE7XG5cbiAgICAgICAgICAgIHJldHVybiBzdHIuXG4gICAgICAgICAgICAgICAgcmVwbGFjZSgvX1NUQVJUXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc3RhcnQpKS5cbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fRU5EXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCkpKS5cbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fTUFYXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgc2V0dGluZ3MuZm5SZWNvcmRzVG90YWwoKSkpLlxuICAgICAgICAgICAgICAgIHJlcGxhY2UoL19UT1RBTF8vZywgZm9ybWF0dGVyLmNhbGwoc2V0dGluZ3MsIHZpcykpLlxuICAgICAgICAgICAgICAgIHJlcGxhY2UoL19QQUdFXy9nLCBmb3JtYXR0ZXIuY2FsbChzZXR0aW5ncywgYWxsID8gMSA6IE1hdGguY2VpbChzdGFydCAvIGxlbikpKS5cbiAgICAgICAgICAgICAgICByZXBsYWNlKC9fUEFHRVNfL2csIGZvcm1hdHRlci5jYWxsKHNldHRpbmdzLCBhbGwgPyAxIDogTWF0aC5jZWlsKHZpcyAvIGxlbikpKTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuSW5pdGlhbGlzZShzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIGksIGlMZW4sIGlBamF4U3RhcnQgPSBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydDtcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gc2V0dGluZ3MuYW9Db2x1bW5zLCBjb2x1bW47XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBzZXR0aW5ncy5vRmVhdHVyZXM7XG4gICAgICAgICAgICB2YXIgZGVmZXJMb2FkaW5nID0gc2V0dGluZ3MuYkRlZmVyTG9hZGluZzsgLy8gdmFsdWUgbW9kaWZpZWQgYnkgdGhlIGRyYXdcblxuICAgICAgICAgICAgLyogRW5zdXJlIHRoYXQgdGhlIHRhYmxlIGRhdGEgaXMgZnVsbHkgaW5pdGlhbGlzZWQgKi9cbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYkluaXRpYWxpc2VkKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IF9mbkluaXRpYWxpc2Uoc2V0dGluZ3MpOyB9LCAyMDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogU2hvdyB0aGUgZGlzcGxheSBIVE1MIG9wdGlvbnMgKi9cbiAgICAgICAgICAgIF9mbkFkZE9wdGlvbnNIdG1sKHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLyogQnVpbGQgYW5kIGRyYXcgdGhlIGhlYWRlciAvIGZvb3RlciBmb3IgdGhlIHRhYmxlICovXG4gICAgICAgICAgICBfZm5CdWlsZEhlYWQoc2V0dGluZ3MpO1xuICAgICAgICAgICAgX2ZuRHJhd0hlYWQoc2V0dGluZ3MsIHNldHRpbmdzLmFvSGVhZGVyKTtcbiAgICAgICAgICAgIF9mbkRyYXdIZWFkKHNldHRpbmdzLCBzZXR0aW5ncy5hb0Zvb3Rlcik7XG5cbiAgICAgICAgICAgIC8qIE9rYXkgdG8gc2hvdyB0aGF0IHNvbWV0aGluZyBpcyBnb2luZyBvbiBub3cgKi9cbiAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcblxuICAgICAgICAgICAgLyogQ2FsY3VsYXRlIHNpemVzIGZvciBjb2x1bW5zICovXG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMuYkF1dG9XaWR0aCkge1xuICAgICAgICAgICAgICAgIF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyhzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBjb2x1bW5zLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNXaWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4ublRoLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29sdW1uLnNXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdwcmVJbml0JywgW3NldHRpbmdzXSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGRlZmF1bHQgc29ydGluZyByZXF1aXJlZCAtIGxldCdzIGRvIGl0LiBUaGUgc29ydCBmdW5jdGlvblxuICAgICAgICAgICAgLy8gd2lsbCBkbyB0aGUgZHJhd2luZyBmb3IgdXMuIE90aGVyd2lzZSB3ZSBkcmF3IHRoZSB0YWJsZSByZWdhcmRsZXNzIG9mIHRoZVxuICAgICAgICAgICAgLy8gQWpheCBzb3VyY2UgLSB0aGlzIGFsbG93cyB0aGUgdGFibGUgdG8gbG9vayBpbml0aWFsaXNlZCBmb3IgQWpheCBzb3VyY2luZ1xuICAgICAgICAgICAgLy8gZGF0YSAoc2hvdyAnbG9hZGluZycgbWVzc2FnZSBwb3NzaWJseSlcbiAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIFNlcnZlci1zaWRlIHByb2Nlc3NpbmcgaW5pdCBjb21wbGV0ZSBpcyBkb25lIGJ5IF9mbkFqYXhVcGRhdGVEcmF3XG4gICAgICAgICAgICB2YXIgZGF0YVNyYyA9IF9mbkRhdGFTb3VyY2Uoc2V0dGluZ3MpO1xuICAgICAgICAgICAgaWYgKGRhdGFTcmMgIT0gJ3NzcCcgfHwgZGVmZXJMb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gYWpheCBzb3VyY2UgbG9hZCB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIGlmIChkYXRhU3JjID09ICdhamF4Jykge1xuICAgICAgICAgICAgICAgICAgICBfZm5CdWlsZEFqYXgoc2V0dGluZ3MsIFtdLCBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFEYXRhID0gX2ZuQWpheERhdGFTcmMoc2V0dGluZ3MsIGpzb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHb3QgdGhlIGRhdGEgLSBhZGQgaXQgdG8gdGhlIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYURhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGREYXRhKHNldHRpbmdzLCBhRGF0YVtpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBpbml0IGRpc3BsYXkgZm9yIGNvb2tpZSBzYXZpbmcuIFdlJ3ZlIGFscmVhZHkgZG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSBmaWx0ZXIsIGFuZCB0aGVyZWZvcmUgY2xlYXJlZCBpdCBiZWZvcmUuIFNvIHdlIG5lZWQgdG8gbWFrZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgYXBwZWFyICdmcmVzaCdcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmlJbml0RGlzcGxheVN0YXJ0ID0gaUFqYXhTdGFydDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkluaXRDb21wbGV0ZShzZXR0aW5ncywganNvbik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIF9mbkluaXRDb21wbGV0ZShzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyB0aGUgdGFibGUgZm9yIHRoZSBmaXJzdCB0aW1lLCBhZGRpbmcgYWxsIHJlcXVpcmVkIGZlYXR1cmVzXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gW2pzb25dIEpTT04gZnJvbSB0aGUgc2VydmVyIHRoYXQgY29tcGxldGVkIHRoZSB0YWJsZSwgaWYgdXNpbmcgQWpheCBzb3VyY2VcbiAgICAgICAgICogICAgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nIChvcHRpb25hbClcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuSW5pdENvbXBsZXRlKHNldHRpbmdzLCBqc29uKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5fYkluaXRDb21wbGV0ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFdoZW4gZGF0YSB3YXMgYWRkZWQgYWZ0ZXIgdGhlIGluaXRpYWxpc2F0aW9uIChkYXRhIG9yIEFqYXgpIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgY29sdW1uIHNpemluZ1xuICAgICAgICAgICAgaWYgKGpzb24gfHwgc2V0dGluZ3Mub0luaXQuYWFEYXRhKSB7XG4gICAgICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAncGx1Z2luLWluaXQnLCBbc2V0dGluZ3MsIGpzb25dKTtcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgJ2FvSW5pdENvbXBsZXRlJywgJ2luaXQnLCBbc2V0dGluZ3MsIGpzb25dKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZnVuY3Rpb24gX2ZuTGVuZ3RoQ2hhbmdlKHNldHRpbmdzLCB2YWwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBwYXJzZUludCh2YWwsIDEwKTtcbiAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IGxlbjtcblxuICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBGaXJlIGxlbmd0aCBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgbnVsbCwgJ2xlbmd0aCcsIFtzZXR0aW5ncywgbGVuXSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdXNlciBkaXNwbGF5IGxlbmd0aCBjaGFuZ2luZ1xuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gRGlzcGxheSBsZW5ndGggZmVhdHVyZSBub2RlXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sTGVuZ3RoKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXMsXG4gICAgICAgICAgICAgICAgdGFibGVJZCA9IHNldHRpbmdzLnNUYWJsZUlkLFxuICAgICAgICAgICAgICAgIG1lbnUgPSBzZXR0aW5ncy5hTGVuZ3RoTWVudSxcbiAgICAgICAgICAgICAgICBkMiA9IEFycmF5LmlzQXJyYXkobWVudVswXSksXG4gICAgICAgICAgICAgICAgbGVuZ3RocyA9IGQyID8gbWVudVswXSA6IG1lbnUsXG4gICAgICAgICAgICAgICAgbGFuZ3VhZ2UgPSBkMiA/IG1lbnVbMV0gOiBtZW51O1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ID0gJCgnPHNlbGVjdC8+Jywge1xuICAgICAgICAgICAgICAgICduYW1lJzogdGFibGVJZCArICdfbGVuZ3RoJyxcbiAgICAgICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHRhYmxlSWQsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogY2xhc3Nlcy5zTGVuZ3RoU2VsZWN0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGxlbmd0aHMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RbMF1baV0gPSBuZXcgT3B0aW9uKFxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgbGFuZ3VhZ2VbaV0gPT09ICdudW1iZXInID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmZuRm9ybWF0TnVtYmVyKGxhbmd1YWdlW2ldKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZVtpXSxcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3Roc1tpXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkaXYgPSAkKCc8ZGl2PjxsYWJlbC8+PC9kaXY+JykuYWRkQ2xhc3MoY2xhc3Nlcy5zTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWFuRmVhdHVyZXMubCkge1xuICAgICAgICAgICAgICAgIGRpdlswXS5pZCA9IHRhYmxlSWQgKyAnX2xlbmd0aCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpdi5jaGlsZHJlbigpLmFwcGVuZChcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0xlbmd0aE1lbnUucmVwbGFjZSgnX01FTlVfJywgc2VsZWN0WzBdLm91dGVySFRNTClcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIENhbid0IHVzZSBgc2VsZWN0YCB2YXJpYWJsZSBhcyB1c2VyIG1pZ2h0IHByb3ZpZGUgdGhlaXIgb3duIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBpcyBicm9rZW4gYnkgdGhlIHVzZSBvZiBvdXRlckhUTUxcbiAgICAgICAgICAgICQoJ3NlbGVjdCcsIGRpdilcbiAgICAgICAgICAgICAgICAudmFsKHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aClcbiAgICAgICAgICAgICAgICAub24oJ2NoYW5nZS5EVCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mbkxlbmd0aENoYW5nZShzZXR0aW5ncywgJCh0aGlzKS52YWwoKSk7XG4gICAgICAgICAgICAgICAgICAgIF9mbkRyYXcoc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgbm9kZSB2YWx1ZSB3aGVuZXZlciBhbnl0aGluZyBjaGFuZ2VzIHRoZSB0YWJsZSdzIGxlbmd0aFxuICAgICAgICAgICAgJChzZXR0aW5ncy5uVGFibGUpLm9uKCdsZW5ndGguZHQuRFQnLCBmdW5jdGlvbiAoZSwgcywgbGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzID09PSBzKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJ3NlbGVjdCcsIGRpdikudmFsKGxlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBkaXZbMF07XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICpcbiAgICAgICAgICogTm90ZSB0aGF0IG1vc3Qgb2YgdGhlIHBhZ2luZyBsb2dpYyBpcyBkb25lIGluXG4gICAgICAgICAqIERhdGFUYWJsZS5leHQucGFnZXJcbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlIHRoZSBub2RlIHJlcXVpcmVkIGZvciBkZWZhdWx0IHBhZ2luYXRpb25cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBQYWdpbmF0aW9uIGZlYXR1cmUgbm9kZVxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5GZWF0dXJlSHRtbFBhZ2luYXRlKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICB0eXBlID0gc2V0dGluZ3Muc1BhZ2luYXRpb25UeXBlLFxuICAgICAgICAgICAgICAgIHBsdWdpbiA9IERhdGFUYWJsZS5leHQucGFnZXJbdHlwZV0sXG4gICAgICAgICAgICAgICAgbW9kZXJuID0gdHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgICAgICAgICAgICByZWRyYXcgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBub2RlID0gJCgnPGRpdi8+JykuYWRkQ2xhc3Moc2V0dGluZ3Mub0NsYXNzZXMuc1BhZ2luZyArIHR5cGUpWzBdLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gc2V0dGluZ3MuYWFuRmVhdHVyZXM7XG5cbiAgICAgICAgICAgIGlmICghbW9kZXJuKSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLmZuSW5pdChzZXR0aW5ncywgbm9kZSwgcmVkcmF3KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogQWRkIGEgZHJhdyBjYWxsYmFjayBmb3IgdGhlIHBhZ2luYXRpb24gb24gZmlyc3QgaW5zdGFuY2UsIHRvIHVwZGF0ZSB0aGUgcGFnaW5nIGRpc3BsYXkgKi9cbiAgICAgICAgICAgIGlmICghZmVhdHVyZXMucCkge1xuICAgICAgICAgICAgICAgIG5vZGUuaWQgPSBzZXR0aW5ncy5zVGFibGVJZCArICdfcGFnaW5hdGUnO1xuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIFwiZm5cIjogZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kZXJuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsID0gbGVuID09PSAtMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFnZSA9IGFsbCA/IDAgOiBNYXRoLmNlaWwoc3RhcnQgLyBsZW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYWdlcyA9IGFsbCA/IDEgOiBNYXRoLmNlaWwodmlzUmVjb3JkcyAvIGxlbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnMgPSBwbHVnaW4ocGFnZSwgcGFnZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpLCBpZW47XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBmZWF0dXJlcy5wLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mblJlbmRlcmVyKHNldHRpbmdzLCAncGFnZUJ1dHRvbicpKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MsIGZlYXR1cmVzLnBbaV0sIGksIGJ1dHRvbnMsIHBhZ2UsIHBhZ2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmZuVXBkYXRlKHNldHRpbmdzLCByZWRyYXcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInNOYW1lXCI6IFwicGFnaW5hdGlvblwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWx0ZXIgdGhlIGRpc3BsYXkgc2V0dGluZ3MgdG8gY2hhbmdlIHRoZSBwYWdlXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfGludH0gYWN0aW9uIFBhZ2luZyBhY3Rpb24gdG8gdGFrZTogXCJmaXJzdFwiLCBcInByZXZpb3VzXCIsXG4gICAgICAgICAqICAgIFwibmV4dFwiIG9yIFwibGFzdFwiIG9yIHBhZ2UgbnVtYmVyIHRvIGp1bXAgdG8gKGludGVnZXIpXG4gICAgICAgICAqICBAcGFyYW0gW2Jvb2xdIHJlZHJhdyBBdXRvbWF0aWNhbGx5IGRyYXcgdGhlIHVwZGF0ZSBvciBub3RcbiAgICAgICAgICogIEByZXR1cm5zIHtib29sfSB0cnVlIHBhZ2UgaGFzIGNoYW5nZWQsIGZhbHNlIC0gbm8gY2hhbmdlXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblBhZ2VDaGFuZ2Uoc2V0dGluZ3MsIGFjdGlvbiwgcmVkcmF3KSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBzdGFydCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlbiA9IHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCxcbiAgICAgICAgICAgICAgICByZWNvcmRzID0gc2V0dGluZ3MuZm5SZWNvcmRzRGlzcGxheSgpO1xuXG4gICAgICAgICAgICBpZiAocmVjb3JkcyA9PT0gMCB8fCBsZW4gPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFjdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gYWN0aW9uICogbGVuO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwiZmlyc3RcIikge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGFjdGlvbiA9PSBcInByZXZpb3VzXCIpIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IGxlbiA+PSAwID9cbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgLSBsZW4gOlxuICAgICAgICAgICAgICAgICAgICAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwibmV4dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ICsgbGVuIDwgcmVjb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBzdGFydCArPSBsZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWN0aW9uID09IFwibGFzdFwiKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBNYXRoLmZsb29yKChyZWNvcmRzIC0gMSkgLyBsZW4pICogbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX2ZuTG9nKHNldHRpbmdzLCAwLCBcIlVua25vd24gcGFnaW5nIGFjdGlvbjogXCIgKyBhY3Rpb24sIDUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2hhbmdlZCA9IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ICE9PSBzdGFydDtcbiAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAncGFnZScsIFtzZXR0aW5nc10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlZHJhdykge1xuICAgICAgICAgICAgICAgICAgICBfZm5EcmF3KHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZW5lcmF0ZSB0aGUgbm9kZSByZXF1aXJlZCBmb3IgdGhlIHByb2Nlc3Npbmcgbm9kZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcmV0dXJucyB7bm9kZX0gUHJvY2Vzc2luZyBlbGVtZW50XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyhzZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuICQoJzxkaXYvPicsIHtcbiAgICAgICAgICAgICAgICAnaWQnOiAhc2V0dGluZ3MuYWFuRmVhdHVyZXMuciA/IHNldHRpbmdzLnNUYWJsZUlkICsgJ19wcm9jZXNzaW5nJyA6IG51bGwsXG4gICAgICAgICAgICAgICAgJ2NsYXNzJzogc2V0dGluZ3Mub0NsYXNzZXMuc1Byb2Nlc3NpbmdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmh0bWwoc2V0dGluZ3Mub0xhbmd1YWdlLnNQcm9jZXNzaW5nKVxuICAgICAgICAgICAgICAgIC5pbnNlcnRCZWZvcmUoc2V0dGluZ3MublRhYmxlKVswXTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc3BsYXkgb3IgaGlkZSB0aGUgcHJvY2Vzc2luZyBpbmRpY2F0b3JcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sfSBzaG93IFNob3cgdGhlIHByb2Nlc3NpbmcgaW5kaWNhdG9yICh0cnVlKSBvciBub3QgKGZhbHNlKVxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgc2hvdykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9GZWF0dXJlcy5iUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgICAgICQoc2V0dGluZ3MuYWFuRmVhdHVyZXMucikuY3NzKCdkaXNwbGF5Jywgc2hvdyA/ICdibG9jaycgOiAnbm9uZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdwcm9jZXNzaW5nJywgW3NldHRpbmdzLCBzaG93XSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFueSBjb250cm9sIGVsZW1lbnRzIGZvciB0aGUgdGFibGUgLSBzcGVjaWZpY2FsbHkgc2Nyb2xsaW5nXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEByZXR1cm5zIHtub2RlfSBOb2RlIHRvIGFkZCB0byB0aGUgRE9NXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkZlYXR1cmVIdG1sVGFibGUoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9ICQoc2V0dGluZ3MublRhYmxlKTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoZSBBUklBIGdyaWQgcm9sZSB0byB0aGUgdGFibGVcbiAgICAgICAgICAgIHRhYmxlLmF0dHIoJ3JvbGUnLCAnZ3JpZCcpO1xuXG4gICAgICAgICAgICAvLyBTY3JvbGxpbmcgZnJvbSBoZXJlIG9uIGluXG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbDtcblxuICAgICAgICAgICAgaWYgKHNjcm9sbC5zWCA9PT0gJycgJiYgc2Nyb2xsLnNZID09PSAnJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5uVGFibGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzY3JvbGxYID0gc2Nyb2xsLnNYO1xuICAgICAgICAgICAgdmFyIHNjcm9sbFkgPSBzY3JvbGwuc1k7XG4gICAgICAgICAgICB2YXIgY2xhc3NlcyA9IHNldHRpbmdzLm9DbGFzc2VzO1xuICAgICAgICAgICAgdmFyIGNhcHRpb24gPSB0YWJsZS5jaGlsZHJlbignY2FwdGlvbicpO1xuICAgICAgICAgICAgdmFyIGNhcHRpb25TaWRlID0gY2FwdGlvbi5sZW5ndGggPyBjYXB0aW9uWzBdLl9jYXB0aW9uU2lkZSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGVhZGVyQ2xvbmUgPSAkKHRhYmxlWzBdLmNsb25lTm9kZShmYWxzZSkpO1xuICAgICAgICAgICAgdmFyIGZvb3RlckNsb25lID0gJCh0YWJsZVswXS5jbG9uZU5vZGUoZmFsc2UpKTtcbiAgICAgICAgICAgIHZhciBmb290ZXIgPSB0YWJsZS5jaGlsZHJlbigndGZvb3QnKTtcbiAgICAgICAgICAgIHZhciBfZGl2ID0gJzxkaXYvPic7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFzID8gbnVsbCA6IF9mblN0cmluZ1RvQ3NzKHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFmb290ZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9vdGVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIFRoZSBIVE1MIHN0cnVjdHVyZSB0aGF0IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaW4gdGhpcyBmdW5jdGlvbiBpczpcbiAgICAgICAgICAgICAqICBkaXYgLSBzY3JvbGxlclxuICAgICAgICAgICAgICogICAgZGl2IC0gc2Nyb2xsIGhlYWRcbiAgICAgICAgICAgICAqICAgICAgZGl2IC0gc2Nyb2xsIGhlYWQgaW5uZXJcbiAgICAgICAgICAgICAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBoZWFkIHRhYmxlXG4gICAgICAgICAgICAgKiAgICAgICAgICB0aGVhZCAtIHRoZWFkXG4gICAgICAgICAgICAgKiAgICBkaXYgLSBzY3JvbGwgYm9keVxuICAgICAgICAgICAgICogICAgICB0YWJsZSAtIHRhYmxlIChtYXN0ZXIgdGFibGUpXG4gICAgICAgICAgICAgKiAgICAgICAgdGhlYWQgLSB0aGVhZCBjbG9uZSBmb3Igc2l6aW5nXG4gICAgICAgICAgICAgKiAgICAgICAgdGJvZHkgLSB0Ym9keVxuICAgICAgICAgICAgICogICAgZGl2IC0gc2Nyb2xsIGZvb3RcbiAgICAgICAgICAgICAqICAgICAgZGl2IC0gc2Nyb2xsIGZvb3QgaW5uZXJcbiAgICAgICAgICAgICAqICAgICAgICB0YWJsZSAtIHNjcm9sbCBmb290IHRhYmxlXG4gICAgICAgICAgICAgKiAgICAgICAgICB0Zm9vdCAtIHRmb290XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBzY3JvbGxlciA9ICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxXcmFwcGVyIH0pXG4gICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgJChfZGl2LCB7ICdjbGFzcyc6IGNsYXNzZXMuc1Njcm9sbEhlYWQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXI6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbFggPyBzaXplKHNjcm9sbFgpIDogJzEwMCUnXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsSGVhZElubmVyIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JveC1zaXppbmcnOiAnY29udGVudC1ib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNjcm9sbC5zWElubmVyIHx8ICcxMDAlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyQ2xvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQXR0cignaWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jc3MoJ21hcmdpbi1sZWZ0JywgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKGNhcHRpb25TaWRlID09PSAndG9wJyA/IGNhcHRpb24gOiBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hcHBlbmQoXG4gICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxCb2R5IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzaXplKHNjcm9sbFgpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0YWJsZSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXIuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAkKF9kaXYsIHsgJ2NsYXNzJzogY2xhc3Nlcy5zU2Nyb2xsRm9vdCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogc2Nyb2xsWCA/IHNpemUoc2Nyb2xsWCkgOiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQoX2RpdiwgeyAnY2xhc3MnOiBjbGFzc2VzLnNTY3JvbGxGb290SW5uZXIgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvb3RlckNsb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2lkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY3NzKCdtYXJnaW4tbGVmdCcsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjYXB0aW9uU2lkZSA9PT0gJ2JvdHRvbScgPyBjYXB0aW9uIDogbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJsZS5jaGlsZHJlbigndGZvb3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHNjcm9sbGVyLmNoaWxkcmVuKCk7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsSGVhZCA9IGNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgdmFyIHNjcm9sbEJvZHkgPSBjaGlsZHJlblsxXTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxGb290ID0gZm9vdGVyID8gY2hpbGRyZW5bMl0gOiBudWxsO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBib2R5IGlzIHNjcm9sbGVkLCB0aGVuIHdlIGFsc28gd2FudCB0byBzY3JvbGwgdGhlIGhlYWRlcnNcbiAgICAgICAgICAgIGlmIChzY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgJChzY3JvbGxCb2R5KS5vbignc2Nyb2xsLkRUJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLnNjcm9sbExlZnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgc2Nyb2xsSGVhZC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxGb290LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQoc2Nyb2xsQm9keSkuY3NzKCdtYXgtaGVpZ2h0Jywgc2Nyb2xsWSk7XG4gICAgICAgICAgICBpZiAoIXNjcm9sbC5iQ29sbGFwc2UpIHtcbiAgICAgICAgICAgICAgICAkKHNjcm9sbEJvZHkpLmNzcygnaGVpZ2h0Jywgc2Nyb2xsWSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxIZWFkID0gc2Nyb2xsSGVhZDtcbiAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxCb2R5ID0gc2Nyb2xsQm9keTtcbiAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxGb290ID0gc2Nyb2xsRm9vdDtcblxuICAgICAgICAgICAgLy8gT24gcmVkcmF3IC0gYWxpZ24gY29sdW1uc1xuICAgICAgICAgICAgc2V0dGluZ3MuYW9EcmF3Q2FsbGJhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgXCJmblwiOiBfZm5TY3JvbGxEcmF3LFxuICAgICAgICAgICAgICAgIFwic05hbWVcIjogXCJzY3JvbGxpbmdcIlxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBzY3JvbGxlclswXTtcbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBoZWFkZXIsIGZvb3RlciBhbmQgYm9keSB0YWJsZXMgZm9yIHJlc2l6aW5nIC0gaS5lLiBjb2x1bW5cbiAgICAgICAgICogYWxpZ25tZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBXZWxjb21lIHRvIHRoZSBtb3N0IGhvcnJpYmxlIGZ1bmN0aW9uIERhdGFUYWJsZXMuIFRoZSBwcm9jZXNzIHRoYXQgdGhpc1xuICAgICAgICAgKiBmdW5jdGlvbiBmb2xsb3dzIGlzIGJhc2ljYWxseTpcbiAgICAgICAgICogICAxLiBSZS1jcmVhdGUgdGhlIHRhYmxlIGluc2lkZSB0aGUgc2Nyb2xsaW5nIGRpdlxuICAgICAgICAgKiAgIDIuIFRha2UgbGl2ZSBtZWFzdXJlbWVudHMgZnJvbSB0aGUgRE9NXG4gICAgICAgICAqICAgMy4gQXBwbHkgdGhlIG1lYXN1cmVtZW50cyB0byBhbGlnbiB0aGUgY29sdW1uc1xuICAgICAgICAgKiAgIDQuIENsZWFuIHVwXG4gICAgICAgICAqXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU2Nyb2xsRHJhdyhzZXR0aW5ncykge1xuICAgICAgICAgICAgLy8gR2l2ZW4gdGhhdCB0aGlzIGlzIHN1Y2ggYSBtb25zdGVyIGZ1bmN0aW9uLCBhIGxvdCBvZiB2YXJpYWJsZXMgYXJlIHVzZVxuICAgICAgICAgICAgLy8gdG8gdHJ5IGFuZCBrZWVwIHRoZSBtaW5pbWlzZWQgc2l6ZSBhcyBzbWFsbCBhcyBwb3NzaWJsZVxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgc2Nyb2xsID0gc2V0dGluZ3Mub1Njcm9sbCxcbiAgICAgICAgICAgICAgICBzY3JvbGxYID0gc2Nyb2xsLnNYLFxuICAgICAgICAgICAgICAgIHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxuICAgICAgICAgICAgICAgIHNjcm9sbFkgPSBzY3JvbGwuc1ksXG4gICAgICAgICAgICAgICAgYmFyV2lkdGggPSBzY3JvbGwuaUJhcldpZHRoLFxuICAgICAgICAgICAgICAgIGRpdkhlYWRlciA9ICQoc2V0dGluZ3MublNjcm9sbEhlYWQpLFxuICAgICAgICAgICAgICAgIGRpdkhlYWRlclN0eWxlID0gZGl2SGVhZGVyWzBdLnN0eWxlLFxuICAgICAgICAgICAgICAgIGRpdkhlYWRlcklubmVyID0gZGl2SGVhZGVyLmNoaWxkcmVuKCdkaXYnKSxcbiAgICAgICAgICAgICAgICBkaXZIZWFkZXJJbm5lclN0eWxlID0gZGl2SGVhZGVySW5uZXJbMF0uc3R5bGUsXG4gICAgICAgICAgICAgICAgZGl2SGVhZGVyVGFibGUgPSBkaXZIZWFkZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcbiAgICAgICAgICAgICAgICBkaXZCb2R5RWwgPSBzZXR0aW5ncy5uU2Nyb2xsQm9keSxcbiAgICAgICAgICAgICAgICBkaXZCb2R5ID0gJChkaXZCb2R5RWwpLFxuICAgICAgICAgICAgICAgIGRpdkJvZHlTdHlsZSA9IGRpdkJvZHlFbC5zdHlsZSxcbiAgICAgICAgICAgICAgICBkaXZGb290ZXIgPSAkKHNldHRpbmdzLm5TY3JvbGxGb290KSxcbiAgICAgICAgICAgICAgICBkaXZGb290ZXJJbm5lciA9IGRpdkZvb3Rlci5jaGlsZHJlbignZGl2JyksXG4gICAgICAgICAgICAgICAgZGl2Rm9vdGVyVGFibGUgPSBkaXZGb290ZXJJbm5lci5jaGlsZHJlbigndGFibGUnKSxcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSAkKHNldHRpbmdzLm5USGVhZCksXG4gICAgICAgICAgICAgICAgdGFibGUgPSAkKHNldHRpbmdzLm5UYWJsZSksXG4gICAgICAgICAgICAgICAgdGFibGVFbCA9IHRhYmxlWzBdLFxuICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUgPSB0YWJsZUVsLnN0eWxlLFxuICAgICAgICAgICAgICAgIGZvb3RlciA9IHNldHRpbmdzLm5URm9vdCA/ICQoc2V0dGluZ3MublRGb290KSA6IG51bGwsXG4gICAgICAgICAgICAgICAgYnJvd3NlciA9IHNldHRpbmdzLm9Ccm93c2VyLFxuICAgICAgICAgICAgICAgIGllNjcgPSBicm93c2VyLmJTY3JvbGxPdmVyc2l6ZSxcbiAgICAgICAgICAgICAgICBkdEhlYWRlckNlbGxzID0gX3BsdWNrKHNldHRpbmdzLmFvQ29sdW1ucywgJ25UaCcpLFxuICAgICAgICAgICAgICAgIGhlYWRlclRyZ0VscywgZm9vdGVyVHJnRWxzLFxuICAgICAgICAgICAgICAgIGhlYWRlclNyY0VscywgZm9vdGVyU3JjRWxzLFxuICAgICAgICAgICAgICAgIGhlYWRlckNvcHksIGZvb3RlckNvcHksXG4gICAgICAgICAgICAgICAgaGVhZGVyV2lkdGhzID0gW10sIGZvb3RlcldpZHRocyA9IFtdLFxuICAgICAgICAgICAgICAgIGhlYWRlckNvbnRlbnQgPSBbXSwgZm9vdGVyQ29udGVudCA9IFtdLFxuICAgICAgICAgICAgICAgIGlkeCwgY29ycmVjdGlvbiwgc2FuaXR5V2lkdGgsXG4gICAgICAgICAgICAgICAgemVyb091dCA9IGZ1bmN0aW9uIChuU2l6ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0eWxlID0gblNpemVyLnN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWRkaW5nVG9wID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhZGRpbmdCb3R0b20gPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBcIjBcIjtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgc2Nyb2xsYmFyIHZpc2liaWxpdHkgaGFzIGNoYW5nZWQgZnJvbSB0aGUgbGFzdCBkcmF3LCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGNvbHVtbiBzaXplcyBhcyB0aGUgdGFibGUgd2lkdGggd2lsbCBoYXZlIGNoYW5nZWQgdG8gYWNjb3VudFxuICAgICAgICAgICAgLy8gZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgICAgICAgIHZhciBzY3JvbGxCYXJWaXMgPSBkaXZCb2R5RWwuc2Nyb2xsSGVpZ2h0ID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodDtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjcm9sbEJhclZpcyAhPT0gc2Nyb2xsQmFyVmlzICYmIHNldHRpbmdzLnNjcm9sbEJhclZpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBhZGp1c3QgY29sdW1uIHNpemluZyB3aWxsIGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2FpblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc2Nyb2xsQmFyVmlzID0gc2Nyb2xsQmFyVmlzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogMS4gUmUtY3JlYXRlIHRoZSB0YWJsZSBpbnNpZGUgdGhlIHNjcm9sbGluZyBkaXZcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCBtaW5pbWlzZWQgdGhlYWQgYW5kIHRmb290IGVsZW1lbnRzIGluIHRoZSBpbm5lciB0YWJsZVxuICAgICAgICAgICAgdGFibGUuY2hpbGRyZW4oJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgZm9vdGVyQ29weSA9IGZvb3Rlci5jbG9uZSgpLnByZXBlbmRUbyh0YWJsZSk7XG4gICAgICAgICAgICAgICAgZm9vdGVyVHJnRWxzID0gZm9vdGVyLmZpbmQoJ3RyJyk7IC8vIHRoZSBvcmlnaW5hbCB0Zm9vdCBpcyBpbiBpdHMgb3duIHRhYmxlIGFuZCBtdXN0IGJlIHNpemVkXG4gICAgICAgICAgICAgICAgZm9vdGVyU3JjRWxzID0gZm9vdGVyQ29weS5maW5kKCd0cicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgY3VycmVudCBoZWFkZXIgYW5kIGZvb3RlciBlbGVtZW50cyBhbmQgdGhlbiBwbGFjZSBpdCBpbnRvIHRoZSBpbm5lciB0YWJsZVxuICAgICAgICAgICAgaGVhZGVyQ29weSA9IGhlYWRlci5jbG9uZSgpLnByZXBlbmRUbyh0YWJsZSk7XG4gICAgICAgICAgICBoZWFkZXJUcmdFbHMgPSBoZWFkZXIuZmluZCgndHInKTsgLy8gb3JpZ2luYWwgaGVhZGVyIGlzIGluIGl0cyBvd24gdGFibGVcbiAgICAgICAgICAgIGhlYWRlclNyY0VscyA9IGhlYWRlckNvcHkuZmluZCgndHInKTtcbiAgICAgICAgICAgIGhlYWRlckNvcHkuZmluZCgndGgsIHRkJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblxuXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogMi4gVGFrZSBsaXZlIG1lYXN1cmVtZW50cyBmcm9tIHRoZSBET00gLSBkbyBub3QgYWx0ZXIgdGhlIERPTSBpdHNlbGYhXG4gICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBzaXppbmcgYW5kIGFwcGx5IHRoZSBjYWxjdWxhdGVkIGNvbHVtbiB3aWR0aHNcbiAgICAgICAgICAgIC8vIEdldCB0aGUgdW5pcXVlIGNvbHVtbiBoZWFkZXJzIGluIHRoZSBuZXdseSBjcmVhdGVkIChjbG9uZWQpIGhlYWRlci4gV2Ugd2FudCB0byBhcHBseSB0aGVcbiAgICAgICAgICAgIC8vIGNhbGN1bGF0ZWQgc2l6ZXMgdG8gdGhpcyBoZWFkZXJcbiAgICAgICAgICAgIGlmICghc2Nyb2xsWCkge1xuICAgICAgICAgICAgICAgIGRpdkJvZHlTdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICBkaXZIZWFkZXJbMF0uc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuZWFjaChfZm5HZXRVbmlxdWVUaHMoc2V0dGluZ3MsIGhlYWRlckNvcHkpLCBmdW5jdGlvbiAoaSwgZWwpIHtcbiAgICAgICAgICAgICAgICBpZHggPSBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChzZXR0aW5ncywgaSk7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBzZXR0aW5ncy5hb0NvbHVtbnNbaWR4XS5zV2lkdGg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xuICAgICAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICBuLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9LCBmb290ZXJTcmNFbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaXplIHRoZSB0YWJsZSBhcyBhIHdob2xlXG4gICAgICAgICAgICBzYW5pdHlXaWR0aCA9IHRhYmxlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxYID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gTm8geCBzY3JvbGxpbmdcbiAgICAgICAgICAgICAgICB0YWJsZVN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG5cbiAgICAgICAgICAgICAgICAvLyBJRTcgd2lsbCBtYWtlIHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgd2hlbiAxMDAlIGluY2x1ZGUgdGhlIHNjcm9sbGJhclxuICAgICAgICAgICAgICAgIC8vIC0gd2hpY2ggaXMgc2hvdWxkbid0LiBXaGVuIHRoZXJlIGlzIGEgc2Nyb2xsYmFyIHdlIG5lZWQgdG8gdGFrZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gaW50byBhY2NvdW50LlxuICAgICAgICAgICAgICAgIGlmIChpZTY3ICYmICh0YWJsZS5maW5kKCd0Ym9keScpLmhlaWdodCgpID4gZGl2Qm9keUVsLm9mZnNldEhlaWdodCB8fFxuICAgICAgICAgICAgICAgICAgICBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCIpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhYmxlU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0YWJsZS5vdXRlcldpZHRoKCkgLSBiYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHNhbml0eSB3aWR0aFxuICAgICAgICAgICAgICAgIHNhbml0eVdpZHRoID0gdGFibGUub3V0ZXJXaWR0aCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2Nyb2xsWElubmVyICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgLy8gbGVnYWN5IHggc2Nyb2xsIGlubmVyIGhhcyBiZWVuIGdpdmVuIC0gdXNlIGl0XG4gICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKHNjcm9sbFhJbm5lcik7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWNhbGN1bGF0ZSB0aGUgc2FuaXR5IHdpZHRoXG4gICAgICAgICAgICAgICAgc2FuaXR5V2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpZGRlbiBoZWFkZXIgc2hvdWxkIGhhdmUgemVybyBoZWlnaHQsIHNvIHJlbW92ZSBwYWRkaW5nIGFuZCBib3JkZXJzLiBUaGVuXG4gICAgICAgICAgICAvLyBzZXQgdGhlIHdpZHRoIGJhc2VkIG9uIHRoZSByZWFsIGhlYWRlcnNcblxuICAgICAgICAgICAgLy8gQXBwbHkgYWxsIHN0eWxlcyBpbiBvbmUgcGFzc1xuICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKHplcm9PdXQsIGhlYWRlclNyY0Vscyk7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgYWxsIHdpZHRocyBpbiBuZXh0IHBhc3NcbiAgICAgICAgICAgIF9mbkFwcGx5VG9DaGlsZHJlbihmdW5jdGlvbiAoblNpemVyKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyQ29udGVudC5wdXNoKG5TaXplci5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgIGhlYWRlcldpZHRocy5wdXNoKF9mblN0cmluZ1RvQ3NzKCQoblNpemVyKS5jc3MoJ3dpZHRoJykpKTtcbiAgICAgICAgICAgIH0sIGhlYWRlclNyY0Vscyk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IGFsbCB3aWR0aHMgaW4gZmluYWwgcGFzc1xuICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuVG9TaXplLCBpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhcHBseSB3aWR0aHMgdG8gdGhlIERhdGFUYWJsZXMgZGV0ZWN0ZWQgaGVhZGVyIGNlbGxzIC0gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHByZXZlbnRzIGNvbXBsZXggaGVhZGVycyBmcm9tIGhhdmluZyBjb250cmFkaWN0b3J5IHNpemVzIGFwcGxpZWRcbiAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KG5Ub1NpemUsIGR0SGVhZGVyQ2VsbHMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBuVG9TaXplLnN0eWxlLndpZHRoID0gaGVhZGVyV2lkdGhzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIGhlYWRlclRyZ0Vscyk7XG5cbiAgICAgICAgICAgICQoaGVhZGVyU3JjRWxzKS5oZWlnaHQoMCk7XG5cbiAgICAgICAgICAgIC8qIFNhbWUgYWdhaW4gd2l0aCB0aGUgZm9vdGVyIGlmIHdlIGhhdmUgb25lICovXG4gICAgICAgICAgICBpZiAoZm9vdGVyKSB7XG4gICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKHplcm9PdXQsIGZvb3RlclNyY0Vscyk7XG5cbiAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplcikge1xuICAgICAgICAgICAgICAgICAgICBmb290ZXJDb250ZW50LnB1c2goblNpemVyLmlubmVySFRNTCk7XG4gICAgICAgICAgICAgICAgICAgIGZvb3RlcldpZHRocy5wdXNoKF9mblN0cmluZ1RvQ3NzKCQoblNpemVyKS5jc3MoJ3dpZHRoJykpKTtcbiAgICAgICAgICAgICAgICB9LCBmb290ZXJTcmNFbHMpO1xuXG4gICAgICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuVG9TaXplLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5Ub1NpemUuc3R5bGUud2lkdGggPSBmb290ZXJXaWR0aHNbaV07XG4gICAgICAgICAgICAgICAgfSwgZm9vdGVyVHJnRWxzKTtcblxuICAgICAgICAgICAgICAgICQoZm9vdGVyU3JjRWxzKS5oZWlnaHQoMCk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIDMuIEFwcGx5IHRoZSBtZWFzdXJlbWVudHNcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAvLyBcIkhpZGVcIiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGhhdCB3ZSB1c2VkIGZvciB0aGUgc2l6aW5nLiBXZSBuZWVkIHRvIGtlZXBcbiAgICAgICAgICAgIC8vIHRoZSBjb250ZW50IG9mIHRoZSBjZWxsIHNvIHRoYXQgdGhlIHdpZHRoIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBhbmQgYm9keVxuICAgICAgICAgICAgLy8gYm90aCBtYXRjaCwgYnV0IHdlIHdhbnQgdG8gaGlkZSBpdCBjb21wbGV0ZWx5LiBXZSB3YW50IHRvIGFsc28gZml4IHRoZWlyXG4gICAgICAgICAgICAvLyB3aWR0aCB0byB3aGF0IHRoZXkgY3VycmVudGx5IGFyZVxuICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuKGZ1bmN0aW9uIChuU2l6ZXIsIGkpIHtcbiAgICAgICAgICAgICAgICBuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicgKyBoZWFkZXJDb250ZW50W2ldICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgblNpemVyLmNoaWxkTm9kZXNbMF0uc3R5bGUuaGVpZ2h0ID0gXCIwXCI7XG4gICAgICAgICAgICAgICAgblNpemVyLmNoaWxkTm9kZXNbMF0uc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgICAgICAgICAgICAgIG5TaXplci5zdHlsZS53aWR0aCA9IGhlYWRlcldpZHRoc1tpXTtcbiAgICAgICAgICAgIH0sIGhlYWRlclNyY0Vscyk7XG5cbiAgICAgICAgICAgIGlmIChmb290ZXIpIHtcbiAgICAgICAgICAgICAgICBfZm5BcHBseVRvQ2hpbGRyZW4oZnVuY3Rpb24gKG5TaXplciwgaSkge1xuICAgICAgICAgICAgICAgICAgICBuU2l6ZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJkYXRhVGFibGVzX3NpemluZ1wiPicgKyBmb290ZXJDb250ZW50W2ldICsgJzwvZGl2Pic7XG4gICAgICAgICAgICAgICAgICAgIG5TaXplci5jaGlsZE5vZGVzWzBdLnN0eWxlLmhlaWdodCA9IFwiMFwiO1xuICAgICAgICAgICAgICAgICAgICBuU2l6ZXIuY2hpbGROb2Rlc1swXS5zdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgIG5TaXplci5zdHlsZS53aWR0aCA9IGZvb3RlcldpZHRoc1tpXTtcbiAgICAgICAgICAgICAgICB9LCBmb290ZXJTcmNFbHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTYW5pdHkgY2hlY2sgdGhhdCB0aGUgdGFibGUgaXMgb2YgYSBzZW5zaWJsZSB3aWR0aC4gSWYgbm90IHRoZW4gd2UgYXJlIGdvaW5nIHRvIGdldFxuICAgICAgICAgICAgLy8gbWlzYWxpZ25tZW50IC0gdHJ5IHRvIHByZXZlbnQgdGhpcyBieSBub3QgYWxsb3dpbmcgdGhlIHRhYmxlIHRvIHNocmluayBiZWxvdyBpdHMgbWluIHdpZHRoXG4gICAgICAgICAgICBpZiAodGFibGUub3V0ZXJXaWR0aCgpIDwgc2FuaXR5V2lkdGgpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWluIHdpZHRoIGRlcGVuZHMgdXBvbiBpZiB3ZSBoYXZlIGEgdmVydGljYWwgc2Nyb2xsYmFyIHZpc2libGUgb3Igbm90ICovXG4gICAgICAgICAgICAgICAgY29ycmVjdGlvbiA9ICgoZGl2Qm9keUVsLnNjcm9sbEhlaWdodCA+IGRpdkJvZHlFbC5vZmZzZXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgZGl2Qm9keS5jc3MoJ292ZXJmbG93LXknKSA9PSBcInNjcm9sbFwiKSkgP1xuICAgICAgICAgICAgICAgICAgICBzYW5pdHlXaWR0aCArIGJhcldpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgc2FuaXR5V2lkdGg7XG5cbiAgICAgICAgICAgICAgICAvLyBJRTYvNyBhcmUgYSBsYXcgdW50byB0aGVtc2VsdmVzLi4uXG4gICAgICAgICAgICAgICAgaWYgKGllNjcgJiYgKGRpdkJvZHlFbC5zY3JvbGxIZWlnaHQgPlxuICAgICAgICAgICAgICAgICAgICBkaXZCb2R5RWwub2Zmc2V0SGVpZ2h0IHx8IGRpdkJvZHkuY3NzKCdvdmVyZmxvdy15JykgPT0gXCJzY3JvbGxcIilcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGFibGVTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGNvcnJlY3Rpb24gLSBiYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQW5kIGdpdmUgdGhlIHVzZXIgYSB3YXJuaW5nIHRoYXQgd2UndmUgc3RvcHBlZCB0aGUgdGFibGUgZ2V0dGluZyB0b28gc21hbGxcbiAgICAgICAgICAgICAgICBpZiAoc2Nyb2xsWCA9PT0gXCJcIiB8fCBzY3JvbGxYSW5uZXIgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuTG9nKHNldHRpbmdzLCAxLCAnUG9zc2libGUgY29sdW1uIG1pc2FsaWdubWVudCcsIDYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcnJlY3Rpb24gPSAnMTAwJSc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRoZSBjb250YWluZXIgZWxlbWVudHNcbiAgICAgICAgICAgIGRpdkJvZHlTdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGNvcnJlY3Rpb24pO1xuICAgICAgICAgICAgZGl2SGVhZGVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhjb3JyZWN0aW9uKTtcblxuICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm5TY3JvbGxGb290LnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoY29ycmVjdGlvbik7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIDQuIENsZWFuIHVwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghc2Nyb2xsWSkge1xuICAgICAgICAgICAgICAgIC8qIElFNzwgcHV0cyBhIHZlcnRpY2FsIHNjcm9sbGJhciBpbiBwbGFjZSAod2hlbiBpdCBzaG91bGRuJ3QgYmUpIGR1ZSB0byBzdWJ0cmFjdGluZ1xuICAgICAgICAgICAgICAgICAqIHRoZSBzY3JvbGxiYXIgaGVpZ2h0IGZyb20gdGhlIHZpc2libGUgZGlzcGxheSwgcmF0aGVyIHRoYW4gYWRkaW5nIGl0IG9uLiBXZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgICogc2V0IHRoZSBoZWlnaHQgaW4gb3JkZXIgdG8gc29ydCB0aGlzLiBEb24ndCB3YW50IHRvIGRvIGl0IGluIGFueSBvdGhlciBicm93c2Vycy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoaWU2Nykge1xuICAgICAgICAgICAgICAgICAgICBkaXZCb2R5U3R5bGUuaGVpZ2h0ID0gX2ZuU3RyaW5nVG9Dc3ModGFibGVFbC5vZmZzZXRIZWlnaHQgKyBiYXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBGaW5hbGx5IHNldCB0aGUgd2lkdGgncyBvZiB0aGUgaGVhZGVyIGFuZCBmb290ZXIgdGFibGVzICovXG4gICAgICAgICAgICB2YXIgaU91dGVyV2lkdGggPSB0YWJsZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgICBkaXZIZWFkZXJUYWJsZVswXS5zdHlsZS53aWR0aCA9IF9mblN0cmluZ1RvQ3NzKGlPdXRlcldpZHRoKTtcbiAgICAgICAgICAgIGRpdkhlYWRlcklubmVyU3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0NzcyhpT3V0ZXJXaWR0aCk7XG5cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgdGhlcmUgYXJlIHNjcm9sbGJhciBwcmVzZW50IC0gaWYgc28gdGhlbiB3ZSBuZWVkIGEgdGhlIGhlYWRlciBhbmQgZm9vdGVyIHRvXG4gICAgICAgICAgICAvLyBwcm92aWRlIGEgYml0IG1vcmUgc3BhY2UgdG8gYWxsb3cgXCJvdmVyZmxvd1wiIHNjcm9sbGluZyAoaS5lLiBwYXN0IHRoZSBzY3JvbGxiYXIpXG4gICAgICAgICAgICB2YXIgYlNjcm9sbGluZyA9IHRhYmxlLmhlaWdodCgpID4gZGl2Qm9keUVsLmNsaWVudEhlaWdodCB8fCBkaXZCb2R5LmNzcygnb3ZlcmZsb3cteScpID09IFwic2Nyb2xsXCI7XG4gICAgICAgICAgICB2YXIgcGFkZGluZyA9ICdwYWRkaW5nJyArIChicm93c2VyLmJTY3JvbGxiYXJMZWZ0ID8gJ0xlZnQnIDogJ1JpZ2h0Jyk7XG4gICAgICAgICAgICBkaXZIZWFkZXJJbm5lclN0eWxlW3BhZGRpbmddID0gYlNjcm9sbGluZyA/IGJhcldpZHRoICsgXCJweFwiIDogXCIwcHhcIjtcblxuICAgICAgICAgICAgaWYgKGZvb3Rlcikge1xuICAgICAgICAgICAgICAgIGRpdkZvb3RlclRhYmxlWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoaU91dGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGRpdkZvb3RlcklubmVyWzBdLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoaU91dGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgIGRpdkZvb3RlcklubmVyWzBdLnN0eWxlW3BhZGRpbmddID0gYlNjcm9sbGluZyA/IGJhcldpZHRoICsgXCJweFwiIDogXCIwcHhcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29ycmVjdCBET00gb3JkZXJpbmcgZm9yIGNvbGdyb3VwIC0gY29tZXMgYmVmb3JlIHRoZSB0aGVhZFxuICAgICAgICAgICAgdGFibGUuY2hpbGRyZW4oJ2NvbGdyb3VwJykuaW5zZXJ0QmVmb3JlKHRhYmxlLmNoaWxkcmVuKCd0aGVhZCcpKTtcblxuICAgICAgICAgICAgLyogQWRqdXN0IHRoZSBwb3NpdGlvbiBvZiB0aGUgaGVhZGVyIGluIGNhc2Ugd2UgbG9vc2UgdGhlIHktc2Nyb2xsYmFyICovXG4gICAgICAgICAgICBkaXZCb2R5LnRyaWdnZXIoJ3Njcm9sbCcpO1xuXG4gICAgICAgICAgICAvLyBJZiBzb3J0aW5nIG9yIGZpbHRlcmluZyBoYXMgb2NjdXJyZWQsIGp1bXAgdGhlIHNjcm9sbGluZyBiYWNrIHRvIHRoZSB0b3BcbiAgICAgICAgICAgIC8vIG9ubHkgaWYgd2UgYXJlbid0IGhvbGRpbmcgdGhlIHBvc2l0aW9uXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzLmJTb3J0ZWQgfHwgc2V0dGluZ3MuYkZpbHRlcmVkKSAmJiAhc2V0dGluZ3MuX2RyYXdIb2xkKSB7XG4gICAgICAgICAgICAgICAgZGl2Qm9keUVsLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IGEgZ2l2ZW4gZnVuY3Rpb24gdG8gdGhlIGRpc3BsYXkgY2hpbGQgbm9kZXMgb2YgYW4gZWxlbWVudCBhcnJheSAodHlwaWNhbGx5XG4gICAgICAgICAqIFREIGNoaWxkcmVuIG9mIFRSIHJvd3NcbiAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIE1ldGhvZCB0byBhcHBseSB0byB0aGUgb2JqZWN0c1xuICAgICAgICAgKiAgQHBhcmFtIGFycmF5IHtub2Rlc30gYW4xIExpc3Qgb2YgZWxlbWVudHMgdG8gbG9vayB0aHJvdWdoIGZvciBkaXNwbGF5IGNoaWxkcmVuXG4gICAgICAgICAqICBAcGFyYW0gYXJyYXkge25vZGVzfSBhbjIgQW5vdGhlciBsaXN0IChpZGVudGljYWwgc3RydWN0dXJlIHRvIHRoZSBmaXJzdCkgLSBvcHRpb25hbFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5BcHBseVRvQ2hpbGRyZW4oZm4sIGFuMSwgYW4yKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwLCBpID0gMCwgaUxlbiA9IGFuMS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbk5vZGUxLCBuTm9kZTI7XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgaUxlbikge1xuICAgICAgICAgICAgICAgIG5Ob2RlMSA9IGFuMVtpXS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIG5Ob2RlMiA9IGFuMiA/IGFuMltpXS5maXJzdENoaWxkIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIHdoaWxlIChuTm9kZTEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5Ob2RlMS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuKG5Ob2RlMSwgbk5vZGUyLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbihuTm9kZTEsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIG5Ob2RlMSA9IG5Ob2RlMS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgbk5vZGUyID0gYW4yID8gbk5vZGUyLm5leHRTaWJsaW5nIDogbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgdmFyIF9fcmVfaHRtbF9yZW1vdmUgPSAvPC4qPz4vZztcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxjdWxhdGUgdGhlIHdpZHRoIG9mIGNvbHVtbnMgZm9yIHRoZSB0YWJsZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHMob1NldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICB0YWJsZSA9IG9TZXR0aW5ncy5uVGFibGUsXG4gICAgICAgICAgICAgICAgY29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXG4gICAgICAgICAgICAgICAgc2Nyb2xsID0gb1NldHRpbmdzLm9TY3JvbGwsXG4gICAgICAgICAgICAgICAgc2Nyb2xsWSA9IHNjcm9sbC5zWSxcbiAgICAgICAgICAgICAgICBzY3JvbGxYID0gc2Nyb2xsLnNYLFxuICAgICAgICAgICAgICAgIHNjcm9sbFhJbm5lciA9IHNjcm9sbC5zWElubmVyLFxuICAgICAgICAgICAgICAgIGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgdmlzaWJsZUNvbHVtbnMgPSBfZm5HZXRDb2x1bW5zKG9TZXR0aW5ncywgJ2JWaXNpYmxlJyksXG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbHMgPSAkKCd0aCcsIG9TZXR0aW5ncy5uVEhlYWQpLFxuICAgICAgICAgICAgICAgIHRhYmxlV2lkdGhBdHRyID0gdGFibGUuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLCAvLyBmcm9tIERPTSBlbGVtZW50XG4gICAgICAgICAgICAgICAgdGFibGVDb250YWluZXIgPSB0YWJsZS5wYXJlbnROb2RlLFxuICAgICAgICAgICAgICAgIHVzZXJJbnB1dHMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBpLCBjb2x1bW4sIGNvbHVtbklkeCwgd2lkdGgsIG91dGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgYnJvd3NlciA9IG9TZXR0aW5ncy5vQnJvd3NlcixcbiAgICAgICAgICAgICAgICBpZTY3ID0gYnJvd3Nlci5iU2Nyb2xsT3ZlcnNpemU7XG5cbiAgICAgICAgICAgIHZhciBzdHlsZVdpZHRoID0gdGFibGUuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBpZiAoc3R5bGVXaWR0aCAmJiBzdHlsZVdpZHRoLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0YWJsZVdpZHRoQXR0ciA9IHN0eWxlV2lkdGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIENvbnZlcnQgYW55IHVzZXIgaW5wdXQgc2l6ZXMgaW50byBwaXhlbCBzaXplcyAqL1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29sdW1uID0gY29sdW1uc1t2aXNpYmxlQ29sdW1uc1tpXV07XG5cbiAgICAgICAgICAgICAgICBpZiAoY29sdW1uLnNXaWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1dpZHRoID0gX2ZuQ29udmVydFRvV2lkdGgoY29sdW1uLnNXaWR0aE9yaWcsIHRhYmxlQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgICAgICB1c2VySW5wdXRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIElmIHRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgRE9NIGVxdWFscyB0aGUgbnVtYmVyIHRoYXQgd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICogcHJvY2VzcyBpbiBEYXRhVGFibGVzLCB0aGVuIHdlIGNhbiB1c2UgdGhlIG9mZnNldHMgdGhhdCBhcmUgY3JlYXRlZCBieVxuICAgICAgICAgICAgICogdGhlIHdlYi0gYnJvd3Nlci4gTm8gY3VzdG9tIHNpemVzIGNhbiBiZSBzZXQgaW4gb3JkZXIgZm9yIHRoaXMgdG8gaGFwcGVuLFxuICAgICAgICAgICAgICogbm9yIHNjcm9sbGluZyB1c2VkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpZTY3IHx8ICF1c2VySW5wdXRzICYmICFzY3JvbGxYICYmICFzY3JvbGxZICYmXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPT0gX2ZuVmlzYmxlQ29sdW1ucyhvU2V0dGluZ3MpICYmXG4gICAgICAgICAgICAgICAgY29sdW1uQ291bnQgPT0gaGVhZGVyQ2VsbHMubGVuZ3RoXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29sSWR4ID0gX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgob1NldHRpbmdzLCBpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sSWR4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zW2NvbElkeF0uc1dpZHRoID0gX2ZuU3RyaW5nVG9Dc3MoaGVhZGVyQ2VsbHMuZXEoaSkud2lkdGgoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgY29uc3RydWN0IGEgc2luZ2xlIHJvdywgd29yc3QgY2FzZSwgdGFibGUgd2l0aCB0aGUgd2lkZXN0XG4gICAgICAgICAgICAgICAgLy8gbm9kZSBpbiB0aGUgZGF0YSwgYXNzaWduIGFueSB1c2VyIGRlZmluZWQgd2lkdGhzLCB0aGVuIGluc2VydCBpdCBpbnRvXG4gICAgICAgICAgICAgICAgLy8gdGhlIERPTSBhbmQgYWxsb3cgdGhlIGJyb3dzZXIgdG8gZG8gYWxsIHRoZSBoYXJkIHdvcmsgb2YgY2FsY3VsYXRpbmdcbiAgICAgICAgICAgICAgICAvLyB0YWJsZSB3aWR0aHNcbiAgICAgICAgICAgICAgICB2YXIgdG1wVGFibGUgPSAkKHRhYmxlKS5jbG9uZSgpIC8vIGRvbid0IHVzZSBjbG9uZU5vZGUgLSBJRTggd2lsbCByZW1vdmUgZXZlbnRzIG9uIHRoZSBtYWluIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgIC5jc3MoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJylcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUF0dHIoJ2lkJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBDbGVhbiB1cCB0aGUgdGFibGUgYm9keVxuICAgICAgICAgICAgICAgIHRtcFRhYmxlLmZpbmQoJ3Rib2R5IHRyJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRyID0gJCgnPHRyLz4nKS5hcHBlbmRUbyh0bXBUYWJsZS5maW5kKCd0Ym9keScpKTtcblxuICAgICAgICAgICAgICAgIC8vIENsb25lIHRoZSB0YWJsZSBoZWFkZXIgYW5kIGZvb3RlciAtIHdlIGNhbid0IHVzZSB0aGUgaGVhZGVyIC8gZm9vdGVyXG4gICAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgY2xvbmVkIHRhYmxlLCBzaW5jZSBpZiBzY3JvbGxpbmcgaXMgYWN0aXZlLCB0aGUgdGFibGUnc1xuICAgICAgICAgICAgICAgIC8vIHJlYWwgaGVhZGVyIGFuZCBmb290ZXIgYXJlIGNvbnRhaW5lZCBpbiBkaWZmZXJlbnQgdGFibGUgdGFnc1xuICAgICAgICAgICAgICAgIHRtcFRhYmxlLmZpbmQoJ3RoZWFkLCB0Zm9vdCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIHRtcFRhYmxlXG4gICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoJChvU2V0dGluZ3MublRIZWFkKS5jbG9uZSgpKVxuICAgICAgICAgICAgICAgICAgICAuYXBwZW5kKCQob1NldHRpbmdzLm5URm9vdCkuY2xvbmUoKSk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYW55IGFzc2lnbmVkIHdpZHRocyBmcm9tIHRoZSBmb290ZXIgKGZyb20gc2Nyb2xsaW5nKVxuICAgICAgICAgICAgICAgIHRtcFRhYmxlLmZpbmQoJ3Rmb290IHRoLCB0Zm9vdCB0ZCcpLmNzcygnd2lkdGgnLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBjdXN0b20gc2l6aW5nIHRvIHRoZSBjbG9uZWQgaGVhZGVyXG4gICAgICAgICAgICAgICAgaGVhZGVyQ2VsbHMgPSBfZm5HZXRVbmlxdWVUaHMob1NldHRpbmdzLCB0bXBUYWJsZS5maW5kKCd0aGVhZCcpWzBdKTtcblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aXNpYmxlQ29sdW1ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBjb2x1bW5zW3Zpc2libGVDb2x1bW5zW2ldXTtcblxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJDZWxsc1tpXS5zdHlsZS53aWR0aCA9IGNvbHVtbi5zV2lkdGhPcmlnICE9PSBudWxsICYmIGNvbHVtbi5zV2lkdGhPcmlnICE9PSAnJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5TdHJpbmdUb0Nzcyhjb2x1bW4uc1dpZHRoT3JpZykgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJyc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIHNjcm9sbFggd2UgbmVlZCB0byBmb3JjZSB0aGUgY29sdW1uIHdpZHRoIG90aGVyd2lzZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYnJvd3NlciB3aWxsIGNvbGxhcHNlIGl0LiBJZiB0aGlzIHdpZHRoIGlzIHNtYWxsZXIgdGhhbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lkdGggdGhlIGNvbHVtbiByZXF1aXJlcywgdGhlbiBpdCB3aWxsIGhhdmUgbm8gZWZmZWN0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2x1bW4uc1dpZHRoT3JpZyAmJiBzY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGhlYWRlckNlbGxzW2ldKS5hcHBlbmQoJCgnPGRpdi8+JykuY3NzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY29sdW1uLnNXaWR0aE9yaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgd2lkZXN0IGNlbGwgZm9yIGVhY2ggY29sdW1uIGFuZCBwdXQgaXQgaW50byB0aGUgdGFibGVcbiAgICAgICAgICAgICAgICBpZiAob1NldHRpbmdzLmFvRGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZpc2libGVDb2x1bW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5JZHggPSB2aXNpYmxlQ29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGNvbHVtbnNbY29sdW1uSWR4XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgJChfZm5HZXRXaWRlc3ROb2RlKG9TZXR0aW5ncywgY29sdW1uSWR4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xvbmUoZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZChjb2x1bW4uc0NvbnRlbnRQYWRkaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaWR5IHRoZSB0ZW1wb3JhcnkgdGFibGUgLSByZW1vdmUgbmFtZSBhdHRyaWJ1dGVzIHNvIHRoZXJlIGFyZW4ndFxuICAgICAgICAgICAgICAgIC8vIGR1cGxpY2F0ZWQgaW4gdGhlIGRvbSAocmFkaW8gZWxlbWVudHMgZm9yIGV4YW1wbGUpXG4gICAgICAgICAgICAgICAgJCgnW25hbWVdJywgdG1wVGFibGUpLnJlbW92ZUF0dHIoJ25hbWUnKTtcblxuICAgICAgICAgICAgICAgIC8vIFRhYmxlIGhhcyBiZWVuIGJ1aWx0LCBhdHRhY2ggdG8gdGhlIGRvY3VtZW50IHNvIHdlIGNhbiB3b3JrIHdpdGggaXQuXG4gICAgICAgICAgICAgICAgLy8gQSBob2xkaW5nIGVsZW1lbnQgaXMgdXNlZCwgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mIHRoZSBjb250YWluZXJcbiAgICAgICAgICAgICAgICAvLyB3aXRoIG1pbmltYWwgaGVpZ2h0LCBzbyBpdCBoYXMgbm8gZWZmZWN0IG9uIGlmIHRoZSBjb250YWluZXIgc2Nyb2xsc1xuICAgICAgICAgICAgICAgIC8vIG9yIG5vdC4gT3RoZXJ3aXNlIGl0IG1pZ2h0IHRyaWdnZXIgc2Nyb2xsaW5nIHdoZW4gaXQgYWN0dWFsbHkgaXNuJ3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkZWRcbiAgICAgICAgICAgICAgICB2YXIgaG9sZGVyID0gJCgnPGRpdi8+JykuY3NzKHNjcm9sbFggfHwgc2Nyb2xsWSA/XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCh0bXBUYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKHRhYmxlQ29udGFpbmVyKTtcblxuICAgICAgICAgICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIChYIG9yIFkpIHdlIHdhbnQgdG8gc2V0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgYXNcbiAgICAgICAgICAgICAgICAvLyBhcHByb3ByaWF0ZS4gSG93ZXZlciwgd2hlbiBub3Qgc2Nyb2xsaW5nIGxlYXZlIHRoZSB0YWJsZSB3aWR0aCBhcyBpdFxuICAgICAgICAgICAgICAgIC8vIGlzLiBUaGlzIHJlc3VsdHMgaW4gc2xpZ2h0bHkgZGlmZmVyZW50LCBidXQgSSB0aGluayBjb3JyZWN0IGJlaGF2aW91clxuICAgICAgICAgICAgICAgIGlmIChzY3JvbGxYICYmIHNjcm9sbFhJbm5lcikge1xuICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aChzY3JvbGxYSW5uZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY3JvbGxYKSB7XG4gICAgICAgICAgICAgICAgICAgIHRtcFRhYmxlLmNzcygnd2lkdGgnLCAnYXV0bycpO1xuICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS5yZW1vdmVBdHRyKCd3aWR0aCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIHdpZHRoIGF0dHJpYnV0ZSBvciBzdHlsZSwgdGhlbiBhbGxvdyB0aGUgdGFibGUgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gY29sbGFwc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFRhYmxlLndpZHRoKCkgPCB0YWJsZUNvbnRhaW5lci5jbGllbnRXaWR0aCAmJiB0YWJsZVdpZHRoQXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgodGFibGVDb250YWluZXIuY2xpZW50V2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjcm9sbFkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG1wVGFibGUud2lkdGgodGFibGVDb250YWluZXIuY2xpZW50V2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0YWJsZVdpZHRoQXR0cikge1xuICAgICAgICAgICAgICAgICAgICB0bXBUYWJsZS53aWR0aCh0YWJsZVdpZHRoQXR0cik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB3aWR0aCBvZiBlYWNoIGNvbHVtbiBpbiB0aGUgY29uc3RydWN0ZWQgdGFibGUgLSB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAgICAgLy8ga25vdyB0aGUgaW5uZXIgd2lkdGggKHNvIGl0IGNhbiBiZSBhc3NpZ25lZCB0byB0aGUgb3RoZXIgdGFibGUnc1xuICAgICAgICAgICAgICAgIC8vIGNlbGxzKSBhbmQgdGhlIG91dGVyIHdpZHRoIHNvIHdlIGNhbiBjYWxjdWxhdGUgdGhlIGZ1bGwgd2lkdGggb2YgdGhlXG4gICAgICAgICAgICAgICAgLy8gdGFibGUuIFRoaXMgaXMgc2FmZSBzaW5jZSBEYXRhVGFibGVzIHJlcXVpcmVzIGEgdW5pcXVlIGNlbGwgZm9yIGVhY2hcbiAgICAgICAgICAgICAgICAvLyBjb2x1bW4sIGJ1dCBpZiBldmVyIGEgaGVhZGVyIGNhbiBzcGFuIG11bHRpcGxlIGNvbHVtbnMsIHRoaXMgd2lsbFxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gYmUgbW9kaWZpZWQuXG4gICAgICAgICAgICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlzaWJsZUNvbHVtbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGwgPSAkKGhlYWRlckNlbGxzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvcmRlciA9IGNlbGwub3V0ZXJXaWR0aCgpIC0gY2VsbC53aWR0aCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBnZXRCb3VuZGluZy4uLiB3aGVyZSBwb3NzaWJsZSAobm90IElFOC0pIGJlY2F1c2UgaXQgY2FuIGdpdmVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ViLXBpeGVsIGFjY3VyYWN5LCB3aGljaCB3ZSB0aGVuIHdhbnQgdG8gcm91bmQgdXAhXG4gICAgICAgICAgICAgICAgICAgIHZhciBib3VuZGluZyA9IGJyb3dzZXIuYkJvdW5kaW5nID9cbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChoZWFkZXJDZWxsc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5vdXRlcldpZHRoKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG90YWwgaXMgdHJhY2tlZCB0byByZW1vdmUgYW55IHN1Yi1waXhlbCBlcnJvcnMgYXMgdGhlIG91dGVyV2lkdGhcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIHRhYmxlIG1pZ2h0IG5vdCBlcXVhbCB0aGUgdG90YWwgZ2l2ZW4gaGVyZSAoSUUhKS5cbiAgICAgICAgICAgICAgICAgICAgdG90YWwgKz0gYm91bmRpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2lkdGggZm9yIGVhY2ggY29sdW1uIHRvIHVzZVxuICAgICAgICAgICAgICAgICAgICBjb2x1bW5zW3Zpc2libGVDb2x1bW5zW2ldXS5zV2lkdGggPSBfZm5TdHJpbmdUb0Nzcyhib3VuZGluZyAtIGJvcmRlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFibGUuc3R5bGUud2lkdGggPSBfZm5TdHJpbmdUb0Nzcyh0b3RhbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBGaW5pc2hlZCB3aXRoIHRoZSB0YWJsZSAtIGRpdGNoIGl0XG4gICAgICAgICAgICAgICAgaG9sZGVyLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHdpZHRoIGF0dHIsIHdlIHdhbnQgdG8gYXR0YWNoIGFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoXG4gICAgICAgICAgICAvLyBhbGxvd3MgdGhlIHRhYmxlIHNpemluZyB0byBhdXRvbWF0aWNhbGx5IGFkanVzdCB3aGVuIHRoZSB3aW5kb3cgaXNcbiAgICAgICAgICAgIC8vIHJlc2l6ZWQuIFVzZSB0aGUgd2lkdGggYXR0ciByYXRoZXIgdGhhbiBDU1MsIHNpbmNlIHdlIGNhbid0IGtub3cgaWYgdGhlXG4gICAgICAgICAgICAvLyBDU1MgaXMgYSByZWxhdGl2ZSB2YWx1ZSBvciBhYnNvbHV0ZSAtIERPTSByZWFkIGlzIGFsd2F5cyBweC5cbiAgICAgICAgICAgIGlmICh0YWJsZVdpZHRoQXR0cikge1xuICAgICAgICAgICAgICAgIHRhYmxlLnN0eWxlLndpZHRoID0gX2ZuU3RyaW5nVG9Dc3ModGFibGVXaWR0aEF0dHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoKHRhYmxlV2lkdGhBdHRyIHx8IHNjcm9sbFgpICYmICFvU2V0dGluZ3MuX3Jlc3pFdnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmluZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuRFQtJyArIG9TZXR0aW5ncy5zSW5zdGFuY2UsIF9mblRocm90dGxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbkFkanVzdENvbHVtblNpemluZyhvU2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIElFNi83IHdpbGwgY3Jhc2ggaWYgd2UgYmluZCBhIHJlc2l6ZSBldmVudCBoYW5kbGVyIG9uIHBhZ2UgbG9hZC5cbiAgICAgICAgICAgICAgICAvLyBUbyBiZSByZW1vdmVkIGluIDEuMTEgd2hpY2ggZHJvcHMgSUU2Lzcgc3VwcG9ydFxuICAgICAgICAgICAgICAgIGlmIChpZTY3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoYmluZFJlc2l6ZSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBiaW5kUmVzaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb1NldHRpbmdzLl9yZXN6RXZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm90dGxlIHRoZSBjYWxscyB0byBhIGZ1bmN0aW9uLiBBcmd1bWVudHMgYW5kIGNvbnRleHQgYXJlIG1haW50YWluZWQgZm9yXG4gICAgICAgICAqIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb25cbiAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGJlIGNhbGxlZFxuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IFtmcmVxPTIwMF0gY2FsbCBmcmVxdWVuY3kgaW4gbVNcbiAgICAgICAgICogIEByZXR1cm5zIHtmdW5jdGlvbn0gd3JhcHBlZCBmdW5jdGlvblxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX2ZuVGhyb3R0bGUgPSBEYXRhVGFibGUudXRpbC50aHJvdHRsZTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IGEgQ1NTIHVuaXQgd2lkdGggdG8gcGl4ZWxzIChlLmcuIDJlbSlcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSB3aWR0aCB3aWR0aCB0byBiZSBjb252ZXJ0ZWRcbiAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcGFyZW50IHBhcmVudCB0byBnZXQgdGhlIHdpdGggZm9yIChyZXF1aXJlZCBmb3IgcmVsYXRpdmUgd2lkdGhzKSAtIG9wdGlvbmFsXG4gICAgICAgICAqICBAcmV0dXJucyB7aW50fSB3aWR0aCBpbiBwaXhlbHNcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuQ29udmVydFRvV2lkdGgod2lkdGgsIHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKCF3aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbiA9ICQoJzxkaXYvPicpXG4gICAgICAgICAgICAgICAgLmNzcygnd2lkdGgnLCBfZm5TdHJpbmdUb0Nzcyh3aWR0aCkpXG4gICAgICAgICAgICAgICAgLmFwcGVuZFRvKHBhcmVudCB8fCBkb2N1bWVudC5ib2R5KTtcblxuICAgICAgICAgICAgdmFyIHZhbCA9IG5bMF0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICBuLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSB3aWRlc3Qgbm9kZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBvZiBpbnRlcmVzdFxuICAgICAgICAgKiAgQHJldHVybnMge25vZGV9IHdpZGVzdCB0YWJsZSBub2RlXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkdldFdpZGVzdE5vZGUoc2V0dGluZ3MsIGNvbElkeCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IF9mbkdldE1heExlblN0cmluZyhzZXR0aW5ncywgY29sSWR4KTtcbiAgICAgICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW2lkeF07XG4gICAgICAgICAgICByZXR1cm4gIWRhdGEublRyID8gLy8gTWlnaHQgbm90IGhhdmUgYmVlbiBjcmVhdGVkIHdoZW4gZGVmZXJyZWQgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgJCgnPHRkLz4nKS5odG1sKF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpZHgsIGNvbElkeCwgJ2Rpc3BsYXknKSlbMF0gOlxuICAgICAgICAgICAgICAgIGRhdGEuYW5DZWxsc1tjb2xJZHhdO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBtYXhpbXVtIHN0cmxlbiBmb3IgZWFjaCBkYXRhIGNvbHVtblxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBvZiBpbnRlcmVzdFxuICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gbWF4IHN0cmluZyBsZW5ndGggZm9yIGVhY2ggY29sdW1uXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkdldE1heExlblN0cmluZyhzZXR0aW5ncywgY29sSWR4KSB7XG4gICAgICAgICAgICB2YXIgcywgbWF4ID0gLTEsIG1heElkeCA9IC0xO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gc2V0dGluZ3MuYW9EYXRhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcyA9IF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCBpLCBjb2xJZHgsICdkaXNwbGF5JykgKyAnJztcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKF9fcmVfaHRtbF9yZW1vdmUsICcnKTtcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKC8mbmJzcDsvZywgJyAnKTtcblxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbWF4SWR4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtYXhJZHg7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBlbmQgYSBDU1MgdW5pdCAob25seSBpZiByZXF1aXJlZCkgdG8gYSBzdHJpbmdcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0byBjc3MtaWZ5XG4gICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSB2YWx1ZSB3aXRoIGNzcyB1bml0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblN0cmluZ1RvQ3NzKHMpIHtcbiAgICAgICAgICAgIGlmIChzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcwcHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHMgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcyA8IDAgP1xuICAgICAgICAgICAgICAgICAgICAnMHB4JyA6XG4gICAgICAgICAgICAgICAgICAgIHMgKyAncHgnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDaGVjayBpdCBoYXMgYSB1bml0IGNoYXJhY3RlciBhbHJlYWR5XG4gICAgICAgICAgICByZXR1cm4gcy5tYXRjaCgvXFxkJC8pID9cbiAgICAgICAgICAgICAgICBzICsgJ3B4JyA6XG4gICAgICAgICAgICAgICAgcztcbiAgICAgICAgfVxuXG5cblxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0RmxhdHRlbihzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgaSwgaUxlbiwgaywga0xlbixcbiAgICAgICAgICAgICAgICBhU29ydCA9IFtdLFxuICAgICAgICAgICAgICAgIGFpT3JpZyA9IFtdLFxuICAgICAgICAgICAgICAgIGFvQ29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucyxcbiAgICAgICAgICAgICAgICBhRGF0YVNvcnQsIGlDb2wsIHNUeXBlLCBzcmNDb2wsXG4gICAgICAgICAgICAgICAgZml4ZWQgPSBzZXR0aW5ncy5hYVNvcnRpbmdGaXhlZCxcbiAgICAgICAgICAgICAgICBmaXhlZE9iaiA9ICQuaXNQbGFpbk9iamVjdChmaXhlZCksXG4gICAgICAgICAgICAgICAgbmVzdGVkU29ydCA9IFtdLFxuICAgICAgICAgICAgICAgIGFkZCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhLmxlbmd0aCAmJiAhQXJyYXkuaXNBcnJheShhWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gMUQgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lc3RlZFNvcnQucHVzaChhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIDJEIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICAkLm1lcmdlKG5lc3RlZFNvcnQsIGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHNvcnQgYXJyYXksIHdpdGggcHJlLWZpeCBhbmQgcG9zdC1maXggb3B0aW9ucyBpZiB0aGV5IGhhdmUgYmVlblxuICAgICAgICAgICAgLy8gc3BlY2lmaWVkXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaXhlZCkpIHtcbiAgICAgICAgICAgICAgICBhZGQoZml4ZWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZml4ZWRPYmogJiYgZml4ZWQucHJlKSB7XG4gICAgICAgICAgICAgICAgYWRkKGZpeGVkLnByZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFkZChzZXR0aW5ncy5hYVNvcnRpbmcpO1xuXG4gICAgICAgICAgICBpZiAoZml4ZWRPYmogJiYgZml4ZWQucG9zdCkge1xuICAgICAgICAgICAgICAgIGFkZChmaXhlZC5wb3N0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5lc3RlZFNvcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzcmNDb2wgPSBuZXN0ZWRTb3J0W2ldWzBdO1xuICAgICAgICAgICAgICAgIGFEYXRhU29ydCA9IGFvQ29sdW1uc1tzcmNDb2xdLmFEYXRhU29ydDtcblxuICAgICAgICAgICAgICAgIGZvciAoayA9IDAsIGtMZW4gPSBhRGF0YVNvcnQubGVuZ3RoOyBrIDwga0xlbjsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlDb2wgPSBhRGF0YVNvcnRba107XG4gICAgICAgICAgICAgICAgICAgIHNUeXBlID0gYW9Db2x1bW5zW2lDb2xdLnNUeXBlIHx8ICdzdHJpbmcnO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXN0ZWRTb3J0W2ldLl9pZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVzdGVkU29ydFtpXS5faWR4ID0gJC5pbkFycmF5KG5lc3RlZFNvcnRbaV1bMV0sIGFvQ29sdW1uc1tpQ29sXS5hc1NvcnRpbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYVNvcnQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcmM6IHNyY0NvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogaUNvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogbmVzdGVkU29ydFtpXVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBuZXN0ZWRTb3J0W2ldLl9pZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBzVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyW3NUeXBlICsgXCItcHJlXCJdXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFTb3J0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoYW5nZSB0aGUgb3JkZXIgb2YgdGhlIHRhYmxlXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICogIEB0b2RvIFRoaXMgcmVhbGx5IG5lZWRzIHNwbGl0IHVwIVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU29ydChvU2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGksIGllbiwgaUxlbiwgaiwgakxlbiwgaywga0xlbixcbiAgICAgICAgICAgICAgICBzRGF0YVR5cGUsIG5UaCxcbiAgICAgICAgICAgICAgICBhaU9yaWcgPSBbXSxcbiAgICAgICAgICAgICAgICBvRXh0U29ydCA9IERhdGFUYWJsZS5leHQudHlwZS5vcmRlcixcbiAgICAgICAgICAgICAgICBhb0RhdGEgPSBvU2V0dGluZ3MuYW9EYXRhLFxuICAgICAgICAgICAgICAgIGFvQ29sdW1ucyA9IG9TZXR0aW5ncy5hb0NvbHVtbnMsXG4gICAgICAgICAgICAgICAgYURhdGFTb3J0LCBkYXRhLCBpQ29sLCBzVHlwZSwgb1NvcnQsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVycyA9IDAsXG4gICAgICAgICAgICAgICAgc29ydENvbCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TWFzdGVyID0gb1NldHRpbmdzLmFpRGlzcGxheU1hc3RlcixcbiAgICAgICAgICAgICAgICBhU29ydDtcblxuICAgICAgICAgICAgLy8gUmVzb2x2ZSBhbnkgY29sdW1uIHR5cGVzIHRoYXQgYXJlIHVua25vd24gZHVlIHRvIGFkZGl0aW9uIG9yIGludmFsaWRhdGlvblxuICAgICAgICAgICAgLy8gQHRvZG8gQ2FuIHRoaXMgYmUgbW92ZWQgaW50byBhICdkYXRhLXJlYWR5JyBoYW5kbGVyIHdoaWNoIGlzIGNhbGxlZCB3aGVuXG4gICAgICAgICAgICAvLyAgIGRhdGEgaXMgZ29pbmcgdG8gYmUgdXNlZCBpbiB0aGUgdGFibGU/XG4gICAgICAgICAgICBfZm5Db2x1bW5UeXBlcyhvU2V0dGluZ3MpO1xuXG4gICAgICAgICAgICBhU29ydCA9IF9mblNvcnRGbGF0dGVuKG9TZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGFTb3J0Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc29ydENvbCA9IGFTb3J0W2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgaWYgd2UgY2FuIHVzZSB0aGUgZmFzdCBzb3J0IGFsZ29yaXRobVxuICAgICAgICAgICAgICAgIGlmIChzb3J0Q29sLmZvcm1hdHRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXJzKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgZGF0YSBuZWVkZWQgZm9yIHRoZSBzb3J0LCBmb3IgZWFjaCBjZWxsXG4gICAgICAgICAgICAgICAgX2ZuU29ydERhdGEob1NldHRpbmdzLCBzb3J0Q29sLmNvbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIE5vIHNvcnRpbmcgcmVxdWlyZWQgaWYgc2VydmVyLXNpZGUgb3Igbm8gc29ydGluZyBhcnJheSAqL1xuICAgICAgICAgICAgaWYgKF9mbkRhdGFTb3VyY2Uob1NldHRpbmdzKSAhPSAnc3NwJyAmJiBhU29ydC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSB2YWx1ZSAtIGtleSBhcnJheSBvZiB0aGUgY3VycmVudCByb3cgcG9zaXRpb25zIHN1Y2ggdGhhdCB3ZSBjYW4gdXNlIHRoZWlyXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudCBwb3NpdGlvbiBkdXJpbmcgdGhlIHNvcnQsIGlmIHZhbHVlcyBtYXRjaCwgaW4gb3JkZXIgdG8gcGVyZm9ybSBzdGFibGUgc29ydGluZ1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGlMZW4gPSBkaXNwbGF5TWFzdGVyLmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhaU9yaWdbZGlzcGxheU1hc3RlcltpXV0gPSBpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIERvIHRoZSBzb3J0IC0gaGVyZSB3ZSB3YW50IG11bHRpLWNvbHVtbiBzb3J0aW5nIGJhc2VkIG9uIGEgZ2l2ZW4gZGF0YSBzb3VyY2UgKGNvbHVtbilcbiAgICAgICAgICAgICAgICAgKiBhbmQgc29ydGluZyBmdW5jdGlvbiAoZnJvbSBvU29ydCkgaW4gYSBjZXJ0YWluIGRpcmVjdGlvbi4gSXQncyByZWFzb25hYmx5IGNvbXBsZXggdG9cbiAgICAgICAgICAgICAgICAgKiBmb2xsb3cgb24gaXQncyBvd24sIGJ1dCB0aGlzIGlzIHdoYXQgd2Ugd2FudCAoZXhhbXBsZSB0d28gY29sdW1uIHNvcnRpbmcpOlxuICAgICAgICAgICAgICAgICAqICBmbkxvY2FsU29ydGluZyA9IGZ1bmN0aW9uKGEsYil7XG4gICAgICAgICAgICAgICAgICogICAgdmFyIGlUZXN0O1xuICAgICAgICAgICAgICAgICAqICAgIGlUZXN0ID0gb1NvcnRbJ3N0cmluZy1hc2MnXSgnZGF0YTExJywgJ2RhdGExMicpO1xuICAgICAgICAgICAgICAgICAqICAgICAgaWYgKGlUZXN0ICE9PSAwKVxuICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gaVRlc3Q7XG4gICAgICAgICAgICAgICAgICogICAgaVRlc3QgPSBvU29ydFsnbnVtZXJpYy1kZXNjJ10oJ2RhdGEyMScsICdkYXRhMjInKTtcbiAgICAgICAgICAgICAgICAgKiAgICBpZiAoaVRlc3QgIT09IDApXG4gICAgICAgICAgICAgICAgICogICAgICByZXR1cm4gaVRlc3Q7XG4gICAgICAgICAgICAgICAgICogICAgcmV0dXJuIG9Tb3J0WydudW1lcmljLWFzYyddKCBhaU9yaWdbYV0sIGFpT3JpZ1tiXSApO1xuICAgICAgICAgICAgICAgICAqICB9XG4gICAgICAgICAgICAgICAgICogQmFzaWNhbGx5IHdlIGhhdmUgYSB0ZXN0IGZvciBlYWNoIHNvcnRpbmcgY29sdW1uLCBpZiB0aGUgZGF0YSBpbiB0aGF0IGNvbHVtbiBpcyBlcXVhbCxcbiAgICAgICAgICAgICAgICAgKiB0ZXN0IHRoZSBuZXh0IGNvbHVtbi4gSWYgYWxsIGNvbHVtbnMgbWF0Y2gsIHRoZW4gd2UgdXNlIGEgbnVtZXJpYyBzb3J0IG9uIHRoZSByb3dcbiAgICAgICAgICAgICAgICAgKiBwb3NpdGlvbnMgaW4gdGhlIG9yaWdpbmFsIGRhdGEgYXJyYXkgdG8gcHJvdmlkZSBhIHN0YWJsZSBzb3J0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTm90ZSAtIEkga25vdyBpdCBzZWVtcyBleGNlc3NpdmUgdG8gaGF2ZSB0d28gc29ydGluZyBtZXRob2RzLCBidXQgdGhlIGZpcnN0IGlzIGFyb3VuZFxuICAgICAgICAgICAgICAgICAqIDE1JSBmYXN0ZXIsIHNvIHRoZSBzZWNvbmQgaXMgb25seSBtYWludGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgKiBtZXRob2RzIHdoaWNoIGRvIG5vdCBoYXZlIGEgcHJlLXNvcnQgZm9ybWF0dGluZyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVycyA9PT0gYVNvcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbCBzb3J0IHR5cGVzIGhhdmUgZm9ybWF0dGluZyBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hc3Rlci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCBrLCB0ZXN0LCBzb3J0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbiA9IGFTb3J0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQSA9IGFvRGF0YVthXS5fYVNvcnREYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFCID0gYW9EYXRhW2JdLl9hU29ydERhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnQgPSBhU29ydFtrXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHggPSBkYXRhQVtzb3J0LmNvbF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGRhdGFCW3NvcnQuY29sXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSB4IDwgeSA/IC0xIDogeCA+IHkgPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVzdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ydC5kaXIgPT09ICdhc2MnID8gdGVzdCA6IC10ZXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgeCA9IGFpT3JpZ1thXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBhaU9yaWdbYl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRGVwcmVjaWF0ZWQgLSByZW1vdmUgaW4gMS4xMSAocHJvdmlkaW5nIGEgcGx1Zy1pbiBvcHRpb24pXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBhbGwgc29ydCB0eXBlcyBoYXZlIGZvcm1hdHRpbmcgbWV0aG9kcywgc28gd2UgaGF2ZSB0byBjYWxsIHRoZWlyIHNvcnRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gbWV0aG9kcy5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hc3Rlci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LCB5LCBrLCBsLCB0ZXN0LCBzb3J0LCBmbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSBhU29ydC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YUEgPSBhb0RhdGFbYV0uX2FTb3J0RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhQiA9IGFvRGF0YVtiXS5fYVNvcnREYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0ID0gYVNvcnRba107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gZGF0YUFbc29ydC5jb2xdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgPSBkYXRhQltzb3J0LmNvbF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbiA9IG9FeHRTb3J0W3NvcnQudHlwZSArIFwiLVwiICsgc29ydC5kaXJdIHx8IG9FeHRTb3J0W1wic3RyaW5nLVwiICsgc29ydC5kaXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSBmbih4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVzdCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBhaU9yaWdbYV07XG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gYWlPcmlnW2JdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggPCB5ID8gLTEgOiB4ID4geSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIFRlbGwgdGhlIGRyYXcgZnVuY3Rpb24gdGhhdCB3ZSBoYXZlIHNvcnRlZCB0aGUgZGF0YSAqL1xuICAgICAgICAgICAgb1NldHRpbmdzLmJTb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICBmdW5jdGlvbiBfZm5Tb3J0QXJpYShzZXR0aW5ncykge1xuICAgICAgICAgICAgdmFyIGxhYmVsO1xuICAgICAgICAgICAgdmFyIG5leHRTb3J0O1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG4gICAgICAgICAgICB2YXIgYVNvcnQgPSBfZm5Tb3J0RmxhdHRlbihzZXR0aW5ncyk7XG4gICAgICAgICAgICB2YXIgb0FyaWEgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub0FyaWE7XG5cbiAgICAgICAgICAgIC8vIEFSSUEgYXR0cmlidXRlcyAtIG5lZWQgdG8gbG9vcCBhbGwgY29sdW1ucywgdG8gdXBkYXRlIGFsbCAocmVtb3Zpbmcgb2xkXG4gICAgICAgICAgICAvLyBhdHRyaWJ1dGVzIGFzIG5lZWRlZClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpTGVuID0gY29sdW1ucy5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gY29sdW1uc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgYXNTb3J0aW5nID0gY29sLmFzU29ydGluZztcbiAgICAgICAgICAgICAgICB2YXIgc1RpdGxlID0gY29sLnNUaXRsZS5yZXBsYWNlKC88Lio/Pi9nLCBcIlwiKTtcbiAgICAgICAgICAgICAgICB2YXIgdGggPSBjb2wublRoO1xuXG4gICAgICAgICAgICAgICAgLy8gSUU3IGlzIHRocm93aW5nIGFuIGVycm9yIHdoZW4gc2V0dGluZyB0aGVzZSBwcm9wZXJ0aWVzIHdpdGggalF1ZXJ5J3NcbiAgICAgICAgICAgICAgICAvLyBhdHRyKCkgYW5kIHJlbW92ZUF0dHIoKSBtZXRob2RzLi4uXG4gICAgICAgICAgICAgICAgdGgucmVtb3ZlQXR0cmlidXRlKCdhcmlhLXNvcnQnKTtcblxuICAgICAgICAgICAgICAgIC8qIEluIEFSSUEgb25seSB0aGUgZmlyc3Qgc29ydGluZyBjb2x1bW4gY2FuIGJlIG1hcmtlZCBhcyBzb3J0aW5nIC0gbm8gbXVsdGktc29ydCBvcHRpb24gKi9cbiAgICAgICAgICAgICAgICBpZiAoY29sLmJTb3J0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYVNvcnQubGVuZ3RoID4gMCAmJiBhU29ydFswXS5jb2wgPT0gaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGguc2V0QXR0cmlidXRlKCdhcmlhLXNvcnQnLCBhU29ydFswXS5kaXIgPT0gXCJhc2NcIiA/IFwiYXNjZW5kaW5nXCIgOiBcImRlc2NlbmRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U29ydCA9IGFzU29ydGluZ1thU29ydFswXS5pbmRleCArIDFdIHx8IGFzU29ydGluZ1swXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTb3J0ID0gYXNTb3J0aW5nWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBzVGl0bGUgKyAobmV4dFNvcnQgPT09IFwiYXNjXCIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgb0FyaWEuc1NvcnRBc2NlbmRpbmcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgb0FyaWEuc1NvcnREZXNjZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbCA9IHNUaXRsZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbiB0byBydW4gb24gdXNlciBzb3J0IHJlcXVlc3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBhdHRhY2hUbyBub2RlIHRvIGF0dGFjaCB0aGUgaGFuZGxlciB0b1xuICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGNvbElkeCBjb2x1bW4gc29ydGluZyBpbmRleFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbYXBwZW5kPWZhbHNlXSBBcHBlbmQgdGhlIHJlcXVlc3RlZCBzb3J0IHRvIHRoZSBleGlzdGluZ1xuICAgICAgICAgKiAgICBzb3J0IGlmIHRydWUgKGkuZS4gbXVsdGktY29sdW1uIHNvcnQpXG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblNvcnRMaXN0ZW5lcihzZXR0aW5ncywgY29sSWR4LCBhcHBlbmQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgY29sID0gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbElkeF07XG4gICAgICAgICAgICB2YXIgc29ydGluZyA9IHNldHRpbmdzLmFhU29ydGluZztcbiAgICAgICAgICAgIHZhciBhc1NvcnRpbmcgPSBjb2wuYXNTb3J0aW5nO1xuICAgICAgICAgICAgdmFyIG5leHRTb3J0SWR4O1xuICAgICAgICAgICAgdmFyIG5leHQgPSBmdW5jdGlvbiAoYSwgb3ZlcmZsb3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gYS5faWR4O1xuICAgICAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZHggPSAkLmluQXJyYXkoYVsxXSwgYXNTb3J0aW5nKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4ICsgMSA8IGFzU29ydGluZy5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICBpZHggKyAxIDpcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3cgP1xuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gQ29udmVydCB0byAyRCBhcnJheSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc29ydGluZ1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzb3J0aW5nID0gc2V0dGluZ3MuYWFTb3J0aW5nID0gW3NvcnRpbmddO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhcHBlbmRpbmcgdGhlIHNvcnQgdGhlbiB3ZSBhcmUgbXVsdGktY29sdW1uIHNvcnRpbmdcbiAgICAgICAgICAgIGlmIChhcHBlbmQgJiYgc2V0dGluZ3Mub0ZlYXR1cmVzLmJTb3J0TXVsdGkpIHtcbiAgICAgICAgICAgICAgICAvLyBBcmUgd2UgYWxyZWFkeSBkb2luZyBzb21lIGtpbmQgb2Ygc29ydCBvbiB0aGlzIGNvbHVtbj9cbiAgICAgICAgICAgICAgICB2YXIgc29ydElkeCA9ICQuaW5BcnJheShjb2xJZHgsIF9wbHVjayhzb3J0aW5nLCAnMCcpKTtcblxuICAgICAgICAgICAgICAgIGlmIChzb3J0SWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBZZXMsIG1vZGlmeSB0aGUgc29ydFxuICAgICAgICAgICAgICAgICAgICBuZXh0U29ydElkeCA9IG5leHQoc29ydGluZ1tzb3J0SWR4XSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRTb3J0SWR4ID09PSBudWxsICYmIHNvcnRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U29ydElkeCA9IDA7IC8vIGNhbid0IHJlbW92ZSBzb3J0aW5nIGNvbXBsZXRlbHlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U29ydElkeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGluZy5zcGxpY2Uoc29ydElkeCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0aW5nW3NvcnRJZHhdWzFdID0gYXNTb3J0aW5nW25leHRTb3J0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbc29ydElkeF0uX2lkeCA9IG5leHRTb3J0SWR4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBzb3J0IG9uIHRoaXMgY29sdW1uIHlldFxuICAgICAgICAgICAgICAgICAgICBzb3J0aW5nLnB1c2goW2NvbElkeCwgYXNTb3J0aW5nWzBdLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRpbmdbc29ydGluZy5sZW5ndGggLSAxXS5faWR4ID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzb3J0aW5nLmxlbmd0aCAmJiBzb3J0aW5nWzBdWzBdID09IGNvbElkeCkge1xuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBjb2x1bW4gLSBhbHJlYWR5IHNvcnRpbmcgb24gdGhpcyBjb2x1bW4sIG1vZGlmeSB0aGUgc29ydFxuICAgICAgICAgICAgICAgIG5leHRTb3J0SWR4ID0gbmV4dChzb3J0aW5nWzBdKTtcblxuICAgICAgICAgICAgICAgIHNvcnRpbmcubGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICBzb3J0aW5nWzBdWzFdID0gYXNTb3J0aW5nW25leHRTb3J0SWR4XTtcbiAgICAgICAgICAgICAgICBzb3J0aW5nWzBdLl9pZHggPSBuZXh0U29ydElkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFNpbmdsZSBjb2x1bW4gLSBzb3J0IG9ubHkgb24gdGhpcyBjb2x1bW5cbiAgICAgICAgICAgICAgICBzb3J0aW5nLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgc29ydGluZy5wdXNoKFtjb2xJZHgsIGFzU29ydGluZ1swXV0pO1xuICAgICAgICAgICAgICAgIHNvcnRpbmdbMF0uX2lkeCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJ1biB0aGUgc29ydCBieSBjYWxsaW5nIGEgZnVsbCByZWRyYXdcbiAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIHVzZWQgZm9yIGFzeW5jIHVzZXIgaW50ZXJhY3Rpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaCBhIHNvcnQgaGFuZGxlciAoY2xpY2spIHRvIGEgbm9kZVxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IGF0dGFjaFRvIG5vZGUgdG8gYXR0YWNoIHRoZSBoYW5kbGVyIHRvXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gY29sSWR4IGNvbHVtbiBzb3J0aW5nIGluZGV4XG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBbY2FsbGJhY2tdIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblNvcnRBdHRhY2hMaXN0ZW5lcihzZXR0aW5ncywgYXR0YWNoVG8sIGNvbElkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBjb2wgPSBzZXR0aW5ncy5hb0NvbHVtbnNbY29sSWR4XTtcblxuICAgICAgICAgICAgX2ZuQmluZEFjdGlvbihhdHRhY2hUbywge30sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIGNvbHVtbiBpcyBub3Qgc29ydGFibGUgLSBkb24ndCB0byBhbnl0aGluZyAqL1xuICAgICAgICAgICAgICAgIGlmIChjb2wuYlNvcnRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgcHJvY2Vzc2luZyBpcyBlbmFibGVkIHVzZSBhIHRpbWVvdXQgdG8gYWxsb3cgdGhlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAvLyBkaXNwbGF5IHRvIGJlIHNob3duIC0gb3RoZXJ3aXNlIHRvIGl0IHN5bmNocm9ub3VzbHlcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mub0ZlYXR1cmVzLmJQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5KHNldHRpbmdzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mblNvcnRMaXN0ZW5lcihzZXR0aW5ncywgY29sSWR4LCBlLnNoaWZ0S2V5LCBjYWxsYmFjayk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcsIHRoZSBkcmF3IGNhbGxiYWNrIHdpbGwgcmVtb3ZlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvY2Vzc2luZyBkaXNwbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgIT09ICdzc3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfZm5Tb3J0TGlzdGVuZXIoc2V0dGluZ3MsIGNvbElkeCwgZS5zaGlmdEtleSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBzb3J0aW5nIGNsYXNzZXMgb24gdGFibGUncyBib2R5LCBOb3RlOiBpdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBmdW5jdGlvblxuICAgICAgICAgKiB3aGVuIGJTb3J0IGFuZCBiU29ydENsYXNzZXMgYXJlIGZhbHNlXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mblNvcnRpbmdDbGFzc2VzKHNldHRpbmdzKSB7XG4gICAgICAgICAgICB2YXIgb2xkU29ydCA9IHNldHRpbmdzLmFMYXN0U29ydDtcbiAgICAgICAgICAgIHZhciBzb3J0Q2xhc3MgPSBzZXR0aW5ncy5vQ2xhc3Nlcy5zU29ydENvbHVtbjtcbiAgICAgICAgICAgIHZhciBzb3J0ID0gX2ZuU29ydEZsYXR0ZW4oc2V0dGluZ3MpO1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gc2V0dGluZ3Mub0ZlYXR1cmVzO1xuICAgICAgICAgICAgdmFyIGksIGllbiwgY29sSWR4O1xuXG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMuYlNvcnQgJiYgZmVhdHVyZXMuYlNvcnRDbGFzc2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIG9sZCBzb3J0aW5nIGNsYXNzZXNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBvbGRTb3J0Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbElkeCA9IG9sZFNvcnRbaV0uc3JjO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjb2x1bW4gc29ydGluZ1xuICAgICAgICAgICAgICAgICAgICAkKF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhzb3J0Q2xhc3MgKyAoaSA8IDIgPyBpICsgMSA6IDMpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IGNvbHVtbiBzb3J0aW5nXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gc29ydC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb2xJZHggPSBzb3J0W2ldLnNyYztcblxuICAgICAgICAgICAgICAgICAgICAkKF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sSWR4KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhzb3J0Q2xhc3MgKyAoaSA8IDIgPyBpICsgMSA6IDMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRpbmdzLmFMYXN0U29ydCA9IHNvcnQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIEdldCB0aGUgZGF0YSB0byBzb3J0IGEgY29sdW1uLCBiZSBpdCBmcm9tIGNhY2hlLCBmcmVzaCAocG9wdWxhdGluZyB0aGVcbiAgICAgICAgLy8gY2FjaGUpLCBvciBmcm9tIGEgc29ydCBmb3JtYXR0ZXJcbiAgICAgICAgZnVuY3Rpb24gX2ZuU29ydERhdGEoc2V0dGluZ3MsIGlkeCkge1xuICAgICAgICAgICAgLy8gQ3VzdG9tIHNvcnRpbmcgZnVuY3Rpb24gLSBwcm92aWRlZCBieSB0aGUgc29ydCBkYXRhIHR5cGVcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSBzZXR0aW5ncy5hb0NvbHVtbnNbaWR4XTtcbiAgICAgICAgICAgIHZhciBjdXN0b21Tb3J0ID0gRGF0YVRhYmxlLmV4dC5vcmRlcltjb2x1bW4uc1NvcnREYXRhVHlwZV07XG4gICAgICAgICAgICB2YXIgY3VzdG9tRGF0YTtcblxuICAgICAgICAgICAgaWYgKGN1c3RvbVNvcnQpIHtcbiAgICAgICAgICAgICAgICBjdXN0b21EYXRhID0gY3VzdG9tU29ydC5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIGlkeCxcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoc2V0dGluZ3MsIGlkeClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgLyBwb3B1bGF0ZSBjYWNoZVxuICAgICAgICAgICAgdmFyIHJvdywgY2VsbERhdGE7XG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVyID0gRGF0YVRhYmxlLmV4dC50eXBlLm9yZGVyW2NvbHVtbi5zVHlwZSArIFwiLXByZVwiXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHNldHRpbmdzLmFvRGF0YS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHJvdyA9IHNldHRpbmdzLmFvRGF0YVtpXTtcblxuICAgICAgICAgICAgICAgIGlmICghcm93Ll9hU29ydERhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9hU29ydERhdGEgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJvdy5fYVNvcnREYXRhW2lkeF0gfHwgY3VzdG9tU29ydCkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YSA9IGN1c3RvbVNvcnQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VzdG9tRGF0YVtpXSA6IC8vIElmIHRoZXJlIHdhcyBhIGN1c3RvbSBzb3J0IGZ1bmN0aW9uLCB1c2UgZGF0YSBmcm9tIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgaSwgaWR4LCAnc29ydCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJvdy5fYVNvcnREYXRhW2lkeF0gPSBmb3JtYXR0ZXIgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyKGNlbGxEYXRhKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjZWxsRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmUgdGhlIHN0YXRlIG9mIGEgdGFibGVcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU2F2ZVN0YXRlKHNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm9GZWF0dXJlcy5iU3RhdGVTYXZlIHx8IHNldHRpbmdzLmJEZXN0cm95aW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBTdG9yZSB0aGUgaW50ZXJlc3RpbmcgdmFyaWFibGVzICovXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgdGltZTogK25ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0LFxuICAgICAgICAgICAgICAgIGxlbmd0aDogc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoLFxuICAgICAgICAgICAgICAgIG9yZGVyOiAkLmV4dGVuZCh0cnVlLCBbXSwgc2V0dGluZ3MuYWFTb3J0aW5nKSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IF9mblNlYXJjaFRvQ2FtZWwoc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiAkLm1hcChzZXR0aW5ncy5hb0NvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2libGU6IGNvbC5iVmlzaWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaDogX2ZuU2VhcmNoVG9DYW1lbChzZXR0aW5ncy5hb1ByZVNlYXJjaENvbHNbaV0pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgXCJhb1N0YXRlU2F2ZVBhcmFtc1wiLCAnc3RhdGVTYXZlUGFyYW1zJywgW3NldHRpbmdzLCBzdGF0ZV0pO1xuXG4gICAgICAgICAgICBzZXR0aW5ncy5vU2F2ZWRTdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgc2V0dGluZ3MuZm5TdGF0ZVNhdmVDYWxsYmFjay5jYWxsKHNldHRpbmdzLm9JbnN0YW5jZSwgc2V0dGluZ3MsIHN0YXRlKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGVtcHQgdG8gbG9hZCBhIHNhdmVkIHRhYmxlIHN0YXRlXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb0luaXQgRGF0YVRhYmxlcyBpbml0IG9iamVjdCBzbyB3ZSBjYW4gb3ZlcnJpZGUgc2V0dGluZ3NcbiAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgaGFzIGJlZW4gbG9hZGVkXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI29BcGlcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIF9mbkxvYWRTdGF0ZShzZXR0aW5ncywgb0luaXQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaSwgaWVuO1xuICAgICAgICAgICAgdmFyIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnM7XG4gICAgICAgICAgICB2YXIgbG9hZGVkID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXMgfHwgIXMudGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgY3VzdG9tIGFuZCBwbHVnLWluIG1hbmlwdWxhdGlvbiBmdW5jdGlvbnMgdG8gYWx0ZXIgdGhlIHNhdmVkIGRhdGEgc2V0IGFuZFxuICAgICAgICAgICAgICAgIC8vIGNhbmNlbGxpbmcgb2YgbG9hZGluZyBieSByZXR1cm5pbmcgZmFsc2VcbiAgICAgICAgICAgICAgICB2YXIgYWJTdGF0ZUxvYWQgPSBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsICdhb1N0YXRlTG9hZFBhcmFtcycsICdzdGF0ZUxvYWRQYXJhbXMnLCBbc2V0dGluZ3MsIHNdKTtcbiAgICAgICAgICAgICAgICBpZiAoJC5pbkFycmF5KGZhbHNlLCBhYlN0YXRlTG9hZCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZWplY3Qgb2xkIGRhdGFcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24gPiAwICYmIHMudGltZSA8ICtuZXcgRGF0ZSgpIC0gKGR1cmF0aW9uICogMTAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE51bWJlciBvZiBjb2x1bW5zIGhhdmUgY2hhbmdlZCAtIGFsbCBiZXRzIGFyZSBvZmYsIG5vIHJlc3RvcmUgb2Ygc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBpZiAocy5jb2x1bW5zICYmIGNvbHVtbnMubGVuZ3RoICE9PSBzLmNvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSB0aGUgc2F2ZWQgc3RhdGUgc28gaXQgbWlnaHQgYmUgYWNjZXNzZWQgYXQgYW55IHRpbWVcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5vTG9hZGVkU3RhdGUgPSAkLmV4dGVuZCh0cnVlLCB7fSwgcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIGtleSBmZWF0dXJlcyAtIHRvZG8gLSBmb3IgMS4xMSB0aGlzIG5lZWRzIHRvIGJlIGRvbmUgYnlcbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpYmVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChzLnN0YXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQgPSBzLnN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5pSW5pdERpc3BsYXlTdGFydCA9IHMuc3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheUxlbmd0aCA9IHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE9yZGVyXG4gICAgICAgICAgICAgICAgaWYgKHMub3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKHMub3JkZXIsIGZ1bmN0aW9uIChpLCBjb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZy5wdXNoKGNvbFswXSA+PSBjb2x1bW5zLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWzAsIGNvbFsxXV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbFxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoXG4gICAgICAgICAgICAgICAgaWYgKHMuc2VhcmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgJC5leHRlbmQoc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCBfZm5TZWFyY2hUb0h1bmcocy5zZWFyY2gpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDb2x1bW5zXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICBpZiAocy5jb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHMuY29sdW1ucy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbCA9IHMuY29sdW1uc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmlzaWJpbGl0eVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC52aXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zW2ldLmJWaXNpYmxlID0gY29sLnZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbC5zZWFyY2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHNldHRpbmdzLmFvUHJlU2VhcmNoQ29sc1tpXSwgX2ZuU2VhcmNoVG9IdW5nKGNvbC5zZWFyY2gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgJ2FvU3RhdGVMb2FkZWQnLCAnc3RhdGVMb2FkZWQnLCBbc2V0dGluZ3MsIHNdKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vRmVhdHVyZXMuYlN0YXRlU2F2ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBzZXR0aW5ncy5mblN0YXRlTG9hZENhbGxiYWNrLmNhbGwoc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywgbG9hZGVkKTtcblxuICAgICAgICAgICAgaWYgKHN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsb2FkZWQoc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCB3YWl0IGZvciB0aGUgbG9hZGVkIGNhbGxiYWNrIHRvIGJlIGV4ZWN1dGVkXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBwYXJ0aWN1bGFyIHRhYmxlXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV9IHRhYmxlIHRhYmxlIHdlIGFyZSB1c2luZyBhcyBhIGRhdGFUYWJsZVxuICAgICAgICAgKiAgQHJldHVybnMge29iamVjdH0gU2V0dGluZ3Mgb2JqZWN0IC0gb3IgbnVsbCBpZiBub3QgZm91bmRcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuU2V0dGluZ3NGcm9tTm9kZSh0YWJsZSkge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuICAgICAgICAgICAgdmFyIGlkeCA9ICQuaW5BcnJheSh0YWJsZSwgX3BsdWNrKHNldHRpbmdzLCAnblRhYmxlJykpO1xuXG4gICAgICAgICAgICByZXR1cm4gaWR4ICE9PSAtMSA/XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NbaWR4XSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvZyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgZGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBsZXZlbCBsb2cgZXJyb3IgbWVzc2FnZXMsIG9yIGRpc3BsYXkgdGhlbSB0byB0aGUgdXNlclxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IG1zZyBlcnJvciBtZXNzYWdlXG4gICAgICAgICAqICBAcGFyYW0ge2ludH0gdG4gVGVjaG5pY2FsIG5vdGUgaWQgdG8gZ2V0IG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yLlxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5Mb2coc2V0dGluZ3MsIGxldmVsLCBtc2csIHRuKSB7XG4gICAgICAgICAgICBtc2cgPSAnRGF0YVRhYmxlcyB3YXJuaW5nOiAnICtcbiAgICAgICAgICAgICAgICAoc2V0dGluZ3MgPyAndGFibGUgaWQ9JyArIHNldHRpbmdzLnNUYWJsZUlkICsgJyAtICcgOiAnJykgKyBtc2c7XG5cbiAgICAgICAgICAgIGlmICh0bikge1xuICAgICAgICAgICAgICAgIG1zZyArPSAnLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGlzIGVycm9yLCBwbGVhc2Ugc2VlICcgK1xuICAgICAgICAgICAgICAgICAgICAnaHR0cDovL2RhdGF0YWJsZXMubmV0L3RuLycgKyB0bjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFsZXZlbCkge1xuICAgICAgICAgICAgICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSAxLjEwXG4gICAgICAgICAgICAgICAgdmFyIGV4dCA9IERhdGFUYWJsZS5leHQ7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBleHQuc0Vyck1vZGUgfHwgZXh0LmVyck1vZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ2FsbGJhY2tGaXJlKHNldHRpbmdzLCBudWxsLCAnZXJyb3InLCBbc2V0dGluZ3MsIHRuLCBtc2ddKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSAnYWxlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KG1zZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gJ3Rocm93Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB0eXBlKHNldHRpbmdzLCB0biwgbXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWUgaWYgYSBwcm9wZXJ0eSBpcyBkZWZpbmVkIG9uIG9uZSBvYmplY3QsIGlmIHNvIGFzc2lnbiBpdCB0byB0aGUgb3RoZXIgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gcmV0IHRhcmdldCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzcmMgc291cmNlIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IG5hbWUgcHJvcGVydHlcbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBbbWFwcGVkTmFtZV0gbmFtZSB0byBtYXAgdG9vIC0gb3B0aW9uYWwsIG5hbWUgdXNlZCBpZiBub3QgZ2l2ZW5cbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuTWFwKHJldCwgc3JjLCBuYW1lLCBtYXBwZWROYW1lKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgICAgICQuZWFjaChuYW1lLCBmdW5jdGlvbiAoaSwgdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9mbk1hcChyZXQsIHNyYywgdmFsWzBdLCB2YWxbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZuTWFwKHJldCwgc3JjLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYXBwZWROYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXBwZWROYW1lID0gbmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNyY1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0W21hcHBlZE5hbWVdID0gc3JjW25hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRXh0ZW5kIG9iamVjdHMgLSB2ZXJ5IHNpbWlsYXIgdG8galF1ZXJ5LmV4dGVuZCwgYnV0IGRlZXAgY29weSBvYmplY3RzLCBhbmRcbiAgICAgICAgICogc2hhbGxvdyBjb3B5IGFycmF5cy4gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIGRvIHRoaXMsIGlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAgKiBkZWVwIGNvcHkgYXJyYXkgaW5pdCB2YWx1ZXMgKHN1Y2ggYXMgYWFTb3J0aW5nKSBzaW5jZSB0aGUgZGV2IHdvdWxkbid0IGJlXG4gICAgICAgICAqIGFibGUgdG8gb3ZlcnJpZGUgdGhlbSwgYnV0IHdlIGRvIHdhbnQgdG8gZGVlcCBjb3B5IGFycmF5cy5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvdXQgT2JqZWN0IHRvIGV4dGVuZFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGV4dGVuZGVyIE9iamVjdCBmcm9tIHdoaWNoIHRoZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXBwbGllZCB0b1xuICAgICAgICAgKiAgICAgIG91dFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBicmVha1JlZnMgSWYgdHJ1ZSwgdGhlbiBhcnJheXMgd2lsbCBiZSBzbGljZWQgdG8gdGFrZSBhblxuICAgICAgICAgKiAgICAgIGluZGVwZW5kZW50IGNvcHkgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIHRoZSBgZGF0YWAgb3IgYGFhRGF0YWAgcGFyYW1ldGVyc1xuICAgICAgICAgKiAgICAgIGlmIHRoZXkgYXJlIHByZXNlbnQuIFRoaXMgaXMgc28geW91IGNhbiBwYXNzIGluIGEgY29sbGVjdGlvbiB0b1xuICAgICAgICAgKiAgICAgIERhdGFUYWJsZXMgYW5kIGhhdmUgdGhhdCB1c2VkIGFzIHlvdXIgZGF0YSBzb3VyY2Ugd2l0aG91dCBicmVha2luZyB0aGVcbiAgICAgICAgICogICAgICByZWZlcmVuY2VzXG4gICAgICAgICAqICBAcmV0dXJucyB7b2JqZWN0fSBvdXQgUmVmZXJlbmNlLCBqdXN0IGZvciBjb252ZW5pZW5jZSAtIG91dCA9PT0gdGhlIHJldHVybi5cbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKiAgQHRvZG8gVGhpcyBkb2Vzbid0IHRha2UgYWNjb3VudCBvZiBhcnJheXMgaW5zaWRlIHRoZSBkZWVwIGNvcGllZCBvYmplY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuRXh0ZW5kKG91dCwgZXh0ZW5kZXIsIGJyZWFrUmVmcykge1xuICAgICAgICAgICAgdmFyIHZhbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBleHRlbmRlcikge1xuICAgICAgICAgICAgICAgIGlmIChleHRlbmRlci5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSBleHRlbmRlcltwcm9wXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghJC5pc1BsYWluT2JqZWN0KG91dFtwcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRbcHJvcF0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHRydWUsIG91dFtwcm9wXSwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChicmVha1JlZnMgJiYgcHJvcCAhPT0gJ2RhdGEnICYmIHByb3AgIT09ICdhYURhdGEnICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W3Byb3BdID0gdmFsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbcHJvcF0gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCaW5kIGFuIGV2ZW50IGhhbmRlcnMgdG8gYWxsb3cgYSBjbGljayBvciByZXR1cm4ga2V5IHRvIGFjdGl2YXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICogVGhpcyBpcyBnb29kIGZvciBhY2Nlc3NpYmlsaXR5IHNpbmNlIGEgcmV0dXJuIG9uIHRoZSBrZXlib2FyZCB3aWxsIGhhdmUgdGhlXG4gICAgICAgICAqIHNhbWUgZWZmZWN0IGFzIGEgY2xpY2ssIGlmIHRoZSBlbGVtZW50IGhhcyBmb2N1cy5cbiAgICAgICAgICogIEBwYXJhbSB7ZWxlbWVudH0gbiBFbGVtZW50IHRvIGJpbmQgdGhlIGFjdGlvbiB0b1xuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9EYXRhIERhdGEgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHRyaWdnZXJlZCBmdW5jdGlvblxuICAgICAgICAgKiAgQHBhcmFtIHtmdW5jdGlvbn0gZm4gQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZFxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5CaW5kQWN0aW9uKG4sIG9EYXRhLCBmbikge1xuICAgICAgICAgICAgJChuKVxuICAgICAgICAgICAgICAgIC5vbignY2xpY2suRFQnLCBvRGF0YSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgJChuKS50cmlnZ2VyKCdibHVyJyk7IC8vIFJlbW92ZSBmb2N1cyBvdXRsaW5lIGZvciBtb3VzZSB1c2Vyc1xuICAgICAgICAgICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5vbigna2V5cHJlc3MuRFQnLCBvRGF0YSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbihlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdzZWxlY3RzdGFydC5EVCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGFrZSB0aGUgYnJ1dGFsIGFwcHJvYWNoIHRvIGNhbmNlbGxpbmcgdGV4dCBzZWxlY3Rpb24gKi9cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayBmdW5jdGlvbi4gRWFzaWx5IGFsbG93cyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGFkZGVkIHRvXG4gICAgICAgICAqIGFuIGFycmF5IHN0b3JlIG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyB0aGF0IGNhbiB0aGVuIGFsbCBiZSBjYWxsZWQgdG9nZXRoZXIuXG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gc1N0b3JlIE5hbWUgb2YgdGhlIGFycmF5IHN0b3JhZ2UgZm9yIHRoZSBjYWxsYmFja3MgaW4gb1NldHRpbmdzXG4gICAgICAgICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYmFja1xuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHNOYW1lIElkZW50aWZ5aW5nIG5hbWUgZm9yIHRoZSBjYWxsYmFjayAoaS5lLiBhIGxhYmVsKVxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5DYWxsYmFja1JlZyhvU2V0dGluZ3MsIHNTdG9yZSwgZm4sIHNOYW1lKSB7XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBvU2V0dGluZ3Nbc1N0b3JlXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgXCJmblwiOiBmbixcbiAgICAgICAgICAgICAgICAgICAgXCJzTmFtZVwiOiBzTmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZSBjYWxsYmFjayBmdW5jdGlvbnMgYW5kIHRyaWdnZXIgZXZlbnRzLiBOb3RlIHRoYXQgdGhlIGxvb3Agb3ZlciB0aGVcbiAgICAgICAgICogY2FsbGJhY2sgYXJyYXkgc3RvcmUgaXMgZG9uZSBiYWNrd2FyZHMhIEZ1cnRoZXIgbm90ZSB0aGF0IHlvdSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAgKiBmaXJlIG9mZiB0cmlnZ2VycyBpbiB0aW1lIHNlbnNpdGl2ZSBhcHBsaWNhdGlvbnMgKGZvciBleGFtcGxlIGNlbGwgY3JlYXRpb24pXG4gICAgICAgICAqIGFzIGl0cyBzbG93LlxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIGRhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gY2FsbGJhY2tBcnIgTmFtZSBvZiB0aGUgYXJyYXkgc3RvcmFnZSBmb3IgdGhlIGNhbGxiYWNrcyBpblxuICAgICAgICAgKiAgICAgIG9TZXR0aW5nc1xuICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIHRoZSBqUXVlcnkgY3VzdG9tIGV2ZW50IHRvIHRyaWdnZXIuIElmXG4gICAgICAgICAqICAgICAgbnVsbCBubyB0cmlnZ2VyIGlzIGZpcmVkXG4gICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBhcmdzIEFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBjYWxsYmFjayBmdW5jdGlvbiAvXG4gICAgICAgICAqICAgICAgdHJpZ2dlclxuICAgICAgICAgKiAgQG1lbWJlcm9mIERhdGFUYWJsZSNvQXBpXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIGNhbGxiYWNrQXJyLCBldmVudE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciByZXQgPSBbXTtcblxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrQXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gJC5tYXAoc2V0dGluZ3NbY2FsbGJhY2tBcnJdLnNsaWNlKCkucmV2ZXJzZSgpLCBmdW5jdGlvbiAodmFsLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuZm4uYXBwbHkoc2V0dGluZ3Mub0luc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gJC5FdmVudChldmVudE5hbWUgKyAnLmR0Jyk7XG5cbiAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkudHJpZ2dlcihlLCBhcmdzKTtcblxuICAgICAgICAgICAgICAgIHJldC5wdXNoKGUucmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgZnVuY3Rpb24gX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kID0gc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG4gICAgICAgICAgICAgICAgbGVuID0gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoO1xuXG4gICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIHNwYWNlIHRvIHNob3cgZXh0cmEgcm93cyAoYmFja2luZyB1cCBmcm9tIHRoZSBlbmQgcG9pbnQgLSB0aGVuIGRvIHNvICovXG4gICAgICAgICAgICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQgLSBsZW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEtlZXAgdGhlIHN0YXJ0IHJlY29yZCBvbiB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgICAgICBzdGFydCAtPSAoc3RhcnQgJSBsZW4pO1xuXG4gICAgICAgICAgICBpZiAobGVuID09PSAtMSB8fCBzdGFydCA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldHRpbmdzLl9pRGlzcGxheVN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGZ1bmN0aW9uIF9mblJlbmRlcmVyKHNldHRpbmdzLCB0eXBlKSB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZXIgPSBzZXR0aW5ncy5yZW5kZXJlcjtcbiAgICAgICAgICAgIHZhciBob3N0ID0gRGF0YVRhYmxlLmV4dC5yZW5kZXJlclt0eXBlXTtcblxuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChyZW5kZXJlcikgJiYgcmVuZGVyZXJbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAvLyBTcGVjaWZpYyByZW5kZXJlciBmb3IgdGhpcyB0eXBlLiBJZiBhdmFpbGFibGUgdXNlIGl0LCBvdGhlcndpc2UgdXNlXG4gICAgICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvc3RbcmVuZGVyZXJbdHlwZV1dIHx8IGhvc3QuXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiByZW5kZXJlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBDb21tb24gcmVuZGVyZXIgLSBpZiB0aGVyZSBpcyBvbmUgYXZhaWxhYmxlIGZvciB0aGlzIHR5cGUgdXNlIGl0LFxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9zdFtyZW5kZXJlcl0gfHwgaG9zdC5fO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIHJldHVybiBob3N0Ll87XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlY3QgdGhlIGRhdGEgc291cmNlIGJlaW5nIHVzZWQgZm9yIHRoZSB0YWJsZS4gVXNlZCB0byBzaW1wbGlmeSB0aGUgY29kZVxuICAgICAgICAgKiBhIGxpdHRsZSAoYWpheCkgYW5kIHRvIG1ha2UgaXQgY29tcHJlc3MgYSBsaXR0bGUgc21hbGxlci5cbiAgICAgICAgICpcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBkYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHJldHVybnMge3N0cmluZ30gRGF0YSBzb3VyY2VcbiAgICAgICAgICogIEBtZW1iZXJvZiBEYXRhVGFibGUjb0FwaVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm9GZWF0dXJlcy5iU2VydmVyU2lkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc3NwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNldHRpbmdzLmFqYXggfHwgc2V0dGluZ3Muc0FqYXhTb3VyY2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FqYXgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICdkb20nO1xuICAgICAgICB9XG5cblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXB1dGVkIHN0cnVjdHVyZSBvZiB0aGUgRGF0YVRhYmxlcyBBUEksIGRlZmluZWQgYnkgdGhlIG9wdGlvbnMgcGFzc2VkIHRvXG4gICAgICAgICAqIGBEYXRhVGFibGUuQXBpLnJlZ2lzdGVyKClgIHdoZW4gYnVpbGRpbmcgdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHN0cnVjdHVyZSBpcyBidWlsdCBpbiBvcmRlciB0byBzcGVlZCBjcmVhdGlvbiBhbmQgZXh0ZW5zaW9uIG9mIHRoZSBBcGlcbiAgICAgICAgICogb2JqZWN0cyBzaW5jZSB0aGUgZXh0ZW5zaW9ucyBhcmUgZWZmZWN0aXZlbHkgcHJlLXBhcnNlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZSwgd2hlcmUgdGhpc1xuICAgICAgICAgKiBiYXNlIGFycmF5IHJlcHJlc2VudHMgdGhlIEFwaSBwcm90b3R5cGUgYmFzZTpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIFtcbiAgICAgICAgICogICAgICAge1xuICAgICAgICAgKiAgICAgICAgIG5hbWU6ICAgICAgJ2RhdGEnICAgICAgICAgICAgICAgIC0tIHN0cmluZyAgIC0gUHJvcGVydHkgbmFtZVxuICAgICAgICAgKiAgICAgICAgIHZhbDogICAgICAgZnVuY3Rpb24gKCkge30sICAgICAgIC0tIGZ1bmN0aW9uIC0gQXBpIG1ldGhvZCAob3IgdW5kZWZpbmVkIGlmIGp1c3QgYW4gb2JqZWN0XG4gICAgICAgICAqICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLCAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgbWV0aG9kIHJlc3VsdFxuICAgICAgICAgKiAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXSAgICAgICAgICAgICAgIC0tIGFycmF5ICAgIC0gQXJyYXkgb2YgQXBpIG9iamVjdCBkZWZpbml0aW9ucyB0byBleHRlbmQgdGhlIHByb3BlcnR5XG4gICAgICAgICAqICAgICAgIH0sXG4gICAgICAgICAqICAgICAgIHtcbiAgICAgICAgICogICAgICAgICBuYW1lOiAgICAgJ3JvdydcbiAgICAgICAgICogICAgICAgICB2YWw6ICAgICAgIHt9LFxuICAgICAgICAgKiAgICAgICAgIG1ldGhvZEV4dDogWyAuLi4gXSxcbiAgICAgICAgICogICAgICAgICBwcm9wRXh0OiAgIFtcbiAgICAgICAgICogICAgICAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgICAgbmFtZTogICAgICAnZGF0YSdcbiAgICAgICAgICogICAgICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICogICAgICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuICAgICAgICAgKiAgICAgICAgICAgICBwcm9wRXh0OiAgIFsgLi4uIF1cbiAgICAgICAgICogICAgICAgICAgIH0sXG4gICAgICAgICAqICAgICAgICAgICAuLi5cbiAgICAgICAgICogICAgICAgICBdXG4gICAgICAgICAqICAgICAgIH1cbiAgICAgICAgICogICAgIF1cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX19hcGlTdHJ1Y3QgPSBbXTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgQXJyYXkucHJvdG90eXBlYCByZWZlcmVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIG9iamVjdFxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgX19hcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFic3RyYWN0aW9uIGZvciBgY29udGV4dGAgcGFyYW1ldGVyIG9mIHRoZSBgQXBpYCBjb25zdHJ1Y3RvciB0byBhbGxvdyBpdCB0b1xuICAgICAgICAgKiB0YWtlIHNldmVyYWwgZGlmZmVyZW50IGZvcm1zIGZvciBlYXNlIG9mIHVzZS5cbiAgICAgICAgICpcbiAgICAgICAgICogRWFjaCBvZiB0aGUgaW5wdXQgcGFyYW1ldGVyIHR5cGVzIHdpbGwgYmUgY29udmVydGVkIHRvIGEgRGF0YVRhYmxlcyBzZXR0aW5nc1xuICAgICAgICAgKiBvYmplY3Qgd2hlcmUgcG9zc2libGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSAge3N0cmluZ3xub2RlfGpRdWVyeXxvYmplY3R9IG1peGVkIERhdGFUYWJsZSBpZGVudGlmaWVyLiBDYW4gYmUgb25lXG4gICAgICAgICAqICAgb2Y6XG4gICAgICAgICAqXG4gICAgICAgICAqICAgKiBgc3RyaW5nYCAtIGpRdWVyeSBzZWxlY3Rvci4gQW55IERhdGFUYWJsZXMnIG1hdGNoaW5nIHRoZSBnaXZlbiBzZWxlY3RvclxuICAgICAgICAgKiAgICAgd2l0aCBiZSBmb3VuZCBhbmQgdXNlZC5cbiAgICAgICAgICogICAqIGBub2RlYCAtIGBUQUJMRWAgbm9kZSB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGZvcm1lZCBpbnRvIGEgRGF0YVRhYmxlLlxuICAgICAgICAgKiAgICogYGpRdWVyeWAgLSBBIGpRdWVyeSBvYmplY3Qgb2YgYFRBQkxFYCBub2Rlcy5cbiAgICAgICAgICogICAqIGBvYmplY3RgIC0gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogICAqIGBEYXRhVGFibGVzLkFwaWAgLSBBUEkgaW5zdGFuY2VcbiAgICAgICAgICogQHJldHVybiB7YXJyYXl8bnVsbH0gTWF0Y2hpbmcgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RzLiBgbnVsbGAgb3JcbiAgICAgICAgICogICBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZCBpZiBubyBtYXRjaGluZyBEYXRhVGFibGUgaXMgZm91bmQuXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHZhciBfdG9TZXR0aW5ncyA9IGZ1bmN0aW9uIChtaXhlZCkge1xuICAgICAgICAgICAgdmFyIGlkeCwganE7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSBEYXRhVGFibGUuc2V0dGluZ3M7XG4gICAgICAgICAgICB2YXIgdGFibGVzID0gJC5tYXAoc2V0dGluZ3MsIGZ1bmN0aW9uIChlbCwgaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbC5uVGFibGU7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFtaXhlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkLm5UYWJsZSAmJiBtaXhlZC5vQXBpKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAgICByZXR1cm4gW21peGVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkLm5vZGVOYW1lICYmIG1peGVkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0YWJsZScpIHtcbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBub2RlXG4gICAgICAgICAgICAgICAgaWR4ID0gJC5pbkFycmF5KG1peGVkLCB0YWJsZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpZHggIT09IC0xID8gW3NldHRpbmdzW2lkeF1dIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1peGVkICYmIHR5cGVvZiBtaXhlZC5zZXR0aW5ncyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtaXhlZC5zZXR0aW5ncygpLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtaXhlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBqcSA9ICQobWl4ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWl4ZWQgaW5zdGFuY2VvZiAkKSB7XG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IG9iamVjdCAoYWxzbyBEYXRhVGFibGVzIGluc3RhbmNlKVxuICAgICAgICAgICAgICAgIGpxID0gbWl4ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChqcSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBqcS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gJC5pbkFycmF5KHRoaXMsIHRhYmxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpZHggIT09IC0xID8gc2V0dGluZ3NbaWR4XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfSkudG9BcnJheSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERhdGFUYWJsZXMgQVBJIGNsYXNzIC0gdXNlZCB0byBjb250cm9sIGFuZCBpbnRlcmZhY2Ugd2l0aCAgb25lIG9yIG1vcmVcbiAgICAgICAgICogRGF0YVRhYmxlcyBlbmhhbmNlZCB0YWJsZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBBUEkgY2xhc3MgaXMgaGVhdmlseSBiYXNlZCBvbiBqUXVlcnksIHByZXNlbnRpbmcgYSBjaGFpbmFibGUgaW50ZXJmYWNlXG4gICAgICAgICAqIHRoYXQgeW91IGNhbiB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0YWJsZXMuIEVhY2ggaW5zdGFuY2Ugb2YgdGhlIEFQSSBjbGFzcyBoYXNcbiAgICAgICAgICogYSBcImNvbnRleHRcIiAtIGkuZS4gdGhlIHRhYmxlcyB0aGF0IGl0IHdpbGwgb3BlcmF0ZSBvbi4gVGhpcyBjb3VsZCBiZSBhIHNpbmdsZVxuICAgICAgICAgKiB0YWJsZSwgYWxsIHRhYmxlcyBvbiBhIHBhZ2Ugb3IgYSBzdWItc2V0IHRoZXJlb2YuXG4gICAgICAgICAqXG4gICAgICAgICAqIEFkZGl0aW9uYWxseSB0aGUgQVBJIGlzIGRlc2lnbmVkIHRvIGFsbG93IHlvdSB0byBlYXNpbHkgd29yayB3aXRoIHRoZSBkYXRhIGluXG4gICAgICAgICAqIHRoZSB0YWJsZXMsIHJldHJpZXZpbmcgYW5kIG1hbmlwdWxhdGluZyBpdCBhcyByZXF1aXJlZC4gVGhpcyBpcyBkb25lIGJ5XG4gICAgICAgICAqIHByZXNlbnRpbmcgdGhlIEFQSSBjbGFzcyBhcyBhbiBhcnJheSBsaWtlIGludGVyZmFjZS4gVGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAgKiBhcnJheSBkZXBlbmQgdXBvbiB0aGUgYWN0aW9ucyByZXF1ZXN0ZWQgYnkgZWFjaCBtZXRob2QgKGZvciBleGFtcGxlXG4gICAgICAgICAqIGByb3dzKCkubm9kZXMoKWAgd2lsbCByZXR1cm4gYW4gYXJyYXkgb2Ygbm9kZXMsIHdoaWxlIGByb3dzKCkuZGF0YSgpYCB3aWxsXG4gICAgICAgICAqIHJldHVybiBhbiBhcnJheSBvZiBvYmplY3RzIG9yIGFycmF5cyBkZXBlbmRpbmcgdXBvbiB5b3VyIHRhYmxlJ3NcbiAgICAgICAgICogY29uZmlndXJhdGlvbikuIFRoZSBBUEkgb2JqZWN0IGhhcyBhIG51bWJlciBvZiBhcnJheSBsaWtlIG1ldGhvZHMgKGBwdXNoYCxcbiAgICAgICAgICogYHBvcGAsIGByZXZlcnNlYCBldGMpIGFzIHdlbGwgYXMgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcyAoYGVhY2hgLCBgcGx1Y2tgLFxuICAgICAgICAgKiBgdW5pcXVlYCBldGMpIHRvIGFzc2lzdCB5b3VyIHdvcmtpbmcgd2l0aCB0aGUgZGF0YSBoZWxkIGluIGEgdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIE1vc3QgbWV0aG9kcyAodGhvc2Ugd2hpY2ggcmV0dXJuIGFuIEFwaSBpbnN0YW5jZSkgYXJlIGNoYWluYWJsZSwgd2hpY2ggbWVhbnNcbiAgICAgICAgICogdGhlIHJldHVybiBmcm9tIGEgbWV0aG9kIGNhbGwgYWxzbyBoYXMgYWxsIG9mIHRoZSBtZXRob2RzIGF2YWlsYWJsZSB0aGF0IHRoZVxuICAgICAgICAgKiB0b3AgbGV2ZWwgb2JqZWN0IGhhZC4gRm9yIGV4YW1wbGUsIHRoZXNlIHR3byBjYWxscyBhcmUgZXF1aXZhbGVudDpcbiAgICAgICAgICpcbiAgICAgICAgICogICAgIC8vIE5vdCBjaGFpbmVkXG4gICAgICAgICAqICAgICBhcGkucm93LmFkZCggey4uLn0gKTtcbiAgICAgICAgICogICAgIGFwaS5kcmF3KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqICAgICAvLyBDaGFpbmVkXG4gICAgICAgICAqICAgICBhcGkucm93LmFkZCggey4uLn0gKS5kcmF3KCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBjbGFzcyBEYXRhVGFibGUuQXBpXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fHN0cmluZ3xqUXVlcnl9IGNvbnRleHQgRGF0YVRhYmxlIGlkZW50aWZpZXIuIFRoaXMgaXNcbiAgICAgICAgICogICB1c2VkIHRvIGRlZmluZSB3aGljaCBEYXRhVGFibGVzIGVuaGFuY2VkIHRhYmxlcyB0aGlzIEFQSSB3aWxsIG9wZXJhdGUgb24uXG4gICAgICAgICAqICAgQ2FuIGJlIG9uZSBvZjpcbiAgICAgICAgICpcbiAgICAgICAgICogICAqIGBzdHJpbmdgIC0galF1ZXJ5IHNlbGVjdG9yLiBBbnkgRGF0YVRhYmxlcycgbWF0Y2hpbmcgdGhlIGdpdmVuIHNlbGVjdG9yXG4gICAgICAgICAqICAgICB3aXRoIGJlIGZvdW5kIGFuZCB1c2VkLlxuICAgICAgICAgKiAgICogYG5vZGVgIC0gYFRBQkxFYCBub2RlIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gZm9ybWVkIGludG8gYSBEYXRhVGFibGUuXG4gICAgICAgICAqICAgKiBgalF1ZXJ5YCAtIEEgalF1ZXJ5IG9iamVjdCBvZiBgVEFCTEVgIG5vZGVzLlxuICAgICAgICAgKiAgICogYG9iamVjdGAgLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBbZGF0YV0gRGF0YSB0byBpbml0aWFsaXNlIHRoZSBBcGkgaW5zdGFuY2Ugd2l0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAvLyBEaXJlY3QgaW5pdGlhbGlzYXRpb24gZHVyaW5nIERhdGFUYWJsZXMgY29uc3RydWN0aW9uXG4gICAgICAgICAqICAgdmFyIGFwaSA9ICQoJyNleGFtcGxlJykuRGF0YVRhYmxlKCk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgLy8gSW5pdGlhbGlzYXRpb24gdXNpbmcgYSBEYXRhVGFibGVzIGpRdWVyeSBvYmplY3RcbiAgICAgICAgICogICB2YXIgYXBpID0gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoKS5hcGkoKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAvLyBJbml0aWFsaXNhdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gICAgICAgICAqICAgdmFyIGFwaSA9IG5ldyAkLmZuLkRhdGFUYWJsZS5BcGkoICd0YWJsZS5kYXRhVGFibGUnICk7XG4gICAgICAgICAqL1xuICAgICAgICBfQXBpID0gZnVuY3Rpb24gKGNvbnRleHQsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfQXBpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaShjb250ZXh0LCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gW107XG4gICAgICAgICAgICB2YXIgY3R4U2V0dGluZ3MgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gX3RvU2V0dGluZ3Mobyk7XG4gICAgICAgICAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucHVzaC5hcHBseShzZXR0aW5ncywgYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gY29udGV4dC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjdHhTZXR0aW5ncyhjb250ZXh0W2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHhTZXR0aW5ncyhjb250ZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVtb3ZlIGR1cGxpY2F0ZXNcbiAgICAgICAgICAgIHRoaXMuY29udGV4dCA9IF91bmlxdWUoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBJbml0aWFsIGRhdGFcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgJC5tZXJnZSh0aGlzLCBkYXRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VsZWN0b3JcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3IgPSB7XG4gICAgICAgICAgICAgICAgcm93czogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2xzOiBudWxsLFxuICAgICAgICAgICAgICAgIG9wdHM6IG51bGxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9BcGkuZXh0ZW5kKHRoaXMsIHRoaXMsIF9fYXBpU3RydWN0KTtcbiAgICAgICAgfTtcblxuICAgICAgICBEYXRhVGFibGUuQXBpID0gX0FwaTtcblxuICAgICAgICAvLyBEb24ndCBkZXN0cm95IHRoZSBleGlzdGluZyBwcm90b3R5cGUsIGp1c3QgZXh0ZW5kIGl0LiBSZXF1aXJlZCBmb3IgalF1ZXJ5IDInc1xuICAgICAgICAvLyBpc1BsYWluT2JqZWN0LlxuICAgICAgICAkLmV4dGVuZChfQXBpLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgYW55OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY291bnQoKSAhPT0gMDtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgY29uY2F0OiBfX2FycmF5UHJvdG8uY29uY2F0LFxuXG5cbiAgICAgICAgICAgIGNvbnRleHQ6IFtdLCAvLyBhcnJheSBvZiB0YWJsZSBzZXR0aW5ncyBvYmplY3RzXG5cblxuICAgICAgICAgICAgY291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCkubGVuZ3RoO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICBlYWNoOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gdGhpcy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKHRoaXMsIHRoaXNbaV0sIGksIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICBlcTogZnVuY3Rpb24gKGlkeCkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA+IGlkeCA/XG4gICAgICAgICAgICAgICAgICAgIG5ldyBfQXBpKGN0eFtpZHhdLCB0aGlzW2lkeF0pIDpcbiAgICAgICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9fYXJyYXlQcm90by5maWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IF9fYXJyYXlQcm90by5maWx0ZXIuY2FsbCh0aGlzLCBmbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHRoaXMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXMsIHRoaXNbaV0sIGksIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHRoaXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBfQXBpKHRoaXMuY29udGV4dCwgYSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIGZsYXR0ZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIGEuY29uY2F0LmFwcGx5KGEsIHRoaXMudG9BcnJheSgpKSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIGpvaW46IF9fYXJyYXlQcm90by5qb2luLFxuXG5cbiAgICAgICAgICAgIGluZGV4T2Y6IF9fYXJyYXlQcm90by5pbmRleE9mIHx8IGZ1bmN0aW9uIChvYmosIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IChzdGFydCB8fCAwKSwgaWVuID0gdGhpcy5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSA9PT0gb2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpdGVyYXRvcjogZnVuY3Rpb24gKGZsYXR0ZW4sIHR5cGUsIGZuLCBhbHdheXNOZXcpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgYSA9IFtdLCByZXQsXG4gICAgICAgICAgICAgICAgICAgIGksIGllbiwgaiwgamVuLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0ID0gdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICByb3dzLCBpdGVtcywgaXRlbSxcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXG4gICAgICAgICAgICAgICAgLy8gQXJndW1lbnQgc2hpZnRpbmdcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZsYXR0ZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c05ldyA9IGZuO1xuICAgICAgICAgICAgICAgICAgICBmbiA9IHR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBmbGF0dGVuO1xuICAgICAgICAgICAgICAgICAgICBmbGF0dGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gY29udGV4dC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXBpSW5zdCA9IG5ldyBfQXBpKGNvbnRleHRbaV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAndGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY29sdW1ucycgfHwgdHlwZSA9PT0gJ3Jvd3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcyBzYW1lIGxlbmd0aCBhcyBjb250ZXh0IC0gb25lIGVudHJ5IGZvciBlYWNoIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIHRoaXNbaV0sIGkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnY29sdW1uJyB8fCB0eXBlID09PSAnY29sdW1uLXJvd3MnIHx8IHR5cGUgPT09ICdyb3cnIHx8IHR5cGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29sdW1ucyBhbmQgcm93cyBzaGFyZSB0aGUgc2FtZSBzdHJ1Y3R1cmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAndGhpcycgaXMgYW4gYXJyYXkgb2YgY29sdW1uIGluZGV4ZXMgZm9yIGVhY2ggY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbHVtbi1yb3dzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoY29udGV4dFtpXSwgc2VsZWN0b3Iub3B0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGl0ZW1zLmxlbmd0aDsgaiA8IGplbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2pdO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjZWxsJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0ucm93LCBpdGVtLmNvbHVtbiwgaSwgaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXQgPSBmbi5jYWxsKGFwaUluc3QsIGNvbnRleHRbaV0sIGl0ZW0sIGksIGosIHJvd3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2gocmV0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYS5sZW5ndGggfHwgYWx3YXlzTmV3KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcGkgPSBuZXcgX0FwaShjb250ZXh0LCBmbGF0dGVuID8gYS5jb25jYXQuYXBwbHkoW10sIGEpIDogYSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhcGlTZWxlY3RvciA9IGFwaS5zZWxlY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgYXBpU2VsZWN0b3Iucm93cyA9IHNlbGVjdG9yLnJvd3M7XG4gICAgICAgICAgICAgICAgICAgIGFwaVNlbGVjdG9yLmNvbHMgPSBzZWxlY3Rvci5jb2xzO1xuICAgICAgICAgICAgICAgICAgICBhcGlTZWxlY3Rvci5vcHRzID0gc2VsZWN0b3Iub3B0cztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIGxhc3RJbmRleE9mOiBfX2FycmF5UHJvdG8ubGFzdEluZGV4T2YgfHwgZnVuY3Rpb24gKG9iaiwgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAvLyBCaXQgY2hlZWt5Li4uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZi5hcHBseSh0aGlzLnRvQXJyYXkucmV2ZXJzZSgpLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICBsZW5ndGg6IDAsXG5cblxuICAgICAgICAgICAgbWFwOiBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9fYXJyYXlQcm90by5tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IF9fYXJyYXlQcm90by5tYXAuY2FsbCh0aGlzLCBmbiwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXRpYmlsaXR5IGZvciBicm93c2VycyB3aXRob3V0IEVNQ0EtMjUyLTUgKEpTIDEuNilcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHRoaXMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChmbi5jYWxsKHRoaXMsIHRoaXNbaV0sIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIGEpO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICBwbHVjazogZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHBvcDogX19hcnJheVByb3RvLnBvcCxcblxuXG4gICAgICAgICAgICBwdXNoOiBfX2FycmF5UHJvdG8ucHVzaCxcblxuXG4gICAgICAgICAgICAvLyBEb2VzIG5vdCByZXR1cm4gYW4gQVBJIGluc3RhbmNlXG4gICAgICAgICAgICByZWR1Y2U6IF9fYXJyYXlQcm90by5yZWR1Y2UgfHwgZnVuY3Rpb24gKGZuLCBpbml0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mblJlZHVjZSh0aGlzLCBmbiwgaW5pdCwgMCwgdGhpcy5sZW5ndGgsIDEpO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICByZWR1Y2VSaWdodDogX19hcnJheVByb3RvLnJlZHVjZVJpZ2h0IHx8IGZ1bmN0aW9uIChmbiwgaW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZm5SZWR1Y2UodGhpcywgZm4sIGluaXQsIHRoaXMubGVuZ3RoIC0gMSwgLTEsIC0xKTtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgcmV2ZXJzZTogX19hcnJheVByb3RvLnJldmVyc2UsXG5cblxuICAgICAgICAgICAgLy8gT2JqZWN0IHdpdGggcm93cywgY29sdW1ucyBhbmQgb3B0c1xuICAgICAgICAgICAgc2VsZWN0b3I6IG51bGwsXG5cblxuICAgICAgICAgICAgc2hpZnQ6IF9fYXJyYXlQcm90by5zaGlmdCxcblxuXG4gICAgICAgICAgICBzbGljZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaSh0aGlzLmNvbnRleHQsIHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICBzb3J0OiBfX2FycmF5UHJvdG8uc29ydCwgLy8gPyBuYW1lIC0gb3JkZXI/XG5cblxuICAgICAgICAgICAgc3BsaWNlOiBfX2FycmF5UHJvdG8uc3BsaWNlLFxuXG5cbiAgICAgICAgICAgIHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hcnJheVByb3RvLnNsaWNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIHRvJDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICB0b0pRdWVyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkKHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICB1bmlxdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCBfdW5pcXVlKHRoaXMpKTtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgdW5zaGlmdDogX19hcnJheVByb3RvLnVuc2hpZnRcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfQXBpLmV4dGVuZCA9IGZ1bmN0aW9uIChzY29wZSwgb2JqLCBleHQpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgZXh0ZW5kIEFQSSBpbnN0YW5jZXMgYW5kIHN0YXRpYyBwcm9wZXJ0aWVzIG9mIHRoZSBBUElcbiAgICAgICAgICAgIGlmICghZXh0Lmxlbmd0aCB8fCAhb2JqIHx8ICghKG9iaiBpbnN0YW5jZW9mIF9BcGkpICYmICFvYmouX19kdF93cmFwcGVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgaSwgaWVuLFxuICAgICAgICAgICAgICAgIHN0cnVjdCxcbiAgICAgICAgICAgICAgICBtZXRob2RTY29waW5nID0gZnVuY3Rpb24gKHNjb3BlLCBmbiwgc3RydWMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXQgPSBmbi5hcHBseShzY29wZSwgYXJndW1lbnRzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWV0aG9kIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgX0FwaS5leHRlbmQocmV0LCByZXQsIHN0cnVjLm1ldGhvZEV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IGV4dC5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHN0cnVjdCA9IGV4dFtpXTtcblxuICAgICAgICAgICAgICAgIC8vIFZhbHVlXG4gICAgICAgICAgICAgICAgb2JqW3N0cnVjdC5uYW1lXSA9IHN0cnVjdC50eXBlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kU2NvcGluZyhzY29wZSwgc3RydWN0LnZhbCwgc3RydWN0KSA6XG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdC50eXBlID09PSAnb2JqZWN0JyA/XG4gICAgICAgICAgICAgICAgICAgICAgICB7fSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJ1Y3QudmFsO1xuXG4gICAgICAgICAgICAgICAgb2JqW3N0cnVjdC5uYW1lXS5fX2R0X3dyYXBwZXIgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJvcGVydHkgZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgX0FwaS5leHRlbmQoc2NvcGUsIG9ialtzdHJ1Y3QubmFtZV0sIHN0cnVjdC5wcm9wRXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8vIEB0b2RvIC0gSXMgdGhlcmUgbmVlZCBmb3IgYW4gYXVnbWVudCBmdW5jdGlvbj9cbiAgICAgICAgLy8gX0FwaS5hdWdtZW50ID0gZnVuY3Rpb24gKCBpbnN0LCBuYW1lIClcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyBcdC8vIEZpbmQgc3JjIG9iamVjdCBpbiB0aGUgc3RydWN0dXJlIGZyb20gdGhlIG5hbWVcbiAgICAgICAgLy8gXHR2YXIgcGFydHMgPSBuYW1lLnNwbGl0KCcuJyk7XG5cbiAgICAgICAgLy8gXHRfQXBpLmV4dGVuZCggaW5zdCwgb2JqICk7XG4gICAgICAgIC8vIH07XG5cblxuICAgICAgICAvLyAgICAgW1xuICAgICAgICAvLyAgICAgICB7XG4gICAgICAgIC8vICAgICAgICAgbmFtZTogICAgICAnZGF0YScgICAgICAgICAgICAgICAgLS0gc3RyaW5nICAgLSBQcm9wZXJ0eSBuYW1lXG4gICAgICAgIC8vICAgICAgICAgdmFsOiAgICAgICBmdW5jdGlvbiAoKSB7fSwgICAgICAgLS0gZnVuY3Rpb24gLSBBcGkgbWV0aG9kIChvciB1bmRlZmluZWQgaWYganVzdCBhbiBvYmplY3RcbiAgICAgICAgLy8gICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sICAgICAgICAgICAgICAtLSBhcnJheSAgICAtIEFycmF5IG9mIEFwaSBvYmplY3QgZGVmaW5pdGlvbnMgdG8gZXh0ZW5kIHRoZSBtZXRob2QgcmVzdWx0XG4gICAgICAgIC8vICAgICAgICAgcHJvcEV4dDogICBbIC4uLiBdICAgICAgICAgICAgICAgLS0gYXJyYXkgICAgLSBBcnJheSBvZiBBcGkgb2JqZWN0IGRlZmluaXRpb25zIHRvIGV4dGVuZCB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gICAgICAgfSxcbiAgICAgICAgLy8gICAgICAge1xuICAgICAgICAvLyAgICAgICAgIG5hbWU6ICAgICAncm93J1xuICAgICAgICAvLyAgICAgICAgIHZhbDogICAgICAge30sXG4gICAgICAgIC8vICAgICAgICAgbWV0aG9kRXh0OiBbIC4uLiBdLFxuICAgICAgICAvLyAgICAgICAgIHByb3BFeHQ6ICAgW1xuICAgICAgICAvLyAgICAgICAgICAge1xuICAgICAgICAvLyAgICAgICAgICAgICBuYW1lOiAgICAgICdkYXRhJ1xuICAgICAgICAvLyAgICAgICAgICAgICB2YWw6ICAgICAgIGZ1bmN0aW9uICgpIHt9LFxuICAgICAgICAvLyAgICAgICAgICAgICBtZXRob2RFeHQ6IFsgLi4uIF0sXG4gICAgICAgIC8vICAgICAgICAgICAgIHByb3BFeHQ6ICAgWyAuLi4gXVxuICAgICAgICAvLyAgICAgICAgICAgfSxcbiAgICAgICAgLy8gICAgICAgICAgIC4uLlxuICAgICAgICAvLyAgICAgICAgIF1cbiAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAvLyAgICAgXVxuXG4gICAgICAgIF9BcGkucmVnaXN0ZXIgPSBfYXBpX3JlZ2lzdGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamVuID0gbmFtZS5sZW5ndGg7IGogPCBqZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICBfQXBpLnJlZ2lzdGVyKG5hbWVbal0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgaSwgaWVuLFxuICAgICAgICAgICAgICAgIGhlaXIgPSBuYW1lLnNwbGl0KCcuJyksXG4gICAgICAgICAgICAgICAgc3RydWN0ID0gX19hcGlTdHJ1Y3QsXG4gICAgICAgICAgICAgICAga2V5LCBtZXRob2Q7XG5cbiAgICAgICAgICAgIHZhciBmaW5kID0gZnVuY3Rpb24gKHNyYywgbmFtZSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzcmMubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1tpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3JjW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gaGVpci5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGhlaXJbaV0uaW5kZXhPZignKCknKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAga2V5ID0gbWV0aG9kID9cbiAgICAgICAgICAgICAgICAgICAgaGVpcltpXS5yZXBsYWNlKCcoKScsICcnKSA6XG4gICAgICAgICAgICAgICAgICAgIGhlaXJbaV07XG5cbiAgICAgICAgICAgICAgICB2YXIgc3JjID0gZmluZChzdHJ1Y3QsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZEV4dDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wRXh0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN0cnVjdC5wdXNoKHNyYyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGllbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnZhbCA9IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgc3JjLnR5cGUgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgICAgICAgICdmdW5jdGlvbicgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJC5pc1BsYWluT2JqZWN0KHZhbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb3RoZXInO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RydWN0ID0gbWV0aG9kID9cbiAgICAgICAgICAgICAgICAgICAgICAgIHNyYy5tZXRob2RFeHQgOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3JjLnByb3BFeHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIF9BcGkucmVnaXN0ZXJQbHVyYWwgPSBfYXBpX3JlZ2lzdGVyUGx1cmFsID0gZnVuY3Rpb24gKHBsdXJhbE5hbWUsIHNpbmd1bGFyTmFtZSwgdmFsKSB7XG4gICAgICAgICAgICBfQXBpLnJlZ2lzdGVyKHBsdXJhbE5hbWUsIHZhbCk7XG5cbiAgICAgICAgICAgIF9BcGkucmVnaXN0ZXIoc2luZ3VsYXJOYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldCA9IHZhbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldCA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5lZCBpdGVtIGlzIHRoZSBBUEkgaW5zdGFuY2UgdGhhdCB3YXMgcGFzc2VkIGluLCByZXR1cm4gaXRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJldCBpbnN0YW5jZW9mIF9BcGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IEFQSSBpbnN0YW5jZSByZXR1cm5lZCwgd2FudCB0aGUgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgZm9yIHRoZSBzaW5ndWxhciByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQubGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocmV0WzBdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkocmV0LmNvbnRleHQsIHJldFswXSkgOiAvLyBBcnJheSByZXN1bHRzIGFyZSAnZW5oYW5jZWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0WzBdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBOb24tQVBJIHJldHVybiAtIGp1c3QgZmlyZSBpdCBiYWNrXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbGVjdG9yIGZvciBIVE1MIHRhYmxlcy4gQXBwbHkgdGhlIGdpdmVuIHNlbGVjdG9yIHRvIHRoZSBnaXZlIGFycmF5IG9mXG4gICAgICAgICAqIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd8aW50ZWdlcn0gW3NlbGVjdG9yXSBqUXVlcnkgc2VsZWN0b3Igc3RyaW5nIG9yIGludGVnZXJcbiAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IEFycmF5IG9mIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0cyB0byBiZSBmaWx0ZXJlZFxuICAgICAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9fdGFibGVfc2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAkLm1hcChzZWxlY3RvciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fdGFibGVfc2VsZWN0b3IoaXRlbSwgYSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEludGVnZXIgaXMgdXNlZCB0byBwaWNrIG91dCBhIHRhYmxlIGJ5IGluZGV4XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbYVtzZWxlY3Rvcl1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGEgalF1ZXJ5IHNlbGVjdG9yIG9uIHRoZSB0YWJsZSBub2Rlc1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gJC5tYXAoYSwgZnVuY3Rpb24gKGVsLCBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsLm5UYWJsZTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gJChub2RlcylcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHNlbGVjdG9yKVxuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmVlZCB0byB0cmFuc2xhdGUgYmFjayBmcm9tIHRoZSB0YWJsZSBub2RlIHRvIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWR4ID0gJC5pbkFycmF5KHRoaXMsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFbaWR4XTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgIH07XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250ZXh0IHNlbGVjdG9yIGZvciB0aGUgQVBJJ3MgY29udGV4dCAoaS5lLiB0aGUgdGFibGVzIHRoZSBBUEkgaW5zdGFuY2VcbiAgICAgICAgICogcmVmZXJzIHRvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZSAgICBEYXRhVGFibGUuQXBpI3RhYmxlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ3xpbnRlZ2VyfSBbc2VsZWN0b3JdIFNlbGVjdG9yIHRvIHBpY2sgd2hpY2ggdGFibGVzIHRoZSBpdGVyYXRvclxuICAgICAgICAgKiAgIHNob3VsZCBvcGVyYXRlIG9uLiBJZiBub3QgZ2l2ZW4sIGFsbCB0YWJsZXMgaW4gdGhlIGN1cnJlbnQgY29udGV4dCBhcmVcbiAgICAgICAgICogICB1c2VkLiBUaGlzIGNhbiBiZSBnaXZlbiBhcyBhIGpRdWVyeSBzZWxlY3RvciAoZm9yIGV4YW1wbGUgYCc6Z3QoMCknYCkgdG9cbiAgICAgICAgICogICBzZWxlY3QgbXVsdGlwbGUgdGFibGVzIG9yIGFzIGFuIGludGVnZXIgdG8gc2VsZWN0IGEgc2luZ2xlIHRhYmxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlLkFwaX0gUmV0dXJucyBhIG5ldyBBUEkgaW5zdGFuY2UgaWYgYSBzZWxlY3RvciBpcyBnaXZlbi5cbiAgICAgICAgICovXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3RhYmxlcygpJywgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAvLyBBIG5ldyBpbnN0YW5jZSBpcyBjcmVhdGVkIGlmIHRoZXJlIHdhcyBhIHNlbGVjdG9yIHNwZWNpZmllZFxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdG9yICE9PSB1bmRlZmluZWQgJiYgc2VsZWN0b3IgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgIG5ldyBfQXBpKF9fdGFibGVfc2VsZWN0b3Ioc2VsZWN0b3IsIHRoaXMuY29udGV4dCkpIDpcbiAgICAgICAgICAgICAgICB0aGlzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3RhYmxlKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHZhciB0YWJsZXMgPSB0aGlzLnRhYmxlcyhzZWxlY3Rvcik7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGFibGVzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCBtYXRjaGVkIHRhYmxlXG4gICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgbmV3IF9BcGkoY3R4WzBdKSA6XG4gICAgICAgICAgICAgICAgdGFibGVzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3RhYmxlcygpLm5vZGVzKCknLCAndGFibGUoKS5ub2RlKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVGFibGU7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5ib2R5KCknLCAndGFibGUoKS5ib2R5KCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5uVEJvZHk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCd0YWJsZXMoKS5oZWFkZXIoKScsICd0YWJsZSgpLmhlYWRlcigpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgublRIZWFkO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgndGFibGVzKCkuZm9vdGVyKCknLCAndGFibGUoKS5mb290ZXIoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lm5URm9vdDtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3RhYmxlcygpLmNvbnRhaW5lcnMoKScsICd0YWJsZSgpLmNvbnRhaW5lcigpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgublRhYmxlV3JhcHBlcjtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZHJhdyB0aGUgdGFibGVzIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgICAgICAqL1xuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdkcmF3KCknLCBmdW5jdGlvbiAocGFnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFnaW5nID09PSAncGFnZScpIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuRHJhdyhzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhZ2luZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2luZyA9IHBhZ2luZyA9PT0gJ2Z1bGwtaG9sZCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2ZuUmVEcmF3KHNldHRpbmdzLCBwYWdpbmcgPT09IGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcGFnZSBpbmRleC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGluZGV4ICh6ZXJvIGJhc2VkKVxuICAgICAgICAgKi8vKipcbiAgICAgICAgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgICAgKlxuICAgICAgICAqIE5vdGUgdGhhdCBpZiB5b3UgYXR0ZW1wdCB0byBzaG93IGEgcGFnZSB3aGljaCBkb2VzIG5vdCBleGlzdCwgRGF0YVRhYmxlcyB3aWxsXG4gICAgICAgICogbm90IHRocm93IGFuIGVycm9yLCBidXQgcmF0aGVyIHJlc2V0IHRoZSBwYWdpbmcuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ8c3RyaW5nfSBhY3Rpb24gVGhlIHBhZ2luZyBhY3Rpb24gdG8gdGFrZS4gVGhpcyBjYW4gYmUgb25lIG9mOlxuICAgICAgICAqICAqIGBpbnRlZ2VyYCAtIFRoZSBwYWdlIGluZGV4IHRvIGp1bXAgdG9cbiAgICAgICAgKiAgKiBgc3RyaW5nYCAtIEFuIGFjdGlvbiB0byB0YWtlOlxuICAgICAgICAqICAgICogYGZpcnN0YCAtIEp1bXAgdG8gZmlyc3QgcGFnZS5cbiAgICAgICAgKiAgICAqIGBuZXh0YCAtIEp1bXAgdG8gdGhlIG5leHQgcGFnZVxuICAgICAgICAqICAgICogYHByZXZpb3VzYCAtIEp1bXAgdG8gcHJldmlvdXMgcGFnZVxuICAgICAgICAqICAgICogYGxhc3RgIC0gSnVtcCB0byB0aGUgbGFzdCBwYWdlLlxuICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICAgICAgICAqL1xuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdwYWdlKCknLCBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYWdlLmluZm8oKS5wYWdlOyAvLyBub3QgYW4gZXhwZW5zaXZlIGNhbGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZWxzZSwgaGF2ZSBhbiBhY3Rpb24gdG8gdGFrZSBvbiBhbGwgdGFibGVzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBfZm5QYWdlQ2hhbmdlKHNldHRpbmdzLCBhY3Rpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhZ2luZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0IHRhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHlvdSByZXF1aXJlIHBhZ2luZyBpbmZvcm1hdGlvbiBmb3IgYW5vdGhlciB0YWJsZSwgdXNlIHRoZSBgdGFibGUoKWAgbWV0aG9kXG4gICAgICAgICAqIHdpdGggYSBzdWl0YWJsZSBzZWxlY3Rvci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgc2V0OlxuICAgICAgICAgKiAgKiBgcGFnZWAgLSBDdXJyZW50IHBhZ2UgaW5kZXggKHplcm8gYmFzZWQgLSBpLmUuIHRoZSBmaXJzdCBwYWdlIGlzIGAwYClcbiAgICAgICAgICogICogYHBhZ2VzYCAtIFRvdGFsIG51bWJlciBvZiBwYWdlc1xuICAgICAgICAgKiAgKiBgc3RhcnRgIC0gRGlzcGxheSBpbmRleCBmb3IgdGhlIGZpcnN0IHJlY29yZCBzaG93biBvbiB0aGUgY3VycmVudCBwYWdlXG4gICAgICAgICAqICAqIGBlbmRgIC0gRGlzcGxheSBpbmRleCBmb3IgdGhlIGxhc3QgcmVjb3JkIHNob3duIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICogICogYGxlbmd0aGAgLSBEaXNwbGF5IGxlbmd0aCAobnVtYmVyIG9mIHJlY29yZHMpLiBOb3RlIHRoYXQgZ2VuZXJhbGx5IGBzdGFydFxuICAgICAgICAgKiAgICArIGxlbmd0aCA9IGVuZGAsIGJ1dCB0aGlzIGlzIG5vdCBhbHdheXMgdHJ1ZSwgZm9yIGV4YW1wbGUgaWYgdGhlcmUgYXJlXG4gICAgICAgICAqICAgIG9ubHkgMiByZWNvcmRzIHRvIHNob3cgb24gdGhlIGZpbmFsIHBhZ2UsIHdpdGggYSBsZW5ndGggb2YgMTAuXG4gICAgICAgICAqICAqIGByZWNvcmRzVG90YWxgIC0gRnVsbCBkYXRhIHNldCBsZW5ndGhcbiAgICAgICAgICogICogYHJlY29yZHNEaXNwbGF5YCAtIERhdGEgc2V0IGxlbmd0aCBvbmNlIHRoZSBjdXJyZW50IGZpbHRlcmluZyBjcml0ZXJpb25cbiAgICAgICAgICogICAgYXJlIGFwcGxpZWQuXG4gICAgICAgICAqL1xuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdwYWdlLmluZm8oKScsIGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSB0aGlzLmNvbnRleHRbMF0sXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBzZXR0aW5ncy5faURpc3BsYXlTdGFydCxcbiAgICAgICAgICAgICAgICBsZW4gPSBzZXR0aW5ncy5vRmVhdHVyZXMuYlBhZ2luYXRlID8gc2V0dGluZ3MuX2lEaXNwbGF5TGVuZ3RoIDogLTEsXG4gICAgICAgICAgICAgICAgdmlzUmVjb3JkcyA9IHNldHRpbmdzLmZuUmVjb3Jkc0Rpc3BsYXkoKSxcbiAgICAgICAgICAgICAgICBhbGwgPSBsZW4gPT09IC0xO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFwicGFnZVwiOiBhbGwgPyAwIDogTWF0aC5mbG9vcihzdGFydCAvIGxlbiksXG4gICAgICAgICAgICAgICAgXCJwYWdlc1wiOiBhbGwgPyAxIDogTWF0aC5jZWlsKHZpc1JlY29yZHMgLyBsZW4pLFxuICAgICAgICAgICAgICAgIFwic3RhcnRcIjogc3RhcnQsXG4gICAgICAgICAgICAgICAgXCJlbmRcIjogc2V0dGluZ3MuZm5EaXNwbGF5RW5kKCksXG4gICAgICAgICAgICAgICAgXCJsZW5ndGhcIjogbGVuLFxuICAgICAgICAgICAgICAgIFwicmVjb3Jkc1RvdGFsXCI6IHNldHRpbmdzLmZuUmVjb3Jkc1RvdGFsKCksXG4gICAgICAgICAgICAgICAgXCJyZWNvcmRzRGlzcGxheVwiOiB2aXNSZWNvcmRzLFxuICAgICAgICAgICAgICAgIFwic2VydmVyU2lkZVwiOiBfZm5EYXRhU291cmNlKHNldHRpbmdzKSA9PT0gJ3NzcCdcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgY3VycmVudCBwYWdlIGxlbmd0aC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7aW50ZWdlcn0gQ3VycmVudCBwYWdlIGxlbmd0aC4gTm90ZSBgLTFgIGluZGljYXRlcyB0aGF0IGFsbCByZWNvcmRzXG4gICAgICAgICAqICAgYXJlIHRvIGJlIHNob3duLlxuICAgICAgICAgKi8vKipcbiAgICAgICAgKiBTZXQgdGhlIGN1cnJlbnQgcGFnZSBsZW5ndGguXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFBhZ2UgbGVuZ3RoIHRvIHNldC4gVXNlIGAtMWAgdG8gc2hvdyBhbGwgcmVjb3Jkcy5cbiAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAgICAgICAgKi9cbiAgICAgICAgX2FwaV9yZWdpc3RlcigncGFnZS5sZW4oKScsIGZ1bmN0aW9uIChsZW4pIHtcbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjYWxsIHRoaXMgZnVuY3Rpb24gJ2xlbmd0aCgpJyBiZWNhdXNlIGBsZW5ndGhgXG4gICAgICAgICAgICAvLyBpcyBhIEphdmFzY3JpcHQgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHdoaWNoIGRlZmluZXMgaG93IG1hbnkgYXJndW1lbnRzXG4gICAgICAgICAgICAvLyB0aGUgZnVuY3Rpb24gZXhwZWN0cy5cbiAgICAgICAgICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwID9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0WzBdLl9pRGlzcGxheUxlbmd0aCA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZWxzZSwgc2V0IHRoZSBwYWdlIGxlbmd0aFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgX2ZuTGVuZ3RoQ2hhbmdlKHNldHRpbmdzLCBsZW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICB2YXIgX19yZWxvYWQgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGhvbGRQb3NpdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgZHJhdyBldmVudCB0byB0cmlnZ2VyIGEgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHZhciBhcGkgPSBuZXcgX0FwaShzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICBhcGkub25lKCdkcmF3JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhhcGkuYWpheC5qc29uKCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgPT0gJ3NzcCcpIHtcbiAgICAgICAgICAgICAgICBfZm5SZURyYXcoc2V0dGluZ3MsIGhvbGRQb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfZm5Qcm9jZXNzaW5nRGlzcGxheShzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgcmVxdWVzdFxuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBzZXR0aW5ncy5qcVhIUjtcbiAgICAgICAgICAgICAgICBpZiAoeGhyICYmIHhoci5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgeGhyXG4gICAgICAgICAgICAgICAgX2ZuQnVpbGRBamF4KHNldHRpbmdzLCBbXSwgZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgX2ZuQ2xlYXJUYWJsZShzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfZm5BamF4RGF0YVNyYyhzZXR0aW5ncywganNvbik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5BZGREYXRhKHNldHRpbmdzLCBkYXRhW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9mblJlRHJhdyhzZXR0aW5ncywgaG9sZFBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgX2ZuUHJvY2Vzc2luZ0Rpc3BsYXkoc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEpTT04gcmVzcG9uc2UgZnJvbSB0aGUgbGFzdCBBamF4IHJlcXVlc3QgdGhhdCBEYXRhVGFibGVzIG1hZGUgdG8gdGhlXG4gICAgICAgICAqIHNlcnZlci4gTm90ZSB0aGF0IHRoaXMgcmV0dXJucyB0aGUgSlNPTiBmcm9tIHRoZSBmaXJzdCB0YWJsZSBpbiB0aGUgY3VycmVudFxuICAgICAgICAgKiBjb250ZXh0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJuIHtvYmplY3R9IEpTT04gcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC5qc29uKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4WzBdLmpzb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGVsc2UgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBkYXRhIHN1Ym1pdHRlZCBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcbiAgICAgICAgICovXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2FqYXgucGFyYW1zKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAoY3R4Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4WzBdLm9BamF4RGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZWxzZSByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWxvYWQgdGFibGVzIGZyb20gdGhlIEFqYXggZGF0YSBzb3VyY2UuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIHdpbGxcbiAgICAgICAgICogYXV0b21hdGljYWxseSByZS1kcmF3IHRoZSB0YWJsZSB3aGVuIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Jlc2V0PXRydWVdIFJlc2V0IChkZWZhdWx0KSBvciBob2xkIHRoZSBjdXJyZW50IHBhZ2luZ1xuICAgICAgICAgKiAgIHBvc2l0aW9uLiBBIGZ1bGwgcmUtc29ydCBhbmQgcmUtZmlsdGVyIGlzIHBlcmZvcm1lZCB3aGVuIHRoaXMgbWV0aG9kIGlzXG4gICAgICAgICAqICAgY2FsbGVkLCB3aGljaCBpcyB3aHkgdGhlIHBhZ2luYXRpb24gcmVzZXQgaXMgdGhlIGRlZmF1bHQgYWN0aW9uLlxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2FqYXgucmVsb2FkKCknLCBmdW5jdGlvbiAoY2FsbGJhY2ssIHJlc2V0UGFnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBfX3JlbG9hZChzZXR0aW5ncywgcmVzZXRQYWdpbmcgPT09IGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIHRoZSBVUkwgZnJvbSB0aGUgZmlyc3RcbiAgICAgICAgICogdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBDdXJyZW50IEFqYXggc291cmNlIFVSTFxuICAgICAgICAgKi8vKipcbiAgICAgICAgKiBTZXQgdGhlIEFqYXggVVJMLiBOb3RlIHRoYXQgdGhpcyB3aWxsIHNldCB0aGUgVVJMIGZvciBhbGwgdGFibGVzIGluIHRoZVxuICAgICAgICAqIGN1cnJlbnQgY29udGV4dC5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHNldC5cbiAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAgICAgICAgKi9cbiAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC51cmwoKScsIGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmICh1cmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGdldFxuICAgICAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eCA9IGN0eFswXTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBjdHguYWpheCA/XG4gICAgICAgICAgICAgICAgICAgICQuaXNQbGFpbk9iamVjdChjdHguYWpheCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFqYXgudXJsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hamF4IDpcbiAgICAgICAgICAgICAgICAgICAgY3R4LnNBamF4U291cmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZXRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qoc2V0dGluZ3MuYWpheCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYWpheC51cmwgPSB1cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5hamF4ID0gdXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGNvbnNpZGVyIHNBamF4U291cmNlIGhlcmUgc2luY2UgRGF0YVRhYmxlcyBnaXZlcyBwcmlvcml0eVxuICAgICAgICAgICAgICAgIC8vIHRvIGBhamF4YCBvdmVyIGBzQWpheFNvdXJjZWAuIFNvIHNldHRpbmcgYGFqYXhgIGhlcmUsIHJlbmRlcnMgYW55XG4gICAgICAgICAgICAgICAgLy8gdmFsdWUgb2YgYHNBamF4U291cmNlYCByZWR1bmRhbnQuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogTG9hZCBkYXRhIGZyb20gdGhlIG5ld2x5IHNldCBBamF4IFVSTC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICAgICAgICogYXZhaWxhYmxlIHdoZW4gYGFqYXgudXJsKClgIGlzIHVzZWQgdG8gc2V0IGEgVVJMLiBBZGRpdGlvbmFsbHksIHRoaXMgbWV0aG9kXG4gICAgICAgICAqIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgY2FsbGluZyBgYWpheC5yZWxvYWQoKWAgYnV0IGlzIHByb3ZpZGVkIGZvclxuICAgICAgICAgKiBjb252ZW5pZW5jZSB3aGVuIHNldHRpbmcgYSBuZXcgVVJMLiBMaWtlIGBhamF4LnJlbG9hZCgpYCBpdCB3aWxsXG4gICAgICAgICAqIGF1dG9tYXRpY2FsbHkgcmVkcmF3IHRoZSB0YWJsZSBvbmNlIHRoZSByZW1vdGUgZGF0YSBoYXMgYmVlbiBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICAgICAgICAgKi9cbiAgICAgICAgX2FwaV9yZWdpc3RlcignYWpheC51cmwoKS5sb2FkKCknLCBmdW5jdGlvbiAoY2FsbGJhY2ssIHJlc2V0UGFnaW5nKSB7XG4gICAgICAgICAgICAvLyBTYW1lIGFzIGEgcmVsb2FkLCBidXQgbWFrZXMgc2Vuc2UgdG8gcHJlc2VudCBpdCBmb3IgZWFzeSBhY2Nlc3MgYWZ0ZXIgYVxuICAgICAgICAgICAgLy8gdXJsIGNoYW5nZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICAgIF9fcmVsb2FkKGN0eCwgcmVzZXRQYWdpbmcgPT09IGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuXG5cbiAgICAgICAgdmFyIF9zZWxlY3Rvcl9ydW4gPSBmdW5jdGlvbiAodHlwZSwgc2VsZWN0b3IsIHNlbGVjdEZuLCBzZXR0aW5ncywgb3B0cykge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgb3V0ID0gW10sIHJlcyxcbiAgICAgICAgICAgICAgICBhLCBpLCBpZW4sIGosIGplbixcbiAgICAgICAgICAgICAgICBzZWxlY3RvclR5cGUgPSB0eXBlb2Ygc2VsZWN0b3I7XG5cbiAgICAgICAgICAgIC8vIENhbid0IGp1c3QgY2hlY2sgZm9yIGlzQXJyYXkgaGVyZSwgYXMgYW4gQVBJIG9yIGpRdWVyeSBpbnN0YW5jZSBtaWdodCBiZVxuICAgICAgICAgICAgLy8gZ2l2ZW4gd2l0aCB0aGVpciBhcnJheSBsaWtlIGxvb2tcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgc2VsZWN0b3JUeXBlID09PSAnc3RyaW5nJyB8fCBzZWxlY3RvclR5cGUgPT09ICdmdW5jdGlvbicgfHwgc2VsZWN0b3IubGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9IFtzZWxlY3Rvcl07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHNlbGVjdG9yLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBzcGxpdCBvbiBzaW1wbGUgc3RyaW5ncyAtIGNvbXBsZXggZXhwcmVzc2lvbnMgd2lsbCBiZSBqUXVlcnkgc2VsZWN0b3JzXG4gICAgICAgICAgICAgICAgYSA9IHNlbGVjdG9yW2ldICYmIHNlbGVjdG9yW2ldLnNwbGl0ICYmICFzZWxlY3RvcltpXS5tYXRjaCgvW1xcW1xcKDpdLykgP1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcltpXS5zcGxpdCgnLCcpIDpcbiAgICAgICAgICAgICAgICAgICAgW3NlbGVjdG9yW2ldXTtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGEubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gc2VsZWN0Rm4odHlwZW9mIGFbal0gPT09ICdzdHJpbmcnID8gKGFbal0pLnRyaW0oKSA6IGFbal0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0ID0gb3V0LmNvbmNhdChyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzZWxlY3RvciBleHRlbnNpb25zXG4gICAgICAgICAgICB2YXIgZXh0ID0gX2V4dC5zZWxlY3Rvclt0eXBlXTtcbiAgICAgICAgICAgIGlmIChleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZXh0Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dCA9IGV4dFtpXShzZXR0aW5ncywgb3B0cywgb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfdW5pcXVlKG91dCk7XG4gICAgICAgIH07XG5cblxuICAgICAgICB2YXIgX3NlbGVjdG9yX29wdHMgPSBmdW5jdGlvbiAob3B0cykge1xuICAgICAgICAgICAgaWYgKCFvcHRzKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgMS45LSB3aGljaCB1c2VkIHRoZSB0ZXJtaW5vbG9neSBmaWx0ZXIgcmF0aGVyXG4gICAgICAgICAgICAvLyB0aGFuIHNlYXJjaFxuICAgICAgICAgICAgaWYgKG9wdHMuZmlsdGVyICYmIG9wdHMuc2VhcmNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBvcHRzLnNlYXJjaCA9IG9wdHMuZmlsdGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gJC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIHNlYXJjaDogJ25vbmUnLFxuICAgICAgICAgICAgICAgIG9yZGVyOiAnY3VycmVudCcsXG4gICAgICAgICAgICAgICAgcGFnZTogJ2FsbCdcbiAgICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIF9zZWxlY3Rvcl9maXJzdCA9IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgICAgICAvLyBSZWR1Y2UgdGhlIEFQSSBpbnN0YW5jZSB0byB0aGUgZmlyc3QgaXRlbSBmb3VuZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGluc3QubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdFtpXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbiB0aGUgZmlyc3QgZWxlbWVudCB0byB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHRydW5jYXRlIHRoZSBpbnN0YW5jZSBhbmQgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICBpbnN0WzBdID0gaW5zdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaW5zdFswXS5sZW5ndGggPSAxO1xuICAgICAgICAgICAgICAgICAgICBpbnN0Lmxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGluc3QuY29udGV4dCA9IFtpbnN0LmNvbnRleHRbaV1dO1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm90IGZvdW5kIC0gcmV0dXJuIGFuIGVtcHR5IGluc3RhbmNlXG4gICAgICAgICAgICBpbnN0Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfc2VsZWN0b3Jfcm93X2luZGV4ZXMgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGksIGllbiwgdG1wLCBhID0gW10sXG4gICAgICAgICAgICAgICAgZGlzcGxheUZpbHRlcmVkID0gc2V0dGluZ3MuYWlEaXNwbGF5LFxuICAgICAgICAgICAgICAgIGRpc3BsYXlNYXN0ZXIgPSBzZXR0aW5ncy5haURpc3BsYXlNYXN0ZXI7XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHNlYXJjaCA9IG9wdHMuc2VhcmNoLCAgLy8gbm9uZSwgYXBwbGllZCwgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIG9yZGVyID0gb3B0cy5vcmRlciwgICAvLyBhcHBsaWVkLCBjdXJyZW50LCBpbmRleCAob3JpZ2luYWwgLSBjb21wYXRpYmlsaXR5IHdpdGggMS45KVxuICAgICAgICAgICAgICAgIHBhZ2UgPSBvcHRzLnBhZ2U7ICAgIC8vIGFsbCwgY3VycmVudFxuXG4gICAgICAgICAgICBpZiAoX2ZuRGF0YVNvdXJjZShzZXR0aW5ncykgPT0gJ3NzcCcpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIG1vZGUsIG1vc3Qgb3B0aW9ucyBhcmUgaXJyZWxldmFudCBzaW5jZVxuICAgICAgICAgICAgICAgIC8vIHJvd3Mgbm90IHNob3duIGRvbid0IGV4aXN0IGFuZCB0aGUgaW5kZXggb3JkZXIgaXMgdGhlIGFwcGxpZWQgb3JkZXJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVkIGlzIGEgc3BlY2lhbCBjYXNlIC0gZm9yIGNvbnNpc3RlbmN5IGp1c3QgcmV0dXJuIGFuIGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gYXJyYXlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VhcmNoID09PSAncmVtb3ZlZCcgP1xuICAgICAgICAgICAgICAgICAgICBbXSA6XG4gICAgICAgICAgICAgICAgICAgIF9yYW5nZSgwLCBkaXNwbGF5TWFzdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYWdlID09ICdjdXJyZW50Jykge1xuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgcGFnZSBpbXBsaWVzIHRoYXQgb3JkZXI9Y3VycmVudCBhbmQgZml0bGVyPWFwcGxpZWQsIHNpbmNlIGl0IGlzXG4gICAgICAgICAgICAgICAgLy8gZmFpcmx5IHNlbnNlbGVzcyBvdGhlcndpc2UsIHJlZ2FyZGxlc3Mgb2Ygd2hhdCBvcmRlciBhbmQgc2VhcmNoIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgLy8gYXJlXG4gICAgICAgICAgICAgICAgZm9yIChpID0gc2V0dGluZ3MuX2lEaXNwbGF5U3RhcnQsIGllbiA9IHNldHRpbmdzLmZuRGlzcGxheUVuZCgpOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYS5wdXNoKGRpc3BsYXlGaWx0ZXJlZFtpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3JkZXIgPT0gJ2N1cnJlbnQnIHx8IG9yZGVyID09ICdhcHBsaWVkJykge1xuICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGEgPSBkaXNwbGF5TWFzdGVyLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlYXJjaCA9PSAnYXBwbGllZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYSA9IGRpc3BsYXlGaWx0ZXJlZC5zbGljZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZWFyY2ggPT0gJ3JlbW92ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE8obittKSBzb2x1dGlvbiBieSBjcmVhdGluZyBhIGhhc2ggbWFwXG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXNwbGF5RmlsdGVyZWRNYXAgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWVuID0gZGlzcGxheUZpbHRlcmVkLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5RmlsdGVyZWRNYXBbZGlzcGxheUZpbHRlcmVkW2ldXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBhID0gJC5tYXAoZGlzcGxheU1hc3RlciwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWRpc3BsYXlGaWx0ZXJlZE1hcC5oYXNPd25Qcm9wZXJ0eShlbCkgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcmRlciA9PSAnaW5kZXgnIHx8IG9yZGVyID09ICdvcmlnaW5hbCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaCA9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gYXBwbGllZCB8IHJlbW92ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9ICQuaW5BcnJheShpLCBkaXNwbGF5RmlsdGVyZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHRtcCA9PT0gLTEgJiYgc2VhcmNoID09ICdyZW1vdmVkJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodG1wID49IDAgJiYgc2VhcmNoID09ICdhcHBsaWVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gICAgICAgICAqIFJvd3NcbiAgICAgICAgICpcbiAgICAgICAgICoge30gICAgICAgICAgLSBubyBzZWxlY3RvciAtIHVzZSBhbGwgYXZhaWxhYmxlIHJvd3NcbiAgICAgICAgICoge2ludGVnZXJ9ICAgLSByb3cgYW9EYXRhIGluZGV4XG4gICAgICAgICAqIHtub2RlfSAgICAgIC0gVFIgbm9kZVxuICAgICAgICAgKiB7c3RyaW5nfSAgICAtIGpRdWVyeSBzZWxlY3RvciB0byBhcHBseSB0byB0aGUgVFIgZWxlbWVudHNcbiAgICAgICAgICoge2FycmF5fSAgICAgLSBqUXVlcnkgYXJyYXkgb2Ygbm9kZXMsIG9yIHNpbXBseSBhbiBhcnJheSBvZiBUUiBub2Rlc1xuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIF9fcm93X3NlbGVjdG9yID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cykge1xuICAgICAgICAgICAgdmFyIHJvd3M7XG4gICAgICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHNlbCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxJbnQgPSBfaW50VmFsKHNlbCk7XG4gICAgICAgICAgICAgICAgdmFyIGksIGllbjtcbiAgICAgICAgICAgICAgICB2YXIgYW9EYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvcnQgY3V0IC0gc2VsZWN0b3IgaXMgYSBudW1iZXIgYW5kIG5vIG9wdGlvbnMgcHJvdmlkZWQgKGRlZmF1bHQgaXNcbiAgICAgICAgICAgICAgICAvLyBhbGwgcmVjb3Jkcywgc28gbm8gbmVlZCB0byBjaGVjayBpZiB0aGUgaW5kZXggaXMgaW4gdGhlcmUsIHNpbmNlIGl0XG4gICAgICAgICAgICAgICAgLy8gbXVzdCBiZSAtIGRldiBlcnJvciBpZiB0aGUgaW5kZXggZG9lc24ndCBleGlzdCkuXG4gICAgICAgICAgICAgICAgaWYgKHNlbEludCAhPT0gbnVsbCAmJiAhb3B0cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlbEludF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFyb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MgPSBfc2VsZWN0b3Jfcm93X2luZGV4ZXMoc2V0dGluZ3MsIG9wdHMpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZWxJbnQgIT09IG51bGwgJiYgJC5pbkFycmF5KHNlbEludCwgcm93cykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW50ZWdlclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3NlbEludF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbCA9PT0gbnVsbCB8fCBzZWwgPT09IHVuZGVmaW5lZCB8fCBzZWwgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gbm9uZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm93cztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKHJvd3MsIGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBhb0RhdGFbaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWwoaWR4LCByb3cuX2FEYXRhLCByb3cublRyKSA/IGlkeCA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gbm9kZVxuICAgICAgICAgICAgICAgIGlmIChzZWwubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvd0lkeCA9IHNlbC5fRFRfUm93SW5kZXg7ICAvLyBQcm9wZXJ0eSBhZGRlZCBieSBEVCBmb3IgZmFzdCBsb29rdXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNlbGxJZHggPSBzZWwuX0RUX0NlbGxJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocm93SWR4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSByb3cgaXMgYWN0dWFsbHkgc3RpbGwgcHJlc2VudCBpbiB0aGUgdGFibGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhb0RhdGFbcm93SWR4XSAmJiBhb0RhdGFbcm93SWR4XS5uVHIgPT09IHNlbCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3Jvd0lkeF0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNlbGxJZHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhb0RhdGFbY2VsbElkeC5yb3ddICYmIGFvRGF0YVtjZWxsSWR4LnJvd10ublRyID09PSBzZWwucGFyZW50Tm9kZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NlbGxJZHgucm93XSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdCA9ICQoc2VsKS5jbG9zZXN0KCcqW2RhdGEtZHQtcm93XScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhvc3QubGVuZ3RoID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaG9zdC5kYXRhKCdkdC1yb3cnKV0gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSUQgc2VsZWN0b3IuIFdhbnQgdG8gYWx3YXlzIGJlIGFibGUgdG8gc2VsZWN0IHJvd3MgYnkgaWQsIHJlZ2FyZGxlc3NcbiAgICAgICAgICAgICAgICAvLyBvZiBpZiB0aGUgdHIgZWxlbWVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIG5vdCwgc28gY2FuJ3QgcmVseSB1cG9uXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IGhlcmUgLSBoZW5jZSBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi4gVGhpcyBkb2VzIG5vdCBtYXRjaFxuICAgICAgICAgICAgICAgIC8vIFNpenpsZSdzIGZhc3Qgc2VsZWN0b3Igb3IgSFRNTDQgLSBpbiBIVE1MNSB0aGUgSUQgY2FuIGJlIGFueXRoaW5nLFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB0byBzZWxlY3QgaXQgdXNpbmcgYSBDU1Mgc2VsZWN0b3IgZW5naW5lIChsaWtlIFNpenpsZSBvclxuICAgICAgICAgICAgICAgIC8vIHF1ZXJ5U2VsZWN0KSBpdCB3b3VsZCBuZWVkIHRvIG5lZWQgdG8gYmUgZXNjYXBlZCBmb3Igc29tZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIC8vIERhdGFUYWJsZXMgc2ltcGxpZmllcyB0aGlzIGZvciByb3cgc2VsZWN0b3JzIHNpbmNlIHlvdSBjYW4gc2VsZWN0XG4gICAgICAgICAgICAgICAgLy8gb25seSBhIHJvdy4gQSAjIGluZGljYXRlcyBhbiBpZCBhbnkgYW55dGhpbmcgdGhhdCBmb2xsb3dzIGlzIHRoZSBpZCAtXG4gICAgICAgICAgICAgICAgLy8gdW5lc2NhcGVkLlxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2VsID09PSAnc3RyaW5nJyAmJiBzZWwuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHJvdyBpbmRleCBmcm9tIGlkXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3dPYmogPSBzZXR0aW5ncy5hSWRzW3NlbC5yZXBsYWNlKC9eIy8sICcnKV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3dPYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtyb3dPYmouaWR4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gZmFsbCB0aHJvdWdoIHRvIGpRdWVyeSBpbiBjYXNlIHRoZXJlIGlzIERPTSBpZCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hdGNoZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgbm9kZXMgaW4gdGhlIG9yZGVyIGZyb20gdGhlIGByb3dzYCBhcnJheSB3aXRoIG51bGwgdmFsdWVzIHJlbW92ZWRcbiAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBfcmVtb3ZlRW1wdHkoXG4gICAgICAgICAgICAgICAgICAgIF9wbHVja19vcmRlcihzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICduVHInKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciAtIGpRdWVyeSBzZWxlY3RvciBzdHJpbmcsIGFycmF5IG9mIG5vZGVzIG9yIGpRdWVyeSBvYmplY3QvXG4gICAgICAgICAgICAgICAgLy8gQXMgalF1ZXJ5J3MgLmZpbHRlcigpIGFsbG93cyBqUXVlcnkgb2JqZWN0cyB0byBiZSBwYXNzZWQgaW4gZmlsdGVyLFxuICAgICAgICAgICAgICAgIC8vIGl0IGFsc28gYWxsb3dzIGFycmF5cywgc28gdGhpcyB3aWxsIGNvcGUgd2l0aCBhbGwgdGhyZWUgb3B0aW9uc1xuICAgICAgICAgICAgICAgIHJldHVybiAkKG5vZGVzKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHNlbClcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fRFRfUm93SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX3J1bigncm93Jywgc2VsZWN0b3IsIHJ1biwgc2V0dGluZ3MsIG9wdHMpO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93cygpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XG4gICAgICAgICAgICAvLyBhcmd1bWVudCBzaGlmdGluZ1xuICAgICAgICAgICAgaWYgKHNlbGVjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJC5pc1BsYWluT2JqZWN0KHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgICAgIG9wdHMgPSBzZWxlY3RvcjtcbiAgICAgICAgICAgICAgICBzZWxlY3RvciA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcHRzID0gX3NlbGVjdG9yX29wdHMob3B0cyk7XG5cbiAgICAgICAgICAgIHZhciBpbnN0ID0gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19yb3dfc2VsZWN0b3Ioc2V0dGluZ3MsIHNlbGVjdG9yLCBvcHRzKTtcbiAgICAgICAgICAgIH0sIDEpO1xuXG4gICAgICAgICAgICAvLyBXYW50IGFyZ3VtZW50IHNoaWZ0aW5nIGhlcmUgYW5kIGluIF9fcm93X3NlbGVjdG9yP1xuICAgICAgICAgICAgaW5zdC5zZWxlY3Rvci5yb3dzID0gc2VsZWN0b3I7XG4gICAgICAgICAgICBpbnN0LnNlbGVjdG9yLm9wdHMgPSBvcHRzO1xuXG4gICAgICAgICAgICByZXR1cm4gaW5zdDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FwaV9yZWdpc3Rlcigncm93cygpLm5vZGVzKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9EYXRhW3Jvd10ublRyIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdyb3dzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IodHJ1ZSwgJ3Jvd3MnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvd3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BsdWNrX29yZGVyKHNldHRpbmdzLmFvRGF0YSwgcm93cywgJ19hRGF0YScpO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3Jvd3MoKS5jYWNoZSgpJywgJ3JvdygpLmNhY2hlKCknLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3JvdycsIGZ1bmN0aW9uIChzZXR0aW5ncywgcm93KSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzZXR0aW5ncy5hb0RhdGFbcm93XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ3NlYXJjaCcgPyByLl9hRmlsdGVyRGF0YSA6IHIuX2FTb3J0RGF0YTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuaW52YWxpZGF0ZSgpJywgJ3JvdygpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdykge1xuICAgICAgICAgICAgICAgIF9mbkludmFsaWRhdGUoc2V0dGluZ3MsIHJvdywgc3JjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdyb3dzKCkuaW5kZXhlcygpJywgJ3JvdygpLmluZGV4KCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigncm93JywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcm93O1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ3Jvd3MoKS5pZHMoKScsICdyb3coKS5pZCgpJywgZnVuY3Rpb24gKGhhc2gpIHtcbiAgICAgICAgICAgIHZhciBhID0gW107XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgICAgICAgLy8gYGl0ZXJhdG9yYCB3aWxsIGRyb3AgdW5kZWZpbmVkIHZhbHVlcywgYnV0IGluIHRoaXMgY2FzZSB3ZSB3YW50IHRoZW1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBjb250ZXh0Lmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGplbiA9IHRoaXNbaV0ubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gY29udGV4dFtpXS5yb3dJZEZuKGNvbnRleHRbaV0uYW9EYXRhW3RoaXNbaV1bal1dLl9hRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGEucHVzaCgoaGFzaCA9PT0gdHJ1ZSA/ICcjJyA6ICcnKSArIGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgX0FwaShjb250ZXh0LCBhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgncm93cygpLnJlbW92ZSgpJywgJ3JvdygpLnJlbW92ZSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yKCdyb3cnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgdGhhdElkeCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuICAgICAgICAgICAgICAgIHZhciByb3dEYXRhID0gZGF0YVtyb3ddO1xuICAgICAgICAgICAgICAgIHZhciBpLCBpZW4sIGosIGplbjtcbiAgICAgICAgICAgICAgICB2YXIgbG9vcFJvdywgbG9vcENlbGxzO1xuXG4gICAgICAgICAgICAgICAgZGF0YS5zcGxpY2Uocm93LCAxKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2FjaGVkIGluZGV4ZXNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvb3BSb3cgPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgICAgICBsb29wQ2VsbHMgPSBsb29wUm93LmFuQ2VsbHM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUm93c1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcFJvdy5uVHIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb3BSb3cublRyLl9EVF9Sb3dJbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDZWxsc1xuICAgICAgICAgICAgICAgICAgICBpZiAobG9vcENlbGxzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwLCBqZW4gPSBsb29wQ2VsbHMubGVuZ3RoOyBqIDwgamVuOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb29wQ2VsbHNbal0uX0RUX0NlbGxJbmRleC5yb3cgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRGVsZXRlIGZyb20gdGhlIGRpc3BsYXkgYXJyYXlzXG4gICAgICAgICAgICAgICAgX2ZuRGVsZXRlSW5kZXgoc2V0dGluZ3MuYWlEaXNwbGF5TWFzdGVyLCByb3cpO1xuICAgICAgICAgICAgICAgIF9mbkRlbGV0ZUluZGV4KHNldHRpbmdzLmFpRGlzcGxheSwgcm93KTtcbiAgICAgICAgICAgICAgICBfZm5EZWxldGVJbmRleCh0aGF0W3RoYXRJZHhdLCByb3csIGZhbHNlKTsgLy8gbWFpbnRhaW4gbG9jYWwgaW5kZXhlc1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGFibGVzIC0gc3VidHJhY3QgdGhlIGRlbGV0ZWQgcm93IGZyb20gdGhlIGNvdW50XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLl9pUmVjb3Jkc0Rpc3BsYXktLTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBmb3IgYW4gJ292ZXJmbG93JyB0aGV5IGNhc2UgZm9yIGRpc3BsYXlpbmcgdGhlIHRhYmxlXG4gICAgICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3coc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSByb3cncyBJRCByZWZlcmVuY2UgaWYgdGhlcmUgaXMgb25lXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2V0dGluZ3Mucm93SWRGbihyb3dEYXRhLl9hRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNldHRpbmdzLmFJZHNbaWRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBpZW4gPSBzZXR0aW5ncy5hb0RhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuYW9EYXRhW2ldLmlkeCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvd3MuYWRkKCknLCBmdW5jdGlvbiAocm93cykge1xuICAgICAgICAgICAgdmFyIG5ld1Jvd3MgPSB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHZhciByb3csIGksIGllbjtcbiAgICAgICAgICAgICAgICB2YXIgb3V0ID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSByb3dzLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvd3NbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goX2ZuQWRkVHIoc2V0dGluZ3MsIHJvdylbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goX2ZuQWRkRGF0YShzZXR0aW5ncywgcm93KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCBzbyByb3dzKCkubm9kZXMoKSBldGMgY2FuIGJlIHVzZWRcbiAgICAgICAgICAgIHZhciBtb2RSb3dzID0gdGhpcy5yb3dzKC0xKTtcbiAgICAgICAgICAgIG1vZFJvd3MucG9wKCk7XG4gICAgICAgICAgICAkLm1lcmdlKG1vZFJvd3MsIG5ld1Jvd3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gbW9kUm93cztcbiAgICAgICAgfSk7XG5cblxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3JvdygpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KHRoaXMucm93cyhzZWxlY3Rvciwgb3B0cykpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3JvdygpLmRhdGEoKScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggJiYgdGhpcy5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLl9hRGF0YSA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU2V0XG4gICAgICAgICAgICB2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVt0aGlzWzBdXTtcbiAgICAgICAgICAgIHJvdy5fYURhdGEgPSBkYXRhO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgRE9NIGhhcyBhbiBpZCwgYW5kIHRoZSBkYXRhIHNvdXJjZSBpcyBhbiBhcnJheVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgJiYgcm93Lm5UciAmJiByb3cublRyLmlkKSB7XG4gICAgICAgICAgICAgICAgX2ZuU2V0T2JqZWN0RGF0YUZuKGN0eFswXS5yb3dJZCkoZGF0YSwgcm93Lm5Uci5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEF1dG9tYXRpY2FsbHkgaW52YWxpZGF0ZVxuICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShjdHhbMF0sIHRoaXNbMF0sICdkYXRhJyk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3JvdygpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoID9cbiAgICAgICAgICAgICAgICBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLm5UciB8fCBudWxsIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3Jvdy5hZGQoKScsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IGEgalF1ZXJ5IG9iamVjdCB0byBiZSBwYXNzZWQgaW4gLSBvbmx5IGEgc2luZ2xlIHJvdyBpcyBhZGRlZCBmcm9tXG4gICAgICAgICAgICAvLyBpdCB0aG91Z2ggLSB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2V0XG4gICAgICAgICAgICBpZiAocm93IGluc3RhbmNlb2YgJCAmJiByb3cubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gcm93WzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcm93cyA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJvdy5ub2RlTmFtZSAmJiByb3cubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZuQWRkVHIoc2V0dGluZ3MsIHJvdylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfZm5BZGREYXRhKHNldHRpbmdzLCByb3cpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybiBhbiBBcGkucm93cygpIGV4dGVuZGVkIGluc3RhbmNlLCB3aXRoIHRoZSBuZXdseSBhZGRlZCByb3cgc2VsZWN0ZWRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvdyhyb3dzWzBdKTtcbiAgICAgICAgfSk7XG5cblxuXG4gICAgICAgIHZhciBfX2RldGFpbHNfYWRkID0gZnVuY3Rpb24gKGN0eCwgcm93LCBkYXRhLCBrbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0byBhcnJheSBvZiBUUiBlbGVtZW50c1xuICAgICAgICAgICAgdmFyIHJvd3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBhZGRSb3cgPSBmdW5jdGlvbiAociwgaykge1xuICAgICAgICAgICAgICAgIC8vIFJlY3Vyc2lvbiB0byBhbGxvdyBmb3IgYXJyYXlzIG9mIGpRdWVyeSBvYmplY3RzXG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgciBpbnN0YW5jZW9mICQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IHIubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFJvdyhyW2ldLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGEgVFIgZWxlbWVudCwgdGhlbiBqdXN0IGFkZCBpdCBkaXJlY3RseSAtIHVwIHRvIHRoZSBkZXZcbiAgICAgICAgICAgICAgICAvLyB0byBhZGQgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIGNvbHVtbnMgZXRjXG4gICAgICAgICAgICAgICAgaWYgKHIubm9kZU5hbWUgJiYgci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndHInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd3MucHVzaChyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSBjcmVhdGUgYSByb3cgd2l0aCBhIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNyZWF0ZWQgPSAkKCc8dHI+PHRkPjwvdGQ+PC90cj4nKS5hZGRDbGFzcyhrKTtcbiAgICAgICAgICAgICAgICAgICAgJCgndGQnLCBjcmVhdGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGspXG4gICAgICAgICAgICAgICAgICAgICAgICAuaHRtbChyKVxuICAgICAgICAgICAgICAgICAgICBbMF0uY29sU3BhbiA9IF9mblZpc2JsZUNvbHVtbnMoY3R4KTtcblxuICAgICAgICAgICAgICAgICAgICByb3dzLnB1c2goY3JlYXRlZFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYWRkUm93KGRhdGEsIGtsYXNzKTtcblxuICAgICAgICAgICAgaWYgKHJvdy5fZGV0YWlscykge1xuICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlscy5kZXRhY2goKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcm93Ll9kZXRhaWxzID0gJChyb3dzKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGNoaWxkcmVuIHdlcmUgYWxyZWFkeSBzaG93biwgdGhhdCBzdGF0ZSBzaG91bGQgYmUgcmV0YWluZWRcbiAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHNTaG93KSB7XG4gICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIF9fZGV0YWlsc19yZW1vdmUgPSBmdW5jdGlvbiAoYXBpLCBpZHgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBhcGkuY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gY3R4WzBdLmFvRGF0YVtpZHggIT09IHVuZGVmaW5lZCA/IGlkeCA6IGFwaVswXV07XG5cbiAgICAgICAgICAgICAgICBpZiAocm93ICYmIHJvdy5fZGV0YWlscykge1xuICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzU2hvdyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfX2RldGFpbHNfZGlzcGxheSA9IGZ1bmN0aW9uIChhcGksIHNob3cpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSBhcGkuY29udGV4dDtcblxuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggJiYgYXBpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBjdHhbMF0uYW9EYXRhW2FwaVswXV07XG5cbiAgICAgICAgICAgICAgICBpZiAocm93Ll9kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5fZGV0YWlsc1Nob3cgPSBzaG93O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMuaW5zZXJ0QWZ0ZXIocm93Lm5Ucik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfX2RldGFpbHNfZXZlbnRzKGN0eFswXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIF9fZGV0YWlsc19ldmVudHMgPSBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgIHZhciBhcGkgPSBuZXcgX0FwaShzZXR0aW5ncyk7XG4gICAgICAgICAgICB2YXIgbmFtZXNwYWNlID0gJy5kdC5EVF9kZXRhaWxzJztcbiAgICAgICAgICAgIHZhciBkcmF3RXZlbnQgPSAnZHJhdycgKyBuYW1lc3BhY2U7XG4gICAgICAgICAgICB2YXIgY29sdmlzRXZlbnQgPSAnY29sdW1uLXZpc2liaWxpdHknICsgbmFtZXNwYWNlO1xuICAgICAgICAgICAgdmFyIGRlc3Ryb3lFdmVudCA9ICdkZXN0cm95JyArIG5hbWVzcGFjZTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhO1xuXG4gICAgICAgICAgICBhcGkub2ZmKGRyYXdFdmVudCArICcgJyArIGNvbHZpc0V2ZW50ICsgJyAnICsgZGVzdHJveUV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKF9wbHVjayhkYXRhLCAnX2RldGFpbHMnKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gT24gZWFjaCBkcmF3LCBpbnNlcnQgdGhlIHJlcXVpcmVkIGVsZW1lbnRzIGludG8gdGhlIGRvY3VtZW50XG4gICAgICAgICAgICAgICAgYXBpLm9uKGRyYXdFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYXBpLnJvd3MoeyBwYWdlOiAnY3VycmVudCcgfSkuZXEoMCkuZWFjaChmdW5jdGlvbiAoaWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcm5hbCBkYXRhIGdyYWJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBkYXRhW2lkeF07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHNTaG93KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93Ll9kZXRhaWxzLmluc2VydEFmdGVyKHJvdy5uVHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vIENvbHVtbiB2aXNpYmlsaXR5IGNoYW5nZSAtIHVwZGF0ZSB0aGUgY29sc3BhblxuICAgICAgICAgICAgICAgIGFwaS5vbihjb2x2aXNFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCwgaWR4LCB2aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY29sc3BhbiBmb3IgdGhlIGRldGFpbHMgcm93cyAobm90ZSwgb25seSBpZiBpdCBhbHJlYWR5IGhhc1xuICAgICAgICAgICAgICAgICAgICAvLyBhIGNvbHNwYW4pXG4gICAgICAgICAgICAgICAgICAgIHZhciByb3csIHZpc2libGUgPSBfZm5WaXNibGVDb2x1bW5zKGN0eCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IGRhdGFbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3cuX2RldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cuX2RldGFpbHMuY2hpbGRyZW4oJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIHZpc2libGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUYWJsZSBkZXN0cm95ZWQgLSBudWtlIGFueSBjaGlsZCByb3dzXG4gICAgICAgICAgICAgICAgYXBpLm9uKGRlc3Ryb3lFdmVudCwgZnVuY3Rpb24gKGUsIGN0eCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGllbiA9IGRhdGEubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhW2ldLl9kZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX19kZXRhaWxzX3JlbW92ZShhcGksIGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gU3RyaW5ncyBmb3IgdGhlIG1ldGhvZCBuYW1lcyB0byBoZWxwIG1pbmlmaWNhdGlvblxuICAgICAgICB2YXIgX2VtcCA9ICcnO1xuICAgICAgICB2YXIgX2NoaWxkX29iaiA9IF9lbXAgKyAncm93KCkuY2hpbGQnO1xuICAgICAgICB2YXIgX2NoaWxkX210aCA9IF9jaGlsZF9vYmogKyAnKCknO1xuXG4gICAgICAgIC8vIGRhdGEgY2FuIGJlOlxuICAgICAgICAvLyAgdHJcbiAgICAgICAgLy8gIHN0cmluZ1xuICAgICAgICAvLyAgalF1ZXJ5IG9yIGFycmF5IG9mIGFueSBvZiB0aGUgYWJvdmVcbiAgICAgICAgX2FwaV9yZWdpc3RlcihfY2hpbGRfbXRoLCBmdW5jdGlvbiAoZGF0YSwga2xhc3MpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXRcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIGN0eFswXS5hb0RhdGFbdGhpc1swXV0uX2RldGFpbHMgOlxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvd1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGQuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyByZW1vdmVcbiAgICAgICAgICAgICAgICBfX2RldGFpbHNfcmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3R4Lmxlbmd0aCAmJiB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHNldFxuICAgICAgICAgICAgICAgIF9fZGV0YWlsc19hZGQoY3R4WzBdLCBjdHhbMF0uYW9EYXRhW3RoaXNbMF1dLCBkYXRhLCBrbGFzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xuICAgICAgICAgICAgX2NoaWxkX29iaiArICcuc2hvdygpJyxcbiAgICAgICAgICAgIF9jaGlsZF9tdGggKyAnLnNob3coKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuICAgICAgICBdLCBmdW5jdGlvbiAoc2hvdykgeyAgIC8vIGl0IHJldHVybnMgYW4gb2JqZWN0IGFuZCB0aGlzIG1ldGhvZCBpcyBub3QgZXhlY3V0ZWQpXG4gICAgICAgICAgICBfX2RldGFpbHNfZGlzcGxheSh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xuICAgICAgICAgICAgX2NoaWxkX29iaiArICcuaGlkZSgpJyxcbiAgICAgICAgICAgIF9jaGlsZF9tdGggKyAnLmhpZGUoKScgLy8gb25seSB3aGVuIGBjaGlsZCgpYCB3YXMgY2FsbGVkIHdpdGggcGFyYW1ldGVycyAod2l0aG91dFxuICAgICAgICBdLCBmdW5jdGlvbiAoKSB7ICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcbiAgICAgICAgICAgIF9fZGV0YWlsc19kaXNwbGF5KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xuICAgICAgICAgICAgX2NoaWxkX29iaiArICcucmVtb3ZlKCknLFxuICAgICAgICAgICAgX2NoaWxkX210aCArICcucmVtb3ZlKCknIC8vIG9ubHkgd2hlbiBgY2hpbGQoKWAgd2FzIGNhbGxlZCB3aXRoIHBhcmFtZXRlcnMgKHdpdGhvdXRcbiAgICAgICAgXSwgZnVuY3Rpb24gKCkgeyAgICAgICAgICAgLy8gaXQgcmV0dXJucyBhbiBvYmplY3QgYW5kIHRoaXMgbWV0aG9kIGlzIG5vdCBleGVjdXRlZClcbiAgICAgICAgICAgIF9fZGV0YWlsc19yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKF9jaGlsZF9vYmogKyAnLmlzU2hvd24oKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoICYmIHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gX2RldGFpbHNTaG93biBhcyBmYWxzZSBvciB1bmRlZmluZWQgd2lsbCBmYWxsIHRocm91Z2ggdG8gcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eFswXS5hb0RhdGFbdGhpc1swXV0uX2RldGFpbHNTaG93IHx8IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgLyogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqICogKiAqXG4gICAgICAgICAqIENvbHVtbnNcbiAgICAgICAgICpcbiAgICAgICAgICoge2ludGVnZXJ9ICAgICAgICAgICAtIGNvbHVtbiBpbmRleCAoPj0wIGNvdW50IGZyb20gbGVmdCwgPDAgY291bnQgZnJvbSByaWdodClcbiAgICAgICAgICogXCJ7aW50ZWdlcn06dmlzSWR4XCIgIC0gdmlzaWJsZSBjb2x1bW4gaW5kZXggKGkuZS4gdHJhbnNsYXRlIHRvIGNvbHVtbiBpbmRleCkgICg+PTAgY291bnQgZnJvbSBsZWZ0LCA8MCBjb3VudCBmcm9tIHJpZ2h0KVxuICAgICAgICAgKiBcIntpbnRlZ2VyfTp2aXNpYmxlXCIgLSBhbGlhcyBmb3Ige2ludGVnZXJ9OnZpc0lkeCAgKD49MCBjb3VudCBmcm9tIGxlZnQsIDwwIGNvdW50IGZyb20gcmlnaHQpXG4gICAgICAgICAqIFwie3N0cmluZ306bmFtZVwiICAgICAtIGNvbHVtbiBuYW1lXG4gICAgICAgICAqIFwie3N0cmluZ31cIiAgICAgICAgICAtIGpRdWVyeSBzZWxlY3RvciBvbiBjb2x1bW4gaGVhZGVyIG5vZGVzXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIGNhbiBiZSBhbiBhcnJheSBvZiB0aGVzZSBpdGVtcywgY29tbWEgc2VwYXJhdGVkIGxpc3QsIG9yIGFuIGFycmF5IG9mIGNvbW1hXG4gICAgICAgIC8vIHNlcGFyYXRlZCBsaXN0c1xuXG4gICAgICAgIHZhciBfX3JlX2NvbHVtbl9zZWxlY3RvciA9IC9eKFteOl0rKToobmFtZXx2aXNJZHh8dmlzaWJsZSkkLztcblxuXG4gICAgICAgIC8vIHIxIGFuZCByMiBhcmUgcmVkdW5kYW50IC0gYnV0IGl0IG1lYW5zIHRoYXQgdGhlIHBhcmFtZXRlcnMgbWF0Y2ggZm9yIHRoZVxuICAgICAgICAvLyBpdGVyYXRvciBjYWxsYmFjayBpbiBjb2x1bW5zKCkuZGF0YSgpXG4gICAgICAgIHZhciBfX2NvbHVtbkRhdGEgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbiwgcjEsIHIyLCByb3dzKSB7XG4gICAgICAgICAgICB2YXIgYSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgcm93ID0gMCwgaWVuID0gcm93cy5sZW5ndGg7IHJvdyA8IGllbjsgcm93KyspIHtcbiAgICAgICAgICAgICAgICBhLnB1c2goX2ZuR2V0Q2VsbERhdGEoc2V0dGluZ3MsIHJvd3Nbcm93XSwgY29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfX2NvbHVtbl9zZWxlY3RvciA9IGZ1bmN0aW9uIChzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGNvbHVtbnMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG4gICAgICAgICAgICAgICAgbmFtZXMgPSBfcGx1Y2soY29sdW1ucywgJ3NOYW1lJyksXG4gICAgICAgICAgICAgICAgbm9kZXMgPSBfcGx1Y2soY29sdW1ucywgJ25UaCcpO1xuXG4gICAgICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsSW50ID0gX2ludFZhbChzKTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gYWxsXG4gICAgICAgICAgICAgICAgaWYgKHMgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmFuZ2UoY29sdW1ucy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW5kZXhcbiAgICAgICAgICAgICAgICBpZiAoc2VsSW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc2VsSW50ID49IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsSW50IDogLy8gQ291bnQgZnJvbSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5zLmxlbmd0aCArIHNlbEludCAvLyBDb3VudCBmcm9tIHJpZ2h0ICgrIGJlY2F1c2UgaXRzIGEgbmVnYXRpdmUgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgPSBmdW5jdGlvblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyhzZXR0aW5ncywgb3B0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICQubWFwKGNvbHVtbnMsIGZ1bmN0aW9uIChjb2wsIGlkeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWR4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9fY29sdW1uRGF0YShzZXR0aW5ncywgaWR4LCAwLCAwLCByb3dzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1tpZHhdXG4gICAgICAgICAgICAgICAgICAgICAgICApID8gaWR4IDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8galF1ZXJ5IG9yIHN0cmluZyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHR5cGVvZiBzID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgICAgIHMubWF0Y2goX19yZV9jb2x1bW5fc2VsZWN0b3IpIDpcbiAgICAgICAgICAgICAgICAgICAgJyc7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlzSWR4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Zpc2libGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZpc2libGUgaW5kZXggZ2l2ZW4sIGNvbnZlcnQgdG8gY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnRpbmcgZnJvbSB0aGUgcmlnaHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZpc0NvbHVtbnMgPSAkLm1hcChjb2x1bW5zLCBmdW5jdGlvbiAoY29sLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sLmJWaXNpYmxlID8gaSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Zpc0NvbHVtbnNbdmlzQ29sdW1ucy5sZW5ndGggKyBpZHhdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ291bnRpbmcgZnJvbSB0aGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgoc2V0dGluZ3MsIGlkeCldO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICduYW1lJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaCBieSBuYW1lLiBgbmFtZXNgIGlzIGNvbHVtbiBpbmRleCBjb21wbGV0ZSBhbmQgaW4gb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5tYXAobmFtZXMsIGZ1bmN0aW9uIChuYW1lLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBtYXRjaFsxXSA/IGkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENlbGwgaW4gdGhlIHRhYmxlIGJvZHlcbiAgICAgICAgICAgICAgICBpZiAocy5ub2RlTmFtZSAmJiBzLl9EVF9DZWxsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzLl9EVF9DZWxsSW5kZXguY29sdW1uXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBqUXVlcnkgc2VsZWN0b3Igb24gdGhlIFRIIGVsZW1lbnRzIGZvciB0aGUgY29sdW1uc1xuICAgICAgICAgICAgICAgIHZhciBqcVJlc3VsdCA9ICQobm9kZXMpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIocylcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJC5pbkFycmF5KHRoaXMsIG5vZGVzKTsgLy8gYG5vZGVzYCBpcyBjb2x1bW4gaW5kZXggY29tcGxldGUgYW5kIGluIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50b0FycmF5KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoanFSZXN1bHQubGVuZ3RoIHx8ICFzLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBqcVJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYSBub2RlIHdoaWNoIG1pZ2h0IGhhdmUgYSBgZHQtY29sdW1uYCBkYXRhIGF0dHJpYnV0ZSwgb3IgYmVcbiAgICAgICAgICAgICAgICAvLyBhIGNoaWxkIG9yIHN1Y2ggYW4gZWxlbWVudFxuICAgICAgICAgICAgICAgIHZhciBob3N0ID0gJChzKS5jbG9zZXN0KCcqW2RhdGEtZHQtY29sdW1uXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBob3N0Lmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIFtob3N0LmRhdGEoJ2R0LWNvbHVtbicpXSA6XG4gICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIF9zZWxlY3Rvcl9ydW4oJ2NvbHVtbicsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzKTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIHZhciBfX3NldENvbHVtblZpcyA9IGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCB2aXMpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGNvbHMgPSBzZXR0aW5ncy5hb0NvbHVtbnMsXG4gICAgICAgICAgICAgICAgY29sID0gY29sc1tjb2x1bW5dLFxuICAgICAgICAgICAgICAgIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGEsXG4gICAgICAgICAgICAgICAgcm93LCBjZWxscywgaSwgaWVuLCB0cjtcblxuICAgICAgICAgICAgLy8gR2V0XG4gICAgICAgICAgICBpZiAodmlzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sLmJWaXNpYmxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTZXRcbiAgICAgICAgICAgIC8vIE5vIGNoYW5nZVxuICAgICAgICAgICAgaWYgKGNvbC5iVmlzaWJsZSA9PT0gdmlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmlzKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IGNvbHVtblxuICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gZGVjaWRlIGlmIHdlIHNob3VsZCB1c2UgYXBwZW5kQ2hpbGQgb3IgaW5zZXJ0QmVmb3JlXG4gICAgICAgICAgICAgICAgdmFyIGluc2VydEJlZm9yZSA9ICQuaW5BcnJheSh0cnVlLCBfcGx1Y2soY29scywgJ2JWaXNpYmxlJyksIGNvbHVtbiArIDEpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gZGF0YS5sZW5ndGg7IGkgPCBpZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0ciA9IGRhdGFbaV0ublRyO1xuICAgICAgICAgICAgICAgICAgICBjZWxscyA9IGRhdGFbaV0uYW5DZWxscztcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2VydEJlZm9yZSBjYW4gYWN0IGxpa2UgYXBwZW5kQ2hpbGQgaWYgMm5kIGFyZyBpcyBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5pbnNlcnRCZWZvcmUoY2VsbHNbY29sdW1uXSwgY2VsbHNbaW5zZXJ0QmVmb3JlXSB8fCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBjb2x1bW5cbiAgICAgICAgICAgICAgICAkKF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdhbkNlbGxzJywgY29sdW1uKSkuZGV0YWNoKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbW1vbiBhY3Rpb25zXG4gICAgICAgICAgICBjb2wuYlZpc2libGUgPSB2aXM7XG4gICAgICAgIH07XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW5zKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcbiAgICAgICAgICAgIC8vIGFyZ3VtZW50IHNoaWZ0aW5nXG4gICAgICAgICAgICBpZiAoc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3Qoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wdHMgPSBfc2VsZWN0b3Jfb3B0cyhvcHRzKTtcblxuICAgICAgICAgICAgdmFyIGluc3QgPSB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBfX2NvbHVtbl9zZWxlY3RvcihzZXR0aW5ncywgc2VsZWN0b3IsIG9wdHMpO1xuICAgICAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgICAgIC8vIFdhbnQgYXJndW1lbnQgc2hpZnRpbmcgaGVyZSBhbmQgaW4gX3Jvd19zZWxlY3Rvcj9cbiAgICAgICAgICAgIGluc3Quc2VsZWN0b3IuY29scyA9IHNlbGVjdG9yO1xuICAgICAgICAgICAgaW5zdC5zZWxlY3Rvci5vcHRzID0gb3B0cztcblxuICAgICAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXJQbHVyYWwoJ2NvbHVtbnMoKS5oZWFkZXIoKScsICdjb2x1bW4oKS5oZWFkZXIoKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLmFvQ29sdW1uc1tjb2x1bW5dLm5UaDtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuZm9vdGVyKCknLCAnY29sdW1uKCkuZm9vdGVyKCknLCBmdW5jdGlvbiAoc2VsZWN0b3IsIG9wdHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5uVGY7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmRhdGEoKScsICdjb2x1bW4oKS5kYXRhKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcignY29sdW1uLXJvd3MnLCBfX2NvbHVtbkRhdGEsIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuZGF0YVNyYygpJywgJ2NvbHVtbigpLmRhdGFTcmMoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5hb0NvbHVtbnNbY29sdW1uXS5tRGF0YTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkuY2FjaGUoKScsICdjb2x1bW4oKS5jYWNoZSgpJywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4tcm93cycsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wbHVja19vcmRlcihzZXR0aW5ncy5hb0RhdGEsIHJvd3MsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YScsIGNvbHVtblxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLm5vZGVzKCknLCAnY29sdW1uKCkubm9kZXMoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4tcm93cycsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uLCBpLCBqLCByb3dzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wbHVja19vcmRlcihzZXR0aW5ncy5hb0RhdGEsIHJvd3MsICdhbkNlbGxzJywgY29sdW1uKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjb2x1bW5zKCkudmlzaWJsZSgpJywgJ2NvbHVtbigpLnZpc2libGUoKScsIGZ1bmN0aW9uICh2aXMsIGNhbGMpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciByZXQgPSB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIGlmICh2aXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MuYW9Db2x1bW5zW2NvbHVtbl0uYlZpc2libGU7XG4gICAgICAgICAgICAgICAgfSAvLyBlbHNlXG4gICAgICAgICAgICAgICAgX19zZXRDb2x1bW5WaXMoc2V0dGluZ3MsIGNvbHVtbiwgdmlzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBHcm91cCB0aGUgY29sdW1uIHZpc2liaWxpdHkgY2hhbmdlc1xuICAgICAgICAgICAgaWYgKHZpcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVkcmF3IHRoZSBoZWFkZXIgYWZ0ZXIgY2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICBfZm5EcmF3SGVhZChzZXR0aW5ncywgc2V0dGluZ3MuYW9IZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICBfZm5EcmF3SGVhZChzZXR0aW5ncywgc2V0dGluZ3MuYW9Gb290ZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb2xzcGFuIGZvciBubyByZWNvcmRzIGRpc3BsYXkuIENoaWxkIHJvd3MgYW5kIGV4dGVuc2lvbnMgd2lsbCB1c2UgdGhlaXIgb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIGxpc3RlbmVycyB0byBkbyB0aGlzIC0gb25seSBuZWVkIHRvIHVwZGF0ZSB0aGUgZW1wdHkgdGFibGUgaXRlbSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3MuYWlEaXNwbGF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJChzZXR0aW5ncy5uVEJvZHkpLmZpbmQoJ3RkW2NvbHNwYW5dJykuYXR0cignY29sc3BhbicsIF9mblZpc2JsZUNvbHVtbnMoc2V0dGluZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9mblNhdmVTdGF0ZShzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2Vjb25kIGxvb3Agb25jZSB0aGUgZmlyc3QgaXMgZG9uZSBmb3IgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuaXRlcmF0b3IoJ2NvbHVtbicsIGZ1bmN0aW9uIChzZXR0aW5ncywgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZm5DYWxsYmFja0ZpcmUoc2V0dGluZ3MsIG51bGwsICdjb2x1bW4tdmlzaWJpbGl0eScsIFtzZXR0aW5ncywgY29sdW1uLCB2aXMsIGNhbGNdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGMgPT09IHVuZGVmaW5lZCB8fCBjYWxjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmNvbHVtbnMuYWRqdXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY29sdW1ucygpLmluZGV4ZXMoKScsICdjb2x1bW4oKS5pbmRleCgpJywgZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlID09PSAndmlzaWJsZScgP1xuICAgICAgICAgICAgICAgICAgICBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZShzZXR0aW5ncywgY29sdW1uKSA6XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW5zLmFkanVzdCgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjb2x1bW4uaW5kZXgoKScsIGZ1bmN0aW9uICh0eXBlLCBpZHgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dFswXTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnJvbVZpc2libGUnIHx8IHR5cGUgPT09ICd0b0RhdGEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleChjdHgsIGlkeCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmcm9tRGF0YScgfHwgdHlwZSA9PT0gJ3RvVmlzaWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mbkNvbHVtbkluZGV4VG9WaXNpYmxlKGN0eCwgaWR4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NvbHVtbigpJywgZnVuY3Rpb24gKHNlbGVjdG9yLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KHRoaXMuY29sdW1ucyhzZWxlY3Rvciwgb3B0cykpO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgX19jZWxsX3NlbGVjdG9yID0gZnVuY3Rpb24gKHNldHRpbmdzLCBzZWxlY3Rvciwgb3B0cykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBzZXR0aW5ncy5hb0RhdGE7XG4gICAgICAgICAgICB2YXIgcm93cyA9IF9zZWxlY3Rvcl9yb3dfaW5kZXhlcyhzZXR0aW5ncywgb3B0cyk7XG4gICAgICAgICAgICB2YXIgY2VsbHMgPSBfcmVtb3ZlRW1wdHkoX3BsdWNrX29yZGVyKGRhdGEsIHJvd3MsICdhbkNlbGxzJykpO1xuICAgICAgICAgICAgdmFyIGFsbENlbGxzID0gJChfZmxhdHRlbihbXSwgY2VsbHMpKTtcbiAgICAgICAgICAgIHZhciByb3c7XG4gICAgICAgICAgICB2YXIgY29sdW1ucyA9IHNldHRpbmdzLmFvQ29sdW1ucy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYSwgaSwgaWVuLCBqLCBvLCBob3N0O1xuXG4gICAgICAgICAgICB2YXIgcnVuID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm5TZWxlY3RvciA9IHR5cGVvZiBzID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICAgICAgICAgICAgaWYgKHMgPT09IG51bGwgfHwgcyA9PT0gdW5kZWZpbmVkIHx8IGZuU2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGNlbGxzIGFuZCBmdW5jdGlvbiBzZWxlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgYSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGllbiA9IHJvd3MubGVuZ3RoOyBpIDwgaWVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdyA9IHJvd3NbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmblNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9zdCA9IGRhdGFbcm93XTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocyhvLCBfZm5HZXRDZWxsRGF0YShzZXR0aW5ncywgcm93LCBqKSwgaG9zdC5hbkNlbGxzID8gaG9zdC5hbkNlbGxzW2pdIDogbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEucHVzaChvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0b3IgLSBhbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0gaW5kZXhcbiAgICAgICAgICAgICAgICBpZiAoJC5pc1BsYWluT2JqZWN0KHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkIGNlbGwgaW5kZXggYW5kIGl0cyBpbiB0aGUgYXJyYXkgb2Ygc2VsZWN0YWJsZSByb3dzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLmNvbHVtbiAhPT0gdW5kZWZpbmVkICYmIHMucm93ICE9PSB1bmRlZmluZWQgJiYgJC5pbkFycmF5KHMucm93LCByb3dzKSAhPT0gLTEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgW3NdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNlbGVjdG9yIC0galF1ZXJ5IGZpbHRlcmVkIGNlbGxzXG4gICAgICAgICAgICAgICAgdmFyIGpxUmVzdWx0ID0gYWxsQ2VsbHNcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpLCBlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgLy8gdXNlIGEgbmV3IG9iamVjdCwgaW4gY2FzZSBzb21lb25lIGNoYW5nZXMgdGhlIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogZWwuX0RUX0NlbGxJbmRleC5yb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlbC5fRFRfQ2VsbEluZGV4LmNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRvQXJyYXkoKTtcblxuICAgICAgICAgICAgICAgIGlmIChqcVJlc3VsdC5sZW5ndGggfHwgIXMubm9kZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpxUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgc2VsZWN0b3IgaXMgYSBub2RlLCBhbmQgdGhlcmUgaXMgb25lIGxhc3Qgb3B0aW9uIC0gdGhlXG4gICAgICAgICAgICAgICAgLy8gZWxlbWVudCBtaWdodCBiZSBhIGNoaWxkIG9mIGFuIGVsZW1lbnQgd2hpY2ggaGFzIGR0LXJvdyBhbmQgZHQtY29sdW1uXG4gICAgICAgICAgICAgICAgLy8gZGF0YSBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgaG9zdCA9ICQocykuY2xvc2VzdCgnKltkYXRhLWR0LXJvd10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaG9zdC5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93OiBob3N0LmRhdGEoJ2R0LXJvdycpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBob3N0LmRhdGEoJ2R0LWNvbHVtbicpXG4gICAgICAgICAgICAgICAgICAgIH1dIDpcbiAgICAgICAgICAgICAgICAgICAgW107XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX3J1bignY2VsbCcsIHNlbGVjdG9yLCBydW4sIHNldHRpbmdzLCBvcHRzKTtcbiAgICAgICAgfTtcblxuXG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxscygpJywgZnVuY3Rpb24gKHJvd1NlbGVjdG9yLCBjb2x1bW5TZWxlY3Rvciwgb3B0cykge1xuICAgICAgICAgICAgLy8gQXJndW1lbnQgc2hpZnRpbmdcbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3Qocm93U2VsZWN0b3IpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW5kZXhlc1xuICAgICAgICAgICAgICAgIGlmIChyb3dTZWxlY3Rvci5yb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZWxlY3RvciBvcHRpb25zIGluIGZpcnN0IHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICBvcHRzID0gcm93U2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHJvd1NlbGVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENlbGwgaW5kZXggb2JqZWN0cyBpbiBmaXJzdCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgb3B0cyA9IGNvbHVtblNlbGVjdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5TZWxlY3RvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChjb2x1bW5TZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBvcHRzID0gY29sdW1uU2VsZWN0b3I7XG4gICAgICAgICAgICAgICAgY29sdW1uU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDZWxsIHNlbGVjdG9yXG4gICAgICAgICAgICBpZiAoY29sdW1uU2VsZWN0b3IgPT09IG51bGwgfHwgY29sdW1uU2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19jZWxsX3NlbGVjdG9yKHNldHRpbmdzLCByb3dTZWxlY3RvciwgX3NlbGVjdG9yX29wdHMob3B0cykpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBidWlsdCBpbiBvcHRpb25zIG5lZWQgdG8gYXBwbHkgdG8gcm93IGFuZCBjb2x1bW5zXG4gICAgICAgICAgICB2YXIgaW50ZXJuYWxPcHRzID0gb3B0cyA/IHtcbiAgICAgICAgICAgICAgICBwYWdlOiBvcHRzLnBhZ2UsXG4gICAgICAgICAgICAgICAgb3JkZXI6IG9wdHMub3JkZXIsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiBvcHRzLnNlYXJjaFxuICAgICAgICAgICAgfSA6IHt9O1xuXG4gICAgICAgICAgICAvLyBSb3cgKyBjb2x1bW4gc2VsZWN0b3JcbiAgICAgICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb2x1bW5zKGNvbHVtblNlbGVjdG9yLCBpbnRlcm5hbE9wdHMpO1xuICAgICAgICAgICAgdmFyIHJvd3MgPSB0aGlzLnJvd3Mocm93U2VsZWN0b3IsIGludGVybmFsT3B0cyk7XG4gICAgICAgICAgICB2YXIgaSwgaWVuLCBqLCBqZW47XG5cbiAgICAgICAgICAgIHZhciBjZWxsc05vT3B0cyA9IHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzLCBpZHgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMCwgaWVuID0gcm93c1tpZHhdLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGplbiA9IGNvbHVtbnNbaWR4XS5sZW5ndGg7IGogPCBqZW47IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJvd3NbaWR4XVtpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbnNbaWR4XVtqXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH0sIDEpO1xuXG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBjdXJyZW50bHkgb25seSBvbmUgZXh0ZW5zaW9uIHdoaWNoIHVzZXMgYSBjZWxsIHNlbGVjdG9yIGV4dGVuc2lvblxuICAgICAgICAgICAgLy8gSXQgaXMgYSBfbWFqb3JfIHBlcmZvcm1hbmNlIGRyYWcgdG8gcnVuIHRoaXMgaWYgaXQgaXNuJ3QgbmVlZGVkLCBzbyB0aGlzIGlzXG4gICAgICAgICAgICAvLyBhbiBleHRlbnNpb24gc3BlY2lmaWMgY2hlY2sgYXQgdGhlIG1vbWVudFxuICAgICAgICAgICAgdmFyIGNlbGxzID0gb3B0cyAmJiBvcHRzLnNlbGVjdGVkID9cbiAgICAgICAgICAgICAgICB0aGlzLmNlbGxzKGNlbGxzTm9PcHRzLCBvcHRzKSA6XG4gICAgICAgICAgICAgICAgY2VsbHNOb09wdHM7XG5cbiAgICAgICAgICAgICQuZXh0ZW5kKGNlbGxzLnNlbGVjdG9yLCB7XG4gICAgICAgICAgICAgICAgY29sczogY29sdW1uU2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgcm93czogcm93U2VsZWN0b3IsXG4gICAgICAgICAgICAgICAgb3B0czogb3B0c1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBjZWxscztcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLm5vZGVzKCknLCAnY2VsbCgpLm5vZGUoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2V0dGluZ3MuYW9EYXRhW3Jvd107XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YSAmJiBkYXRhLmFuQ2VsbHMgP1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmFuQ2VsbHNbY29sdW1uXSA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NlbGxzKCkuZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGNvbHVtbik7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmNhY2hlKCknLCAnY2VsbCgpLmNhY2hlKCknLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUgPT09ICdzZWFyY2gnID8gJ19hRmlsdGVyRGF0YScgOiAnX2FTb3J0RGF0YSc7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy5hb0RhdGFbcm93XVt0eXBlXVtjb2x1bW5dO1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY2VsbHMoKS5yZW5kZXIoKScsICdjZWxsKCkucmVuZGVyKCknLCBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ2NlbGwnLCBmdW5jdGlvbiAoc2V0dGluZ3MsIHJvdywgY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mbkdldENlbGxEYXRhKHNldHRpbmdzLCByb3csIGNvbHVtbiwgdHlwZSk7XG4gICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKCdjZWxscygpLmluZGV4ZXMoKScsICdjZWxsKCkuaW5kZXgoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICBjb2x1bW46IGNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUoc2V0dGluZ3MsIGNvbHVtbilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSwgMSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3RlclBsdXJhbCgnY2VsbHMoKS5pbnZhbGlkYXRlKCknLCAnY2VsbCgpLmludmFsaWRhdGUoKScsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjZWxsJywgZnVuY3Rpb24gKHNldHRpbmdzLCByb3csIGNvbHVtbikge1xuICAgICAgICAgICAgICAgIF9mbkludmFsaWRhdGUoc2V0dGluZ3MsIHJvdywgc3JjLCBjb2x1bW4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdjZWxsKCknLCBmdW5jdGlvbiAocm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gX3NlbGVjdG9yX2ZpcnN0KHRoaXMuY2VsbHMocm93U2VsZWN0b3IsIGNvbHVtblNlbGVjdG9yLCBvcHRzKSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3RlcignY2VsbCgpLmRhdGEoKScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIGNlbGwgPSB0aGlzWzBdO1xuXG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggJiYgY2VsbC5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICBfZm5HZXRDZWxsRGF0YShjdHhbMF0sIGNlbGxbMF0ucm93LCBjZWxsWzBdLmNvbHVtbikgOlxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNldFxuICAgICAgICAgICAgX2ZuU2V0Q2VsbERhdGEoY3R4WzBdLCBjZWxsWzBdLnJvdywgY2VsbFswXS5jb2x1bW4sIGRhdGEpO1xuICAgICAgICAgICAgX2ZuSW52YWxpZGF0ZShjdHhbMF0sIGNlbGxbMF0ucm93LCAnZGF0YScsIGNlbGxbMF0uY29sdW1uKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGN1cnJlbnQgb3JkZXJpbmcgKHNvcnRpbmcpIHRoYXQgaGFzIGJlZW4gYXBwbGllZCB0byB0aGUgdGFibGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHthcnJheX0gMkQgYXJyYXkgY29udGFpbmluZyB0aGUgc29ydGluZyBpbmZvcm1hdGlvbiBmb3IgdGhlIGZpcnN0XG4gICAgICAgICAqICAgdGFibGUgaW4gdGhlIGN1cnJlbnQgY29udGV4dC4gRWFjaCBlbGVtZW50IGluIHRoZSBwYXJlbnQgYXJyYXkgcmVwcmVzZW50c1xuICAgICAgICAgKiAgIGEgY29sdW1uIGJlaW5nIHNvcnRlZCB1cG9uIChpLmUuIG11bHRpLXNvcnRpbmcgd2l0aCB0d28gY29sdW1ucyB3b3VsZCBoYXZlXG4gICAgICAgICAqICAgMiBpbm5lciBhcnJheXMpLiBUaGUgaW5uZXIgYXJyYXlzIG1heSBoYXZlIDIgb3IgMyBlbGVtZW50cy4gVGhlIGZpcnN0IGlzXG4gICAgICAgICAqICAgdGhlIGNvbHVtbiBpbmRleCB0aGF0IHRoZSBzb3J0aW5nIGNvbmRpdGlvbiBhcHBsaWVzIHRvLCB0aGUgc2Vjb25kIGlzIHRoZVxuICAgICAgICAgKiAgIGRpcmVjdGlvbiBvZiB0aGUgc29ydCAoYGRlc2NgIG9yIGBhc2NgKSBhbmQsIG9wdGlvbmFsbHksIHRoZSB0aGlyZCBpcyB0aGVcbiAgICAgICAgICogICBpbmRleCBvZiB0aGUgc29ydGluZyBvcmRlciBmcm9tIHRoZSBgY29sdW1uLnNvcnRpbmdgIGluaXRpYWxpc2F0aW9uIGFycmF5LlxuICAgICAgICAgKi8vKipcbiAgICAgICAgKiBTZXQgdGhlIG9yZGVyaW5nIGZvciB0aGUgdGFibGUuXG4gICAgICAgICpcbiAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IG9yZGVyIENvbHVtbiBpbmRleCB0byBzb3J0IHVwb24uXG4gICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdGlvbiBEaXJlY3Rpb24gb2YgdGhlIHNvcnQgdG8gYmUgYXBwbGllZCAoYGFzY2Agb3IgYGRlc2NgKVxuICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICAgICAgICAqLy8qKlxuICAgICAgICAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDFEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBbLi4uXSBPcHRpb25hbCBhZGRpdGlvbmFsIHNvcnRpbmcgY29uZGl0aW9uc1xuICAgICAgICAqIEByZXR1cm5zIHtEYXRhVGFibGVzLkFwaX0gdGhpc1xuICAgICAgICAqLy8qKlxuICAgICAgICAqIFNldCB0aGUgb3JkZXJpbmcgZm9yIHRoZSB0YWJsZS5cbiAgICAgICAgKlxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IG9yZGVyIDJEIGFycmF5IG9mIHNvcnRpbmcgaW5mb3JtYXRpb24gdG8gYmUgYXBwbGllZC5cbiAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAgICAgICAgKi9cbiAgICAgICAgX2FwaV9yZWdpc3Rlcignb3JkZXIoKScsIGZ1bmN0aW9uIChvcmRlciwgZGlyKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAob3JkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIGdldFxuICAgICAgICAgICAgICAgIHJldHVybiBjdHgubGVuZ3RoICE9PSAwID9cbiAgICAgICAgICAgICAgICAgICAgY3R4WzBdLmFhU29ydGluZyA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBjb2x1bW4gLyBkaXJlY3Rpb24gcGFzc2VkIGluXG4gICAgICAgICAgICAgICAgb3JkZXIgPSBbW29yZGVyLCBkaXJdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG9yZGVyLmxlbmd0aCAmJiAhQXJyYXkuaXNBcnJheShvcmRlclswXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBBcmd1bWVudHMgcGFzc2VkIGluIChsaXN0IG9mIDFEIGFycmF5cylcbiAgICAgICAgICAgICAgICBvcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYSAyRCBhcnJheSB3YXMgcGFzc2VkIGluXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZyA9IG9yZGVyLnNsaWNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byBhbiBlbGVtZW50IGZvciBhIGdpdmVuIGNvbHVtblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge25vZGV8alF1ZXJ5fHN0cmluZ30gbm9kZSBJZGVudGlmaWVyIGZvciB0aGUgZWxlbWVudChzKSB0byBhdHRhY2ggdGhlXG4gICAgICAgICAqICAgbGlzdGVuZXIgdG8uIFRoaXMgY2FuIHRha2UgdGhlIGZvcm0gb2YgYSBzaW5nbGUgRE9NIG5vZGUsIGEgalF1ZXJ5XG4gICAgICAgICAqICAgY29sbGVjdGlvbiBvZiBub2RlcyBvciBhIGpRdWVyeSBzZWxlY3RvciB3aGljaCB3aWxsIGlkZW50aWZ5IHRoZSBub2RlKHMpLlxuICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IGNvbHVtbiB0aGUgY29sdW1uIHRoYXQgYSBjbGljayBvbiB0aGlzIG5vZGUgd2lsbCBzb3J0IG9uXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja10gY2FsbGJhY2sgZnVuY3Rpb24gd2hlbiBzb3J0IGlzIHJ1blxuICAgICAgICAgKiBAcmV0dXJucyB7RGF0YVRhYmxlcy5BcGl9IHRoaXNcbiAgICAgICAgICovXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ29yZGVyLmxpc3RlbmVyKCknLCBmdW5jdGlvbiAobm9kZSwgY29sdW1uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgX2ZuU29ydEF0dGFjaExpc3RlbmVyKHNldHRpbmdzLCBub2RlLCBjb2x1bW4sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ29yZGVyLmZpeGVkKCknLCBmdW5jdGlvbiAoc2V0KSB7XG4gICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdmFyIGZpeGVkID0gY3R4Lmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgICAgIGN0eFswXS5hYVNvcnRpbmdGaXhlZCA6XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGZpeGVkKSA/XG4gICAgICAgICAgICAgICAgICAgIHsgcHJlOiBmaXhlZCB9IDpcbiAgICAgICAgICAgICAgICAgICAgZml4ZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFhU29ydGluZ0ZpeGVkID0gJC5leHRlbmQodHJ1ZSwge30sIHNldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBPcmRlciBieSB0aGUgc2VsZWN0ZWQgY29sdW1uKHMpXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoW1xuICAgICAgICAgICAgJ2NvbHVtbnMoKS5vcmRlcigpJyxcbiAgICAgICAgICAgICdjb2x1bW4oKS5vcmRlcigpJ1xuICAgICAgICBdLCBmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncywgaSkge1xuICAgICAgICAgICAgICAgIHZhciBzb3J0ID0gW107XG5cbiAgICAgICAgICAgICAgICAkLmVhY2godGhhdFtpXSwgZnVuY3Rpb24gKGosIGNvbCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0LnB1c2goW2NvbCwgZGlyXSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5hYVNvcnRpbmcgPSBzb3J0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzZWFyY2goKScsIGZ1bmN0aW9uIChpbnB1dCwgcmVnZXgsIHNtYXJ0LCBjYXNlSW5zZW4pIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5sZW5ndGggIT09IDAgP1xuICAgICAgICAgICAgICAgICAgICBjdHhbMF0ub1ByZXZpb3VzU2VhcmNoLnNTZWFyY2ggOlxuICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5vRmVhdHVyZXMuYkZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGUoc2V0dGluZ3MsICQuZXh0ZW5kKHt9LCBzZXR0aW5ncy5vUHJldmlvdXNTZWFyY2gsIHtcbiAgICAgICAgICAgICAgICAgICAgXCJzU2VhcmNoXCI6IGlucHV0ICsgXCJcIixcbiAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICBcImJTbWFydFwiOiBzbWFydCA9PT0gbnVsbCA/IHRydWUgOiBzbWFydCxcbiAgICAgICAgICAgICAgICAgICAgXCJiQ2FzZUluc2Vuc2l0aXZlXCI6IGNhc2VJbnNlbiA9PT0gbnVsbCA/IHRydWUgOiBjYXNlSW5zZW5cbiAgICAgICAgICAgICAgICB9KSwgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyUGx1cmFsKFxuICAgICAgICAgICAgJ2NvbHVtbnMoKS5zZWFyY2goKScsXG4gICAgICAgICAgICAnY29sdW1uKCkuc2VhcmNoKCknLFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlucHV0LCByZWdleCwgc21hcnQsIGNhc2VJbnNlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCdjb2x1bW4nLCBmdW5jdGlvbiAoc2V0dGluZ3MsIGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlU2VhcmNoID0gc2V0dGluZ3MuYW9QcmVTZWFyY2hDb2xzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVTZWFyY2hbY29sdW1uXS5zU2VhcmNoO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3Mub0ZlYXR1cmVzLmJGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICQuZXh0ZW5kKHByZVNlYXJjaFtjb2x1bW5dLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcInNTZWFyY2hcIjogaW5wdXQgKyBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiUmVnZXhcIjogcmVnZXggPT09IG51bGwgPyBmYWxzZSA6IHJlZ2V4LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiU21hcnRcIjogc21hcnQgPT09IG51bGwgPyB0cnVlIDogc21hcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJDYXNlSW5zZW5zaXRpdmVcIjogY2FzZUluc2VuID09PSBudWxsID8gdHJ1ZSA6IGNhc2VJbnNlblxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBfZm5GaWx0ZXJDb21wbGV0ZShzZXR0aW5ncywgc2V0dGluZ3Mub1ByZXZpb3VzU2VhcmNoLCAxKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBTdGF0ZSBBUEkgbWV0aG9kc1xuICAgICAgICAgKi9cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5sZW5ndGggP1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dFswXS5vU2F2ZWRTdGF0ZSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZS5jbGVhcigpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBhbiBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5mblN0YXRlU2F2ZUNhbGxiYWNrLmNhbGwoc2V0dGluZ3Mub0luc3RhbmNlLCBzZXR0aW5ncywge30pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3Rlcignc3RhdGUubG9hZGVkKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0WzBdLm9Mb2FkZWRTdGF0ZSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdzdGF0ZS5zYXZlKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBfZm5TYXZlU3RhdGUoc2V0dGluZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvdmlkZSBhIGNvbW1vbiBtZXRob2QgZm9yIHBsdWctaW5zIHRvIGNoZWNrIHRoZSB2ZXJzaW9uIG9mIERhdGFUYWJsZXMgYmVpbmdcbiAgICAgICAgICogdXNlZCwgaW4gb3JkZXIgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkuXG4gICAgICAgICAqXG4gICAgICAgICAqICBAcGFyYW0ge3N0cmluZ30gdmVyc2lvbiBWZXJzaW9uIHN0cmluZyB0byBjaGVjayBmb3IsIGluIHRoZSBmb3JtYXQgXCJYLlkuWlwiLlxuICAgICAgICAgKiAgICBOb3RlIHRoYXQgdGhlIGZvcm1hdHMgXCJYXCIgYW5kIFwiWC5ZXCIgYXJlIGFsc28gYWNjZXB0YWJsZS5cbiAgICAgICAgICogIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFibGVzIGlzIGdyZWF0ZXIgb3IgZXF1YWwgdG9cbiAgICAgICAgICogICAgdGhlIHJlcXVpcmVkIHZlcnNpb24sIG9yIGZhbHNlIGlmIHRoaXMgdmVyc2lvbiBvZiBEYXRhVGFsZXMgaXMgbm90XG4gICAgICAgICAqICAgIHN1aXRhYmxlXG4gICAgICAgICAqICBAc3RhdGljXG4gICAgICAgICAqICBAZHRvcHQgQVBJLVN0YXRpY1xuICAgICAgICAgKlxuICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICogICAgYWxlcnQoICQuZm4uZGF0YVRhYmxlLnZlcnNpb25DaGVjayggJzEuOS4wJyApICk7XG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUudmVyc2lvbkNoZWNrID0gRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgICAgICAgICAgIHZhciBhVGhpcyA9IERhdGFUYWJsZS52ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgYVRoYXQgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICB2YXIgaVRoaXMsIGlUaGF0O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaUxlbiA9IGFUaGF0Lmxlbmd0aDsgaSA8IGlMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlUaGlzID0gcGFyc2VJbnQoYVRoaXNbaV0sIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgIGlUaGF0ID0gcGFyc2VJbnQoYVRoYXRbaV0sIDEwKSB8fCAwO1xuXG4gICAgICAgICAgICAgICAgLy8gUGFydHMgYXJlIHRoZSBzYW1lLCBrZWVwIGNvbXBhcmluZ1xuICAgICAgICAgICAgICAgIGlmIChpVGhpcyA9PT0gaVRoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUGFydHMgYXJlIGRpZmZlcmVudCwgcmV0dXJuIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlUaGlzID4gaVRoYXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIGEgYDx0YWJsZT5gIG5vZGUgaXMgYSBEYXRhVGFibGUgdGFibGUgYWxyZWFkeSBvciBub3QuXG4gICAgICAgICAqXG4gICAgICAgICAqICBAcGFyYW0ge25vZGV8anF1ZXJ5fHN0cmluZ30gdGFibGUgVGFibGUgbm9kZSwgalF1ZXJ5IG9iamVjdCBvciBqUXVlcnlcbiAgICAgICAgICogICAgICBzZWxlY3RvciBmb3IgdGhlIHRhYmxlIHRvIHRlc3QuIE5vdGUgdGhhdCBpZiBtb3JlIHRoYW4gbW9yZSB0aGFuIG9uZVxuICAgICAgICAgKiAgICAgIHRhYmxlIGlzIHBhc3NlZCBvbiwgb25seSB0aGUgZmlyc3Qgd2lsbCBiZSBjaGVja2VkXG4gICAgICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSB0aGUgdGFibGUgZ2l2ZW4gaXMgYSBEYXRhVGFibGUsIG9yIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiAgQHN0YXRpY1xuICAgICAgICAgKiAgQGR0b3B0IEFQSS1TdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAqICAgIGlmICggISAkLmZuLkRhdGFUYWJsZS5pc0RhdGFUYWJsZSggJyNleGFtcGxlJyApICkge1xuICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCk7XG4gICAgICAgICAqICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIERhdGFUYWJsZS5pc0RhdGFUYWJsZSA9IERhdGFUYWJsZS5mbklzRGF0YVRhYmxlID0gZnVuY3Rpb24gKHRhYmxlKSB7XG4gICAgICAgICAgICB2YXIgdCA9ICQodGFibGUpLmdldCgwKTtcbiAgICAgICAgICAgIHZhciBpcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAodGFibGUgaW5zdGFuY2VvZiBEYXRhVGFibGUuQXBpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICQuZWFjaChEYXRhVGFibGUuc2V0dGluZ3MsIGZ1bmN0aW9uIChpLCBvKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBvLm5TY3JvbGxIZWFkID8gJCgndGFibGUnLCBvLm5TY3JvbGxIZWFkKVswXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGZvb3QgPSBvLm5TY3JvbGxGb290ID8gJCgndGFibGUnLCBvLm5TY3JvbGxGb290KVswXSA6IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoby5uVGFibGUgPT09IHQgfHwgaGVhZCA9PT0gdCB8fCBmb290ID09PSB0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGlzO1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbGwgRGF0YVRhYmxlIHRhYmxlcyB0aGF0IGhhdmUgYmVlbiBpbml0aWFsaXNlZCAtIG9wdGlvbmFsbHkgeW91IGNhblxuICAgICAgICAgKiBzZWxlY3QgdG8gZ2V0IG9ubHkgY3VycmVudGx5IHZpc2libGUgdGFibGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBbdmlzaWJsZT1mYWxzZV0gRmxhZyB0byBpbmRpY2F0ZSBpZiB5b3Ugd2FudCBhbGwgKGRlZmF1bHQpXG4gICAgICAgICAqICAgIG9yIHZpc2libGUgdGFibGVzIG9ubHkuXG4gICAgICAgICAqICBAcmV0dXJucyB7YXJyYXl9IEFycmF5IG9mIGB0YWJsZWAgbm9kZXMgKG5vdCBEYXRhVGFibGUgaW5zdGFuY2VzKSB3aGljaCBhcmVcbiAgICAgICAgICogICAgRGF0YVRhYmxlc1xuICAgICAgICAgKiAgQHN0YXRpY1xuICAgICAgICAgKiAgQGR0b3B0IEFQSS1TdGF0aWNcbiAgICAgICAgICpcbiAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAqICAgICQuZWFjaCggJC5mbi5kYXRhVGFibGUudGFibGVzKHRydWUpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAqICAgICAgJCh0YWJsZSkuRGF0YVRhYmxlKCkuY29sdW1ucy5hZGp1c3QoKTtcbiAgICAgICAgICogICAgfSApO1xuICAgICAgICAgKi9cbiAgICAgICAgRGF0YVRhYmxlLnRhYmxlcyA9IERhdGFUYWJsZS5mblRhYmxlcyA9IGZ1bmN0aW9uICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB2YXIgYXBpID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodmlzaWJsZSkpIHtcbiAgICAgICAgICAgICAgICBhcGkgPSB2aXNpYmxlLmFwaTtcbiAgICAgICAgICAgICAgICB2aXNpYmxlID0gdmlzaWJsZS52aXNpYmxlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYSA9ICQubWFwKERhdGFUYWJsZS5zZXR0aW5ncywgZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIXZpc2libGUgfHwgKHZpc2libGUgJiYgJChvLm5UYWJsZSkuaXMoJzp2aXNpYmxlJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvLm5UYWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIGFwaSA/XG4gICAgICAgICAgICAgICAgbmV3IF9BcGkoYSkgOlxuICAgICAgICAgICAgICAgIGE7XG4gICAgICAgIH07XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydCBmcm9tIGNhbWVsIGNhc2UgcGFyYW1ldGVycyB0byBIdW5nYXJpYW4gbm90YXRpb24uIFRoaXMgaXMgbWFkZSBwdWJsaWNcbiAgICAgICAgICogZm9yIHRoZSBleHRlbnNpb25zIHRvIHByb3ZpZGUgdGhlIHNhbWUgYWJpbGl0eSBhcyBEYXRhVGFibGVzIGNvcmUgdG8gYWNjZXB0XG4gICAgICAgICAqIGVpdGhlciB0aGUgMS45IHN0eWxlIEh1bmdhcmlhbiBub3RhdGlvbiwgb3IgdGhlIDEuMTArIHN0eWxlIGNhbWVsQ2FzZVxuICAgICAgICAgKiBwYXJhbWV0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNyYyBUaGUgbW9kZWwgb2JqZWN0IHdoaWNoIGhvbGRzIGFsbCBwYXJhbWV0ZXJzIHRoYXQgY2FuIGJlXG4gICAgICAgICAqICAgIG1hcHBlZC5cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSB1c2VyIFRoZSBvYmplY3QgdG8gY29udmVydCBmcm9tIGNhbWVsIGNhc2UgdG8gSHVuZ2FyaWFuLlxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBmb3JjZSBXaGVuIHNldCB0byBgdHJ1ZWAsIHByb3BlcnRpZXMgd2hpY2ggYWxyZWFkeSBoYXZlIGFcbiAgICAgICAgICogICAgSHVuZ2FyaWFuIHZhbHVlIGluIHRoZSBgdXNlcmAgb2JqZWN0IHdpbGwgYmUgb3ZlcndyaXR0ZW4uIE90aGVyd2lzZSB0aGV5XG4gICAgICAgICAqICAgIHdvbid0IGJlLlxuICAgICAgICAgKi9cbiAgICAgICAgRGF0YVRhYmxlLmNhbWVsVG9IdW5nYXJpYW4gPSBfZm5DYW1lbFRvSHVuZ2FyaWFuO1xuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJyQoKScsIGZ1bmN0aW9uIChzZWxlY3Rvciwgb3B0cykge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgcm93cyA9IHRoaXMucm93cyhvcHRzKS5ub2RlcygpLCAvLyBHZXQgYWxsIHJvd3NcbiAgICAgICAgICAgICAgICBqcVJvd3MgPSAkKHJvd3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gJChbXS5jb25jYXQoXG4gICAgICAgICAgICAgICAganFSb3dzLmZpbHRlcihzZWxlY3RvcikudG9BcnJheSgpLFxuICAgICAgICAgICAgICAgIGpxUm93cy5maW5kKHNlbGVjdG9yKS50b0FycmF5KClcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIGpRdWVyeSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiB0aGUgdGFibGVzXG4gICAgICAgICQuZWFjaChbJ29uJywgJ29uZScsICdvZmYnXSwgZnVuY3Rpb24gKGksIGtleSkge1xuICAgICAgICAgICAgX2FwaV9yZWdpc3RlcihrZXkgKyAnKCknLCBmdW5jdGlvbiAoIC8qIGV2ZW50LCBoYW5kbGVyICovKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBgZHRgIG5hbWVzcGFjZSBhdXRvbWF0aWNhbGx5IGlmIGl0IGlzbid0IGFscmVhZHkgcHJlc2VudFxuICAgICAgICAgICAgICAgIGFyZ3NbMF0gPSAkLm1hcChhcmdzWzBdLnNwbGl0KC9cXHMvKSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFlLm1hdGNoKC9cXC5kdFxcYi8pID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGUgKyAnLmR0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBlO1xuICAgICAgICAgICAgICAgIH0pLmpvaW4oJyAnKTtcblxuICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gJCh0aGlzLnRhYmxlcygpLm5vZGVzKCkpO1xuICAgICAgICAgICAgICAgIGluc3Rba2V5XS5hcHBseShpbnN0LCBhcmdzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2NsZWFyKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRvcigndGFibGUnLCBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICBfZm5DbGVhclRhYmxlKHNldHRpbmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ3NldHRpbmdzKCknLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9BcGkodGhpcy5jb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB9KTtcblxuXG4gICAgICAgIF9hcGlfcmVnaXN0ZXIoJ2luaXQoKScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgICAgICByZXR1cm4gY3R4Lmxlbmd0aCA/IGN0eFswXS5vSW5pdCA6IG51bGw7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgX2FwaV9yZWdpc3RlcignZGF0YSgpJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoJ3RhYmxlJywgZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9wbHVjayhzZXR0aW5ncy5hb0RhdGEsICdfYURhdGEnKTtcbiAgICAgICAgICAgIH0pLmZsYXR0ZW4oKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdkZXN0cm95KCknLCBmdW5jdGlvbiAocmVtb3ZlKSB7XG4gICAgICAgICAgICByZW1vdmUgPSByZW1vdmUgfHwgZmFsc2U7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCd0YWJsZScsIGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHZhciBvcmlnID0gc2V0dGluZ3MublRhYmxlV3JhcHBlci5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIHZhciBjbGFzc2VzID0gc2V0dGluZ3Mub0NsYXNzZXM7XG4gICAgICAgICAgICAgICAgdmFyIHRhYmxlID0gc2V0dGluZ3MublRhYmxlO1xuICAgICAgICAgICAgICAgIHZhciB0Ym9keSA9IHNldHRpbmdzLm5UQm9keTtcbiAgICAgICAgICAgICAgICB2YXIgdGhlYWQgPSBzZXR0aW5ncy5uVEhlYWQ7XG4gICAgICAgICAgICAgICAgdmFyIHRmb290ID0gc2V0dGluZ3MublRGb290O1xuICAgICAgICAgICAgICAgIHZhciBqcVRhYmxlID0gJCh0YWJsZSk7XG4gICAgICAgICAgICAgICAgdmFyIGpxVGJvZHkgPSAkKHRib2R5KTtcbiAgICAgICAgICAgICAgICB2YXIganFXcmFwcGVyID0gJChzZXR0aW5ncy5uVGFibGVXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICB2YXIgcm93cyA9ICQubWFwKHNldHRpbmdzLmFvRGF0YSwgZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIublRyOyB9KTtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaWVuO1xuXG4gICAgICAgICAgICAgICAgLy8gRmxhZyB0byBub3RlIHRoYXQgdGhlIHRhYmxlIGlzIGN1cnJlbnRseSBiZWluZyBkZXN0cm95ZWQgLSBubyBhY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgdGFrZW5cbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5iRGVzdHJveWluZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJlIG9mZiB0aGUgZGVzdHJveSBjYWxsYmFja3MgZm9yIHBsdWctaW5zIGV0Y1xuICAgICAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZShzZXR0aW5ncywgXCJhb0Rlc3Ryb3lDYWxsYmFja1wiLCBcImRlc3Ryb3lcIiwgW3NldHRpbmdzXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgYmVpbmcgcmVtb3ZlZCBmcm9tIHRoZSBkb2N1bWVudCwgbWFrZSBhbGwgY29sdW1ucyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgaWYgKCFyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IF9BcGkoc2V0dGluZ3MpLmNvbHVtbnMoKS52aXNpYmxlKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJsaXR6IGFsbCBgRFRgIG5hbWVzcGFjZWQgZXZlbnRzICh0aGVzZSBhcmUgaW50ZXJuYWwgZXZlbnRzLCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsb3dlcmNhc2UsIGBkdGAgZXZlbnRzIGFyZSB1c2VyIHN1YnNjcmliZWQgYW5kIHRoZXkgYXJlIHJlc3BvbnNpYmxlXG4gICAgICAgICAgICAgICAgLy8gZm9yIHJlbW92aW5nIHRoZW1cbiAgICAgICAgICAgICAgICBqcVdyYXBwZXIub2ZmKCcuRFQnKS5maW5kKCc6bm90KHRib2R5ICopJykub2ZmKCcuRFQnKTtcbiAgICAgICAgICAgICAgICAkKHdpbmRvdykub2ZmKCcuRFQtJyArIHNldHRpbmdzLnNJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHNjcm9sbGluZyB3ZSBoYWQgdG8gYnJlYWsgdGhlIHRhYmxlIHVwIC0gcmVzdG9yZSBpdFxuICAgICAgICAgICAgICAgIGlmICh0YWJsZSAhPSB0aGVhZC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGpxVGFibGUuY2hpbGRyZW4oJ3RoZWFkJykuZGV0YWNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGpxVGFibGUuYXBwZW5kKHRoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGZvb3QgJiYgdGFibGUgIT0gdGZvb3QucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBqcVRhYmxlLmNoaWxkcmVuKCd0Zm9vdCcpLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgICAgICBqcVRhYmxlLmFwcGVuZCh0Zm9vdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nID0gW107XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuYWFTb3J0aW5nRml4ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBfZm5Tb3J0aW5nQ2xhc3NlcyhzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAkKHJvd3MpLnJlbW92ZUNsYXNzKHNldHRpbmdzLmFzU3RyaXBlQ2xhc3Nlcy5qb2luKCcgJykpO1xuXG4gICAgICAgICAgICAgICAgJCgndGgsIHRkJywgdGhlYWQpLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1NvcnRhYmxlICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydGFibGVBc2MgKyAnICcgKyBjbGFzc2VzLnNTb3J0YWJsZURlc2MgKyAnICcgKyBjbGFzc2VzLnNTb3J0YWJsZU5vbmVcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBUUiBlbGVtZW50cyBiYWNrIGludG8gdGhlIHRhYmxlIGluIHRoZWlyIG9yaWdpbmFsIG9yZGVyXG4gICAgICAgICAgICAgICAganFUYm9keS5jaGlsZHJlbigpLmRldGFjaCgpO1xuICAgICAgICAgICAgICAgIGpxVGJvZHkuYXBwZW5kKHJvd3MpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBEYXRhVGFibGVzIGdlbmVyYXRlZCBub2RlcywgZXZlbnRzIGFuZCBjbGFzc2VzXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRNZXRob2QgPSByZW1vdmUgPyAncmVtb3ZlJyA6ICdkZXRhY2gnO1xuICAgICAgICAgICAgICAgIGpxVGFibGVbcmVtb3ZlZE1ldGhvZF0oKTtcbiAgICAgICAgICAgICAgICBqcVdyYXBwZXJbcmVtb3ZlZE1ldGhvZF0oKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlIG5lZWQgdG8gcmVhdHRhY2ggdGhlIHRhYmxlIHRvIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIGlmICghcmVtb3ZlICYmIG9yaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zZXJ0QmVmb3JlIGFjdHMgbGlrZSBhcHBlbmRDaGlsZCBpZiAhYXJnWzFdXG4gICAgICAgICAgICAgICAgICAgIG9yaWcuaW5zZXJ0QmVmb3JlKHRhYmxlLCBzZXR0aW5ncy5uVGFibGVSZWluc2VydEJlZm9yZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgd2lkdGggb2YgdGhlIG9yaWdpbmFsIHRhYmxlIC0gd2FzIHJlYWQgZnJvbSB0aGUgc3R5bGUgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGNhbiByZXN0b3JlIGRpcmVjdGx5IHRvIHRoYXRcbiAgICAgICAgICAgICAgICAgICAganFUYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNzcygnd2lkdGgnLCBzZXR0aW5ncy5zRGVzdHJveVdpZHRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKGNsYXNzZXMuc1RhYmxlKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgd2VyZSBvcmlnaW5hbGx5IHN0cmlwZSBjbGFzc2VzIC0gdGhlbiB3ZSBhZGQgdGhlbSBiYWNrIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhpcyBpcyBub3QgZm9vbCBwcm9vZiAoZm9yIGV4YW1wbGUgaWYgbm90IGFsbCByb3dzIGhhZCBzdHJpcGVcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xhc3NlcyAtIGJ1dCBpdCdzIGEgZ29vZCBlZmZvcnQgd2l0aG91dCBnZXR0aW5nIGNhcnJpZWQgYXdheVxuICAgICAgICAgICAgICAgICAgICBpZW4gPSBzZXR0aW5ncy5hc0Rlc3Ryb3lTdHJpcGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaWVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqcVRib2R5LmNoaWxkcmVuKCkuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQodGhpcykuYWRkQ2xhc3Moc2V0dGluZ3MuYXNEZXN0cm95U3RyaXBlc1tpICUgaWVuXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIFJlbW92ZSB0aGUgc2V0dGluZ3Mgb2JqZWN0IGZyb20gdGhlIHNldHRpbmdzIGFycmF5ICovXG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9ICQuaW5BcnJheShzZXR0aW5ncywgRGF0YVRhYmxlLnNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBEYXRhVGFibGUuc2V0dGluZ3Muc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8gQWRkIHRoZSBgZXZlcnkoKWAgbWV0aG9kIGZvciByb3dzLCBjb2x1bW5zIGFuZCBjZWxscyBpbiBhIGNvbXBhY3QgZm9ybVxuICAgICAgICAkLmVhY2goWydjb2x1bW4nLCAncm93JywgJ2NlbGwnXSwgZnVuY3Rpb24gKGksIHR5cGUpIHtcbiAgICAgICAgICAgIF9hcGlfcmVnaXN0ZXIodHlwZSArICdzKCkuZXZlcnkoKScsIGZ1bmN0aW9uIChmbikge1xuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5zZWxlY3Rvci5vcHRzO1xuICAgICAgICAgICAgICAgIHZhciBhcGkgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IodHlwZSwgZnVuY3Rpb24gKHNldHRpbmdzLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvd3MgYW5kIGNvbHVtbnM6XG4gICAgICAgICAgICAgICAgICAgIC8vICBhcmcxIC0gaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgLy8gIGFyZzIgLSB0YWJsZSBjb3VudGVyXG4gICAgICAgICAgICAgICAgICAgIC8vICBhcmczIC0gbG9vcCBjb3VudGVyXG4gICAgICAgICAgICAgICAgICAgIC8vICBhcmc0IC0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIC8vIENlbGxzOlxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnMSAtIHJvdyBpbmRleFxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnMiAtIGNvbHVtbiBpbmRleFxuICAgICAgICAgICAgICAgICAgICAvLyAgYXJnMyAtIHRhYmxlIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gIGFyZzQgLSBsb29wIGNvdW50ZXJcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaVt0eXBlXShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdjZWxsJyA/IGFyZzIgOiBvcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPT09ICdjZWxsJyA/IG9wdHMgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcxLCBhcmcyLCBhcmczLCBhcmc0XG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBpMThuIG1ldGhvZCBmb3IgZXh0ZW5zaW9ucyB0byBiZSBhYmxlIHRvIHVzZSB0aGUgbGFuZ3VhZ2Ugb2JqZWN0IGZyb20gdGhlXG4gICAgICAgIC8vIERhdGFUYWJsZVxuICAgICAgICBfYXBpX3JlZ2lzdGVyKCdpMThuKCknLCBmdW5jdGlvbiAodG9rZW4sIGRlZiwgcGx1cmFsKSB7XG4gICAgICAgICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0WzBdO1xuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gX2ZuR2V0T2JqZWN0RGF0YUZuKHRva2VuKShjdHgub0xhbmd1YWdlKTtcblxuICAgICAgICAgICAgaWYgKHJlc29sdmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IGRlZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBsdXJhbCAhPT0gdW5kZWZpbmVkICYmICQuaXNQbGFpbk9iamVjdChyZXNvbHZlZCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHJlc29sdmVkW3BsdXJhbF0gIT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkW3BsdXJhbF0gOlxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5fO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWQucmVwbGFjZSgnJWQnLCBwbHVyYWwpOyAvLyBuYjogcGx1cmFsIG1pZ2h0IGJlIHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBWZXJzaW9uIHN0cmluZyBmb3IgcGx1Zy1pbnMgdG8gY2hlY2sgY29tcGF0aWJpbGl0eS4gQWxsb3dlZCBmb3JtYXQgaXNcbiAgICAgICAgICogYGEuYi5jLWRgIHdoZXJlOiBhOmludCwgYjppbnQsIGM6aW50LCBkOnN0cmluZyhkZXZ8YmV0YXxhbHBoYSkuIGBkYCBpcyB1c2VkXG4gICAgICAgICAqIG9ubHkgZm9yIG5vbi1yZWxlYXNlIGJ1aWxkcy4gU2VlIGh0dHA6Ly9zZW12ZXIub3JnLyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgICAgICogIEBtZW1iZXJcbiAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgKiAgQGRlZmF1bHQgVmVyc2lvbiBudW1iZXJcbiAgICAgICAgICovXG4gICAgICAgIERhdGFUYWJsZS52ZXJzaW9uID0gXCIxLjEwLjIzXCI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByaXZhdGUgZGF0YSBzdG9yZSwgY29udGFpbmluZyBhbGwgb2YgdGhlIHNldHRpbmdzIG9iamVjdHMgdGhhdCBhcmVcbiAgICAgICAgICogY3JlYXRlZCBmb3IgdGhlIHRhYmxlcyBvbiBhIGdpdmVuIHBhZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGUgYERhdGFUYWJsZS5zZXR0aW5nc2Agb2JqZWN0IGlzIGFsaWFzZWQgdG9cbiAgICAgICAgICogYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIHRocm91Z2ggd2hpY2ggaXQgbWF5IGJlIGFjY2Vzc2VkIGFuZFxuICAgICAgICAgKiBtYW5pcHVsYXRlZCwgb3IgYGpRdWVyeS5mbi5kYXRhVGFibGUuc2V0dGluZ3NgLlxuICAgICAgICAgKiAgQG1lbWJlclxuICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAqICBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgRGF0YVRhYmxlLnNldHRpbmdzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9iamVjdCBtb2RlbHMgY29udGFpbmVyLCBmb3IgdGhlIHZhcmlvdXMgbW9kZWxzIHRoYXQgRGF0YVRhYmxlcyBoYXNcbiAgICAgICAgICogYXZhaWxhYmxlIHRvIGl0LiBUaGVzZSBtb2RlbHMgZGVmaW5lIHRoZSBvYmplY3RzIHRoYXQgYXJlIHVzZWQgdG8gaG9sZFxuICAgICAgICAgKiB0aGUgYWN0aXZlIHN0YXRlIGFuZCBjb25maWd1cmF0aW9uIG9mIHRoZSB0YWJsZS5cbiAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIERhdGFUYWJsZS5tb2RlbHMgPSB7fTtcblxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIHdheSBpbiB3aGljaCBEYXRhVGFibGVzIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICAgICAqIHNlYXJjaCBpbmZvcm1hdGlvbiBmb3IgdGhlIGdsb2JhbCBmaWx0ZXIgYW5kIGluZGl2aWR1YWwgY29sdW1uIGZpbHRlcnMuXG4gICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2ggPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGZpbHRlcmluZyBzaG91bGQgYmUgY2FzZSBpbnNlbnNpdGl2ZSBvciBub3RcbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJDYXNlSW5zZW5zaXRpdmVcIjogdHJ1ZSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBsaWVkIHNlYXJjaCB0ZXJtXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPC9pPlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNTZWFyY2hcIjogXCJcIixcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIGluZGljYXRlIGlmIHRoZSBzZWFyY2ggdGVybSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICAgICAgICAgICAgICogcmVndWxhciBleHByZXNzaW9uICh0cnVlKSBvciBub3QgKGZhbHNlKSBhbmQgdGhlcmVmb3JlIGFuZCBzcGVjaWFsXG4gICAgICAgICAgICAgKiByZWdleCBjaGFyYWN0ZXJzIGVzY2FwZWQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlJlZ2V4XCI6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgRGF0YVRhYmxlcyBpcyB0byB1c2UgaXRzIHNtYXJ0IGZpbHRlcmluZyBvciBub3QuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiU21hcnRcIjogdHJ1ZVxuICAgICAgICB9O1xuXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZW1wbGF0ZSBvYmplY3QgZm9yIHRoZSB3YXkgaW4gd2hpY2ggRGF0YVRhYmxlcyBob2xkcyBpbmZvcm1hdGlvbiBhYm91dFxuICAgICAgICAgKiBlYWNoIGluZGl2aWR1YWwgcm93LiBUaGlzIGlzIHRoZSBvYmplY3QgZm9ybWF0IHVzZWQgZm9yIHRoZSBzZXR0aW5nc1xuICAgICAgICAgKiBhb0RhdGEgYXJyYXkuXG4gICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9Sb3cgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRSIGVsZW1lbnQgZm9yIHRoZSByb3dcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5UclwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFycmF5IG9mIFREIGVsZW1lbnRzIGZvciBlYWNoIHJvdy4gVGhpcyBpcyBudWxsIHVudGlsIHRoZSByb3cgaGFzIGJlZW5cbiAgICAgICAgICAgICAqIGNyZWF0ZWQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXkgbm9kZXNcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFuQ2VsbHNcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEYXRhIG9iamVjdCBmcm9tIHRoZSBvcmlnaW5hbCBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdy4gVGhpcyBpcyBlaXRoZXJcbiAgICAgICAgICAgICAqIGFuIGFycmF5IGlmIHVzaW5nIHRoZSB0cmFkaXRpb25hbCBmb3JtIG9mIERhdGFUYWJsZXMsIG9yIGFuIG9iamVjdCBpZlxuICAgICAgICAgICAgICogdXNpbmcgbURhdGEgb3B0aW9ucy4gVGhlIGV4YWN0IHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIHBhc3NlZCBpblxuICAgICAgICAgICAgICogZGF0YSBmcm9tIHRoZSBkYXRhIHNvdXJjZSwgb3Igd2lsbCBiZSBhbiBhcnJheSBpZiB1c2luZyBET00gYSBkYXRhXG4gICAgICAgICAgICAgKiBzb3VyY2UuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXl8b2JqZWN0XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJfYURhdGFcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29ydGluZyBkYXRhIGNhY2hlIC0gdGhpcyBhcnJheSBpcyBvc3RlbnNpYmx5IHRoZSBzYW1lIGxlbmd0aCBhcyB0aGVcbiAgICAgICAgICAgICAqIG51bWJlciBvZiBjb2x1bW5zIChhbHRob3VnaCBlYWNoIGluZGV4IGlzIGdlbmVyYXRlZCBvbmx5IGFzIGl0IGlzXG4gICAgICAgICAgICAgKiBuZWVkZWQpLCBhbmQgaG9sZHMgdGhlIGRhdGEgdGhhdCBpcyB1c2VkIGZvciBzb3J0aW5nIGVhY2ggY29sdW1uIGluIHRoZVxuICAgICAgICAgICAgICogcm93LiBXZSBkbyB0aGlzIGNhY2hlIGdlbmVyYXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSBzb3J0IGluIG9yZGVyIHRoYXRcbiAgICAgICAgICAgICAqIHRoZSBmb3JtYXR0aW5nIG9mIHRoZSBzb3J0IGRhdGEgbmVlZCBiZSBkb25lIG9ubHkgb25jZSBmb3IgZWFjaCBjZWxsXG4gICAgICAgICAgICAgKiBwZXIgc29ydC4gVGhpcyBhcnJheSBzaG91bGQgbm90IGJlIHJlYWQgZnJvbSBvciB3cml0dGVuIHRvIGJ5IGFueXRoaW5nXG4gICAgICAgICAgICAgKiBvdGhlciB0aGFuIHRoZSBtYXN0ZXIgc29ydGluZyBtZXRob2RzLlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICogIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiX2FTb3J0RGF0YVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlciBjZWxsIGZpbHRlcmluZyBkYXRhIGNhY2hlLiBBcyBwZXIgdGhlIHNvcnQgZGF0YSBjYWNoZSwgdXNlZCB0b1xuICAgICAgICAgICAgICogaW5jcmVhc2UgdGhlIHBlcmZvcm1hbmNlIG9mIHRoZSBmaWx0ZXJpbmcgaW4gRGF0YVRhYmxlc1xuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICogIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiX2FGaWx0ZXJEYXRhXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmlsdGVyaW5nIGRhdGEgY2FjaGUuIFRoaXMgaXMgdGhlIHNhbWUgYXMgdGhlIGNlbGwgZmlsdGVyaW5nIGNhY2hlLCBidXRcbiAgICAgICAgICAgICAqIGluIHRoaXMgY2FzZSBhIHN0cmluZyByYXRoZXIgdGhhbiBhbiBhcnJheS4gVGhpcyBpcyBlYXNpbHkgY29tcHV0ZWQgd2l0aFxuICAgICAgICAgICAgICogYSBqb2luIG9uIGBfYUZpbHRlckRhdGFgLCBidXQgaXMgcHJvdmlkZWQgYXMgYSBjYWNoZSBzbyB0aGUgam9pbiBpc24ndFxuICAgICAgICAgICAgICogbmVlZGVkIG9uIGV2ZXJ5IHNlYXJjaCAobWVtb3J5IHRyYWRlZCBmb3IgcGVyZm9ybWFuY2UpXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKiAgQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJfc0ZpbHRlclJvd1wiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhY2hlIG9mIHRoZSBjbGFzcyBuYW1lIHRoYXQgRGF0YVRhYmxlcyBoYXMgYXBwbGllZCB0byB0aGUgcm93LCBzbyB3ZVxuICAgICAgICAgICAgICogY2FuIHF1aWNrbHkgbG9vayBhdCB0aGlzIHZhcmlhYmxlIHJhdGhlciB0aGFuIG5lZWRpbmcgdG8gZG8gYSBET00gY2hlY2tcbiAgICAgICAgICAgICAqIG9uIGNsYXNzTmFtZSBmb3IgdGhlIG5UciBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG4gICAgICAgICAgICAgKiAgQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJfc1Jvd1N0cmlwZVwiOiBcIlwiLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlbm90ZSBpZiB0aGUgb3JpZ2luYWwgZGF0YSBzb3VyY2Ugd2FzIGZyb20gdGhlIERPTSwgb3IgdGhlIGRhdGEgc291cmNlXG4gICAgICAgICAgICAgKiBvYmplY3QuIFRoaXMgaXMgdXNlZCBmb3IgaW52YWxpZGF0aW5nIGRhdGEsIHNvIERhdGFUYWJsZXMgY2FuXG4gICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlYWQgZGF0YSBmcm9tIHRoZSBvcmlnaW5hbCBzb3VyY2UsIHVubGVzcyB1bmluc3RydWN0ZWRcbiAgICAgICAgICAgICAqIG90aGVyd2lzZS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKiAgQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzcmNcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbmRleCBpbiB0aGUgYW9EYXRhIGFycmF5LiBUaGlzIHNhdmVzIGFuIGluZGV4T2YgbG9va3VwIHdoZW4gd2UgaGF2ZSB0aGVcbiAgICAgICAgICAgICAqIG9iamVjdCwgYnV0IHdhbnQgdG8ga25vdyB0aGUgaW5kZXhcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRlZ2VyXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgLTFcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlkeFwiOiAtMVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRlbXBsYXRlIG9iamVjdCBmb3IgdGhlIGNvbHVtbiBpbmZvcm1hdGlvbiBvYmplY3QgaW4gRGF0YVRhYmxlcy4gVGhpcyBvYmplY3RcbiAgICAgICAgICogaXMgaGVsZCBpbiB0aGUgc2V0dGluZ3MgYW9Db2x1bW5zIGFycmF5IGFuZCBjb250YWlucyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXRcbiAgICAgICAgICogRGF0YVRhYmxlcyBuZWVkcyBhYm91dCBlYWNoIGluZGl2aWR1YWwgY29sdW1uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn1cbiAgICAgICAgICogYnV0IHRoaXMgb25lIGlzIHRoZSBpbnRlcm5hbCBkYXRhIHN0b3JlIGZvciBEYXRhVGFibGVzJ3MgY2FjaGUgb2YgY29sdW1ucy5cbiAgICAgICAgICogSXQgc2hvdWxkIE5PVCBiZSBtYW5pcHVsYXRlZCBvdXRzaWRlIG9mIERhdGFUYWJsZXMuIEFueSBjb25maWd1cmF0aW9uIHNob3VsZFxuICAgICAgICAgKiBiZSBkb25lIHRocm91Z2ggdGhlIGluaXRpYWxpc2F0aW9uIG9wdGlvbnMuXG4gICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUubW9kZWxzLm9Db2x1bW4gPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbHVtbiBpbmRleC4gVGhpcyBjb3VsZCBiZSB3b3JrZWQgb3V0IG9uLXRoZS1mbHkgd2l0aCAkLmluQXJyYXksIGJ1dCBpdFxuICAgICAgICAgICAgICogaXMgZmFzdGVyIHRvIGp1c3QgaG9sZCBpdCBhcyBhIHZhcmlhYmxlXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50ZWdlclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJpZHhcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGxpc3Qgb2YgdGhlIGNvbHVtbnMgdGhhdCBzb3J0aW5nIHNob3VsZCBvY2N1ciBvbiB3aGVuIHRoaXMgY29sdW1uXG4gICAgICAgICAgICAgKiBpcyBzb3J0ZWQuIFRoYXQgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhcnJheSBhbGxvd3MgbXVsdGktY29sdW1uIHNvcnRpbmdcbiAgICAgICAgICAgICAqIHRvIGJlIGRlZmluZWQgZm9yIGEgY29sdW1uIChmb3IgZXhhbXBsZSBmaXJzdCBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnNcbiAgICAgICAgICAgICAqIHdvdWxkIGJlbmVmaXQgZnJvbSB0aGlzKS4gVGhlIHZhbHVlcyBhcmUgaW50ZWdlcnMgcG9pbnRpbmcgdG8gdGhlXG4gICAgICAgICAgICAgKiBjb2x1bW5zIHRvIGJlIHNvcnRlZCBvbiAodHlwaWNhbGx5IGl0IHdpbGwgYmUgYSBzaW5nbGUgaW50ZWdlciBwb2ludGluZ1xuICAgICAgICAgICAgICogYXQgaXRzZWxmLCBidXQgdGhhdCBkb2Vzbid0IG5lZWQgdG8gYmUgdGhlIGNhc2UpLlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYURhdGFTb3J0XCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVmaW5lIHRoZSBzb3J0aW5nIGRpcmVjdGlvbnMgdGhhdCBhcmUgYXBwbGllZCB0byB0aGUgY29sdW1uLCBpbiBzZXF1ZW5jZVxuICAgICAgICAgICAgICogYXMgdGhlIGNvbHVtbiBpcyByZXBlYXRlZGx5IHNvcnRlZCB1cG9uIC0gaS5lLiB0aGUgZmlyc3QgdmFsdWUgaXMgdXNlZFxuICAgICAgICAgICAgICogYXMgdGhlIHNvcnRpbmcgZGlyZWN0aW9uIHdoZW4gdGhlIGNvbHVtbiBpZiBmaXJzdCBzb3J0ZWQgKGNsaWNrZWQgb24pLlxuICAgICAgICAgICAgICogU29ydCBpdCBhZ2FpbiAoY2xpY2sgYWdhaW4pIGFuZCBpdCB3aWxsIG1vdmUgb24gdG8gdGhlIG5leHQgaW5kZXguXG4gICAgICAgICAgICAgKiBSZXBlYXQgdW50aWwgbG9vcC5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFzU29ydGluZ1wiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzZWFyY2hhYmxlLCBhbmQgdGh1cyBzaG91bGQgYmUgaW5jbHVkZWRcbiAgICAgICAgICAgICAqIGluIHRoZSBmaWx0ZXJpbmcgb3Igbm90LlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiU2VhcmNoYWJsZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBzb3J0YWJsZSBvciBub3QuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJTb3J0YWJsZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGNvbHVtbiBpcyBjdXJyZW50bHkgdmlzaWJsZSBpbiB0aGUgdGFibGUgb3Igbm90XG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJWaXNpYmxlXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmUgZm9yIG1hbnVhbCB0eXBlIGFzc2lnbm1lbnQgdXNpbmcgdGhlIGBjb2x1bW4udHlwZWAgb3B0aW9uLiBUaGlzXG4gICAgICAgICAgICAgKiBpcyBoZWxkIGluIHN0b3JlIHNvIHdlIGNhbiBtYW5pcHVsYXRlIHRoZSBjb2x1bW4ncyBgc1R5cGVgIHByb3BlcnR5LlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIl9zTWFudWFsVHlwZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdG8gaW5kaWNhdGUgaWYgSFRNTDUgZGF0YSBhdHRyaWJ1dGVzIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBkYXRhXG4gICAgICAgICAgICAgKiBzb3VyY2UgZm9yIGZpbHRlcmluZyBvciBzb3J0aW5nLiBUcnVlIGlzIGVpdGhlciBhcmUuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKiAgQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJfYkF0dHJTcmNcIjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG4gICAgICAgICAgICAgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXG4gICAgICAgICAgICAgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuICAgICAgICAgICAgICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAcGFyYW0ge2VsZW1lbnR9IG5UZCBUaGUgVEQgbm9kZSB0aGF0IGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAqICBAcGFyYW0geyp9IHNEYXRhIFRoZSBEYXRhIGZvciB0aGUgY2VsbFxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBmb3IgdGhlIHdob2xlIHJvd1xuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBpUm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmbkNyZWF0ZWRDZWxsXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRnVuY3Rpb24gdG8gZ2V0IGRhdGEgZnJvbSBhIGNlbGwgaW4gYSBjb2x1bW4uIFlvdSBzaG91bGQgPGI+bmV2ZXI8L2I+XG4gICAgICAgICAgICAgKiBhY2Nlc3MgZGF0YSBkaXJlY3RseSB0aHJvdWdoIF9hRGF0YSBpbnRlcm5hbGx5IGluIERhdGFUYWJsZXMgLSBhbHdheXMgdXNlXG4gICAgICAgICAgICAgKiB0aGUgbWV0aG9kIGF0dGFjaGVkIHRvIHRoaXMgcHJvcGVydHkuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhc1xuICAgICAgICAgICAgICogcmVxdWlyZWQuIFRoaXMgZnVuY3Rpb24gaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uXG4gICAgICAgICAgICAgKiBpbml0aWFsaXNhdGlvbiBtZXRob2RcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBvRGF0YSBUaGUgZGF0YSBhcnJheS9vYmplY3QgZm9yIHRoZSBhcnJheVxuICAgICAgICAgICAgICogICAgKGkuZS4gYW9EYXRhW10uX2FEYXRhKVxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzU3BlY2lmaWMgVGhlIHNwZWNpZmljIGRhdGEgdHlwZSB5b3Ugd2FudCB0byBnZXQgLVxuICAgICAgICAgICAgICogICAgJ2Rpc3BsYXknLCAndHlwZScgJ2ZpbHRlcicgJ3NvcnQnXG4gICAgICAgICAgICAgKiAgQHJldHVybnMgeyp9IFRoZSBkYXRhIGZvciB0aGUgY2VsbCBmcm9tIHRoZSBnaXZlbiByb3cncyBkYXRhXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuR2V0RGF0YVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZ1bmN0aW9uIHRvIHNldCBkYXRhIGZvciBhIGNlbGwgaW4gdGhlIGNvbHVtbi4gWW91IHNob3VsZCA8Yj5uZXZlcjwvYj5cbiAgICAgICAgICAgICAqIHNldCB0aGUgZGF0YSBkaXJlY3RseSB0byBfYURhdGEgaW50ZXJuYWxseSBpbiBEYXRhVGFibGVzIC0gYWx3YXlzIHVzZVxuICAgICAgICAgICAgICogdGhpcyBtZXRob2QuIEl0IGFsbG93cyBtRGF0YSB0byBmdW5jdGlvbiBhcyByZXF1aXJlZC4gVGhpcyBmdW5jdGlvblxuICAgICAgICAgICAgICogaXMgYXV0b21hdGljYWxseSBhc3NpZ25lZCBieSB0aGUgY29sdW1uIGluaXRpYWxpc2F0aW9uIG1ldGhvZFxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IG9EYXRhIFRoZSBkYXRhIGFycmF5L29iamVjdCBmb3IgdGhlIGFycmF5XG4gICAgICAgICAgICAgKiAgICAoaS5lLiBhb0RhdGFbXS5fYURhdGEpXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHsqfSBzVmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuU2V0RGF0YVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByb3BlcnR5IHRvIHJlYWQgdGhlIHZhbHVlIGZvciB0aGUgY2VsbHMgaW4gdGhlIGNvbHVtbiBmcm9tIHRoZSBkYXRhXG4gICAgICAgICAgICAgKiBzb3VyY2UgYXJyYXkgLyBvYmplY3QuIElmIG51bGwsIHRoZW4gdGhlIGRlZmF1bHQgY29udGVudCBpcyB1c2VkLCBpZiBhXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBpcyBnaXZlbiB0aGVuIHRoZSByZXR1cm4gZnJvbSB0aGUgZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvbnxpbnR8c3RyaW5nfG51bGxcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwibURhdGFcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQYXJ0bmVyIHByb3BlcnR5IHRvIG1EYXRhIHdoaWNoIGlzIHVzZWQgKG9ubHkgd2hlbiBkZWZpbmVkKSB0byBnZXRcbiAgICAgICAgICAgICAqIHRoZSBkYXRhIC0gaS5lLiBpdCBpcyBiYXNpY2FsbHkgdGhlIHNhbWUgYXMgbURhdGEsIGJ1dCB3aXRob3V0IHRoZVxuICAgICAgICAgICAgICogJ3NldCcgb3B0aW9uLCBhbmQgYWxzbyB0aGUgZGF0YSBmZWQgdG8gaXQgaXMgdGhlIHJlc3VsdCBmcm9tIG1EYXRhLlxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgcmVuZGVyaW5nIG1ldGhvZCB0byBtYXRjaCB0aGUgZGF0YSBtZXRob2Qgb2YgbURhdGEuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb258aW50fHN0cmluZ3xudWxsXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm1SZW5kZXJcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVbmlxdWUgaGVhZGVyIFRIL1REIGVsZW1lbnQgZm9yIHRoaXMgY29sdW1uIC0gdGhpcyBpcyB3aGF0IHRoZSBzb3J0aW5nXG4gICAgICAgICAgICAgKiBsaXN0ZW5lciBpcyBhdHRhY2hlZCB0byAoaWYgc29ydGluZyBpcyBlbmFibGVkLilcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5UaFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVuaXF1ZSBmb290ZXIgVEgvVEQgZWxlbWVudCBmb3IgdGhpcyBjb2x1bW4gKGlmIHRoZXJlIGlzIG9uZSkuIE5vdCB1c2VkXG4gICAgICAgICAgICAgKiBpbiBEYXRhVGFibGVzIGFzIHN1Y2gsIGJ1dCBjYW4gYmUgdXNlZCBmb3IgcGx1Zy1pbnMgdG8gcmVmZXJlbmNlIHRoZVxuICAgICAgICAgICAgICogZm9vdGVyIGZvciBlYWNoIGNvbHVtbi5cbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5UZlwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBjbGFzcyB0byBhcHBseSB0byBhbGwgVEQgZWxlbWVudHMgaW4gdGhlIHRhYmxlJ3MgVEJPRFkgZm9yIHRoZSBjb2x1bW5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0NsYXNzXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBEYXRhVGFibGVzIGNhbGN1bGF0ZXMgdGhlIGNvbHVtbiB3aWR0aHMgdG8gYXNzaWduIHRvIGVhY2ggY29sdW1uLFxuICAgICAgICAgICAgICogaXQgZmluZHMgdGhlIGxvbmdlc3Qgc3RyaW5nIGluIGVhY2ggY29sdW1uIGFuZCB0aGVuIGNvbnN0cnVjdHMgYVxuICAgICAgICAgICAgICogdGVtcG9yYXJ5IHRhYmxlIGFuZCByZWFkcyB0aGUgd2lkdGhzIGZyb20gdGhhdC4gVGhlIHByb2JsZW0gd2l0aCB0aGlzXG4gICAgICAgICAgICAgKiBpcyB0aGF0IFwibW1tXCIgaXMgbXVjaCB3aWRlciB0aGVuIFwiaWlpaVwiLCBidXQgdGhlIGxhdHRlciBpcyBhIGxvbmdlclxuICAgICAgICAgICAgICogc3RyaW5nIC0gdGh1cyB0aGUgY2FsY3VsYXRpb24gY2FuIGdvIHdyb25nIChkb2luZyBpdCBwcm9wZXJseSBhbmQgcHV0dGluZ1xuICAgICAgICAgICAgICogaXQgaW50byBhbiBET00gb2JqZWN0IGFuZCBtZWFzdXJpbmcgdGhhdCBpcyBob3JyaWJseSghKSBzbG93KS4gVGh1cyBhc1xuICAgICAgICAgICAgICogYSBcIndvcmsgYXJvdW5kXCIgd2UgcHJvdmlkZSB0aGlzIG9wdGlvbi4gSXQgd2lsbCBhcHBlbmQgaXRzIHZhbHVlIHRvIHRoZVxuICAgICAgICAgICAgICogdGV4dCB0aGF0IGlzIGZvdW5kIHRvIGJlIHRoZSBsb25nZXN0IHN0cmluZyBmb3IgdGhlIGNvbHVtbiAtIGkuZS4gcGFkZGluZy5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzQ29udGVudFBhZGRpbmdcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBtRGF0YVxuICAgICAgICAgICAgICogaXMgc2V0IHRvIG51bGwsIG9yIGJlY2F1c2UgdGhlIGRhdGEgc291cmNlIGl0c2VsZiBpcyBudWxsKS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0RlZmF1bHRDb250ZW50XCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmFtZSBmb3IgdGhlIGNvbHVtbiwgYWxsb3dpbmcgcmVmZXJlbmNlIHRvIHRoZSBjb2x1bW4gYnkgbmFtZSBhcyB3ZWxsIGFzXG4gICAgICAgICAgICAgKiBieSBpbmRleCAobmVlZHMgYSBsb29rdXAgdG8gd29yayBieSBuYW1lKS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzTmFtZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEN1c3RvbSBzb3J0aW5nIGRhdGEgdHlwZSAtIGRlZmluZXMgd2hpY2ggb2YgdGhlIGF2YWlsYWJsZSBwbHVnLWlucyBpblxuICAgICAgICAgICAgICogYWZuU29ydERhdGEgdGhlIGN1c3RvbSBzb3J0aW5nIHdpbGwgdXNlIC0gaWYgYW55IGlzIGRlZmluZWQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgc3RkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1NvcnREYXRhVHlwZVwiOiAnc3RkJyxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDbGFzcyB0byBiZSBhcHBsaWVkIHRvIHRoZSBoZWFkZXIgZWxlbWVudCB3aGVuIHNvcnRpbmcgb24gdGhpcyBjb2x1bW5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1NvcnRpbmdDbGFzc1wiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGhlYWRlciBlbGVtZW50IHdoZW4gc29ydGluZyBvbiB0aGlzIGNvbHVtbiAtXG4gICAgICAgICAgICAgKiB3aGVuIGpRdWVyeSBVSSB0aGVtaW5nIGlzIHVzZWQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNTb3J0aW5nQ2xhc3NKVUlcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaXRsZSBvZiB0aGUgY29sdW1uIC0gd2hhdCBpcyBzZWVuIGluIHRoZSBUSCBlbGVtZW50IChuVGgpLlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNUaXRsZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbHVtbiBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcgdHlwZVxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzVHlwZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdpZHRoIG9mIHRoZSBjb2x1bW5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1dpZHRoXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2lkdGggb2YgdGhlIGNvbHVtbiB3aGVuIGl0IHdhcyBmaXJzdCBcImVuY291bnRlcmVkXCJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1dpZHRoT3JpZ1wiOiBudWxsXG4gICAgICAgIH07XG5cblxuICAgICAgICAvKlxuICAgICAgICAgKiBEZXZlbG9wZXIgbm90ZTogVGhlIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdCBiZWxvdyBhcmUgZ2l2ZW4gaW4gSHVuZ2FyaWFuXG4gICAgICAgICAqIG5vdGF0aW9uLCB0aGF0IHdhcyB1c2VkIGFzIHRoZSBpbnRlcmZhY2UgZm9yIERhdGFUYWJsZXMgcHJpb3IgdG8gdjEuMTAsIGhvd2V2ZXJcbiAgICAgICAgICogZnJvbSB2MS4xMCBvbndhcmRzIHRoZSBwcmltYXJ5IGludGVyZmFjZSBpcyBjYW1lbCBjYXNlLiBJbiBvcmRlciB0byBhdm9pZFxuICAgICAgICAgKiBicmVha2luZyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB1dHRlcmx5IHdpdGggdGhpcyBjaGFuZ2UsIHRoZSBIdW5nYXJpYW5cbiAgICAgICAgICogdmVyc2lvbiBpcyBzdGlsbCwgaW50ZXJuYWxseSB0aGUgcHJpbWFyeSBpbnRlcmZhY2UsIGJ1dCBpcyBpcyBub3QgZG9jdW1lbnRlZFxuICAgICAgICAgKiAtIGhlbmNlIHRoZSBAbmFtZSB0YWdzIGluIGVhY2ggZG9jIGNvbW1lbnQuIFRoaXMgYWxsb3dzIGEgSmF2YXNjcmlwdCBmdW5jdGlvblxuICAgICAgICAgKiB0byBjcmVhdGUgYSBtYXAgZnJvbSBIdW5nYXJpYW4gbm90YXRpb24gdG8gY2FtZWwgY2FzZSAoZ29pbmcgdGhlIG90aGVyIGRpcmVjdGlvblxuICAgICAgICAgKiB3b3VsZCByZXF1aXJlIGVhY2ggcHJvcGVydHkgdG8gYmUgbGlzdGVkLCB3aGljaCB3b3VsZCBhZGQgYXJvdW5kIDNLIHRvIHRoZSBzaXplXG4gICAgICAgICAqIG9mIERhdGFUYWJsZXMsIHdoaWxlIHRoaXMgbWV0aG9kIGlzIGFib3V0IGEgMC41SyBoaXQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBVbHRpbWF0ZWx5IHRoaXMgZG9lcyBwYXZlIHRoZSB3YXkgZm9yIEh1bmdhcmlhbiBub3RhdGlvbiB0byBiZSBkcm9wcGVkXG4gICAgICAgICAqIGNvbXBsZXRlbHksIGJ1dCB0aGF0IGlzIGEgbWFzc2l2ZSBhbW91bnQgb2Ygd29yayBhbmQgd2lsbCBicmVhayBjdXJyZW50XG4gICAgICAgICAqIGluc3RhbGxzICh0aGVyZWZvcmUgaXMgb24taG9sZCB1bnRpbCB2MikuXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXNhdGlvbiBvcHRpb25zIHRoYXQgY2FuIGJlIGdpdmVuIHRvIERhdGFUYWJsZXMgYXQgaW5pdGlhbGlzYXRpb25cbiAgICAgICAgICogdGltZS5cbiAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICovXG4gICAgICAgIERhdGFUYWJsZS5kZWZhdWx0cyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gYXJyYXkgb2YgZGF0YSB0byB1c2UgZm9yIHRoZSB0YWJsZSwgcGFzc2VkIGluIGF0IGluaXRpYWxpc2F0aW9uIHdoaWNoXG4gICAgICAgICAgICAgKiB3aWxsIGJlIHVzZWQgaW4gcHJlZmVyZW5jZSB0byBhbnkgZGF0YSB3aGljaCBpcyBhbHJlYWR5IGluIHRoZSBET00uIFRoaXMgaXNcbiAgICAgICAgICAgICAqIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIGNvbnN0cnVjdGluZyB0YWJsZXMgcHVyZWx5IGluIEphdmFzY3JpcHQsIGZvclxuICAgICAgICAgICAgICogZXhhbXBsZSB3aXRoIGEgY3VzdG9tIEFqYXggY2FsbC5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kYXRhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBhIDJEIGFycmF5IGRhdGEgc291cmNlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiZGF0YVwiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICBbJ1RyaWRlbnQnLCAnSW50ZXJuZXQgRXhwbG9yZXIgNC4wJywgJ1dpbiA5NSsnLCA0LCAnWCddLFxuICAgICAgICAgICAgICogICAgICAgICAgWydUcmlkZW50JywgJ0ludGVybmV0IEV4cGxvcmVyIDUuMCcsICdXaW4gOTUrJywgNSwgJ0MnXSxcbiAgICAgICAgICAgICAqICAgICAgICBdLFxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJFbmdpbmVcIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiQnJvd3NlclwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJQbGF0Zm9ybVwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJWZXJzaW9uXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkdyYWRlXCIgfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYW4gYXJyYXkgb2Ygb2JqZWN0cyBhcyBhIGRhdGEgc291cmNlIChgZGF0YWApXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiZGF0YVwiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZW5naW5lXCI6ICAgXCJUcmlkZW50XCIsXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiYnJvd3NlclwiOiAgXCJJbnRlcm5ldCBFeHBsb3JlciA0LjBcIixcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJwbGF0Zm9ybVwiOiBcIldpbiA5NStcIixcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ2ZXJzaW9uXCI6ICA0LFxuICAgICAgICAgICAgICogICAgICAgICAgICBcImdyYWRlXCI6ICAgIFwiWFwiXG4gICAgICAgICAgICAgKiAgICAgICAgICB9LFxuICAgICAgICAgICAgICogICAgICAgICAge1xuICAgICAgICAgICAgICogICAgICAgICAgICBcImVuZ2luZVwiOiAgIFwiVHJpZGVudFwiLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcImJyb3dzZXJcIjogIFwiSW50ZXJuZXQgRXhwbG9yZXIgNS4wXCIsXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwicGxhdGZvcm1cIjogXCJXaW4gOTUrXCIsXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwidmVyc2lvblwiOiAgNSxcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJncmFkZVwiOiAgICBcIkNcIlxuICAgICAgICAgICAgICogICAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgIF0sXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIkVuZ2luZVwiLCAgIFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwidGl0bGVcIjogXCJCcm93c2VyXCIsICBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlBsYXRmb3JtXCIsIFwiZGF0YVwiOiBcInBsYXRmb3JtXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIlZlcnNpb25cIiwgIFwiZGF0YVwiOiBcInZlcnNpb25cIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInRpdGxlXCI6IFwiR3JhZGVcIiwgICAgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYWFEYXRhXCI6IG51bGwsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiBvcmRlcmluZyBpcyBlbmFibGVkLCB0aGVuIERhdGFUYWJsZXMgd2lsbCBwZXJmb3JtIGEgZmlyc3QgcGFzcyBzb3J0IG9uXG4gICAgICAgICAgICAgKiBpbml0aWFsaXNhdGlvbi4gWW91IGNhbiBkZWZpbmUgd2hpY2ggY29sdW1uKHMpIHRoZSBzb3J0IGlzIHBlcmZvcm1lZFxuICAgICAgICAgICAgICogdXBvbiwgYW5kIHRoZSBzb3J0aW5nIGRpcmVjdGlvbiwgd2l0aCB0aGlzIHZhcmlhYmxlLiBUaGUgYHNvcnRpbmdgIGFycmF5XG4gICAgICAgICAgICAgKiBzaG91bGQgY29udGFpbiBhbiBhcnJheSBmb3IgZWFjaCBjb2x1bW4gdG8gYmUgc29ydGVkIGluaXRpYWxseSBjb250YWluaW5nXG4gICAgICAgICAgICAgKiB0aGUgY29sdW1uJ3MgaW5kZXggYW5kIGEgZGlyZWN0aW9uIHN0cmluZyAoJ2FzYycgb3IgJ2Rlc2MnKS5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtbMCwnYXNjJ11dXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFNvcnQgYnkgM3JkIGNvbHVtbiBmaXJzdCwgYW5kIHRoZW4gNHRoIGNvbHVtblxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJcIjogW1syLCdhc2MnXSwgWzMsJ2Rlc2MnXV1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgIC8vIE5vIGluaXRpYWwgc29ydGluZ1xuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJcIjogW11cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFhU29ydGluZ1wiOiBbWzAsICdhc2MnXV0sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBpcyBiYXNpY2FsbHkgaWRlbnRpY2FsIHRvIHRoZSBgc29ydGluZ2AgcGFyYW1ldGVyLCBidXRcbiAgICAgICAgICAgICAqIGNhbm5vdCBiZSBvdmVycmlkZGVuIGJ5IHVzZXIgaW50ZXJhY3Rpb24gd2l0aCB0aGUgdGFibGUuIFdoYXQgdGhpcyBtZWFuc1xuICAgICAgICAgICAgICogaXMgdGhhdCB5b3UgY291bGQgaGF2ZSBhIGNvbHVtbiAodmlzaWJsZSBvciBoaWRkZW4pIHdoaWNoIHRoZSBzb3J0aW5nXG4gICAgICAgICAgICAgKiB3aWxsIGFsd2F5cyBiZSBmb3JjZWQgb24gZmlyc3QgLSBhbnkgc29ydGluZyBhZnRlciB0aGF0IChmcm9tIHRoZSB1c2VyKVxuICAgICAgICAgICAgICogd2lsbCB0aGVuIGJlIHBlcmZvcm1lZCBhcyByZXF1aXJlZC4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBncm91cGluZyByb3dzXG4gICAgICAgICAgICAgKiB0b2dldGhlci5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckZpeGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlckZpeGVkXCI6IFtbMCwnYXNjJ11dXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGF0YVRhYmxlcyBjYW4gYmUgaW5zdHJ1Y3RlZCB0byBsb2FkIGRhdGEgdG8gZGlzcGxheSBpbiB0aGUgdGFibGUgZnJvbSBhXG4gICAgICAgICAgICAgKiBBamF4IHNvdXJjZS4gVGhpcyBvcHRpb24gZGVmaW5lcyBob3cgdGhhdCBBamF4IGNhbGwgaXMgbWFkZSBhbmQgd2hlcmUgdG8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIGBhamF4YCBwcm9wZXJ0eSBoYXMgdGhyZWUgZGlmZmVyZW50IG1vZGVzIG9mIG9wZXJhdGlvbiwgZGVwZW5kaW5nIG9uXG4gICAgICAgICAgICAgKiBob3cgaXQgaXMgZGVmaW5lZC4gVGhlc2UgYXJlOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICogYHN0cmluZ2AgLSBTZXQgdGhlIFVSTCBmcm9tIHdoZXJlIHRoZSBkYXRhIHNob3VsZCBiZSBsb2FkZWQgZnJvbS5cbiAgICAgICAgICAgICAqICogYG9iamVjdGAgLSBEZWZpbmUgcHJvcGVydGllcyBmb3IgYGpRdWVyeS5hamF4YC5cbiAgICAgICAgICAgICAqICogYGZ1bmN0aW9uYCAtIEN1c3RvbSBkYXRhIGdldCBmdW5jdGlvblxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIGBzdHJpbmdgXG4gICAgICAgICAgICAgKiAtLS0tLS0tLVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFzIGEgc3RyaW5nLCB0aGUgYGFqYXhgIHByb3BlcnR5IHNpbXBseSBkZWZpbmVzIHRoZSBVUkwgZnJvbSB3aGljaFxuICAgICAgICAgICAgICogRGF0YVRhYmxlcyB3aWxsIGxvYWQgZGF0YS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgb2JqZWN0YFxuICAgICAgICAgICAgICogLS0tLS0tLS1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBBcyBhbiBvYmplY3QsIHRoZSBwYXJhbWV0ZXJzIGluIHRoZSBvYmplY3QgYXJlIHBhc3NlZCB0b1xuICAgICAgICAgICAgICogW2pRdWVyeS5hamF4XShodHRwOi8vYXBpLmpxdWVyeS5jb20valF1ZXJ5LmFqYXgvKSBhbGxvd2luZyBmaW5lIGNvbnRyb2xcbiAgICAgICAgICAgICAqIG9mIHRoZSBBamF4IHJlcXVlc3QuIERhdGFUYWJsZXMgaGFzIGEgbnVtYmVyIG9mIGRlZmF1bHQgcGFyYW1ldGVycyB3aGljaFxuICAgICAgICAgICAgICogeW91IGNhbiBvdmVycmlkZSB1c2luZyB0aGlzIG9wdGlvbi4gUGxlYXNlIHJlZmVyIHRvIHRoZSBqUXVlcnlcbiAgICAgICAgICAgICAqIGRvY3VtZW50YXRpb24gZm9yIGEgZnVsbCBkZXNjcmlwdGlvbiBvZiB0aGUgb3B0aW9ucyBhdmFpbGFibGUsIGFsdGhvdWdoXG4gICAgICAgICAgICAgKiB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnMgcHJvdmlkZSBhZGRpdGlvbmFsIG9wdGlvbnMgaW4gRGF0YVRhYmxlcyBvclxuICAgICAgICAgICAgICogcmVxdWlyZSBzcGVjaWFsIGNvbnNpZGVyYXRpb246XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBgZGF0YWAgLSBBcyB3aXRoIGpRdWVyeSwgYGRhdGFgIGNhbiBiZSBwcm92aWRlZCBhcyBhbiBvYmplY3QsIGJ1dCBpdFxuICAgICAgICAgICAgICogICBjYW4gYWxzbyBiZSB1c2VkIGFzIGEgZnVuY3Rpb24gdG8gbWFuaXB1bGF0ZSB0aGUgZGF0YSBEYXRhVGFibGVzIHNlbmRzXG4gICAgICAgICAgICAgKiAgIHRvIHRoZSBzZXJ2ZXIuIFRoZSBmdW5jdGlvbiB0YWtlcyBhIHNpbmdsZSBwYXJhbWV0ZXIsIGFuIG9iamVjdCBvZlxuICAgICAgICAgICAgICogICBwYXJhbWV0ZXJzIHdpdGggdGhlIHZhbHVlcyB0aGF0IERhdGFUYWJsZXMgaGFzIHJlYWRpZWQgZm9yIHNlbmRpbmcuIEFuXG4gICAgICAgICAgICAgKiAgIG9iamVjdCBtYXkgYmUgcmV0dXJuZWQgd2hpY2ggd2lsbCBiZSBtZXJnZWQgaW50byB0aGUgRGF0YVRhYmxlc1xuICAgICAgICAgICAgICogICBkZWZhdWx0cywgb3IgeW91IGNhbiBhZGQgdGhlIGl0ZW1zIHRvIHRoZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGluIGFuZFxuICAgICAgICAgICAgICogICBub3QgcmV0dXJuIGFueXRoaW5nIGZyb20gdGhlIGZ1bmN0aW9uLiBUaGlzIHN1cGVyc2VkZXMgYGZuU2VydmVyUGFyYW1zYFxuICAgICAgICAgICAgICogICBmcm9tIERhdGFUYWJsZXMgMS45LS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqIGBkYXRhU3JjYCAtIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIGxvb2sgZm9yIHRoZSBwcm9wZXJ0eSBgZGF0YWAgKG9yXG4gICAgICAgICAgICAgKiAgIGBhYURhdGFgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggRGF0YVRhYmxlcyAxLjktKSB3aGVuIG9idGFpbmluZyBkYXRhXG4gICAgICAgICAgICAgKiAgIGZyb20gYW4gQWpheCBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlclxuICAgICAgICAgICAgICogICBhbGxvd3MgdGhhdCBwcm9wZXJ0eSB0byBiZSBjaGFuZ2VkLiBZb3UgY2FuIHVzZSBKYXZhc2NyaXB0IGRvdHRlZFxuICAgICAgICAgICAgICogICBvYmplY3Qgbm90YXRpb24gdG8gZ2V0IGEgZGF0YSBzb3VyY2UgZm9yIG11bHRpcGxlIGxldmVscyBvZiBuZXN0aW5nLCBvclxuICAgICAgICAgICAgICogICBpdCBteSBiZSB1c2VkIGFzIGEgZnVuY3Rpb24uIEFzIGEgZnVuY3Rpb24gaXQgdGFrZXMgYSBzaW5nbGUgcGFyYW1ldGVyLFxuICAgICAgICAgICAgICogICB0aGUgSlNPTiByZXR1cm5lZCBmcm9tIHRoZSBzZXJ2ZXIsIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBhc1xuICAgICAgICAgICAgICogICByZXF1aXJlZCwgd2l0aCB0aGUgcmV0dXJuZWQgdmFsdWUgYmVpbmcgdGhhdCB1c2VkIGJ5IERhdGFUYWJsZXMgYXMgdGhlXG4gICAgICAgICAgICAgKiAgIGRhdGEgc291cmNlIGZvciB0aGUgdGFibGUuIFRoaXMgc3VwZXJzZWRlcyBgc0FqYXhEYXRhUHJvcGAgZnJvbVxuICAgICAgICAgICAgICogICBEYXRhVGFibGVzIDEuOS0uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBgc3VjY2Vzc2AgLSBTaG91bGQgbm90IGJlIG92ZXJyaWRkZW4gaXQgaXMgdXNlZCBpbnRlcm5hbGx5IGluXG4gICAgICAgICAgICAgKiAgIERhdGFUYWJsZXMuIFRvIG1hbmlwdWxhdGUgLyB0cmFuc2Zvcm0gdGhlIGRhdGEgcmV0dXJuZWQgYnkgdGhlIHNlcnZlclxuICAgICAgICAgICAgICogICB1c2UgYGFqYXguZGF0YVNyY2AsIG9yIHVzZSBgYWpheGAgYXMgYSBmdW5jdGlvbiAoc2VlIGJlbG93KS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBgZnVuY3Rpb25gXG4gICAgICAgICAgICAgKiAtLS0tLS0tLS0tXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQXMgYSBmdW5jdGlvbiwgbWFraW5nIHRoZSBBamF4IGNhbGwgaXMgbGVmdCB1cCB0byB5b3Vyc2VsZiBhbGxvd2luZ1xuICAgICAgICAgICAgICogY29tcGxldGUgY29udHJvbCBvZiB0aGUgQWpheCByZXF1ZXN0LiBJbmRlZWQsIGlmIGRlc2lyZWQsIGEgbWV0aG9kIG90aGVyXG4gICAgICAgICAgICAgKiB0aGFuIEFqYXggY291bGQgYmUgdXNlZCB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEsIHN1Y2ggYXMgV2ViIHN0b3JhZ2VcbiAgICAgICAgICAgICAqIG9yIGFuIEFJUiBkYXRhYmFzZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgZnVuY3Rpb24gaXMgZ2l2ZW4gZm91ciBwYXJhbWV0ZXJzIGFuZCBubyByZXR1cm4gaXMgcmVxdWlyZWQuIFRoZVxuICAgICAgICAgICAgICogcGFyYW1ldGVycyBhcmU6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogMS4gX29iamVjdF8gLSBEYXRhIHRvIHNlbmQgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgICogMi4gX2Z1bmN0aW9uXyAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgbXVzdCBiZSBleGVjdXRlZCB3aGVuIHRoZSByZXF1aXJlZFxuICAgICAgICAgICAgICogICAgZGF0YSBoYXMgYmVlbiBvYnRhaW5lZC4gVGhhdCBkYXRhIHNob3VsZCBiZSBwYXNzZWQgaW50byB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAqICAgIGFzIHRoZSBvbmx5IHBhcmFtZXRlclxuICAgICAgICAgICAgICogMy4gX29iamVjdF8gLSBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgc3VwZXJzZWRlcyBgZm5TZXJ2ZXJEYXRhYCBmcm9tIERhdGFUYWJsZXMgMS45LS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfG9iamVjdHxmdW5jdGlvblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvblxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4XG4gICAgICAgICAgICAgKiAgQHNpbmNlIDEuMTAuMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXguXG4gICAgICAgICAgICAgKiAgIC8vIE5vdGUgRGF0YVRhYmxlcyBleHBlY3RzIGRhdGEgaW4gdGhlIGZvcm0gYHsgZGF0YTogWyAuLi5kYXRhLi4uIF0gfWAgYnkgZGVmYXVsdCkuXG4gICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IFwiZGF0YS5qc29uXCJcbiAgICAgICAgICAgICAqICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byBjaGFuZ2VcbiAgICAgICAgICAgICAqICAgLy8gYGRhdGFgIHRvIGB0YWJsZURhdGFgIChpLmUuIGB7IHRhYmxlRGF0YTogWyAuLi5kYXRhLi4uIF0gfWApXG4gICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcbiAgICAgICAgICAgICAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXG4gICAgICAgICAgICAgKiAgICAgICBcImRhdGFTcmNcIjogXCJ0YWJsZURhdGFcIlxuICAgICAgICAgICAgICogICAgIH1cbiAgICAgICAgICAgICAqICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgIC8vIEdldCBKU09OIGRhdGEgZnJvbSBhIGZpbGUgdmlhIEFqYXgsIHVzaW5nIGBkYXRhU3JjYCB0byByZWFkIGRhdGFcbiAgICAgICAgICAgICAqICAgLy8gZnJvbSBhIHBsYWluIGFycmF5IHJhdGhlciB0aGFuIGFuIGFycmF5IGluIGFuIG9iamVjdFxuICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XG4gICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuICAgICAgICAgICAgICogICAgICAgXCJkYXRhU3JjXCI6IFwiXCJcbiAgICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICAgKiAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAvLyBNYW5pcHVsYXRlIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciAtIGFkZCBhIGxpbmsgdG8gZGF0YVxuICAgICAgICAgICAgICogICAvLyAobm90ZSB0aGlzIGNhbiwgc2hvdWxkLCBiZSBkb25lIHVzaW5nIGByZW5kZXJgIGZvciB0aGUgY29sdW1uIC0gdGhpc1xuICAgICAgICAgICAgICogICAvLyBpcyBqdXN0IGEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRoZSBkYXRhIGNhbiBiZSBtYW5pcHVsYXRlZCkuXG4gICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcbiAgICAgICAgICAgICAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXG4gICAgICAgICAgICAgKiAgICAgICBcImRhdGFTcmNcIjogZnVuY3Rpb24gKCBqc29uICkge1xuICAgICAgICAgICAgICogICAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5sZW5ndGggOyBpPGllbiA7IGkrKyApIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICBqc29uW2ldWzBdID0gJzxhIGhyZWY9XCIvbWVzc2FnZS8nK2pzb25baV1bMF0rJz5WaWV3IG1lc3NhZ2U8L2E+JztcbiAgICAgICAgICAgICAqICAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgICByZXR1cm4ganNvbjtcbiAgICAgICAgICAgICAqICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICAgKiAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAvLyBBZGQgZGF0YSB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgICAgICogICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgIFwiYWpheFwiOiB7XG4gICAgICAgICAgICAgKiAgICAgICBcInVybFwiOiBcImRhdGEuanNvblwiLFxuICAgICAgICAgICAgICogICAgICAgXCJkYXRhXCI6IGZ1bmN0aW9uICggZCApIHtcbiAgICAgICAgICAgICAqICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICBcImV4dHJhX3NlYXJjaFwiOiAkKCcjZXh0cmEnKS52YWwoKVxuICAgICAgICAgICAgICogICAgICAgICB9O1xuICAgICAgICAgICAgICogICAgICAgfVxuICAgICAgICAgICAgICogICAgIH1cbiAgICAgICAgICAgICAqICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgIC8vIFNlbmQgcmVxdWVzdCBhcyBQT1NUXG4gICAgICAgICAgICAgKiAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgXCJhamF4XCI6IHtcbiAgICAgICAgICAgICAqICAgICAgIFwidXJsXCI6IFwiZGF0YS5qc29uXCIsXG4gICAgICAgICAgICAgKiAgICAgICBcInR5cGVcIjogXCJQT1NUXCJcbiAgICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICAgKiAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAvLyBHZXQgdGhlIGRhdGEgZnJvbSBsb2NhbFN0b3JhZ2UgKGNvdWxkIGludGVyZmFjZSB3aXRoIGEgZm9ybSBmb3JcbiAgICAgICAgICAgICAqICAgLy8gYWRkaW5nLCBlZGl0aW5nIGFuZCByZW1vdmluZyByb3dzKS5cbiAgICAgICAgICAgICAqICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICBcImFqYXhcIjogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgICogICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICAgKiAgICAgICAgIEpTT04ucGFyc2UoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkYXRhVGFibGVzRGF0YScpIClcbiAgICAgICAgICAgICAqICAgICAgICk7XG4gICAgICAgICAgICAgKiAgICAgfVxuICAgICAgICAgICAgICogICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYWpheFwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byByZWFkaWx5IHNwZWNpZnkgdGhlIGVudHJpZXMgaW4gdGhlIGxlbmd0aCBkcm9wXG4gICAgICAgICAgICAgKiBkb3duIG1lbnUgdGhhdCBEYXRhVGFibGVzIHNob3dzIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLiBJdCBjYW4gYmVcbiAgICAgICAgICAgICAqIGVpdGhlciBhIDFEIGFycmF5IG9mIG9wdGlvbnMgd2hpY2ggd2lsbCBiZSB1c2VkIGZvciBib3RoIHRoZSBkaXNwbGF5ZWRcbiAgICAgICAgICAgICAqIG9wdGlvbiBhbmQgdGhlIHZhbHVlLCBvciBhIDJEIGFycmF5IHdoaWNoIHdpbGwgdXNlIHRoZSBhcnJheSBpbiB0aGUgZmlyc3RcbiAgICAgICAgICAgICAqIHBvc2l0aW9uIGFzIHRoZSB2YWx1ZSwgYW5kIHRoZSBhcnJheSBpbiB0aGUgc2Vjb25kIHBvc2l0aW9uIGFzIHRoZVxuICAgICAgICAgICAgICogZGlzcGxheWVkIG9wdGlvbnMgKHVzZWZ1bCBmb3IgbGFuZ3VhZ2Ugc3RyaW5ncyBzdWNoIGFzICdBbGwnKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGBwYWdlTGVuZ3RoYCBwcm9wZXJ0eSB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgc2V0IHRvIHRoZVxuICAgICAgICAgICAgICogZmlyc3QgdmFsdWUgZ2l2ZW4gaW4gdGhpcyBhcnJheSwgdW5sZXNzIGBwYWdlTGVuZ3RoYCBpcyBhbHNvIHByb3ZpZGVkLlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgWyAxMCwgMjUsIDUwLCAxMDAgXVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxlbmd0aE1lbnVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImxlbmd0aE1lbnVcIjogW1sxMCwgMjUsIDUwLCAtMV0sIFsxMCwgMjUsIDUwLCBcIkFsbFwiXV1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFMZW5ndGhNZW51XCI6IFsxMCwgMjUsIDUwLCAxMDBdLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGBjb2x1bW5zYCBvcHRpb24gaW4gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIGRlZmluZVxuICAgICAgICAgICAgICogZGV0YWlscyBhYm91dCB0aGUgd2F5IGluZGl2aWR1YWwgY29sdW1ucyBiZWhhdmUuIEZvciBhIGZ1bGwgbGlzdCBvZlxuICAgICAgICAgICAgICogY29sdW1uIG9wdGlvbnMgdGhhdCBjYW4gYmUgc2V0LCBwbGVhc2Ugc2VlXG4gICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0uIE5vdGUgdGhhdCBpZiB5b3UgdXNlIGBjb2x1bW5zYCB0b1xuICAgICAgICAgICAgICogZGVmaW5lIHlvdXIgY29sdW1ucywgeW91IG11c3QgaGF2ZSBhbiBlbnRyeSBpbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IHNpbmdsZVxuICAgICAgICAgICAgICogY29sdW1uIHRoYXQgeW91IGhhdmUgaW4geW91ciB0YWJsZSAodGhlc2UgY2FuIGJlIG51bGwgaWYgeW91IGRvbid0IHdoaWNoXG4gICAgICAgICAgICAgKiB0byBzcGVjaWZ5IGFueSBvcHRpb25zKS5cbiAgICAgICAgICAgICAqICBAbWVtYmVyXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb0NvbHVtbnNcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBWZXJ5IHNpbWlsYXIgdG8gYGNvbHVtbnNgLCBgY29sdW1uRGVmc2AgYWxsb3dzIHlvdSB0byB0YXJnZXQgYSBzcGVjaWZpY1xuICAgICAgICAgICAgICogY29sdW1uLCBtdWx0aXBsZSBjb2x1bW5zLCBvciBhbGwgY29sdW1ucywgdXNpbmcgdGhlIGB0YXJnZXRzYCBwcm9wZXJ0eSBvZlxuICAgICAgICAgICAgICogZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBUaGlzIGFsbG93cyBncmVhdCBmbGV4aWJpbGl0eSB3aGVuIGNyZWF0aW5nXG4gICAgICAgICAgICAgKiB0YWJsZXMsIGFzIHRoZSBgY29sdW1uRGVmc2AgYXJyYXlzIGNhbiBiZSBvZiBhbnkgbGVuZ3RoLCB0YXJnZXRpbmcgdGhlXG4gICAgICAgICAgICAgKiBjb2x1bW5zIHlvdSBzcGVjaWZpY2FsbHkgd2FudC4gYGNvbHVtbkRlZnNgIG1heSB1c2UgYW55IG9mIHRoZSBjb2x1bW5cbiAgICAgICAgICAgICAqIG9wdGlvbnMgYXZhaWxhYmxlOiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbn0sIGJ1dCBpdCBfbXVzdF9cbiAgICAgICAgICAgICAqIGhhdmUgYHRhcmdldHNgIGRlZmluZWQgaW4gZWFjaCBvYmplY3QgaW4gdGhlIGFycmF5LiBWYWx1ZXMgaW4gdGhlIGB0YXJnZXRzYFxuICAgICAgICAgICAgICogYXJyYXkgbWF5IGJlOlxuICAgICAgICAgICAgICogICA8dWw+XG4gICAgICAgICAgICAgKiAgICAgPGxpPmEgc3RyaW5nIC0gY2xhc3MgbmFtZSB3aWxsIGJlIG1hdGNoZWQgb24gdGhlIFRIIGZvciB0aGUgY29sdW1uPC9saT5cbiAgICAgICAgICAgICAqICAgICA8bGk+MCBvciBhIHBvc2l0aXZlIGludGVnZXIgLSBjb2x1bW4gaW5kZXggY291bnRpbmcgZnJvbSB0aGUgbGVmdDwvbGk+XG4gICAgICAgICAgICAgKiAgICAgPGxpPmEgbmVnYXRpdmUgaW50ZWdlciAtIGNvbHVtbiBpbmRleCBjb3VudGluZyBmcm9tIHRoZSByaWdodDwvbGk+XG4gICAgICAgICAgICAgKiAgICAgPGxpPnRoZSBzdHJpbmcgXCJfYWxsXCIgLSBhbGwgY29sdW1ucyAoaS5lLiBhc3NpZ24gYSBkZWZhdWx0KTwvbGk+XG4gICAgICAgICAgICAgKiAgIDwvdWw+XG4gICAgICAgICAgICAgKiAgQG1lbWJlclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uRGVmc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvQ29sdW1uRGVmc1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmFzaWNhbGx5IHRoZSBzYW1lIGFzIGBzZWFyY2hgLCB0aGlzIHBhcmFtZXRlciBkZWZpbmVzIHRoZSBpbmRpdmlkdWFsIGNvbHVtblxuICAgICAgICAgICAgICogZmlsdGVyaW5nIHN0YXRlIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuIFRoZSBhcnJheSBtdXN0IGJlIG9mIHRoZSBzYW1lIHNpemVcbiAgICAgICAgICAgICAqIGFzIHRoZSBudW1iZXIgb2YgY29sdW1ucywgYW5kIGVhY2ggZWxlbWVudCBiZSBhbiBvYmplY3Qgd2l0aCB0aGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICogYHNlYXJjaGAgYW5kIGBlc2NhcGVSZWdleGAgKHRoZSBsYXR0ZXIgaXMgb3B0aW9uYWwpLiAnbnVsbCcgaXMgYWxzb1xuICAgICAgICAgICAgICogYWNjZXB0ZWQgYW5kIHRoZSBkZWZhdWx0IHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2VhcmNoQ29sc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoQ29sc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIk15IGZpbHRlclwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInNlYXJjaFwiOiBcIl5bMC05XVwiLCBcImVzY2FwZVJlZ2V4XCI6IGZhbHNlIH1cbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvU2VhcmNoQ29sc1wiOiBbXSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIGFycmF5IG9mIENTUyBjbGFzc2VzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gZGlzcGxheWVkIHJvd3MuIFRoaXNcbiAgICAgICAgICAgICAqIGFycmF5IG1heSBiZSBvZiBhbnkgbGVuZ3RoLCBhbmQgRGF0YVRhYmxlcyB3aWxsIGFwcGx5IGVhY2ggY2xhc3NcbiAgICAgICAgICAgICAqIHNlcXVlbnRpYWxseSwgbG9vcGluZyB3aGVuIHJlcXVpcmVkLlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5XaWxsIHRha2UgdGhlIHZhbHVlcyBkZXRlcm1pbmVkIGJ5IHRoZSBgb0NsYXNzZXMuc3RyaXBlKmBcbiAgICAgICAgICAgICAqICAgIG9wdGlvbnM8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25cbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RyaXBlQ2xhc3Nlc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic3RyaXBlQ2xhc3Nlc1wiOiBbICdzdHJpcDEnLCAnc3RyaXAyJywgJ3N0cmlwMycgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9IClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGF1dG9tYXRpYyBjb2x1bW4gd2lkdGggY2FsY3VsYXRpb24uIFRoaXMgY2FuIGJlIGRpc2FibGVkXG4gICAgICAgICAgICAgKiBhcyBhbiBvcHRpbWlzYXRpb24gKGl0IHRha2VzIHNvbWUgdGltZSB0byBjYWxjdWxhdGUgdGhlIHdpZHRocykgaWYgdGhlXG4gICAgICAgICAgICAgKiB0YWJsZXMgd2lkdGhzIGFyZSBwYXNzZWQgaW4gdXNpbmcgYGNvbHVtbnNgLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hdXRvV2lkdGhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJhdXRvV2lkdGhcIjogZmFsc2VcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJBdXRvV2lkdGhcIjogdHJ1ZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlZmVycmVkIHJlbmRlcmluZyBjYW4gcHJvdmlkZSBEYXRhVGFibGVzIHdpdGggYSBodWdlIHNwZWVkIGJvb3N0IHdoZW4geW91XG4gICAgICAgICAgICAgKiBhcmUgdXNpbmcgYW4gQWpheCBvciBKUyBkYXRhIHNvdXJjZSBmb3IgdGhlIHRhYmxlLiBUaGlzIG9wdGlvbiwgd2hlbiBzZXQgdG9cbiAgICAgICAgICAgICAqIHRydWUsIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBkZWZlciB0aGUgY3JlYXRpb24gb2YgdGhlIHRhYmxlIGVsZW1lbnRzIGZvclxuICAgICAgICAgICAgICogZWFjaCByb3cgdW50aWwgdGhleSBhcmUgbmVlZGVkIGZvciBhIGRyYXcgLSBzYXZpbmcgYSBzaWduaWZpY2FudCBhbW91bnQgb2ZcbiAgICAgICAgICAgICAqIHRpbWUuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5kZWZlclJlbmRlclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInNvdXJjZXMvYXJyYXlzLnR4dFwiLFxuICAgICAgICAgICAgICogICAgICAgIFwiZGVmZXJSZW5kZXJcIjogdHJ1ZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYkRlZmVyUmVuZGVyXCI6IGZhbHNlLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwbGFjZSBhIERhdGFUYWJsZSB3aGljaCBtYXRjaGVzIHRoZSBnaXZlbiBzZWxlY3RvciBhbmQgcmVwbGFjZSBpdCB3aXRoXG4gICAgICAgICAgICAgKiBvbmUgd2hpY2ggaGFzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBuZXcgaW5pdGlhbGlzYXRpb24gb2JqZWN0IHBhc3NlZC4gSWYgbm9cbiAgICAgICAgICAgICAqIHRhYmxlIG1hdGNoZXMgdGhlIHNlbGVjdG9yLCB0aGVuIHRoZSBuZXcgRGF0YVRhYmxlIHdpbGwgYmUgY29uc3RydWN0ZWQgYXNcbiAgICAgICAgICAgICAqIHBlciBub3JtYWwuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlc3Ryb3lcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInNyb2xsWVwiOiBcIjIwMHB4XCIsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgICAvLyBTb21lIHRpbWUgbGF0ZXIuLi4uXG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJmaWx0ZXJcIjogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJkZXN0cm95XCI6IHRydWVcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJEZXN0cm95XCI6IGZhbHNlLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgZmlsdGVyaW5nIG9mIGRhdGEuIEZpbHRlcmluZyBpbiBEYXRhVGFibGVzIGlzIFwic21hcnRcIiBpblxuICAgICAgICAgICAgICogdGhhdCBpdCBhbGxvd3MgdGhlIGVuZCB1c2VyIHRvIGlucHV0IG11bHRpcGxlIHdvcmRzIChzcGFjZSBzZXBhcmF0ZWQpIGFuZFxuICAgICAgICAgICAgICogd2lsbCBtYXRjaCBhIHJvdyBjb250YWluaW5nIHRob3NlIHdvcmRzLCBldmVuIGlmIG5vdCBpbiB0aGUgb3JkZXIgdGhhdCB3YXNcbiAgICAgICAgICAgICAqIHNwZWNpZmllZCAodGhpcyBhbGxvdyBtYXRjaGluZyBhY3Jvc3MgbXVsdGlwbGUgY29sdW1ucykuIE5vdGUgdGhhdCBpZiB5b3VcbiAgICAgICAgICAgICAqIHdpc2ggdG8gdXNlIGZpbHRlcmluZyBpbiBEYXRhVGFibGVzIHRoaXMgbXVzdCByZW1haW4gJ3RydWUnIC0gdG8gcmVtb3ZlIHRoZVxuICAgICAgICAgICAgICogZGVmYXVsdCBmaWx0ZXJpbmcgaW5wdXQgYm94IGFuZCByZXRhaW4gZmlsdGVyaW5nIGFiaWxpdGllcywgcGxlYXNlIHVzZVxuICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0cy5kb219LlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZWFyY2hpbmdcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZWFyY2hpbmdcIjogZmFsc2VcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJGaWx0ZXJcIjogdHJ1ZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSB0YWJsZSBpbmZvcm1hdGlvbiBkaXNwbGF5LiBUaGlzIHNob3dzIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgKiBhYm91dCB0aGUgZGF0YSB0aGF0IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9uIHRoZSBwYWdlLCBpbmNsdWRpbmcgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAqIGFib3V0IGZpbHRlcmVkIGRhdGEgaWYgdGhhdCBhY3Rpb24gaXMgYmVpbmcgcGVyZm9ybWVkLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5pbmZvXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiaW5mb1wiOiBmYWxzZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYkluZm9cIjogdHJ1ZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFsbG93cyB0aGUgZW5kIHVzZXIgdG8gc2VsZWN0IHRoZSBzaXplIG9mIGEgZm9ybWF0dGVkIHBhZ2UgZnJvbSBhIHNlbGVjdFxuICAgICAgICAgICAgICogbWVudSAoc2l6ZXMgYXJlIDEwLCAyNSwgNTAgYW5kIDEwMCkuIFJlcXVpcmVzIHBhZ2luYXRpb24gKGBwYWdpbmF0ZWApLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sZW5ndGhDaGFuZ2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJsZW5ndGhDaGFuZ2VcIjogZmFsc2VcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJMZW5ndGhDaGFuZ2VcIjogdHJ1ZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHBhZ2luYXRpb24uXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInBhZ2luZ1wiOiBmYWxzZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlBhZ2luYXRlXCI6IHRydWUsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSB0aGUgZGlzcGxheSBvZiBhICdwcm9jZXNzaW5nJyBpbmRpY2F0b3Igd2hlbiB0aGUgdGFibGUgaXNcbiAgICAgICAgICAgICAqIGJlaW5nIHByb2Nlc3NlZCAoZS5nLiBhIHNvcnQpLiBUaGlzIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHRhYmxlcyB3aXRoXG4gICAgICAgICAgICAgKiBsYXJnZSBhbW91bnRzIG9mIGRhdGEgd2hlcmUgaXQgY2FuIHRha2UgYSBub3RpY2VhYmxlIGFtb3VudCBvZiB0aW1lIHRvIHNvcnRcbiAgICAgICAgICAgICAqIHRoZSBlbnRyaWVzLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJvY2Vzc2luZ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInByb2Nlc3NpbmdcIjogdHJ1ZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlByb2Nlc3NpbmdcIjogZmFsc2UsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXRyaWV2ZSB0aGUgRGF0YVRhYmxlcyBvYmplY3QgZm9yIHRoZSBnaXZlbiBzZWxlY3Rvci4gTm90ZSB0aGF0IGlmIHRoZVxuICAgICAgICAgICAgICogdGFibGUgaGFzIGFscmVhZHkgYmVlbiBpbml0aWFsaXNlZCwgdGhpcyBwYXJhbWV0ZXIgd2lsbCBjYXVzZSBEYXRhVGFibGVzXG4gICAgICAgICAgICAgKiB0byBzaW1wbHkgcmV0dXJuIHRoZSBvYmplY3QgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNldCB1cCAtIGl0IHdpbGwgbm90IHRha2VcbiAgICAgICAgICAgICAqIGFjY291bnQgb2YgYW55IGNoYW5nZXMgeW91IG1pZ2h0IGhhdmUgbWFkZSB0byB0aGUgaW5pdGlhbGlzYXRpb24gb2JqZWN0XG4gICAgICAgICAgICAgKiBwYXNzZWQgdG8gRGF0YVRhYmxlcyAoc2V0dGluZyB0aGlzIHBhcmFtZXRlciB0byB0cnVlIGlzIGFuIGFja25vd2xlZGdlbWVudFxuICAgICAgICAgICAgICogdGhhdCB5b3UgdW5kZXJzdGFuZCB0aGlzKS4gYGRlc3Ryb3lgIGNhbiBiZSB1c2VkIHRvIHJlaW5pdGlhbGlzZSBhIHRhYmxlIGlmXG4gICAgICAgICAgICAgKiB5b3UgbmVlZC5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmV0cmlldmVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgaW5pdFRhYmxlKCk7XG4gICAgICAgICAgICAgKiAgICAgIHRhYmxlQWN0aW9ucygpO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgIGZ1bmN0aW9uIGluaXRUYWJsZSAoKVxuICAgICAgICAgICAgICogICAge1xuICAgICAgICAgICAgICogICAgICByZXR1cm4gJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFlcIjogXCIyMDBweFwiLFxuICAgICAgICAgICAgICogICAgICAgIFwicGFnaW5hdGVcIjogZmFsc2UsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJyZXRyaWV2ZVwiOiB0cnVlXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH1cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgICBmdW5jdGlvbiB0YWJsZUFjdGlvbnMgKClcbiAgICAgICAgICAgICAqICAgIHtcbiAgICAgICAgICAgICAqICAgICAgdmFyIHRhYmxlID0gaW5pdFRhYmxlKCk7XG4gICAgICAgICAgICAgKiAgICAgIC8vIHBlcmZvcm0gQVBJIG9wZXJhdGlvbnMgd2l0aCBvVGFibGVcbiAgICAgICAgICAgICAqICAgIH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiUmV0cmlldmVcIjogZmFsc2UsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHZlcnRpY2FsICh5KSBzY3JvbGxpbmcgaXMgZW5hYmxlZCwgRGF0YVRhYmxlcyB3aWxsIGZvcmNlIHRoZSBoZWlnaHQgb2ZcbiAgICAgICAgICAgICAqIHRoZSB0YWJsZSdzIHZpZXdwb3J0IHRvIHRoZSBnaXZlbiBoZWlnaHQgYXQgYWxsIHRpbWVzICh1c2VmdWwgZm9yIGxheW91dCkuXG4gICAgICAgICAgICAgKiBIb3dldmVyLCB0aGlzIGNhbiBsb29rIG9kZCB3aGVuIGZpbHRlcmluZyBkYXRhIGRvd24gdG8gYSBzbWFsbCBkYXRhIHNldCxcbiAgICAgICAgICAgICAqIGFuZCB0aGUgZm9vdGVyIGlzIGxlZnQgXCJmbG9hdGluZ1wiIGZ1cnRoZXIgZG93bi4gVGhpcyBwYXJhbWV0ZXIgKHdoZW5cbiAgICAgICAgICAgICAqIGVuYWJsZWQpIHdpbGwgY2F1c2UgRGF0YVRhYmxlcyB0byBjb2xsYXBzZSB0aGUgdGFibGUncyB2aWV3cG9ydCBkb3duIHdoZW5cbiAgICAgICAgICAgICAqIHRoZSByZXN1bHQgc2V0IHdpbGwgZml0IHdpdGhpbiB0aGUgZ2l2ZW4gWSBoZWlnaHQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbENvbGxhcHNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxZXCI6IFwiMjAwXCIsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzY3JvbGxDb2xsYXBzZVwiOiB0cnVlXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiU2Nyb2xsQ29sbGFwc2VcIjogZmFsc2UsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25maWd1cmUgRGF0YVRhYmxlcyB0byB1c2Ugc2VydmVyLXNpZGUgcHJvY2Vzc2luZy4gTm90ZSB0aGF0IHRoZVxuICAgICAgICAgICAgICogYGFqYXhgIHBhcmFtZXRlciBtdXN0IGFsc28gYmUgZ2l2ZW4gaW4gb3JkZXIgdG8gZ2l2ZSBEYXRhVGFibGVzIGFcbiAgICAgICAgICAgICAqIHNvdXJjZSB0byBvYnRhaW4gdGhlIHJlcXVpcmVkIGRhdGEgZm9yIGVhY2ggZHJhdy5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IEZlYXR1cmVzXG4gICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlclNpZGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZXJ2ZXJTaWRlXCI6IHRydWUsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJhamF4XCI6IFwieGhyLnBocFwiXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiU2VydmVyU2lkZVwiOiBmYWxzZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHNvcnRpbmcgb2YgY29sdW1ucy4gU29ydGluZyBvZiBpbmRpdmlkdWFsIGNvbHVtbnMgY2FuIGJlXG4gICAgICAgICAgICAgKiBkaXNhYmxlZCBieSB0aGUgYHNvcnRhYmxlYCBvcHRpb24gZm9yIGVhY2ggY29sdW1uLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlcmluZ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyaW5nXCI6IGZhbHNlXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiU29ydFwiOiB0cnVlLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc3BsYXkgRGF0YVRhYmxlcycgYWJpbGl0eSB0byBzb3J0IG11bHRpcGxlIGNvbHVtbnMgYXQgdGhlXG4gICAgICAgICAgICAgKiBzYW1lIHRpbWUgKGFjdGl2YXRlZCBieSBzaGlmdC1jbGljayBieSB0aGUgdXNlcikuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMub3JkZXJNdWx0aVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gRGlzYWJsZSBtdWx0aXBsZSBjb2x1bW4gc29ydGluZyBhYmlsaXR5XG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwib3JkZXJNdWx0aVwiOiBmYWxzZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiOiB0cnVlLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWxsb3dzIGNvbnRyb2wgb3ZlciB3aGV0aGVyIERhdGFUYWJsZXMgc2hvdWxkIHVzZSB0aGUgdG9wICh0cnVlKSB1bmlxdWVcbiAgICAgICAgICAgICAqIGNlbGwgdGhhdCBpcyBmb3VuZCBmb3IgYSBzaW5nbGUgY29sdW1uLCBvciB0aGUgYm90dG9tIChmYWxzZSAtIGRlZmF1bHQpLlxuICAgICAgICAgICAgICogVGhpcyBpcyB1c2VmdWwgd2hlbiB1c2luZyBjb21wbGV4IGhlYWRlcnMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLm9yZGVyQ2VsbHNUb3BcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcIm9yZGVyQ2VsbHNUb3BcIjogdHJ1ZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlNvcnRDZWxsc1RvcFwiOiBmYWxzZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBhZGRpdGlvbiBvZiB0aGUgY2xhc3NlcyBgc29ydGluZ1xcXzFgLCBgc29ydGluZ1xcXzJgIGFuZFxuICAgICAgICAgICAgICogYHNvcnRpbmdcXF8zYCB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGJlaW5nIHNvcnRlZCBvbi4gVGhpcyBpc1xuICAgICAgICAgICAgICogcHJlc2VudGVkIGFzIGEgZmVhdHVyZSBzd2l0Y2ggYXMgaXQgY2FuIGluY3JlYXNlIHByb2Nlc3NpbmcgdGltZSAod2hpbGVcbiAgICAgICAgICAgICAqIGNsYXNzZXMgYXJlIHJlbW92ZWQgYW5kIGFkZGVkKSBzbyBmb3IgbGFyZ2UgZGF0YSBzZXRzIHlvdSBtaWdodCB3YW50IHRvXG4gICAgICAgICAgICAgKiB0dXJuIHRoaXMgb2ZmLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBGZWF0dXJlc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5vcmRlckNsYXNzZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJvcmRlckNsYXNzZXNcIjogZmFsc2VcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJTb3J0Q2xhc3Nlc1wiOiB0cnVlLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5hYmxlIG9yIGRpc2FibGUgc3RhdGUgc2F2aW5nLiBXaGVuIGVuYWJsZWQgSFRNTDUgYGxvY2FsU3RvcmFnZWAgd2lsbCBiZVxuICAgICAgICAgICAgICogdXNlZCB0byBzYXZlIHRhYmxlIGRpc3BsYXkgaW5mb3JtYXRpb24gc3VjaCBhcyBwYWdpbmF0aW9uIGluZm9ybWF0aW9uLFxuICAgICAgICAgICAgICogZGlzcGxheSBsZW5ndGgsIGZpbHRlcmluZyBhbmQgc29ydGluZy4gQXMgc3VjaCB3aGVuIHRoZSBlbmQgdXNlciByZWxvYWRzXG4gICAgICAgICAgICAgKiB0aGUgcGFnZSB0aGUgZGlzcGxheSBkaXNwbGF5IHdpbGwgbWF0Y2ggd2hhdCB0aHkgaGFkIHByZXZpb3VzbHkgc2V0IHVwLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIER1ZSB0byB0aGUgdXNlIG9mIGBsb2NhbFN0b3JhZ2VgIHRoZSBkZWZhdWx0IHN0YXRlIHNhdmluZyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAgKiBpbiBJRTYgb3IgNy4gSWYgc3RhdGUgc2F2aW5nIGlzIHJlcXVpcmVkIGluIHRob3NlIGJyb3dzZXJzLCB1c2VcbiAgICAgICAgICAgICAqIGBzdGF0ZVNhdmVDYWxsYmFja2AgdG8gcHJvdmlkZSBhIHN0b3JhZ2Ugc29sdXRpb24gc3VjaCBhcyBjb29raWVzLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVTYXZlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWVcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJTdGF0ZVNhdmVcIjogZmFsc2UsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aGVuIGEgVFIgZWxlbWVudCBpcyBjcmVhdGVkIChhbmQgYWxsIFREIGNoaWxkXG4gICAgICAgICAgICAgKiBlbGVtZW50cyBoYXZlIGJlZW4gaW5zZXJ0ZWQpLCBvciByZWdpc3RlcmVkIGlmIHVzaW5nIGEgRE9NIHNvdXJjZSwgYWxsb3dpbmdcbiAgICAgICAgICAgICAqIG1hbmlwdWxhdGlvbiBvZiB0aGUgVFIgZWxlbWVudCAoYWRkaW5nIGNsYXNzZXMgZXRjKS5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7bm9kZX0gcm93IFwiVFJcIiBlbGVtZW50IGZvciB0aGUgY3VycmVudCByb3dcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIFJhdyBkYXRhIGFycmF5IGZvciB0aGlzIHJvd1xuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBkYXRhSW5kZXggVGhlIGluZGV4IG9mIHRoaXMgcm93IGluIHRoZSBpbnRlcm5hbCBhb0RhdGEgYXJyYXlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jcmVhdGVkUm93XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjcmVhdGVkUm93XCI6IGZ1bmN0aW9uKCByb3csIGRhdGEsIGRhdGFJbmRleCApIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIC8vIEJvbGQgdGhlIGdyYWRlIGZvciBhbGwgJ0EnIGdyYWRlIGJyb3dzZXJzXG4gICAgICAgICAgICAgKiAgICAgICAgICBpZiAoIGRhdGFbNF0gPT0gXCJBXCIgKVxuICAgICAgICAgICAgICogICAgICAgICAge1xuICAgICAgICAgICAgICogICAgICAgICAgICAkKCd0ZDplcSg0KScsIHJvdykuaHRtbCggJzxiPkE8L2I+JyApO1xuICAgICAgICAgICAgICogICAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuQ3JlYXRlZFJvd1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZXZlcnkgJ2RyYXcnIGV2ZW50LCBhbmQgYWxsb3dzIHlvdSB0b1xuICAgICAgICAgICAgICogZHluYW1pY2FsbHkgbW9kaWZ5IGFueSBhc3BlY3QgeW91IHdhbnQgYWJvdXQgdGhlIGNyZWF0ZWQgRE9NLlxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZHJhd0NhbGxiYWNrXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJkcmF3Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuICAgICAgICAgICAgICogICAgICAgICAgYWxlcnQoICdEYXRhVGFibGVzIGhhcyByZWRyYXduIHRoZSB0YWJsZScgKTtcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmbkRyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWRlbnRpY2FsIHRvIGZuSGVhZGVyQ2FsbGJhY2soKSBidXQgZm9yIHRoZSB0YWJsZSBmb290ZXIgdGhpcyBmdW5jdGlvblxuICAgICAgICAgICAgICogYWxsb3dzIHlvdSB0byBtb2RpZnkgdGhlIHRhYmxlIGZvb3RlciBvbiBldmVyeSAnZHJhdycgZXZlbnQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IGZvb3QgXCJUUlwiIGVsZW1lbnQgZm9yIHRoZSBmb290ZXJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEZ1bGwgdGFibGUgZGF0YSAoYXMgZGVyaXZlZCBmcm9tIHRoZSBvcmlnaW5hbCBIVE1MKVxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBzdGFydCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBzdGFydGluZyBwb2ludCBpbiB0aGVcbiAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZW5kIEluZGV4IGZvciB0aGUgY3VycmVudCBkaXNwbGF5IGVuZGluZyBwb2ludCBpbiB0aGVcbiAgICAgICAgICAgICAqICAgIGRpc3BsYXkgYXJyYXlcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5IGludH0gZGlzcGxheSBJbmRleCBhcnJheSB0byB0cmFuc2xhdGUgdGhlIHZpc3VhbCBwb3NpdGlvblxuICAgICAgICAgICAgICogICAgdG8gdGhlIGZ1bGwgZGF0YSBhcnJheVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvb3RlckNhbGxiYWNrXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJmb290ZXJDYWxsYmFja1wiOiBmdW5jdGlvbiggdGZvb3QsIGRhdGEsIHN0YXJ0LCBlbmQsIGRpc3BsYXkgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICB0Zm9vdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIlN0YXJ0aW5nIGluZGV4IGlzIFwiK3N0YXJ0O1xuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5Gb290ZXJDYWxsYmFja1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiByZW5kZXJpbmcgbGFyZ2UgbnVtYmVycyBpbiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAgICAgKiAoaS5lLiBcIlNob3dpbmcgMSB0byAxMCBvZiA1NyBlbnRyaWVzXCIpIERhdGFUYWJsZXMgd2lsbCByZW5kZXIgbGFyZ2UgbnVtYmVyc1xuICAgICAgICAgICAgICogdG8gaGF2ZSBhIGNvbW1hIHNlcGFyYXRvciBmb3IgdGhlICd0aG91c2FuZHMnIHVuaXRzIChlLmcuIDEgbWlsbGlvbiBpc1xuICAgICAgICAgICAgICogcmVuZGVyZWQgYXMgXCIxLDAwMCwwMDBcIikgdG8gaGVscCByZWFkYWJpbGl0eSBmb3IgdGhlIGVuZCB1c2VyLiBUaGlzXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG1ldGhvZCBEYXRhVGFibGVzIHVzZXMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAbWVtYmVyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHRvRm9ybWF0IG51bWJlciB0byBiZSBmb3JtYXR0ZWRcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7c3RyaW5nfSBmb3JtYXR0ZWQgc3RyaW5nIGZvciBEYXRhVGFibGVzIHRvIHNob3cgdGhlIG51bWJlclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmZvcm1hdE51bWJlclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gRm9ybWF0IGEgbnVtYmVyIHVzaW5nIGEgc2luZ2xlIHF1b3RlIGZvciB0aGUgc2VwYXJhdG9yIChub3RlIHRoYXRcbiAgICAgICAgICAgICAqICAgIC8vIHRoaXMgY2FuIGFsc28gYmUgZG9uZSB3aXRoIHRoZSBsYW5ndWFnZS50aG91c2FuZHMgb3B0aW9uKVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiZm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICggdG9Gb3JtYXQgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdG9Gb3JtYXQudG9TdHJpbmcoKS5yZXBsYWNlKFxuICAgICAgICAgICAgICogICAgICAgICAgICAvXFxCKD89KFxcZHszfSkrKD8hXFxkKSkvZywgXCInXCJcbiAgICAgICAgICAgICAqICAgICAgICAgICk7XG4gICAgICAgICAgICAgKiAgICAgICAgfTtcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuRm9ybWF0TnVtYmVyXCI6IGZ1bmN0aW9uICh0b0Zvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b0Zvcm1hdC50b1N0cmluZygpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgIC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9MYW5ndWFnZS5zVGhvdXNhbmRzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBldmVyeSAnZHJhdycgZXZlbnQsIGFuZCBhbGxvd3MgeW91IHRvXG4gICAgICAgICAgICAgKiBkeW5hbWljYWxseSBtb2RpZnkgdGhlIGhlYWRlciByb3cuIFRoaXMgY2FuIGJlIHVzZWQgdG8gY2FsY3VsYXRlIGFuZFxuICAgICAgICAgICAgICogZGlzcGxheSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlLlxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtub2RlfSBoZWFkIFwiVFJcIiBlbGVtZW50IGZvciB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBGdWxsIHRhYmxlIGRhdGEgKGFzIGRlcml2ZWQgZnJvbSB0aGUgb3JpZ2luYWwgSFRNTClcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gc3RhcnQgSW5kZXggZm9yIHRoZSBjdXJyZW50IGRpc3BsYXkgc3RhcnRpbmcgcG9pbnQgaW4gdGhlXG4gICAgICAgICAgICAgKiAgICBkaXNwbGF5IGFycmF5XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGVuZCBJbmRleCBmb3IgdGhlIGN1cnJlbnQgZGlzcGxheSBlbmRpbmcgcG9pbnQgaW4gdGhlXG4gICAgICAgICAgICAgKiAgICBkaXNwbGF5IGFycmF5XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheSBpbnR9IGRpc3BsYXkgSW5kZXggYXJyYXkgdG8gdHJhbnNsYXRlIHRoZSB2aXN1YWwgcG9zaXRpb25cbiAgICAgICAgICAgICAqICAgIHRvIHRoZSBmdWxsIGRhdGEgYXJyYXlcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5oZWFkZXJDYWxsYmFja1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiZmhlYWRlckNhbGxiYWNrXCI6IGZ1bmN0aW9uKCBoZWFkLCBkYXRhLCBzdGFydCwgZW5kLCBkaXNwbGF5ICkge1xuICAgICAgICAgICAgICogICAgICAgICAgaGVhZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgndGgnKVswXS5pbm5lckhUTUwgPSBcIkRpc3BsYXlpbmcgXCIrKGVuZC1zdGFydCkrXCIgcmVjb3Jkc1wiO1xuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5IZWFkZXJDYWxsYmFja1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGluZm9ybWF0aW9uIGVsZW1lbnQgY2FuIGJlIHVzZWQgdG8gY29udmV5IGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50XG4gICAgICAgICAgICAgKiBzdGF0ZSBvZiB0aGUgdGFibGUuIEFsdGhvdWdoIHRoZSBpbnRlcm5hdGlvbmFsaXNhdGlvbiBvcHRpb25zIHByZXNlbnRlZCBieVxuICAgICAgICAgICAgICogRGF0YVRhYmxlcyBhcmUgcXVpdGUgY2FwYWJsZSBvZiBkZWFsaW5nIHdpdGggbW9zdCBjdXN0b21pc2F0aW9ucywgdGhlcmUgbWF5XG4gICAgICAgICAgICAgKiBiZSB0aW1lcyB3aGVyZSB5b3Ugd2lzaCB0byBjdXN0b21pc2UgdGhlIHN0cmluZyBmdXJ0aGVyLiBUaGlzIGNhbGxiYWNrXG4gICAgICAgICAgICAgKiBhbGxvd3MgeW91IHRvIGRvIGV4YWN0bHkgdGhhdC5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gc3RhcnQgU3RhcnRpbmcgcG9zaXRpb24gaW4gZGF0YSBmb3IgdGhlIGRyYXdcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZW5kIEVuZCBwb3NpdGlvbiBpbiBkYXRhIGZvciB0aGUgZHJhd1xuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBtYXggVG90YWwgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHRhYmxlIChyZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAgKiAgICBmaWx0ZXJpbmcpXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IHRvdGFsIFRvdGFsIG51bWJlciBvZiByb3dzIGluIHRoZSBkYXRhIHNldCwgYWZ0ZXIgZmlsdGVyaW5nXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtzdHJpbmd9IHByZSBUaGUgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBoYXMgZm9ybWF0dGVkIHVzaW5nIGl0J3NcbiAgICAgICAgICAgICAqICAgIG93biBydWxlc1xuICAgICAgICAgICAgICogIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBpbmZvcm1hdGlvbiBlbGVtZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluZm9DYWxsYmFja1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgXCJpbmZvQ2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzLCBzdGFydCwgZW5kLCBtYXgsIHRvdGFsLCBwcmUgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIHN0YXJ0ICtcIiB0byBcIisgZW5kO1xuICAgICAgICAgICAgICogICAgICB9XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5JbmZvQ2FsbGJhY2tcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxlZCB3aGVuIHRoZSB0YWJsZSBoYXMgYmVlbiBpbml0aWFsaXNlZC4gTm9ybWFsbHkgRGF0YVRhYmxlcyB3aWxsXG4gICAgICAgICAgICAgKiBpbml0aWFsaXNlIHNlcXVlbnRpYWxseSBhbmQgdGhlcmUgd2lsbCBiZSBubyBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uLFxuICAgICAgICAgICAgICogaG93ZXZlciwgdGhpcyBkb2VzIG5vdCBob2xkIHRydWUgd2hlbiB1c2luZyBleHRlcm5hbCBsYW5ndWFnZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICogc2luY2UgdGhhdCBpcyBvYnRhaW5lZCB1c2luZyBhbiBhc3luYyBYSFIgY2FsbC5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcbiAgICAgICAgICAgICAqICAgIHByZXNlbnQgaWYgY2xpZW50LXNpZGUgQWpheCBzb3VyY2VkIGRhdGEgaXMgdXNlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmluaXRDb21wbGV0ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiaW5pdENvbXBsZXRlXCI6IGZ1bmN0aW9uKHNldHRpbmdzLCBqc29uKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBhbGVydCggJ0RhdGFUYWJsZXMgaGFzIGZpbmlzaGVkIGl0cyBpbml0aWFsaXNhdGlvbi4nICk7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9IClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmbkluaXRDb21wbGV0ZVwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGVkIGF0IHRoZSB2ZXJ5IHN0YXJ0IG9mIGVhY2ggdGFibGUgZHJhdyBhbmQgY2FuIGJlIHVzZWQgdG8gY2FuY2VsIHRoZVxuICAgICAgICAgICAgICogZHJhdyBieSByZXR1cm5pbmcgZmFsc2UsIGFueSBvdGhlciByZXR1cm4gKGluY2x1ZGluZyB1bmRlZmluZWQpIHJlc3VsdHMgaW5cbiAgICAgICAgICAgICAqIHRoZSBmdWxsIGRyYXcgb2NjdXJyaW5nKS5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgICogIEByZXR1cm5zIHtib29sZWFufSBGYWxzZSB3aWxsIGNhbmNlbCB0aGUgZHJhdywgYW55dGhpbmcgZWxzZSAoaW5jbHVkaW5nIG5vXG4gICAgICAgICAgICAgKiAgICByZXR1cm4pIHdpbGwgYWxsb3cgaXQgdG8gY29tcGxldGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucHJlRHJhd0NhbGxiYWNrXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJwcmVEcmF3Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuICAgICAgICAgICAgICogICAgICAgICAgaWYgKCAkKCcjdGVzdCcpLnZhbCgpID09IDEgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmblByZURyYXdDYWxsYmFja1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBmdW5jdGlvbiBhbGxvd3MgeW91IHRvICdwb3N0IHByb2Nlc3MnIGVhY2ggcm93IGFmdGVyIGl0IGhhdmUgYmVlblxuICAgICAgICAgICAgICogZ2VuZXJhdGVkIGZvciBlYWNoIHRhYmxlIGRyYXcsIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgb24gc2NyZWVuLiBUaGlzXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBtaWdodCBiZSB1c2VkIGZvciBzZXR0aW5nIHRoZSByb3cgY2xhc3MgbmFtZSBldGMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAcGFyYW0ge25vZGV9IHJvdyBcIlRSXCIgZWxlbWVudCBmb3IgdGhlIGN1cnJlbnQgcm93XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheX0gZGF0YSBSYXcgZGF0YSBhcnJheSBmb3IgdGhpcyByb3dcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gZGlzcGxheUluZGV4IFRoZSBkaXNwbGF5IGluZGV4IGZvciB0aGUgY3VycmVudCB0YWJsZSBkcmF3XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtpbnR9IGRpc3BsYXlJbmRleEZ1bGwgVGhlIGluZGV4IG9mIHRoZSBkYXRhIGluIHRoZSBmdWxsIGxpc3Qgb2ZcbiAgICAgICAgICAgICAqICAgIHJvd3MgKGFmdGVyIGZpbHRlcmluZylcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5yb3dDYWxsYmFja1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwicm93Q2FsbGJhY2tcIjogZnVuY3Rpb24oIHJvdywgZGF0YSwgZGlzcGxheUluZGV4LCBkaXNwbGF5SW5kZXhGdWxsICkge1xuICAgICAgICAgICAgICogICAgICAgICAgLy8gQm9sZCB0aGUgZ3JhZGUgZm9yIGFsbCAnQScgZ3JhZGUgYnJvd3NlcnNcbiAgICAgICAgICAgICAqICAgICAgICAgIGlmICggZGF0YVs0XSA9PSBcIkFcIiApIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgJCgndGQ6ZXEoNCknLCByb3cpLmh0bWwoICc8Yj5BPC9iPicgKTtcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmblJvd0NhbGxiYWNrXCI6IG51bGwsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cbiAgICAgICAgICAgICAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IGZ1bmN0aW9uIHdoaWNoIG9idGFpbnNcbiAgICAgICAgICAgICAqIHRoZSBkYXRhIGZyb20gdGhlIHNlcnZlciBzbyBzb21ldGhpbmcgbW9yZSBzdWl0YWJsZSBmb3IgeW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAqIEZvciBleGFtcGxlIHlvdSBjb3VsZCB1c2UgUE9TVCBkYXRhLCBvciBwdWxsIGluZm9ybWF0aW9uIGZyb20gYSBHZWFycyBvclxuICAgICAgICAgICAgICogQUlSIGRhdGFiYXNlLlxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQG1lbWJlclxuICAgICAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgSFRUUCBzb3VyY2UgdG8gb2J0YWluIHRoZSBkYXRhIGZyb20gKGBhamF4YClcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2FycmF5fSBkYXRhIEEga2V5L3ZhbHVlIHBhaXIgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGRhdGEgdG8gc2VuZFxuICAgICAgICAgICAgICogICAgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgICogIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBjb21wbGV0aW9uIG9mIHRoZSBkYXRhIGdldFxuICAgICAgICAgICAgICogICAgcHJvY2VzcyB0aGF0IHdpbGwgZHJhdyB0aGUgZGF0YSBvbiB0aGUgcGFnZS5cbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xuICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJEYXRhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIDEuMTAuIFBsZWFzZSB1c2UgYGFqYXhgIGZvciB0aGlzIGZ1bmN0aW9uYWxpdHkgbm93LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuU2VydmVyRGF0YVwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogX19EZXByZWNhdGVkX18gVGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgYnkgdGhpcyBwYXJhbWV0ZXIgaGFzIG5vdyBiZWVuXG4gICAgICAgICAgICAgKiBzdXBlcnNlZGVkIGJ5IHRoYXQgcHJvdmlkZWQgdGhyb3VnaCBgYWpheGAsIHdoaWNoIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEl0IGlzIG9mdGVuIHVzZWZ1bCB0byBzZW5kIGV4dHJhIGRhdGEgdG8gdGhlIHNlcnZlciB3aGVuIG1ha2luZyBhbiBBamF4XG4gICAgICAgICAgICAgKiByZXF1ZXN0IC0gZm9yIGV4YW1wbGUgY3VzdG9tIGZpbHRlcmluZyBpbmZvcm1hdGlvbiwgYW5kIHRoaXMgY2FsbGJhY2tcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIG1ha2VzIGl0IHRyaXZpYWwgdG8gc2VuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgc2VydmVyLiBUaGVcbiAgICAgICAgICAgICAqIHBhc3NlZCBpbiBwYXJhbWV0ZXIgaXMgdGhlIGRhdGEgc2V0IHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnlcbiAgICAgICAgICAgICAqIERhdGFUYWJsZXMsIGFuZCB5b3UgY2FuIGFkZCB0byB0aGlzIG9yIG1vZGlmeSBpdCBhcyB5b3UgcmVxdWlyZS5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7YXJyYXl9IGRhdGEgRGF0YSBhcnJheSAoYXJyYXkgb2Ygb2JqZWN0cyB3aGljaCBhcmUgbmFtZS92YWx1ZVxuICAgICAgICAgICAgICogICAgcGFpcnMpIHRoYXQgaGFzIGJlZW4gY29uc3RydWN0ZWQgYnkgRGF0YVRhYmxlcyBhbmQgd2lsbCBiZSBzZW50IHRvIHRoZVxuICAgICAgICAgICAgICogICAgc2VydmVyLiBJbiB0aGUgY2FzZSBvZiBBamF4IHNvdXJjZWQgZGF0YSB3aXRoIHNlcnZlci1zaWRlIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAqICAgIHRoaXMgd2lsbCBiZSBhbiBlbXB0eSBhcnJheSwgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgdGhlcmUgd2lsbCBiZSBhXG4gICAgICAgICAgICAgKiAgICBzaWduaWZpY2FudCBudW1iZXIgb2YgcGFyYW1ldGVycyFcbiAgICAgICAgICAgICAqICBAcmV0dXJucyB7dW5kZWZpbmVkfSBFbnN1cmUgdGhhdCB5b3UgbW9kaWZ5IHRoZSBkYXRhIGFycmF5IHBhc3NlZCBpbixcbiAgICAgICAgICAgICAqICAgIGFzIHRoaXMgaXMgcGFzc2VkIGJ5IHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xuICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zZXJ2ZXJQYXJhbXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5TZXJ2ZXJQYXJhbXNcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvYWQgdGhlIHRhYmxlIHN0YXRlLiBXaXRoIHRoaXMgZnVuY3Rpb24geW91IGNhbiBkZWZpbmUgZnJvbSB3aGVyZSwgYW5kIGhvdywgdGhlXG4gICAgICAgICAgICAgKiBzdGF0ZSBvZiBhIHRhYmxlIGlzIGxvYWRlZC4gQnkgZGVmYXVsdCBEYXRhVGFibGVzIHdpbGwgbG9hZCBmcm9tIGBsb2NhbFN0b3JhZ2VgXG4gICAgICAgICAgICAgKiBidXQgeW91IG1pZ2h0IHdpc2ggdG8gdXNlIGEgc2VydmVyLXNpZGUgZGF0YWJhc2Ugb3IgY29va2llcy5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBtZW1iZXJcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCBjYW4gYmUgZXhlY3V0ZWQgd2hlbiBkb25lLiBJdFxuICAgICAgICAgICAgICogICAgc2hvdWxkIGJlIHBhc3NlZCB0aGUgbG9hZGVkIHN0YXRlIG9iamVjdC5cbiAgICAgICAgICAgICAqICBAcmV0dXJuIHtvYmplY3R9IFRoZSBEYXRhVGFibGVzIHN0YXRlIG9iamVjdCB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENhbGxiYWNrc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5zdGF0ZUxvYWRDYWxsYmFja1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlXCI6IHRydWUsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAkLmFqYXgoIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJ1cmxcIjogXCIvc3RhdGVfbG9hZFwiLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICBjYWxsYmFjaygganNvbiApO1xuICAgICAgICAgICAgICogICAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRDYWxsYmFja1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuZ2V0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnRGF0YVRhYmxlc18nICsgc2V0dGluZ3Muc0luc3RhbmNlICsgJ18nICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2F2ZWQgc3RhdGUgcHJpb3IgdG8gbG9hZGluZyB0aGF0IHN0YXRlLlxuICAgICAgICAgICAgICogVGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgd2hlbiB0aGUgdGFibGUgaXMgbG9hZGluZyBzdGF0ZSBmcm9tIHRoZSBzdG9yZWQgZGF0YSwgYnV0XG4gICAgICAgICAgICAgKiBwcmlvciB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzYXZlZCBzdGF0ZS4gTm90ZSB0aGF0IGZvclxuICAgICAgICAgICAgICogcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkIHVzZSB0aGUgYHN0YXRlTG9hZFBhcmFtc2AgZXZlbnQgdG8gbG9hZCBwYXJhbWV0ZXJzIGZvclxuICAgICAgICAgICAgICogYSBwbHVnLWluLlxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0aGF0IGlzIHRvIGJlIGxvYWRlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlTG9hZFBhcmFtc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgbG9hZGVkXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlTG9hZFBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIGRhdGEub1NlYXJjaC5zU2VhcmNoID0gXCJcIjtcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIERpc2FsbG93IHN0YXRlIGxvYWRpbmcgYnkgcmV0dXJuaW5nIGZhbHNlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlTG9hZFBhcmFtc1wiOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGRhdGEpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmblN0YXRlTG9hZFBhcmFtc1wiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgc3RhdGUgaGFzIGJlZW4gbG9hZGVkIGZyb20gdGhlIHN0YXRlIHNhdmluZyBtZXRob2RcbiAgICAgICAgICAgICAqIGFuZCB0aGUgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgYXMgYSByZXN1bHQgb2YgdGhlIGxvYWRlZCBzdGF0ZS5cbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBkYXRhIFRoZSBzdGF0ZSBvYmplY3QgdGhhdCB3YXMgbG9hZGVkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBDYWxsYmFja3NcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc3RhdGVMb2FkZWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFNob3cgYW4gYWxlcnQgd2l0aCB0aGUgZmlsdGVyaW5nIHZhbHVlIHRoYXQgd2FzIHNhdmVkXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlTG9hZGVkXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuICAgICAgICAgICAgICogICAgICAgICAgYWxlcnQoICdTYXZlZCBmaWx0ZXIgd2FzOiAnK2RhdGEub1NlYXJjaC5zU2VhcmNoICk7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5TdGF0ZUxvYWRlZFwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2F2ZSB0aGUgdGFibGUgc3RhdGUuIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBkZWZpbmUgd2hlcmUgYW5kIGhvdyB0aGUgc3RhdGVcbiAgICAgICAgICAgICAqIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUgaXMgc3RvcmVkIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyB3aWxsIHVzZSBgbG9jYWxTdG9yYWdlYFxuICAgICAgICAgICAgICogYnV0IHlvdSBtaWdodCB3aXNoIHRvIHVzZSBhIHNlcnZlci1zaWRlIGRhdGFiYXNlIG9yIGNvb2tpZXMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAbWVtYmVyXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZUNhbGxiYWNrXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzdGF0ZVNhdmVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuICAgICAgICAgICAgICogICAgICAgICAgLy8gU2VuZCBhbiBBamF4IHJlcXVlc3QgdG8gdGhlIHNlcnZlciB3aXRoIHRoZSBzdGF0ZSBvYmplY3RcbiAgICAgICAgICAgICAqICAgICAgICAgICQuYWpheCgge1xuICAgICAgICAgICAgICogICAgICAgICAgICBcInVybFwiOiBcIi9zdGF0ZV9zYXZlXCIsXG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBkYXRhLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFUeXBlXCI6IFwianNvblwiLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcIm1ldGhvZFwiOiBcIlBPU1RcIlxuICAgICAgICAgICAgICogICAgICAgICAgICBcInN1Y2Nlc3NcIjogZnVuY3Rpb24gKCkge31cbiAgICAgICAgICAgICAqICAgICAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmblN0YXRlU2F2ZUNhbGxiYWNrXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIChzZXR0aW5ncy5pU3RhdGVEdXJhdGlvbiA9PT0gLTEgPyBzZXNzaW9uU3RvcmFnZSA6IGxvY2FsU3RvcmFnZSkuc2V0SXRlbShcbiAgICAgICAgICAgICAgICAgICAgICAgICdEYXRhVGFibGVzXycgKyBzZXR0aW5ncy5zSW5zdGFuY2UgKyAnXycgKyBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2sgd2hpY2ggYWxsb3dzIG1vZGlmaWNhdGlvbiBvZiB0aGUgc3RhdGUgdG8gYmUgc2F2ZWQuIENhbGxlZCB3aGVuIHRoZSB0YWJsZVxuICAgICAgICAgICAgICogaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZSBpcyByZXF1aXJlZC4gVGhpcyBtZXRob2QgYWxsb3dzIG1vZGlmaWNhdGlvbiBvZlxuICAgICAgICAgICAgICogdGhlIHN0YXRlIHNhdmluZyBvYmplY3QgcHJpb3IgdG8gYWN0dWFsbHkgZG9pbmcgdGhlIHNhdmUsIGluY2x1ZGluZyBhZGRpdGlvbiBvclxuICAgICAgICAgICAgICogb3RoZXIgc3RhdGUgcHJvcGVydGllcyBvciBtb2RpZmljYXRpb24uIE5vdGUgdGhhdCBmb3IgcGx1Zy1pbiBhdXRob3JzLCB5b3Ugc2hvdWxkXG4gICAgICAgICAgICAgKiB1c2UgdGhlIGBzdGF0ZVNhdmVQYXJhbXNgIGV2ZW50IHRvIHNhdmUgcGFyYW1ldGVycyBmb3IgYSBwbHVnLWluLlxuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGRhdGEgVGhlIHN0YXRlIG9iamVjdCB0byBiZSBzYXZlZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ2FsbGJhY2tzXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlU2F2ZVBhcmFtc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gUmVtb3ZlIGEgc2F2ZWQgZmlsdGVyLCBzbyBmaWx0ZXJpbmcgaXMgbmV2ZXIgc2F2ZWRcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlU2F2ZVwiOiB0cnVlLFxuICAgICAgICAgICAgICogICAgICAgIFwic3RhdGVTYXZlUGFyYW1zXCI6IGZ1bmN0aW9uIChzZXR0aW5ncywgZGF0YSkge1xuICAgICAgICAgICAgICogICAgICAgICAgZGF0YS5vU2VhcmNoLnNTZWFyY2ggPSBcIlwiO1xuICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuU3RhdGVTYXZlUGFyYW1zXCI6IG51bGwsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEdXJhdGlvbiBmb3Igd2hpY2ggdGhlIHNhdmVkIHN0YXRlIGluZm9ybWF0aW9uIGlzIGNvbnNpZGVyZWQgdmFsaWQuIEFmdGVyIHRoaXMgcGVyaW9kXG4gICAgICAgICAgICAgKiBoYXMgZWxhcHNlZCB0aGUgc3RhdGUgd2lsbCBiZSByZXR1cm5lZCB0byB0aGUgZGVmYXVsdC5cbiAgICAgICAgICAgICAqIFZhbHVlIGlzIGdpdmVuIGluIHNlY29uZHMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgNzIwMCA8aT4oMiBob3Vycyk8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnN0YXRlRHVyYXRpb25cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInN0YXRlRHVyYXRpb25cIjogNjAqNjAqMjQ7IC8vIDEgZGF5XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlTdGF0ZUR1cmF0aW9uXCI6IDcyMDAsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsIG5vdCBtYWtlIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIGZvciB0aGUgZmlyc3RcbiAgICAgICAgICAgICAqIHBhZ2UgZHJhdyAtIHJhdGhlciBpdCB3aWxsIHVzZSB0aGUgZGF0YSBhbHJlYWR5IG9uIHRoZSBwYWdlIChubyBzb3J0aW5nIGV0Y1xuICAgICAgICAgICAgICogd2lsbCBiZSBhcHBsaWVkIHRvIGl0KSwgdGh1cyBzYXZpbmcgb24gYW4gWEhSIGF0IGxvYWQgdGltZS4gYGRlZmVyTG9hZGluZ2BcbiAgICAgICAgICAgICAqIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhhdCBkZWZlcnJlZCBsb2FkaW5nIGlzIHJlcXVpcmVkLCBidXQgaXQgaXMgYWxzbyB1c2VkXG4gICAgICAgICAgICAgKiB0byB0ZWxsIERhdGFUYWJsZXMgaG93IG1hbnkgcmVjb3JkcyB0aGVyZSBhcmUgaW4gdGhlIGZ1bGwgdGFibGUgKGFsbG93aW5nXG4gICAgICAgICAgICAgKiB0aGUgaW5mb3JtYXRpb24gZWxlbWVudCBhbmQgcGFnaW5hdGlvbiB0byBiZSBkaXNwbGF5ZWQgY29ycmVjdGx5KS4gSW4gdGhlIGNhc2VcbiAgICAgICAgICAgICAqIHdoZXJlIGEgZmlsdGVyaW5nIGlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIG9uIGluaXRpYWwgbG9hZCwgdGhpcyBjYW4gYmVcbiAgICAgICAgICAgICAqIGluZGljYXRlZCBieSBnaXZpbmcgdGhlIHBhcmFtZXRlciBhcyBhbiBhcnJheSwgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXNcbiAgICAgICAgICAgICAqIHRoZSBudW1iZXIgb2YgcmVjb3JkcyBhdmFpbGFibGUgYWZ0ZXIgZmlsdGVyaW5nIGFuZCB0aGUgc2Vjb25kIGVsZW1lbnQgaXMgdGhlXG4gICAgICAgICAgICAgKiBudW1iZXIgb2YgcmVjb3JkcyB3aXRob3V0IGZpbHRlcmluZyAoYWxsb3dpbmcgdGhlIHRhYmxlIGluZm9ybWF0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgICAqIHRvIGJlIHNob3duIGNvcnJlY3RseSkuXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50IHwgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRlZmVyTG9hZGluZ1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gNTcgcmVjb3JkcyBhdmFpbGFibGUgaW4gdGhlIHRhYmxlLCBubyBmaWx0ZXJpbmcgYXBwbGllZFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic2VydmVyU2lkZVwiOiB0cnVlLFxuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFwiOiBcInNjcmlwdHMvc2VydmVyX3Byb2Nlc3NpbmcucGhwXCIsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJkZWZlckxvYWRpbmdcIjogNTdcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gNTcgcmVjb3JkcyBhZnRlciBmaWx0ZXJpbmcsIDEwMCB3aXRob3V0IGZpbHRlcmluZyAoYW4gaW5pdGlhbCBmaWx0ZXIgYXBwbGllZClcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInNlcnZlclNpZGVcIjogdHJ1ZSxcbiAgICAgICAgICAgICAqICAgICAgICBcImFqYXhcIjogXCJzY3JpcHRzL3NlcnZlcl9wcm9jZXNzaW5nLnBocFwiLFxuICAgICAgICAgICAgICogICAgICAgIFwiZGVmZXJMb2FkaW5nXCI6IFsgNTcsIDEwMCBdLFxuICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoXCI6IHtcbiAgICAgICAgICAgICAqICAgICAgICAgIFwic2VhcmNoXCI6IFwibXlfZmlsdGVyXCJcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJpRGVmZXJMb2FkaW5nXCI6IG51bGwsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOdW1iZXIgb2Ygcm93cyB0byBkaXNwbGF5IG9uIGEgc2luZ2xlIHBhZ2Ugd2hlbiB1c2luZyBwYWdpbmF0aW9uLiBJZlxuICAgICAgICAgICAgICogZmVhdHVyZSBlbmFibGVkIChgbGVuZ3RoQ2hhbmdlYCkgdGhlbiB0aGUgZW5kIHVzZXIgd2lsbCBiZSBhYmxlIHRvIG92ZXJyaWRlXG4gICAgICAgICAgICAgKiB0aGlzIHRvIGEgY3VzdG9tIHNldHRpbmcgdXNpbmcgYSBwb3AtdXAgbWVudS5cbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAxMFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5wYWdlTGVuZ3RoXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdlTGVuZ3RoXCI6IDUwXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlEaXNwbGF5TGVuZ3RoXCI6IDEwLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVmaW5lIHRoZSBzdGFydGluZyBwb2ludCBmb3IgZGF0YSBkaXNwbGF5IHdoZW4gdXNpbmcgRGF0YVRhYmxlcyB3aXRoXG4gICAgICAgICAgICAgKiBwYWdpbmF0aW9uLiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgaXMgdGhlIG51bWJlciBvZiByZWNvcmRzLCByYXRoZXIgdGhhblxuICAgICAgICAgICAgICogdGhlIHBhZ2UgbnVtYmVyLCBzbyBpZiB5b3UgaGF2ZSAxMCByZWNvcmRzIHBlciBwYWdlIGFuZCB3YW50IHRvIHN0YXJ0IG9uXG4gICAgICAgICAgICAgKiB0aGUgdGhpcmQgcGFnZSwgaXQgc2hvdWxkIGJlIFwiMjBcIi5cbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmRpc3BsYXlTdGFydFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiZGlzcGxheVN0YXJ0XCI6IDIwXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlEaXNwbGF5U3RhcnRcIjogMCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ5IGRlZmF1bHQgRGF0YVRhYmxlcyBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgKHNvcnRpbmcsIHBhZ2luZyxcbiAgICAgICAgICAgICAqIGFuZCBmaWx0ZXJpbmcpIGJ5IGFkZGluZyBhIGB0YWJpbmRleGAgYXR0cmlidXRlIHRvIHRoZSByZXF1aXJlZCBlbGVtZW50cy4gVGhpc1xuICAgICAgICAgICAgICogYWxsb3dzIHlvdSB0byB0YWIgdGhyb3VnaCB0aGUgY29udHJvbHMgYW5kIHByZXNzIHRoZSBlbnRlciBrZXkgdG8gYWN0aXZhdGUgdGhlbS5cbiAgICAgICAgICAgICAqIFRoZSB0YWJpbmRleCBpcyBkZWZhdWx0IDAsIG1lYW5pbmcgdGhhdCB0aGUgdGFiIGZvbGxvd3MgdGhlIGZsb3cgb2YgdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgICogWW91IGNhbiBvdmVycnVsZSB0aGlzIHVzaW5nIHRoaXMgcGFyYW1ldGVyIGlmIHlvdSB3aXNoLiBVc2UgYSB2YWx1ZSBvZiAtMSB0b1xuICAgICAgICAgICAgICogZGlzYWJsZSBidWlsdC1pbiBrZXlib2FyZCBuYXZpZ2F0aW9uLlxuICAgICAgICAgICAgICogIEB0eXBlIGludFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMudGFiSW5kZXhcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInRhYkluZGV4XCI6IDFcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlUYWJJbmRleFwiOiAwLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2xhc3NlcyB0aGF0IERhdGFUYWJsZXMgYXNzaWducyB0byB0aGUgdmFyaW91cyBjb21wb25lbnRzIGFuZCBmZWF0dXJlc1xuICAgICAgICAgICAgICogdGhhdCBpdCBhZGRzIHRvIHRoZSBIVE1MIHRhYmxlLiBUaGlzIGFsbG93cyBjbGFzc2VzIHRvIGJlIGNvbmZpZ3VyZWRcbiAgICAgICAgICAgICAqIGR1cmluZyBpbml0aWFsaXNhdGlvbiBpbiBhZGRpdGlvbiB0byB0aHJvdWdoIHRoZSBzdGF0aWNcbiAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZXh0Lm9TdGRDbGFzc2VzfSBvYmplY3QpLlxuICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY2xhc3Nlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm9DbGFzc2VzXCI6IHt9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWxsIHN0cmluZ3MgdGhhdCBEYXRhVGFibGVzIHVzZXMgaW4gdGhlIHVzZXIgaW50ZXJmYWNlIHRoYXQgaXQgY3JlYXRlc1xuICAgICAgICAgICAgICogYXJlIGRlZmluZWQgaW4gdGhpcyBvYmplY3QsIGFsbG93aW5nIHlvdSB0byBtb2RpZmllZCB0aGVtIGluZGl2aWR1YWxseSBvclxuICAgICAgICAgICAgICogY29tcGxldGVseSByZXBsYWNlIHRoZW0gYWxsIGFzIHJlcXVpcmVkLlxuICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJvTGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFN0cmluZ3MgdGhhdCBhcmUgdXNlZCBmb3IgV0FJLUFSSUEgbGFiZWxzIGFuZCBjb250cm9scyBvbmx5ICh0aGVzZSBhcmUgbm90XG4gICAgICAgICAgICAgICAgICogYWN0dWFsbHkgdmlzaWJsZSBvbiB0aGUgcGFnZSwgYnV0IHdpbGwgYmUgcmVhZCBieSBzY3JlZW5yZWFkZXJzLCBhbmQgdGh1c1xuICAgICAgICAgICAgICAgICAqIG11c3QgYmUgaW50ZXJuYXRpb25hbGlzZWQgYXMgd2VsbCkuXG4gICAgICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcIm9BcmlhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEFSSUEgbGFiZWwgdGhhdCBpcyBhZGRlZCB0byB0aGUgdGFibGUgaGVhZGVycyB3aGVuIHRoZSBjb2x1bW4gbWF5IGJlXG4gICAgICAgICAgICAgICAgICAgICAqIHNvcnRlZCBhc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG4gICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydEFzY2VuZGluZ1xuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgXCJhcmlhXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInNvcnRBc2NlbmRpbmdcIjogXCIgLSBjbGljay9yZXR1cm4gdG8gc29ydCBhc2NlbmRpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBcInNTb3J0QXNjZW5kaW5nXCI6IFwiOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcIixcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogQVJJQSBsYWJlbCB0aGF0IGlzIGFkZGVkIHRvIHRoZSB0YWJsZSBoZWFkZXJzIHdoZW4gdGhlIGNvbHVtbiBtYXkgYmVcbiAgICAgICAgICAgICAgICAgICAgICogc29ydGVkIGRlc2NlbmRpbmcgYnkgYWN0aXZpbmcgdGhlIGNvbHVtbiAoY2xpY2sgb3IgcmV0dXJuIHdoZW4gZm9jdXNlZCkuXG4gICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgY29sdW1uIGhlYWRlciBpcyBwcmVmaXhlZCB0byB0aGlzIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgOiBhY3RpdmF0ZSB0byBzb3J0IGNvbHVtbiBhc2NlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmFyaWEuc29ydERlc2NlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiYXJpYVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgXCJzb3J0RGVzY2VuZGluZ1wiOiBcIiAtIGNsaWNrL3JldHVybiB0byBzb3J0IGRlc2NlbmRpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBcInNTb3J0RGVzY2VuZGluZ1wiOiBcIjogYWN0aXZhdGUgdG8gc29ydCBjb2x1bW4gZGVzY2VuZGluZ1wiXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFBhZ2luYXRpb24gc3RyaW5nIHVzZWQgYnkgRGF0YVRhYmxlcyBmb3IgdGhlIGJ1aWx0LWluIHBhZ2luYXRpb25cbiAgICAgICAgICAgICAgICAgKiBjb250cm9sIHR5cGVzLlxuICAgICAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS5wYWdpbmF0ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwib1BhZ2luYXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBmaXJzdCBwYWdlLlxuICAgICAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBGaXJzdFxuICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UucGFnaW5hdGUuZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZmlyc3RcIjogXCJGaXJzdCBwYWdlXCJcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgXCJzRmlyc3RcIjogXCJGaXJzdFwiLFxuXG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIFRleHQgdG8gdXNlIHdoZW4gdXNpbmcgdGhlICdmdWxsX251bWJlcnMnIHR5cGUgb2YgcGFnaW5hdGlvbiBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIGJ1dHRvbiB0byB0YWtlIHRoZSB1c2VyIHRvIHRoZSBsYXN0IHBhZ2UuXG4gICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IExhc3RcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLmxhc3RcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwibGFzdFwiOiBcIkxhc3QgcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIFwic0xhc3RcIjogXCJMYXN0XCIsXG5cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGV4dCB0byB1c2UgZm9yIHRoZSAnbmV4dCcgcGFnaW5hdGlvbiBidXR0b24gKHRvIHRha2UgdGhlIHVzZXIgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIG5leHQgcGFnZSkuXG4gICAgICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IE5leHRcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLm5leHRcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicGFnaW5hdGVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgIFwibmV4dFwiOiBcIk5leHQgcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIFwic05leHRcIjogXCJOZXh0XCIsXG5cblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGV4dCB0byB1c2UgZm9yIHRoZSAncHJldmlvdXMnIHBhZ2luYXRpb24gYnV0dG9uICh0byB0YWtlIHRoZSB1c2VyIHRvXG4gICAgICAgICAgICAgICAgICAgICAqIHRoZSBwcmV2aW91cyBwYWdlKS5cbiAgICAgICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgUHJldmlvdXNcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnBhZ2luYXRlLnByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcInBhZ2luYXRlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgICAgICBcInByZXZpb3VzXCI6IFwiUHJldmlvdXMgcGFnZVwiXG4gICAgICAgICAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIFwic1ByZXZpb3VzXCI6IFwiUHJldmlvdXNcIlxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGlzIHN0cmluZyBpcyBzaG93biBpbiBwcmVmZXJlbmNlIHRvIGB6ZXJvUmVjb3Jkc2Agd2hlbiB0aGUgdGFibGUgaXNcbiAgICAgICAgICAgICAgICAgKiBlbXB0eSBvZiBkYXRhIChyZWdhcmRsZXNzIG9mIGZpbHRlcmluZykuIE5vdGUgdGhhdCB0aGlzIGlzIGFuIG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICogcGFyYW1ldGVyIC0gaWYgaXQgaXMgbm90IGdpdmVuLCB0aGUgdmFsdWUgb2YgYHplcm9SZWNvcmRzYCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgKiBpbnN0ZWFkIChlaXRoZXIgdGhlIGRlZmF1bHQgb3IgZ2l2ZW4gdmFsdWUpLlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmVtcHR5VGFibGVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZW1wdHlUYWJsZVwiOiBcIk5vIGRhdGEgYXZhaWxhYmxlIGluIHRhYmxlXCJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcInNFbXB0eVRhYmxlXCI6IFwiTm8gZGF0YSBhdmFpbGFibGUgaW4gdGFibGVcIixcblxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBzdHJpbmcgZ2l2ZXMgaW5mb3JtYXRpb24gdG8gdGhlIGVuZCB1c2VyIGFib3V0IHRoZSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAqIHRoYXQgaXMgY3VycmVudCBvbiBkaXNwbGF5IG9uIHRoZSBwYWdlLiBUaGUgZm9sbG93aW5nIHRva2VucyBjYW4gYmVcbiAgICAgICAgICAgICAgICAgKiB1c2VkIGluIHRoZSBzdHJpbmcgYW5kIHdpbGwgYmUgZHluYW1pY2FsbHkgcmVwbGFjZWQgYXMgdGhlIHRhYmxlXG4gICAgICAgICAgICAgICAgICogZGlzcGxheSB1cGRhdGVzLiBUaGlzIHRva2VucyBjYW4gYmUgcGxhY2VkIGFueXdoZXJlIGluIHRoZSBzdHJpbmcsIG9yXG4gICAgICAgICAgICAgICAgICogcmVtb3ZlZCBhcyBuZWVkZWQgYnkgdGhlIGxhbmd1YWdlIHJlcXVpcmVzOlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogKiBgXFxfU1RBUlRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgZmlyc3QgcmVjb3JkIG9uIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgICAgICAgICAgKiAqIGBcXF9FTkRcXF9gIC0gRGlzcGxheSBpbmRleCBvZiB0aGUgbGFzdCByZWNvcmQgb24gdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgICAgICAqICogYFxcX1RPVEFMXFxfYCAtIE51bWJlciBvZiByZWNvcmRzIGluIHRoZSB0YWJsZSBhZnRlciBmaWx0ZXJpbmdcbiAgICAgICAgICAgICAgICAgKiAqIGBcXF9NQVhcXF9gIC0gTnVtYmVyIG9mIHJlY29yZHMgaW4gdGhlIHRhYmxlIHdpdGhvdXQgZmlsdGVyaW5nXG4gICAgICAgICAgICAgICAgICogKiBgXFxfUEFHRVxcX2AgLSBDdXJyZW50IHBhZ2UgbnVtYmVyXG4gICAgICAgICAgICAgICAgICogKiBgXFxfUEFHRVNcXF9gIC0gVG90YWwgbnVtYmVyIG9mIHBhZ2VzIG9mIGRhdGEgaW4gdGhlIHRhYmxlXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiaW5mb1wiOiBcIlNob3dpbmcgcGFnZSBfUEFHRV8gb2YgX1BBR0VTX1wiXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzSW5mb1wiOiBcIlNob3dpbmcgX1NUQVJUXyB0byBfRU5EXyBvZiBfVE9UQUxfIGVudHJpZXNcIixcblxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGlzcGxheSBpbmZvcm1hdGlvbiBzdHJpbmcgZm9yIHdoZW4gdGhlIHRhYmxlIGlzIGVtcHR5LiBUeXBpY2FsbHkgdGhlXG4gICAgICAgICAgICAgICAgICogZm9ybWF0IG9mIHRoaXMgc3RyaW5nIHNob3VsZCBtYXRjaCBgaW5mb2AuXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBTaG93aW5nIDAgdG8gMCBvZiAwIGVudHJpZXNcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9FbXB0eVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJpbmZvRW1wdHlcIjogXCJObyBlbnRyaWVzIHRvIHNob3dcIlxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwic0luZm9FbXB0eVwiOiBcIlNob3dpbmcgMCB0byAwIG9mIDAgZW50cmllc1wiLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGVuIGEgdXNlciBmaWx0ZXJzIHRoZSBpbmZvcm1hdGlvbiBpbiBhIHRhYmxlLCB0aGlzIHN0cmluZyBpcyBhcHBlbmRlZFxuICAgICAgICAgICAgICAgICAqIHRvIHRoZSBpbmZvcm1hdGlvbiAoYGluZm9gKSB0byBnaXZlIGFuIGlkZWEgb2YgaG93IHN0cm9uZyB0aGUgZmlsdGVyaW5nXG4gICAgICAgICAgICAgICAgICogaXMuIFRoZSB2YXJpYWJsZSBfTUFYXyBpcyBkeW5hbWljYWxseSB1cGRhdGVkLlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgKGZpbHRlcmVkIGZyb20gX01BWF8gdG90YWwgZW50cmllcylcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9GaWx0ZXJlZFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJpbmZvRmlsdGVyZWRcIjogXCIgLSBmaWx0ZXJpbmcgZnJvbSBfTUFYXyByZWNvcmRzXCJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcInNJbmZvRmlsdGVyZWRcIjogXCIoZmlsdGVyZWQgZnJvbSBfTUFYXyB0b3RhbCBlbnRyaWVzKVwiLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBjYW4gYmUgdXNlZnVsIHRvIGFwcGVuZCBleHRyYSBpbmZvcm1hdGlvbiB0byB0aGUgaW5mbyBzdHJpbmcgYXQgdGltZXMsXG4gICAgICAgICAgICAgICAgICogYW5kIHRoaXMgdmFyaWFibGUgZG9lcyBleGFjdGx5IHRoYXQuIFRoaXMgaW5mb3JtYXRpb24gd2lsbCBiZSBhcHBlbmRlZCB0b1xuICAgICAgICAgICAgICAgICAqIHRoZSBgaW5mb2AgKGBpbmZvRW1wdHlgIGFuZCBgaW5mb0ZpbHRlcmVkYCBpbiB3aGF0ZXZlciBjb21iaW5hdGlvbiB0aGV5IGFyZVxuICAgICAgICAgICAgICAgICAqIGJlaW5nIHVzZWQpIGF0IGFsbCB0aW1lcy5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZzwvaT5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmluZm9Qb3N0Rml4XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImluZm9Qb3N0Rml4XCI6IFwiQWxsIHJlY29yZHMgc2hvd24gYXJlIGRlcml2ZWQgZnJvbSByZWFsIGluZm9ybWF0aW9uLlwiXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzSW5mb1Bvc3RGaXhcIjogXCJcIixcblxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBkZWNpbWFsIHBsYWNlIG9wZXJhdG9yIGlzIGEgbGl0dGxlIGRpZmZlcmVudCBmcm9tIHRoZSBvdGhlclxuICAgICAgICAgICAgICAgICAqIGxhbmd1YWdlIG9wdGlvbnMgc2luY2UgRGF0YVRhYmxlcyBkb2Vzbid0IG91dHB1dCBmbG9hdGluZyBwb2ludFxuICAgICAgICAgICAgICAgICAqIG51bWJlcnMsIHNvIGl0IHdvbid0IGV2ZXIgdXNlIHRoaXMgZm9yIGRpc3BsYXkgb2YgYSBudW1iZXIuIFJhdGhlcixcbiAgICAgICAgICAgICAgICAgKiB3aGF0IHRoaXMgcGFyYW1ldGVyIGRvZXMgaXMgbW9kaWZ5IHRoZSBzb3J0IG1ldGhvZHMgb2YgdGhlIHRhYmxlIHNvXG4gICAgICAgICAgICAgICAgICogdGhhdCBudW1iZXJzIHdoaWNoIGFyZSBpbiBhIGZvcm1hdCB3aGljaCBoYXMgYSBjaGFyYWN0ZXIgb3RoZXIgdGhhblxuICAgICAgICAgICAgICAgICAqIGEgcGVyaW9kIChgLmApIGFzIGEgZGVjaW1hbCBwbGFjZSB3aWxsIGJlIHNvcnRlZCBudW1lcmljYWxseS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBudW1iZXJzIHdpdGggZGlmZmVyZW50IGRlY2ltYWwgcGxhY2VzIGNhbm5vdCBiZSBzaG93biBpblxuICAgICAgICAgICAgICAgICAqIHRoZSBzYW1lIHRhYmxlIGFuZCBzdGlsbCBiZSBzb3J0YWJsZSwgdGhlIHRhYmxlIG11c3QgYmUgY29uc2lzdGVudC5cbiAgICAgICAgICAgICAgICAgKiBIb3dldmVyLCBtdWx0aXBsZSBkaWZmZXJlbnQgdGFibGVzIG9uIHRoZSBwYWdlIGNhbiB1c2UgZGlmZmVyZW50XG4gICAgICAgICAgICAgICAgICogZGVjaW1hbCBwbGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmRlY2ltYWxcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiZGVjaW1hbFwiOiBcIixcIlxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidGhvdXNhbmRzXCI6IFwiLlwiXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzRGVjaW1hbFwiOiBcIlwiLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBEYXRhVGFibGVzIGhhcyBhIGJ1aWxkIGluIG51bWJlciBmb3JtYXR0ZXIgKGBmb3JtYXROdW1iZXJgKSB3aGljaCBpc1xuICAgICAgICAgICAgICAgICAqIHVzZWQgdG8gZm9ybWF0IGxhcmdlIG51bWJlcnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgdGFibGUgaW5mb3JtYXRpb24uXG4gICAgICAgICAgICAgICAgICogQnkgZGVmYXVsdCBhIGNvbW1hIGlzIHVzZWQsIGJ1dCB0aGlzIGNhbiBiZSB0cml2aWFsbHkgY2hhbmdlZCB0byBhbnlcbiAgICAgICAgICAgICAgICAgKiBjaGFyYWN0ZXIgeW91IHdpc2ggd2l0aCB0aGlzIHBhcmFtZXRlci5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0ICxcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnRob3VzYW5kc1xuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJ0aG91c2FuZHNcIjogXCInXCJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcInNUaG91c2FuZHNcIjogXCIsXCIsXG5cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERldGFpbCB0aGUgYWN0aW9uIHRoYXQgd2lsbCBiZSB0YWtlbiB3aGVuIHRoZSBkcm9wIGRvd24gbWVudSBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICogcGFnaW5hdGlvbiBsZW5ndGggb3B0aW9uIGlzIGNoYW5nZWQuIFRoZSAnX01FTlVfJyB2YXJpYWJsZSBpcyByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAqIHdpdGggYSBkZWZhdWx0IHNlbGVjdCBsaXN0IG9mIDEwLCAyNSwgNTAgYW5kIDEwMCwgYW5kIGNhbiBiZSByZXBsYWNlZFxuICAgICAgICAgICAgICAgICAqIHdpdGggYSBjdXN0b20gc2VsZWN0IGJveCBpZiByZXF1aXJlZC5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFNob3cgX01FTlVfIGVudHJpZXNcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLmxlbmd0aE1lbnVcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgIC8vIExhbmd1YWdlIGNoYW5nZSBvbmx5XG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJsZW5ndGhNZW51XCI6IFwiRGlzcGxheSBfTUVOVV8gcmVjb3Jkc1wiXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKiAgICAvLyBMYW5ndWFnZSBhbmQgb3B0aW9ucyBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICAgICAqICAgICAgICBcImxhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBcImxlbmd0aE1lbnVcIjogJ0Rpc3BsYXkgPHNlbGVjdD4nK1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCIxMFwiPjEwPC9vcHRpb24+JytcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiMjBcIj4yMDwvb3B0aW9uPicrXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIjMwXCI+MzA8L29wdGlvbj4nK1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgICAgJzxvcHRpb24gdmFsdWU9XCI0MFwiPjQwPC9vcHRpb24+JytcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8b3B0aW9uIHZhbHVlPVwiNTBcIj41MDwvb3B0aW9uPicrXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgICAnPG9wdGlvbiB2YWx1ZT1cIi0xXCI+QWxsPC9vcHRpb24+JytcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAgICc8L3NlbGVjdD4gcmVjb3JkcydcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcInNMZW5ndGhNZW51XCI6IFwiU2hvdyBfTUVOVV8gZW50cmllc1wiLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGVuIHVzaW5nIEFqYXggc291cmNlZCBkYXRhIGFuZCBkdXJpbmcgdGhlIGZpcnN0IGRyYXcgd2hlbiBEYXRhVGFibGVzIGlzXG4gICAgICAgICAgICAgICAgICogZ2F0aGVyaW5nIHRoZSBkYXRhLCB0aGlzIG1lc3NhZ2UgaXMgc2hvd24gaW4gYW4gZW1wdHkgcm93IGluIHRoZSB0YWJsZSB0b1xuICAgICAgICAgICAgICAgICAqIGluZGljYXRlIHRvIHRoZSBlbmQgdXNlciB0aGUgdGhlIGRhdGEgaXMgYmVpbmcgbG9hZGVkLiBOb3RlIHRoYXQgdGhpc1xuICAgICAgICAgICAgICAgICAqIHBhcmFtZXRlciBpcyBub3QgdXNlZCB3aGVuIGxvYWRpbmcgZGF0YSBieSBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nLCBqdXN0XG4gICAgICAgICAgICAgICAgICogQWpheCBzb3VyY2VkIGRhdGEgd2l0aCBjbGllbnQtc2lkZSBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTG9hZGluZy4uLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UubG9hZGluZ1JlY29yZHNcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwibG9hZGluZ1JlY29yZHNcIjogXCJQbGVhc2Ugd2FpdCAtIGxvYWRpbmcuLi5cIlxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwic0xvYWRpbmdSZWNvcmRzXCI6IFwiTG9hZGluZy4uLlwiLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUZXh0IHdoaWNoIGlzIGRpc3BsYXllZCB3aGVuIHRoZSB0YWJsZSBpcyBwcm9jZXNzaW5nIGEgdXNlciBhY3Rpb25cbiAgICAgICAgICAgICAgICAgKiAodXN1YWxseSBhIHNvcnQgY29tbWFuZCBvciBzaW1pbGFyKS5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IFByb2Nlc3NpbmcuLi5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwicHJvY2Vzc2luZ1wiOiBcIkRhdGFUYWJsZXMgaXMgY3VycmVudGx5IGJ1c3lcIlxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwic1Byb2Nlc3NpbmdcIjogXCJQcm9jZXNzaW5nLi4uXCIsXG5cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERldGFpbHMgdGhlIGFjdGlvbnMgdGhhdCB3aWxsIGJlIHRha2VuIHdoZW4gdGhlIHVzZXIgdHlwZXMgaW50byB0aGVcbiAgICAgICAgICAgICAgICAgKiBmaWx0ZXJpbmcgaW5wdXQgdGV4dCBib3guIFRoZSB2YXJpYWJsZSBcIl9JTlBVVF9cIiwgaWYgdXNlZCBpbiB0aGUgc3RyaW5nLFxuICAgICAgICAgICAgICAgICAqIGlzIHJlcGxhY2VkIHdpdGggdGhlIEhUTUwgdGV4dCBib3ggZm9yIHRoZSBmaWx0ZXJpbmcgaW5wdXQgYWxsb3dpbmdcbiAgICAgICAgICAgICAgICAgKiBjb250cm9sIG92ZXIgd2hlcmUgaXQgYXBwZWFycyBpbiB0aGUgc3RyaW5nLiBJZiBcIl9JTlBVVF9cIiBpcyBub3QgZ2l2ZW5cbiAgICAgICAgICAgICAgICAgKiB0aGVuIHRoZSBpbnB1dCBib3ggaXMgYXBwZW5kZWQgdG8gdGhlIHN0cmluZyBhdXRvbWF0aWNhbGx5LlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgU2VhcmNoOlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2Uuc2VhcmNoXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKiAgICAvLyBJbnB1dCB0ZXh0IGJveCB3aWxsIGJlIGFwcGVuZGVkIGF0IHRoZSBlbmQgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwic2VhcmNoXCI6IFwiRmlsdGVyIHJlY29yZHM6XCJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgIC8vIFNwZWNpZnkgd2hlcmUgdGhlIGZpbHRlciBzaG91bGQgYXBwZWFyXG4gICAgICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgXCJsYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgXCJzZWFyY2hcIjogXCJBcHBseSBmaWx0ZXIgX0lOUFVUXyB0byB0YWJsZVwiXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzU2VhcmNoXCI6IFwiU2VhcmNoOlwiLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBc3NpZ24gYSBgcGxhY2Vob2xkZXJgIGF0dHJpYnV0ZSB0byB0aGUgc2VhcmNoIGBpbnB1dGAgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZHRvcHQgTGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmxhbmd1YWdlLnNlYXJjaFBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzU2VhcmNoUGxhY2Vob2xkZXJcIjogXCJcIixcblxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWxsIG9mIHRoZSBsYW5ndWFnZSBpbmZvcm1hdGlvbiBjYW4gYmUgc3RvcmVkIGluIGEgZmlsZSBvbiB0aGVcbiAgICAgICAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSwgd2hpY2ggRGF0YVRhYmxlcyB3aWxsIGxvb2sgdXAgaWYgdGhpcyBwYXJhbWV0ZXIgaXMgcGFzc2VkLlxuICAgICAgICAgICAgICAgICAqIEl0IG11c3Qgc3RvcmUgdGhlIFVSTCBvZiB0aGUgbGFuZ3VhZ2UgZmlsZSwgd2hpY2ggaXMgaW4gYSBKU09OIGZvcm1hdCxcbiAgICAgICAgICAgICAgICAgKiBhbmQgdGhlIG9iamVjdCBoYXMgdGhlIHNhbWUgcHJvcGVydGllcyBhcyB0aGUgb0xhbmd1YWdlIG9iamVjdCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgKiBpbml0aWFsaXNlciBvYmplY3QgKGkuZS4gdGhlIGFib3ZlIHBhcmFtZXRlcnMpLiBQbGVhc2UgcmVmZXIgdG8gb25lIG9mXG4gICAgICAgICAgICAgICAgICogdGhlIGV4YW1wbGUgbGFuZ3VhZ2UgZmlsZXMgdG8gc2VlIGhvdyB0aGlzIHdvcmtzIGluIGFjdGlvbi5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPkVtcHR5IHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQGR0b3B0IExhbmd1YWdlXG4gICAgICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5sYW5ndWFnZS51cmxcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwidXJsXCI6IFwiaHR0cDovL3d3dy5zcHJ5bWVkaWEuY28udWsvZGF0YVRhYmxlcy9sYW5nLnR4dFwiXG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzVXJsXCI6IFwiXCIsXG5cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRleHQgc2hvd24gaW5zaWRlIHRoZSB0YWJsZSByZWNvcmRzIHdoZW4gdGhlIGlzIG5vIGluZm9ybWF0aW9uIHRvIGJlXG4gICAgICAgICAgICAgICAgICogZGlzcGxheWVkIGFmdGVyIGZpbHRlcmluZy4gYGVtcHR5VGFibGVgIGlzIHNob3duIHdoZW4gdGhlcmUgaXMgc2ltcGx5IG5vXG4gICAgICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gdGhlIHRhYmxlIGF0IGFsbCAocmVnYXJkbGVzcyBvZiBmaWx0ZXJpbmcpLlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBkdG9wdCBMYW5ndWFnZVxuICAgICAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMubGFuZ3VhZ2UuemVyb1JlY29yZHNcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgICAgICogICAgICAgIFwibGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgICAqICAgICAgICAgIFwiemVyb1JlY29yZHNcIjogXCJObyByZWNvcmRzIHRvIGRpc3BsYXlcIlxuICAgICAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwic1plcm9SZWNvcmRzXCI6IFwiTm8gbWF0Y2hpbmcgcmVjb3JkcyBmb3VuZFwiXG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgYWxsb3dzIHlvdSB0byBoYXZlIGRlZmluZSB0aGUgZ2xvYmFsIGZpbHRlcmluZyBzdGF0ZSBhdFxuICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gdGltZS4gQXMgYW4gb2JqZWN0IHRoZSBgc2VhcmNoYCBwYXJhbWV0ZXIgbXVzdCBiZVxuICAgICAgICAgICAgICogZGVmaW5lZCwgYnV0IGFsbCBvdGhlciBwYXJhbWV0ZXJzIGFyZSBvcHRpb25hbC4gV2hlbiBgcmVnZXhgIGlzIHRydWUsXG4gICAgICAgICAgICAgKiB0aGUgc2VhcmNoIHN0cmluZyB3aWxsIGJlIHRyZWF0ZWQgYXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIHdoZW4gZmFsc2VcbiAgICAgICAgICAgICAqIChkZWZhdWx0KSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBzdHJhaWdodCBzdHJpbmcuIFdoZW4gYHNtYXJ0YFxuICAgICAgICAgICAgICogRGF0YVRhYmxlcyB3aWxsIHVzZSBpdCdzIHNtYXJ0IGZpbHRlcmluZyBtZXRob2RzICh0byB3b3JkIG1hdGNoIGF0XG4gICAgICAgICAgICAgKiBhbnkgcG9pbnQgaW4gdGhlIGRhdGEpLCB3aGVuIGZhbHNlIHRoaXMgd2lsbCBub3QgYmUgZG9uZS5cbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAgICAgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5vU2VhcmNoXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic2VhcmNoXCI6IHtcInNlYXJjaFwiOiBcIkluaXRpYWwgc2VhcmNoXCJ9XG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm9TZWFyY2hcIjogJC5leHRlbmQoe30sIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaCksXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBfX0RlcHJlY2F0ZWRfXyBUaGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBieSB0aGlzIHBhcmFtZXRlciBoYXMgbm93IGJlZW5cbiAgICAgICAgICAgICAqIHN1cGVyc2VkZWQgYnkgdGhhdCBwcm92aWRlZCB0aHJvdWdoIGBhamF4YCwgd2hpY2ggc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCeSBkZWZhdWx0IERhdGFUYWJsZXMgd2lsbCBsb29rIGZvciB0aGUgcHJvcGVydHkgYGRhdGFgIChvciBgYWFEYXRhYCBmb3JcbiAgICAgICAgICAgICAqIGNvbXBhdGliaWxpdHkgd2l0aCBEYXRhVGFibGVzIDEuOS0pIHdoZW4gb2J0YWluaW5nIGRhdGEgZnJvbSBhbiBBamF4XG4gICAgICAgICAgICAgKiBzb3VyY2Ugb3IgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcgLSB0aGlzIHBhcmFtZXRlciBhbGxvd3MgdGhhdFxuICAgICAgICAgICAgICogcHJvcGVydHkgdG8gYmUgY2hhbmdlZC4gWW91IGNhbiB1c2UgSmF2YXNjcmlwdCBkb3R0ZWQgb2JqZWN0IG5vdGF0aW9uIHRvXG4gICAgICAgICAgICAgKiBnZXQgYSBkYXRhIHNvdXJjZSBmb3IgbXVsdGlwbGUgbGV2ZWxzIG9mIG5lc3RpbmcuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZGF0YVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgT3B0aW9uc1xuICAgICAgICAgICAgICogIEBkdG9wdCBTZXJ2ZXItc2lkZVxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5hamF4RGF0YVByb3BcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0FqYXhEYXRhUHJvcFwiOiBcImRhdGFcIixcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFlvdSBjYW4gaW5zdHJ1Y3QgRGF0YVRhYmxlcyB0byBsb2FkIGRhdGEgZnJvbSBhbiBleHRlcm5hbFxuICAgICAgICAgICAgICogc291cmNlIHVzaW5nIHRoaXMgcGFyYW1ldGVyICh1c2UgYURhdGEgaWYgeW91IHdhbnQgdG8gcGFzcyBkYXRhIGluIHlvdVxuICAgICAgICAgICAgICogYWxyZWFkeSBoYXZlKS4gU2ltcGx5IHByb3ZpZGUgYSB1cmwgYSBKU09OIG9iamVjdCBjYW4gYmUgb2J0YWluZWQgZnJvbS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmFqYXhTb3VyY2VcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgMS4xMC4gUGxlYXNlIHVzZSBgYWpheGAgZm9yIHRoaXMgZnVuY3Rpb25hbGl0eSBub3cuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0FqYXhTb3VyY2VcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaW5pdGlhbGlzYXRpb24gdmFyaWFibGUgYWxsb3dzIHlvdSB0byBzcGVjaWZ5IGV4YWN0bHkgd2hlcmUgaW4gdGhlXG4gICAgICAgICAgICAgKiBET00geW91IHdhbnQgRGF0YVRhYmxlcyB0byBpbmplY3QgdGhlIHZhcmlvdXMgY29udHJvbHMgaXQgYWRkcyB0byB0aGUgcGFnZVxuICAgICAgICAgICAgICogKGZvciBleGFtcGxlIHlvdSBtaWdodCB3YW50IHRoZSBwYWdpbmF0aW9uIGNvbnRyb2xzIGF0IHRoZSB0b3Agb2YgdGhlXG4gICAgICAgICAgICAgKiB0YWJsZSkuIERJViBlbGVtZW50cyAod2l0aCBvciB3aXRob3V0IGEgY3VzdG9tIGNsYXNzKSBjYW4gYWxzbyBiZSBhZGRlZCB0b1xuICAgICAgICAgICAgICogYWlkIHN0eWxpbmcuIFRoZSBmb2xsb3cgc3ludGF4IGlzIHVzZWQ6XG4gICAgICAgICAgICAgKiAgIDx1bD5cbiAgICAgICAgICAgICAqICAgICA8bGk+VGhlIGZvbGxvd2luZyBvcHRpb25zIGFyZSBhbGxvd2VkOlxuICAgICAgICAgICAgICogICAgICAgPHVsPlxuICAgICAgICAgICAgICogICAgICAgICA8bGk+J2wnIC0gTGVuZ3RoIGNoYW5naW5nPC9saT5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG4gICAgICAgICAgICAgKiAgICAgICAgIDxsaT4ndCcgLSBUaGUgdGFibGUhPC9saT5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPidpJyAtIEluZm9ybWF0aW9uPC9saT5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuICAgICAgICAgICAgICogICAgICAgICA8bGk+J3InIC0gcFJvY2Vzc2luZzwvbGk+XG4gICAgICAgICAgICAgKiAgICAgICA8L3VsPlxuICAgICAgICAgICAgICogICAgIDwvbGk+XG4gICAgICAgICAgICAgKiAgICAgPGxpPlRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSBhbGxvd2VkOlxuICAgICAgICAgICAgICogICAgICAgPHVsPlxuICAgICAgICAgICAgICogICAgICAgICA8bGk+J0gnIC0galF1ZXJ5VUkgdGhlbWUgXCJoZWFkZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci10bCB1aS1jb3JuZXItdHIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuICAgICAgICAgICAgICogICAgICAgICA8bGk+J0YnIC0galF1ZXJ5VUkgdGhlbWUgXCJmb290ZXJcIiBjbGFzc2VzICgnZmctdG9vbGJhciB1aS13aWRnZXQtaGVhZGVyIHVpLWNvcm5lci1ibCB1aS1jb3JuZXItYnIgdWktaGVscGVyLWNsZWFyZml4Jyk8L2xpPlxuICAgICAgICAgICAgICogICAgICAgPC91bD5cbiAgICAgICAgICAgICAqICAgICA8L2xpPlxuICAgICAgICAgICAgICogICAgIDxsaT5UaGUgZm9sbG93aW5nIHN5bnRheCBpcyBleHBlY3RlZDpcbiAgICAgICAgICAgICAqICAgICAgIDx1bD5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7JyBhbmQgJyZndDsnIC0gZGl2IGVsZW1lbnRzPC9saT5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7XCJjbGFzc1wiIGFuZCAnJmd0OycgLSBkaXYgd2l0aCBhIGNsYXNzPC9saT5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7XCIjaWRcIiBhbmQgJyZndDsnIC0gZGl2IHdpdGggYW4gSUQ8L2xpPlxuICAgICAgICAgICAgICogICAgICAgPC91bD5cbiAgICAgICAgICAgICAqICAgICA8L2xpPlxuICAgICAgICAgICAgICogICAgIDxsaT5FeGFtcGxlczpcbiAgICAgICAgICAgICAqICAgICAgIDx1bD5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7XCJ3cmFwcGVyXCJmbGlwdCZndDsnPC9saT5cbiAgICAgICAgICAgICAqICAgICAgICAgPGxpPicmbHQ7bGYmbHQ7dCZndDtpcCZndDsnPC9saT5cbiAgICAgICAgICAgICAqICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgKiAgICAgPC9saT5cbiAgICAgICAgICAgICAqICAgPC91bD5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBsZnJ0aXAgPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyBmYWxzZSk8L2k+IDxiPm9yPC9iPlxuICAgICAgICAgICAgICogICAgPFwiSFwibGZyPnQ8XCJGXCJpcD4gPGk+KHdoZW4gYGpRdWVyeVVJYCBpcyB0cnVlKTwvaT5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGR0b3B0IE9wdGlvbnNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuZG9tXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJkb21cIjogJyZsdDtcInRvcFwiaSZndDtydCZsdDtcImJvdHRvbVwiZmxwJmd0OyZsdDtcImNsZWFyXCImZ3Q7J1xuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0RvbVwiOiBcImxmcnRpcFwiLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VhcmNoIGRlbGF5IG9wdGlvbi4gVGhpcyB3aWxsIHRocm90dGxlIGZ1bGwgdGFibGUgc2VhcmNoZXMgdGhhdCB1c2UgdGhlXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIHByb3ZpZGVkIHNlYXJjaCBpbnB1dCBlbGVtZW50IChpdCBkb2VzIG5vdCBlZmZlY3QgY2FsbHMgdG9cbiAgICAgICAgICAgICAqIGBkdC1hcGkgc2VhcmNoKClgLCBwcm92aWRpbmcgYSBkZWxheSBiZWZvcmUgdGhlIHNlYXJjaCBpcyBtYWRlLlxuICAgICAgICAgICAgICogIEB0eXBlIGludGVnZXJcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlYXJjaERlbGF5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJzZWFyY2hEZWxheVwiOiAyMDBcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic2VhcmNoRGVsYXlcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERhdGFUYWJsZXMgZmVhdHVyZXMgc2l4IGRpZmZlcmVudCBidWlsdC1pbiBvcHRpb25zIGZvciB0aGUgYnV0dG9ucyB0b1xuICAgICAgICAgICAgICogZGlzcGxheSBmb3IgcGFnaW5hdGlvbiBjb250cm9sOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICogYG51bWJlcnNgIC0gUGFnZSBudW1iZXIgYnV0dG9ucyBvbmx5XG4gICAgICAgICAgICAgKiAqIGBzaW1wbGVgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMgb25seVxuICAgICAgICAgICAgICogKiAnc2ltcGxlX251bWJlcnNgIC0gJ1ByZXZpb3VzJyBhbmQgJ05leHQnIGJ1dHRvbnMsIHBsdXMgcGFnZSBudW1iZXJzXG4gICAgICAgICAgICAgKiAqIGBmdWxsYCAtICdGaXJzdCcsICdQcmV2aW91cycsICdOZXh0JyBhbmQgJ0xhc3QnIGJ1dHRvbnNcbiAgICAgICAgICAgICAqICogYGZ1bGxfbnVtYmVyc2AgLSAnRmlyc3QnLCAnUHJldmlvdXMnLCAnTmV4dCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuICAgICAgICAgICAgICogKiBgZmlyc3RfbGFzdF9udW1iZXJzYCAtICdGaXJzdCcgYW5kICdMYXN0JyBidXR0b25zLCBwbHVzIHBhZ2UgbnVtYmVyc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEZ1cnRoZXIgbWV0aG9kcyBjYW4gYmUgYWRkZWQgdXNpbmcge0BsaW5rIERhdGFUYWJsZS5leHQub1BhZ2luYXRpb259LlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IHNpbXBsZV9udW1iZXJzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnBhZ2luZ1R5cGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcInBhZ2luZ1R5cGVcIjogXCJmdWxsX251bWJlcnNcIlxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9IClcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzUGFnaW5hdGlvblR5cGVcIjogXCJzaW1wbGVfbnVtYmVyc1wiLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5hYmxlIGhvcml6b250YWwgc2Nyb2xsaW5nLiBXaGVuIGEgdGFibGUgaXMgdG9vIHdpZGUgdG8gZml0IGludG8gYVxuICAgICAgICAgICAgICogY2VydGFpbiBsYXlvdXQsIG9yIHlvdSBoYXZlIGEgbGFyZ2UgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLCB5b3VcbiAgICAgICAgICAgICAqIGNhbiBlbmFibGUgeC1zY3JvbGxpbmcgdG8gc2hvdyB0aGUgdGFibGUgaW4gYSB2aWV3cG9ydCwgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAgKiBzY3JvbGxlZC4gVGhpcyBwcm9wZXJ0eSBjYW4gYmUgYHRydWVgIHdoaWNoIHdpbGwgYWxsb3cgdGhlIHRhYmxlIHRvXG4gICAgICAgICAgICAgKiBzY3JvbGwgaG9yaXpvbnRhbGx5IHdoZW4gbmVlZGVkLCBvciBhbnkgQ1NTIHVuaXQsIG9yIGEgbnVtYmVyIChpbiB3aGljaFxuICAgICAgICAgICAgICogY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbCBtZWFzdXJlbWVudCkuIFNldHRpbmcgYXMgc2ltcGx5IGB0cnVlYFxuICAgICAgICAgICAgICogaXMgcmVjb21tZW5kZWQuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhbnxzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsWFwiOiB0cnVlLFxuICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsQ29sbGFwc2VcIjogdHJ1ZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1Njcm9sbFhcIjogXCJcIixcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgcHJvcGVydHkgY2FuIGJlIHVzZWQgdG8gZm9yY2UgYSBEYXRhVGFibGUgdG8gdXNlIG1vcmUgd2lkdGggdGhhbiBpdFxuICAgICAgICAgICAgICogbWlnaHQgb3RoZXJ3aXNlIGRvIHdoZW4geC1zY3JvbGxpbmcgaXMgZW5hYmxlZC4gRm9yIGV4YW1wbGUgaWYgeW91IGhhdmUgYVxuICAgICAgICAgICAgICogdGFibGUgd2hpY2ggcmVxdWlyZXMgdG8gYmUgd2VsbCBzcGFjZWQsIHRoaXMgcGFyYW1ldGVyIGlzIHVzZWZ1bCBmb3JcbiAgICAgICAgICAgICAqIFwib3Zlci1zaXppbmdcIiB0aGUgdGFibGUsIGFuZCB0aHVzIGZvcmNpbmcgc2Nyb2xsaW5nLiBUaGlzIHByb3BlcnR5IGNhbiBieVxuICAgICAgICAgICAgICogYW55IENTUyB1bml0LCBvciBhIG51bWJlciAoaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGJlIHRyZWF0ZWQgYXMgYSBwaXhlbFxuICAgICAgICAgICAgICogbWVhc3VyZW1lbnQpLlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IDxpPmJsYW5rIHN0cmluZyAtIGkuZS4gZGlzYWJsZWQ8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNjcm9sbFhJbm5lclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsWFwiOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAqICAgICAgICBcInNjcm9sbFhJbm5lclwiOiBcIjExMCVcIlxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1Njcm9sbFhJbm5lclwiOiBcIlwiLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5hYmxlIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIHdpbGwgY29uc3RyYWluIHRoZSBEYXRhVGFibGVcbiAgICAgICAgICAgICAqIHRvIHRoZSBnaXZlbiBoZWlnaHQsIGFuZCBlbmFibGUgc2Nyb2xsaW5nIGZvciBhbnkgZGF0YSB3aGljaCBvdmVyZmxvd3MgdGhlXG4gICAgICAgICAgICAgKiBjdXJyZW50IHZpZXdwb3J0LiBUaGlzIGNhbiBiZSB1c2VkIGFzIGFuIGFsdGVybmF0aXZlIHRvIHBhZ2luZyB0byBkaXNwbGF5XG4gICAgICAgICAgICAgKiBhIGxvdCBvZiBkYXRhIGluIGEgc21hbGwgYXJlYSAoYWx0aG91Z2ggcGFnaW5nIGFuZCBzY3JvbGxpbmcgY2FuIGJvdGggYmVcbiAgICAgICAgICAgICAqIGVuYWJsZWQgYXQgdGhlIHNhbWUgdGltZSkuIFRoaXMgcHJvcGVydHkgY2FuIGJlIGFueSBDU1MgdW5pdCwgb3IgYSBudW1iZXJcbiAgICAgICAgICAgICAqIChpbiB3aGljaCBjYXNlIGl0IHdpbGwgYmUgdHJlYXRlZCBhcyBhIHBpeGVsIG1lYXN1cmVtZW50KS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5ibGFuayBzdHJpbmcgLSBpLmUuIGRpc2FibGVkPC9pPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZHRvcHQgRmVhdHVyZXNcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuc2Nyb2xsWVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwic2Nyb2xsWVwiOiBcIjIwMHB4XCIsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJwYWdpbmF0ZVwiOiBmYWxzZVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1Njcm9sbFlcIjogXCJcIixcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIF9fRGVwcmVjYXRlZF9fIFRoZSBmdW5jdGlvbmFsaXR5IHByb3ZpZGVkIGJ5IHRoaXMgcGFyYW1ldGVyIGhhcyBub3cgYmVlblxuICAgICAgICAgICAgICogc3VwZXJzZWRlZCBieSB0aGF0IHByb3ZpZGVkIHRocm91Z2ggYGFqYXhgLCB3aGljaCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFNldCB0aGUgSFRUUCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIG1ha2UgdGhlIEFqYXggY2FsbCBmb3Igc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAqIHByb2Nlc3Npbmcgb3IgQWpheCBzb3VyY2VkIGRhdGEuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgR0VUXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBkdG9wdCBPcHRpb25zXG4gICAgICAgICAgICAgKiAgQGR0b3B0IFNlcnZlci1zaWRlXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnNlcnZlck1ldGhvZFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCAxLjEwLiBQbGVhc2UgdXNlIGBhamF4YCBmb3IgdGhpcyBmdW5jdGlvbmFsaXR5IG5vdy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzU2VydmVyTWV0aG9kXCI6IFwiR0VUXCIsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIG1ha2VzIHVzZSBvZiByZW5kZXJlcnMgd2hlbiBkaXNwbGF5aW5nIEhUTUwgZWxlbWVudHMgZm9yXG4gICAgICAgICAgICAgKiBhIHRhYmxlLiBUaGVzZSByZW5kZXJlcnMgY2FuIGJlIGFkZGVkIG9yIG1vZGlmaWVkIGJ5IHBsdWctaW5zIHRvXG4gICAgICAgICAgICAgKiBnZW5lcmF0ZSBzdWl0YWJsZSBtYXJrLXVwIGZvciBhIHNpdGUuIEZvciBleGFtcGxlIHRoZSBCb290c3RyYXBcbiAgICAgICAgICAgICAqIGludGVncmF0aW9uIHBsdWctaW4gZm9yIERhdGFUYWJsZXMgdXNlcyBhIHBhZ2luZyBidXR0b24gcmVuZGVyZXIgdG9cbiAgICAgICAgICAgICAqIGRpc3BsYXkgcGFnaW5hdGlvbiBidXR0b25zIGluIHRoZSBtYXJrLXVwIHJlcXVpcmVkIGJ5IEJvb3RzdHJhcC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3IgZnVydGhlciBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVuZGVyZXJzIGF2YWlsYWJsZSBzZWVcbiAgICAgICAgICAgICAqIERhdGFUYWJsZS5leHQucmVuZGVyZXJcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8b2JqZWN0XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMucmVuZGVyZXJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwicmVuZGVyZXJcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgZGF0YSBwcm9wZXJ0eSBuYW1lIHRoYXQgRGF0YVRhYmxlcyBzaG91bGQgdXNlIHRvIGdldCBhIHJvdydzIGlkXG4gICAgICAgICAgICAgKiB0byBzZXQgYXMgdGhlIGBpZGAgcHJvcGVydHkgaW4gdGhlIG5vZGUuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgRFRfUm93SWRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLnJvd0lkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwicm93SWRcIjogXCJEVF9Sb3dJZFwiXG4gICAgICAgIH07XG5cbiAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwKERhdGFUYWJsZS5kZWZhdWx0cyk7XG5cblxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIERldmVsb3BlciBub3RlIC0gU2VlIG5vdGUgaW4gbW9kZWwuZGVmYXVsdHMuanMgYWJvdXQgdGhlIHVzZSBvZiBIdW5nYXJpYW5cbiAgICAgICAgICogbm90YXRpb24gYW5kIGNhbWVsIGNhc2UuXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2x1bW4gb3B0aW9ucyB0aGF0IGNhbiBiZSBnaXZlbiB0byBEYXRhVGFibGVzIGF0IGluaXRpYWxpc2F0aW9uIHRpbWUuXG4gICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uID0ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWZpbmUgd2hpY2ggY29sdW1uKHMpIGFuIG9yZGVyIHdpbGwgb2NjdXIgb24gZm9yIHRoaXMgY29sdW1uLiBUaGlzXG4gICAgICAgICAgICAgKiBhbGxvd3MgYSBjb2x1bW4ncyBvcmRlcmluZyB0byB0YWtlIG11bHRpcGxlIGNvbHVtbnMgaW50byBhY2NvdW50IHdoZW5cbiAgICAgICAgICAgICAqIGRvaW5nIGEgc29ydCBvciB1c2UgdGhlIGRhdGEgZnJvbSBhIGRpZmZlcmVudCBjb2x1bW4uIEZvciBleGFtcGxlIGZpcnN0XG4gICAgICAgICAgICAgKiBuYW1lIC8gbGFzdCBuYW1lIGNvbHVtbnMgbWFrZSBzZW5zZSB0byBkbyBhIG11bHRpLWNvbHVtbiBzb3J0IG92ZXIgdGhlXG4gICAgICAgICAgICAgKiB0d28gY29sdW1ucy5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheXxpbnRcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPlRha2VzIHRoZSB2YWx1ZSBvZiB0aGUgY29sdW1uIGluZGV4IGF1dG9tYXRpY2FsbHk8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJEYXRhXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhXCI6IFsgMCwgMSBdLCBcInRhcmdldHNcIjogWyAwIF0gfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVwiOiAyLCBcInRhcmdldHNcIjogWyAyIF0gfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAwLCAxIF0gfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogWyAxLCAwIF0gfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFcIjogMiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhRGF0YVNvcnRcIjogbnVsbCxcbiAgICAgICAgICAgIFwiaURhdGFTb3J0XCI6IC0xLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogWW91IGNhbiBjb250cm9sIHRoZSBkZWZhdWx0IG9yZGVyaW5nIGRpcmVjdGlvbiwgYW5kIGV2ZW4gYWx0ZXIgdGhlXG4gICAgICAgICAgICAgKiBiZWhhdmlvdXIgb2YgdGhlIHNvcnQgaGFuZGxlciAoaS5lLiBvbmx5IGFsbG93IGFzY2VuZGluZyBvcmRlcmluZyBldGMpXG4gICAgICAgICAgICAgKiB1c2luZyB0aGlzIHBhcmFtZXRlci5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFsgJ2FzYycsICdkZXNjJyBdXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJTZXF1ZW5jZVxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0sIFwidGFyZ2V0c1wiOiBbIDEgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiwgXCJhc2NcIiwgXCJhc2NcIiBdLCBcInRhcmdldHNcIjogWyAyIF0gfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIgXSwgXCJ0YXJnZXRzXCI6IFsgMyBdIH1cbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImFzY1wiIF0gfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlclNlcXVlbmNlXCI6IFsgXCJkZXNjXCIsIFwiYXNjXCIsIFwiYXNjXCIgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyU2VxdWVuY2VcIjogWyBcImRlc2NcIiBdIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYXNTb3J0aW5nXCI6IFsnYXNjJywgJ2Rlc2MnXSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIGZpbHRlcmluZyBvbiB0aGUgZGF0YSBpbiB0aGlzIGNvbHVtbi5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLnNlYXJjaGFibGVcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJzZWFyY2hhYmxlXCI6IGZhbHNlIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlNlYXJjaGFibGVcIjogdHJ1ZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIG9yZGVyaW5nIG9uIHRoaXMgY29sdW1uLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ub3JkZXJhYmxlXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJhYmxlXCI6IGZhbHNlLCBcInRhcmdldHNcIjogWyAwIF0gfVxuICAgICAgICAgICAgICogICAgICAgIF0gfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlcmFibGVcIjogZmFsc2UgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiU29ydGFibGVcIjogdHJ1ZSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIHRoZSBkaXNwbGF5IG9mIHRoaXMgY29sdW1uLlxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udmlzaWJsZVxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG4gICAgICAgICAgICAgKiAgICAgICAgXSB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcInZpc2libGVcIjogZmFsc2UgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAqICAgICAgICBdIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiVmlzaWJsZVwiOiB0cnVlLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV2ZWxvcGVyIGRlZmluYWJsZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuZXZlciBhIGNlbGwgaXMgY3JlYXRlZCAoQWpheCBzb3VyY2UsXG4gICAgICAgICAgICAgKiBldGMpIG9yIHByb2Nlc3NlZCBmb3IgaW5wdXQgKERPTSBzb3VyY2UpLiBUaGlzIGNhbiBiZSB1c2VkIGFzIGEgY29tcGxpbWVudCB0byBtUmVuZGVyXG4gICAgICAgICAgICAgKiBhbGxvd2luZyB5b3UgdG8gbW9kaWZ5IHRoZSBET00gZWxlbWVudCAoYWRkIGJhY2tncm91bmQgY29sb3VyIGZvciBleGFtcGxlKSB3aGVuIHRoZVxuICAgICAgICAgICAgICogZWxlbWVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAcGFyYW0ge2VsZW1lbnR9IHRkIFRoZSBURCBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICogIEBwYXJhbSB7Kn0gY2VsbERhdGEgVGhlIERhdGEgZm9yIHRoZSBjZWxsXG4gICAgICAgICAgICAgKiAgQHBhcmFtIHthcnJheXxvYmplY3R9IHJvd0RhdGEgVGhlIGRhdGEgZm9yIHRoZSB3aG9sZSByb3dcbiAgICAgICAgICAgICAqICBAcGFyYW0ge2ludH0gcm93IFRoZSByb3cgaW5kZXggZm9yIHRoZSBhb0RhdGEgZGF0YSBzdG9yZVxuICAgICAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2wgVGhlIGNvbHVtbiBpbmRleCBmb3IgYW9Db2x1bW5zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY3JlYXRlZENlbGxcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbM10sXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImNyZWF0ZWRDZWxsXCI6IGZ1bmN0aW9uICh0ZCwgY2VsbERhdGEsIHJvd0RhdGEsIHJvdywgY29sKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIGlmICggY2VsbERhdGEgPT0gXCIxLjdcIiApIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICAkKHRkKS5jc3MoJ2NvbG9yJywgJ2JsdWUnKVxuICAgICAgICAgICAgICogICAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgfSBdXG4gICAgICAgICAgICAgKiAgICAgIH0pO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuQ3JlYXRlZENlbGxcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlcGxhY2VkIGJ5IGBkYXRhYCBpbiBEYXRhVGFibGVzIHRvIGVuc3VyZSBuYW1pbmdcbiAgICAgICAgICAgICAqIGNvbnNpc3RlbmN5LiBgZGF0YVByb3BgIGNhbiBzdGlsbCBiZSB1c2VkLCBhcyB0aGVyZSBpcyBiYWNrd2FyZHNcbiAgICAgICAgICAgICAqIGNvbXBhdGliaWxpdHkgaW4gRGF0YVRhYmxlcyBmb3IgdGhpcyBvcHRpb24sIGJ1dCBpdCBpcyBzdHJvbmdseVxuICAgICAgICAgICAgICogcmVjb21tZW5kZWQgdGhhdCB5b3UgdXNlIGBkYXRhYCBpbiBwcmVmZXJlbmNlIHRvIGBkYXRhUHJvcGAuXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5kYXRhUHJvcFxuICAgICAgICAgICAgICovXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHByb3BlcnR5IGNhbiBiZSB1c2VkIHRvIHJlYWQgZGF0YSBmcm9tIGFueSBkYXRhIHNvdXJjZSBwcm9wZXJ0eSxcbiAgICAgICAgICAgICAqIGluY2x1ZGluZyBkZWVwbHkgbmVzdGVkIG9iamVjdHMgLyBwcm9wZXJ0aWVzLiBgZGF0YWAgY2FuIGJlIGdpdmVuIGluIGFcbiAgICAgICAgICAgICAqIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB3aGljaCBlZmZlY3QgaXRzIGJlaGF2aW91cjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqIGBpbnRlZ2VyYCAtIHRyZWF0ZWQgYXMgYW4gYXJyYXkgaW5kZXggZm9yIHRoZSBkYXRhIHNvdXJjZS4gVGhpcyBpcyB0aGVcbiAgICAgICAgICAgICAqICAgZGVmYXVsdCB0aGF0IERhdGFUYWJsZXMgdXNlcyAoaW5jcmVtZW50YWxseSBpbmNyZWFzZWQgZm9yIGVhY2ggY29sdW1uKS5cbiAgICAgICAgICAgICAqICogYHN0cmluZ2AgLSByZWFkIGFuIG9iamVjdCBwcm9wZXJ0eSBmcm9tIHRoZSBkYXRhIHNvdXJjZS4gVGhlcmUgYXJlXG4gICAgICAgICAgICAgKiAgIHRocmVlICdzcGVjaWFsJyBvcHRpb25zIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIHN0cmluZyB0byBhbHRlciBob3dcbiAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyByZWFkcyB0aGUgZGF0YSBmcm9tIHRoZSBzb3VyY2Ugb2JqZWN0OlxuICAgICAgICAgICAgICogICAgKiBgLmAgLSBEb3R0ZWQgSmF2YXNjcmlwdCBub3RhdGlvbi4gSnVzdCBhcyB5b3UgdXNlIGEgYC5gIGluXG4gICAgICAgICAgICAgKiAgICAgIEphdmFzY3JpcHQgdG8gcmVhZCBmcm9tIG5lc3RlZCBvYmplY3RzLCBzbyB0byBjYW4gdGhlIG9wdGlvbnNcbiAgICAgICAgICAgICAqICAgICAgc3BlY2lmaWVkIGluIGBkYXRhYC4gRm9yIGV4YW1wbGU6IGBicm93c2VyLnZlcnNpb25gIG9yXG4gICAgICAgICAgICAgKiAgICAgIGBicm93c2VyLm5hbWVgLiBJZiB5b3VyIG9iamVjdCBwYXJhbWV0ZXIgbmFtZSBjb250YWlucyBhIHBlcmlvZCwgdXNlXG4gICAgICAgICAgICAgKiAgICAgIGBcXFxcYCB0byBlc2NhcGUgaXQgLSBpLmUuIGBmaXJzdFxcXFwubmFtZWAuXG4gICAgICAgICAgICAgKiAgICAqIGBbXWAgLSBBcnJheSBub3RhdGlvbi4gRGF0YVRhYmxlcyBjYW4gYXV0b21hdGljYWxseSBjb21iaW5lIGRhdGFcbiAgICAgICAgICAgICAqICAgICAgZnJvbSBhbmQgYXJyYXkgc291cmNlLCBqb2luaW5nIHRoZSBkYXRhIHdpdGggdGhlIGNoYXJhY3RlcnMgcHJvdmlkZWRcbiAgICAgICAgICAgICAqICAgICAgYmV0d2VlbiB0aGUgdHdvIGJyYWNrZXRzLiBGb3IgZXhhbXBsZTogYG5hbWVbLCBdYCB3b3VsZCBwcm92aWRlIGFcbiAgICAgICAgICAgICAqICAgICAgY29tbWEtc3BhY2Ugc2VwYXJhdGVkIGxpc3QgZnJvbSB0aGUgc291cmNlIGFycmF5LiBJZiBubyBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgKiAgICAgIGFyZSBwcm92aWRlZCBiZXR3ZWVuIHRoZSBicmFja2V0cywgdGhlIG9yaWdpbmFsIGFycmF5IHNvdXJjZSBpc1xuICAgICAgICAgICAgICogICAgICByZXR1cm5lZC5cbiAgICAgICAgICAgICAqICAgICogYCgpYCAtIEZ1bmN0aW9uIG5vdGF0aW9uLiBBZGRpbmcgYCgpYCB0byB0aGUgZW5kIG9mIGEgcGFyYW1ldGVyIHdpbGxcbiAgICAgICAgICAgICAqICAgICAgZXhlY3V0ZSBhIGZ1bmN0aW9uIG9mIHRoZSBuYW1lIGdpdmVuLiBGb3IgZXhhbXBsZTogYGJyb3dzZXIoKWAgZm9yIGFcbiAgICAgICAgICAgICAqICAgICAgc2ltcGxlIGZ1bmN0aW9uIG9uIHRoZSBkYXRhIHNvdXJjZSwgYGJyb3dzZXIudmVyc2lvbigpYCBmb3IgYVxuICAgICAgICAgICAgICogICAgICBmdW5jdGlvbiBpbiBhIG5lc3RlZCBwcm9wZXJ0eSBvciBldmVuIGBicm93c2VyKCkudmVyc2lvbmAgdG8gZ2V0IGFuXG4gICAgICAgICAgICAgKiAgICAgIG9iamVjdCBwcm9wZXJ0eSBpZiB0aGUgZnVuY3Rpb24gY2FsbGVkIHJldHVybnMgYW4gb2JqZWN0LiBOb3RlIHRoYXRcbiAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gbm90YXRpb24gaXMgcmVjb21tZW5kZWQgZm9yIHVzZSBpbiBgcmVuZGVyYCByYXRoZXIgdGhhblxuICAgICAgICAgICAgICogICAgICBgZGF0YWAgYXMgaXQgaXMgbXVjaCBzaW1wbGVyIHRvIHVzZSBhcyBhIHJlbmRlcmVyLlxuICAgICAgICAgICAgICogKiBgbnVsbGAgLSB1c2UgdGhlIG9yaWdpbmFsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IHJhdGhlciB0aGFuIHBsdWNraW5nXG4gICAgICAgICAgICAgKiAgIGRhdGEgZGlyZWN0bHkgZnJvbSBpdC4gVGhpcyBhY3Rpb24gaGFzIGVmZmVjdHMgb24gdHdvIG90aGVyXG4gICAgICAgICAgICAgKiAgIGluaXRpYWxpc2F0aW9uIG9wdGlvbnM6XG4gICAgICAgICAgICAgKiAgICAqIGBkZWZhdWx0Q29udGVudGAgLSBXaGVuIG51bGwgaXMgZ2l2ZW4gYXMgdGhlIGBkYXRhYCBvcHRpb24gYW5kXG4gICAgICAgICAgICAgKiAgICAgIGBkZWZhdWx0Q29udGVudGAgaXMgc3BlY2lmaWVkIGZvciB0aGUgY29sdW1uLCB0aGUgdmFsdWUgZGVmaW5lZCBieVxuICAgICAgICAgICAgICogICAgICBgZGVmYXVsdENvbnRlbnRgIHdpbGwgYmUgdXNlZCBmb3IgdGhlIGNlbGwuXG4gICAgICAgICAgICAgKiAgICAqIGByZW5kZXJgIC0gV2hlbiBudWxsIGlzIHVzZWQgZm9yIHRoZSBgZGF0YWAgb3B0aW9uIGFuZCB0aGUgYHJlbmRlcmBcbiAgICAgICAgICAgICAqICAgICAgb3B0aW9uIGlzIHNwZWNpZmllZCBmb3IgdGhlIGNvbHVtbiwgdGhlIHdob2xlIGRhdGEgc291cmNlIGZvciB0aGVcbiAgICAgICAgICAgICAqICAgICAgcm93IGlzIHVzZWQgZm9yIHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgICAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICogICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICogICAgICAqIGB7YXJyYXl8b2JqZWN0fWAgVGhlIGRhdGEgc291cmNlIGZvciB0aGUgcm93XG4gICAgICAgICAgICAgKiAgICAgICogYHtzdHJpbmd9YCBUaGUgdHlwZSBjYWxsIGRhdGEgcmVxdWVzdGVkIC0gdGhpcyB3aWxsIGJlICdzZXQnIHdoZW5cbiAgICAgICAgICAgICAqICAgICAgICBzZXR0aW5nIGRhdGEgb3IgJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnLCAnc29ydCcgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICAgKiAgICAgICAgd2hlbiBnYXRoZXJpbmcgZGF0YS4gTm90ZSB0aGF0IHdoZW4gYHVuZGVmaW5lZGAgaXMgZ2l2ZW4gZm9yIHRoZVxuICAgICAgICAgICAgICogICAgICAgIHR5cGUgRGF0YVRhYmxlcyBleHBlY3RzIHRvIGdldCB0aGUgcmF3IGRhdGEgZm9yIHRoZSBvYmplY3QgYmFjazxcbiAgICAgICAgICAgICAqICAgICAgKiBgeyp9YCBEYXRhIHRvIHNldCB3aGVuIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzICdzZXQnLlxuICAgICAgICAgICAgICogICAgKiBSZXR1cm46XG4gICAgICAgICAgICAgKiAgICAgICogVGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBmdW5jdGlvbiBpcyBub3QgcmVxdWlyZWQgd2hlbiAnc2V0JyBpc1xuICAgICAgICAgICAgICogICAgICAgIHRoZSB0eXBlIG9mIGNhbGwsIGJ1dCBvdGhlcndpc2UgdGhlIHJldHVybiBpcyB3aGF0IHdpbGwgYmUgdXNlZFxuICAgICAgICAgICAgICogICAgICAgIGZvciB0aGUgZGF0YSByZXF1ZXN0ZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IGBkYXRhYCBpcyBhIGdldHRlciBhbmQgc2V0dGVyIG9wdGlvbi4gSWYgeW91IGp1c3QgcmVxdWlyZVxuICAgICAgICAgICAgICogZm9ybWF0dGluZyBvZiBkYXRhIGZvciBvdXRwdXQsIHlvdSB3aWxsIGxpa2VseSB3YW50IHRvIHVzZSBgcmVuZGVyYCB3aGljaFxuICAgICAgICAgICAgICogaXMgc2ltcGx5IGEgZ2V0dGVyIGFuZCB0aHVzIHNpbXBsZXIgdG8gdXNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCBwcmlvciB0byBEYXRhVGFibGVzIDEuOS4yIGBkYXRhYCB3YXMgY2FsbGVkIGBtRGF0YVByb3BgLiBUaGVcbiAgICAgICAgICAgICAqIG5hbWUgY2hhbmdlIHJlZmxlY3RzIHRoZSBmbGV4aWJpbGl0eSBvZiB0aGlzIHByb3BlcnR5IGFuZCBpcyBjb25zaXN0ZW50XG4gICAgICAgICAgICAgKiB3aXRoIHRoZSBuYW1pbmcgb2YgbVJlbmRlci4gSWYgJ21EYXRhUHJvcCcgaXMgZ2l2ZW4sIHRoZW4gaXQgd2lsbCBzdGlsbFxuICAgICAgICAgICAgICogYmUgdXNlZCBieSBEYXRhVGFibGVzLCBhcyBpdCBhdXRvbWF0aWNhbGx5IG1hcHMgdGhlIG9sZCBuYW1lIHRvIHRoZSBuZXdcbiAgICAgICAgICAgICAqIGlmIHJlcXVpcmVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmd8aW50fGZ1bmN0aW9ufG51bGxcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsIDxpPlVzZSBhdXRvbWF0aWNhbGx5IGNhbGN1bGF0ZWQgY29sdW1uIGluZGV4PC9pPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRhdGFcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gUmVhZCB0YWJsZSBkYXRhIGZyb20gb2JqZWN0c1xuICAgICAgICAgICAgICogICAgLy8gSlNPTiBzdHJ1Y3R1cmUgZm9yIGVhY2ggcm93OlxuICAgICAgICAgICAgICogICAgLy8gICB7XG4gICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiZW5naW5lXCI6IHt2YWx1ZX0sXG4gICAgICAgICAgICAgKiAgICAvLyAgICAgIFwiYnJvd3NlclwiOiB7dmFsdWV9LFxuICAgICAgICAgICAgICogICAgLy8gICAgICBcInBsYXRmb3JtXCI6IHt2YWx1ZX0sXG4gICAgICAgICAgICAgKiAgICAvLyAgICAgIFwidmVyc2lvblwiOiB7dmFsdWV9LFxuICAgICAgICAgICAgICogICAgLy8gICAgICBcImdyYWRlXCI6IHt2YWx1ZX1cbiAgICAgICAgICAgICAqICAgIC8vICAgfVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiYWpheFNvdXJjZVwiOiBcInNvdXJjZXMvb2JqZWN0cy50eHRcIixcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJlbmdpbmVcIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJicm93c2VyXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwicGxhdGZvcm1cIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcImRhdGFcIjogXCJ2ZXJzaW9uXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZ3JhZGVcIiB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBSZWFkIGluZm9ybWF0aW9uIGZyb20gZGVlcGx5IG5lc3RlZCBvYmplY3RzXG4gICAgICAgICAgICAgKiAgICAvLyBKU09OIHN0cnVjdHVyZSBmb3IgZWFjaCByb3c6XG4gICAgICAgICAgICAgKiAgICAvLyAgIHtcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJlbmdpbmVcIjoge3ZhbHVlfSxcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJicm93c2VyXCI6IHt2YWx1ZX0sXG4gICAgICAgICAgICAgKiAgICAvLyAgICAgIFwicGxhdGZvcm1cIjoge1xuICAgICAgICAgICAgICogICAgLy8gICAgICAgICBcImlubmVyXCI6IHt2YWx1ZX1cbiAgICAgICAgICAgICAqICAgIC8vICAgICAgfSxcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgXCJkZXRhaWxzXCI6IFtcbiAgICAgICAgICAgICAqICAgIC8vICAgICAgICAge3ZhbHVlfSwge3ZhbHVlfVxuICAgICAgICAgICAgICogICAgLy8gICAgICBdXG4gICAgICAgICAgICAgKiAgICAvLyAgIH1cbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImFqYXhTb3VyY2VcIjogXCJzb3VyY2VzL2RlZXAudHh0XCIsXG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZW5naW5lXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiYnJvd3NlclwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcInBsYXRmb3JtLmlubmVyXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZGV0YWlscy4wXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJkYXRhXCI6IFwiZGV0YWlscy4xXCIgfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGRhdGFgIGFzIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBkaWZmZXJlbnQgaW5mb3JtYXRpb24gZm9yXG4gICAgICAgICAgICAgKiAgICAvLyBzb3J0aW5nLCBmaWx0ZXJpbmcgYW5kIGRpc3BsYXkuIEluIHRoaXMgY2FzZSwgY3VycmVuY3kgKHByaWNlKVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcbiAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBmdW5jdGlvbiAoIHNvdXJjZSwgdHlwZSwgdmFsICkge1xuICAgICAgICAgICAgICogICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3NldCcpIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICBzb3VyY2UucHJpY2UgPSB2YWw7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgLy8gU3RvcmUgdGhlIGNvbXB1dGVkIGRpc2xheSBhbmQgZmlsdGVyIHZhbHVlcyBmb3IgZWZmaWNpZW5jeVxuICAgICAgICAgICAgICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9kaXNwbGF5ID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpO1xuICAgICAgICAgICAgICogICAgICAgICAgICAgIHNvdXJjZS5wcmljZV9maWx0ZXIgID0gdmFsPT1cIlwiID8gXCJcIiA6IFwiJFwiK251bWJlckZvcm1hdCh2YWwpK1wiIFwiK3ZhbDtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2Rpc3BsYXknKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9kaXNwbGF5O1xuICAgICAgICAgICAgICogICAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdmaWx0ZXInKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZV9maWx0ZXI7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgICAgICAgLy8gJ3NvcnQnLCAndHlwZScgYW5kIHVuZGVmaW5lZCBhbGwganVzdCB1c2UgdGhlIGludGVnZXJcbiAgICAgICAgICAgICAqICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5wcmljZTtcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgICB9IF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgZGVmYXVsdCBjb250ZW50XG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuICAgICAgICAgICAgICogICAgICAgICAgXCJkYXRhXCI6IG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiQ2xpY2sgdG8gZWRpdFwiXG4gICAgICAgICAgICAgKiAgICAgICAgfSBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGFycmF5IG5vdGF0aW9uIC0gb3V0cHV0dGluZyBhIGxpc3QgZnJvbSBhbiBhcnJheVxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcbiAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBcIm5hbWVbLCBdXCJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJtRGF0YVwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0aGUgcmVuZGVyaW5nIHBhcnRuZXIgdG8gYGRhdGFgIGFuZCBpdCBpcyBzdWdnZXN0ZWQgdGhhdFxuICAgICAgICAgICAgICogd2hlbiB5b3Ugd2FudCB0byBtYW5pcHVsYXRlIGRhdGEgZm9yIGRpc3BsYXkgKGluY2x1ZGluZyBmaWx0ZXJpbmcsXG4gICAgICAgICAgICAgKiBzb3J0aW5nIGV0Yykgd2l0aG91dCBhbHRlcmluZyB0aGUgdW5kZXJseWluZyBkYXRhIGZvciB0aGUgdGFibGUsIHVzZSB0aGlzXG4gICAgICAgICAgICAgKiBwcm9wZXJ0eS4gYHJlbmRlcmAgY2FuIGJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIHRoZSByZWFkIG9ubHkgY29tcGFuaW9uIHRvXG4gICAgICAgICAgICAgKiBgZGF0YWAgd2hpY2ggaXMgcmVhZCAvIHdyaXRlICh0aGVuIGFzIHN1Y2ggbW9yZSBjb21wbGV4KS4gTGlrZSBgZGF0YWBcbiAgICAgICAgICAgICAqIHRoaXMgb3B0aW9uIGNhbiBiZSBnaXZlbiBpbiBhIG51bWJlciBvZiBkaWZmZXJlbnQgd2F5cyB0byBlZmZlY3QgaXRzXG4gICAgICAgICAgICAgKiBiZWhhdmlvdXI6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBgaW50ZWdlcmAgLSB0cmVhdGVkIGFzIGFuIGFycmF5IGluZGV4IGZvciB0aGUgZGF0YSBzb3VyY2UuIFRoaXMgaXMgdGhlXG4gICAgICAgICAgICAgKiAgIGRlZmF1bHQgdGhhdCBEYXRhVGFibGVzIHVzZXMgKGluY3JlbWVudGFsbHkgaW5jcmVhc2VkIGZvciBlYWNoIGNvbHVtbikuXG4gICAgICAgICAgICAgKiAqIGBzdHJpbmdgIC0gcmVhZCBhbiBvYmplY3QgcHJvcGVydHkgZnJvbSB0aGUgZGF0YSBzb3VyY2UuIFRoZXJlIGFyZVxuICAgICAgICAgICAgICogICB0aHJlZSAnc3BlY2lhbCcgb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGluIHRoZSBzdHJpbmcgdG8gYWx0ZXIgaG93XG4gICAgICAgICAgICAgKiAgIERhdGFUYWJsZXMgcmVhZHMgdGhlIGRhdGEgZnJvbSB0aGUgc291cmNlIG9iamVjdDpcbiAgICAgICAgICAgICAqICAgICogYC5gIC0gRG90dGVkIEphdmFzY3JpcHQgbm90YXRpb24uIEp1c3QgYXMgeW91IHVzZSBhIGAuYCBpblxuICAgICAgICAgICAgICogICAgICBKYXZhc2NyaXB0IHRvIHJlYWQgZnJvbSBuZXN0ZWQgb2JqZWN0cywgc28gdG8gY2FuIHRoZSBvcHRpb25zXG4gICAgICAgICAgICAgKiAgICAgIHNwZWNpZmllZCBpbiBgZGF0YWAuIEZvciBleGFtcGxlOiBgYnJvd3Nlci52ZXJzaW9uYCBvclxuICAgICAgICAgICAgICogICAgICBgYnJvd3Nlci5uYW1lYC4gSWYgeW91ciBvYmplY3QgcGFyYW1ldGVyIG5hbWUgY29udGFpbnMgYSBwZXJpb2QsIHVzZVxuICAgICAgICAgICAgICogICAgICBgXFxcXGAgdG8gZXNjYXBlIGl0IC0gaS5lLiBgZmlyc3RcXFxcLm5hbWVgLlxuICAgICAgICAgICAgICogICAgKiBgW11gIC0gQXJyYXkgbm90YXRpb24uIERhdGFUYWJsZXMgY2FuIGF1dG9tYXRpY2FsbHkgY29tYmluZSBkYXRhXG4gICAgICAgICAgICAgKiAgICAgIGZyb20gYW5kIGFycmF5IHNvdXJjZSwgam9pbmluZyB0aGUgZGF0YSB3aXRoIHRoZSBjaGFyYWN0ZXJzIHByb3ZpZGVkXG4gICAgICAgICAgICAgKiAgICAgIGJldHdlZW4gdGhlIHR3byBicmFja2V0cy4gRm9yIGV4YW1wbGU6IGBuYW1lWywgXWAgd291bGQgcHJvdmlkZSBhXG4gICAgICAgICAgICAgKiAgICAgIGNvbW1hLXNwYWNlIHNlcGFyYXRlZCBsaXN0IGZyb20gdGhlIHNvdXJjZSBhcnJheS4gSWYgbm8gY2hhcmFjdGVyc1xuICAgICAgICAgICAgICogICAgICBhcmUgcHJvdmlkZWQgYmV0d2VlbiB0aGUgYnJhY2tldHMsIHRoZSBvcmlnaW5hbCBhcnJheSBzb3VyY2UgaXNcbiAgICAgICAgICAgICAqICAgICAgcmV0dXJuZWQuXG4gICAgICAgICAgICAgKiAgICAqIGAoKWAgLSBGdW5jdGlvbiBub3RhdGlvbi4gQWRkaW5nIGAoKWAgdG8gdGhlIGVuZCBvZiBhIHBhcmFtZXRlciB3aWxsXG4gICAgICAgICAgICAgKiAgICAgIGV4ZWN1dGUgYSBmdW5jdGlvbiBvZiB0aGUgbmFtZSBnaXZlbi4gRm9yIGV4YW1wbGU6IGBicm93c2VyKClgIGZvciBhXG4gICAgICAgICAgICAgKiAgICAgIHNpbXBsZSBmdW5jdGlvbiBvbiB0aGUgZGF0YSBzb3VyY2UsIGBicm93c2VyLnZlcnNpb24oKWAgZm9yIGFcbiAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gaW4gYSBuZXN0ZWQgcHJvcGVydHkgb3IgZXZlbiBgYnJvd3NlcigpLnZlcnNpb25gIHRvIGdldCBhblxuICAgICAgICAgICAgICogICAgICBvYmplY3QgcHJvcGVydHkgaWYgdGhlIGZ1bmN0aW9uIGNhbGxlZCByZXR1cm5zIGFuIG9iamVjdC5cbiAgICAgICAgICAgICAqICogYG9iamVjdGAgLSB1c2UgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgZGF0YSB0eXBlcyByZXF1ZXN0ZWQgYnlcbiAgICAgICAgICAgICAqICAgRGF0YVRhYmxlcyAoJ2ZpbHRlcicsICdkaXNwbGF5JywgJ3R5cGUnIG9yICdzb3J0JykuIFRoZSBwcm9wZXJ0eSBuYW1lc1xuICAgICAgICAgICAgICogICBvZiB0aGUgb2JqZWN0IGlzIHRoZSBkYXRhIHR5cGUgdGhlIHByb3BlcnR5IHJlZmVycyB0byBhbmQgdGhlIHZhbHVlIGNhblxuICAgICAgICAgICAgICogICBkZWZpbmVkIHVzaW5nIGFuIGludGVnZXIsIHN0cmluZyBvciBmdW5jdGlvbiB1c2luZyB0aGUgc2FtZSBydWxlcyBhc1xuICAgICAgICAgICAgICogICBgcmVuZGVyYCBub3JtYWxseSBkb2VzLiBOb3RlIHRoYXQgYW4gYF9gIG9wdGlvbiBfbXVzdF8gYmUgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICogICBUaGlzIGlzIHRoZSBkZWZhdWx0IHZhbHVlIHRvIHVzZSBpZiB5b3UgaGF2ZW4ndCBzcGVjaWZpZWQgYSB2YWx1ZSBmb3JcbiAgICAgICAgICAgICAqICAgdGhlIGRhdGEgdHlwZSByZXF1ZXN0ZWQgYnkgRGF0YVRhYmxlcy5cbiAgICAgICAgICAgICAqICogYGZ1bmN0aW9uYCAtIHRoZSBmdW5jdGlvbiBnaXZlbiB3aWxsIGJlIGV4ZWN1dGVkIHdoZW5ldmVyIERhdGFUYWJsZXNcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gc2V0IG9yIGdldCB0aGUgZGF0YSBmb3IgYSBjZWxsIGluIHRoZSBjb2x1bW4uIFRoZSBmdW5jdGlvblxuICAgICAgICAgICAgICogICB0YWtlcyB0aHJlZSBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICogICAgKiBQYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICogICAgICAqIHthcnJheXxvYmplY3R9IFRoZSBkYXRhIHNvdXJjZSBmb3IgdGhlIHJvdyAoYmFzZWQgb24gYGRhdGFgKVxuICAgICAgICAgICAgICogICAgICAqIHtzdHJpbmd9IFRoZSB0eXBlIGNhbGwgZGF0YSByZXF1ZXN0ZWQgLSB0aGlzIHdpbGwgYmUgJ2ZpbHRlcicsXG4gICAgICAgICAgICAgKiAgICAgICAgJ2Rpc3BsYXknLCAndHlwZScgb3IgJ3NvcnQnLlxuICAgICAgICAgICAgICogICAgICAqIHthcnJheXxvYmplY3R9IFRoZSBmdWxsIGRhdGEgc291cmNlIGZvciB0aGUgcm93IChub3QgYmFzZWQgb25cbiAgICAgICAgICAgICAqICAgICAgICBgZGF0YWApXG4gICAgICAgICAgICAgKiAgICAqIFJldHVybjpcbiAgICAgICAgICAgICAqICAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGZ1bmN0aW9uIGlzIHdoYXQgd2lsbCBiZSB1c2VkIGZvciB0aGVcbiAgICAgICAgICAgICAqICAgICAgICBkYXRhIHJlcXVlc3RlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nfGludHxmdW5jdGlvbnxvYmplY3R8bnVsbFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgVXNlIHRoZSBkYXRhIHNvdXJjZSB2YWx1ZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5yZW5kZXJcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gQ3JlYXRlIGEgY29tbWEgc2VwYXJhdGVkIGxpc3QgZnJvbSBhbiBhcnJheSBvZiBvYmplY3RzXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJhamF4U291cmNlXCI6IFwic291cmNlcy9kZWVwLnR4dFwiLFxuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImVuZ2luZVwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwiZGF0YVwiOiBcImJyb3dzZXJcIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAge1xuICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFcIjogXCJwbGF0Zm9ybVwiLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcInJlbmRlclwiOiBcIlssIF0ubmFtZVwiXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBFeGVjdXRlIGEgZnVuY3Rpb24gdG8gb2J0YWluIGRhdGFcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogbnVsbCwgLy8gVXNlIHRoZSBmdWxsIGRhdGEgc291cmNlIG9iamVjdCBmb3IgdGhlIHJlbmRlcmVyJ3Mgc291cmNlXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInJlbmRlclwiOiBcImJyb3dzZXJOYW1lKClcIlxuICAgICAgICAgICAgICogICAgICAgIH0gXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBBcyBhbiBvYmplY3QsIGV4dHJhY3RpbmcgZGlmZmVyZW50IGRhdGEgZm9yIHRoZSBkaWZmZXJlbnQgdHlwZXNcbiAgICAgICAgICAgICAqICAgIC8vIFRoaXMgd291bGQgYmUgdXNlZCB3aXRoIGEgZGF0YSBzb3VyY2Ugc3VjaCBhczpcbiAgICAgICAgICAgICAqICAgIC8vICAgeyBcInBob25lXCI6IDU1NTIzNjgsIFwicGhvbmVfZmlsdGVyXCI6IFwiNTU1MjM2OCA1NTUtMjM2OFwiLCBcInBob25lX2Rpc3BsYXlcIjogXCI1NTUtMjM2OFwiIH1cbiAgICAgICAgICAgICAqICAgIC8vIEhlcmUgdGhlIGBwaG9uZWAgaW50ZWdlciBpcyB1c2VkIGZvciBzb3J0aW5nIGFuZCB0eXBlIGRldGVjdGlvbiwgd2hpbGUgYHBob25lX2ZpbHRlcmBcbiAgICAgICAgICAgICAqICAgIC8vICh3aGljaCBoYXMgYm90aCBmb3JtcykgaXMgdXNlZCBmb3IgZmlsdGVyaW5nIGZvciBpZiBhIHVzZXIgaW5wdXRzIGVpdGhlciBmb3JtYXQsIHdoaWxlXG4gICAgICAgICAgICAgKiAgICAvLyB0aGUgZm9ybWF0dGVkIHBob25lIG51bWJlciBpcyB0aGUgb25lIHRoYXQgaXMgc2hvd24gaW4gdGhlIHRhYmxlLlxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbIHtcbiAgICAgICAgICAgICAqICAgICAgICAgIFwidGFyZ2V0c1wiOiBbIDAgXSxcbiAgICAgICAgICAgICAqICAgICAgICAgIFwiZGF0YVwiOiBudWxsLCAvLyBVc2UgdGhlIGZ1bGwgZGF0YSBzb3VyY2Ugb2JqZWN0IGZvciB0aGUgcmVuZGVyZXIncyBzb3VyY2VcbiAgICAgICAgICAgICAqICAgICAgICAgIFwicmVuZGVyXCI6IHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJfXCI6IFwicGhvbmVcIixcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJmaWx0ZXJcIjogXCJwaG9uZV9maWx0ZXJcIixcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkaXNwbGF5XCI6IFwicGhvbmVfZGlzcGxheVwiXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgfSBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzZSBhcyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGxpbmsgZnJvbSB0aGUgZGF0YSBzb3VyY2VcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogWyB7XG4gICAgICAgICAgICAgKiAgICAgICAgICBcInRhcmdldHNcIjogWyAwIF0sXG4gICAgICAgICAgICAgKiAgICAgICAgICBcImRhdGFcIjogXCJkb3dubG9hZF9saW5rXCIsXG4gICAgICAgICAgICAgKiAgICAgICAgICBcInJlbmRlclwiOiBmdW5jdGlvbiAoIGRhdGEsIHR5cGUsIGZ1bGwgKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIHJldHVybiAnPGEgaHJlZj1cIicrZGF0YSsnXCI+RG93bmxvYWQ8L2E+JztcbiAgICAgICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICAgICAqICAgICAgICB9IF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm1SZW5kZXJcIjogbnVsbCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoYW5nZSB0aGUgY2VsbCB0eXBlIGNyZWF0ZWQgZm9yIHRoZSBjb2x1bW4gLSBlaXRoZXIgVEQgY2VsbHMgb3IgVEggY2VsbHMuIFRoaXNcbiAgICAgICAgICAgICAqIGNhbiBiZSB1c2VmdWwgYXMgVEggY2VsbHMgaGF2ZSBzZW1hbnRpYyBtZWFuaW5nIGluIHRoZSB0YWJsZSBib2R5LCBhbGxvd2luZyB0aGVtXG4gICAgICAgICAgICAgKiB0byBhY3QgYXMgYSBoZWFkZXIgZm9yIGEgcm93ICh5b3UgbWF5IHdpc2ggdG8gYWRkIHNjb3BlPSdyb3cnIHRvIHRoZSBUSCBlbGVtZW50cykuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgdGRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5jZWxsVHlwZVxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBNYWtlIHRoZSBmaXJzdCBjb2x1bW4gdXNlIFRIIGNlbGxzXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFsge1xuICAgICAgICAgICAgICogICAgICAgICAgXCJ0YXJnZXRzXCI6IFsgMCBdLFxuICAgICAgICAgICAgICogICAgICAgICAgXCJjZWxsVHlwZVwiOiBcInRoXCJcbiAgICAgICAgICAgICAqICAgICAgICB9IF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNDZWxsVHlwZVwiOiBcInRkXCIsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDbGFzcyB0byBnaXZlIHRvIGVhY2ggY2VsbCBpbiB0aGlzIGNvbHVtbi5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY2xhc3NcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJjbGFzc1wiOiBcIm15X2NsYXNzXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcImNsYXNzXCI6IFwibXlfY2xhc3NcIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNDbGFzc1wiOiBcIlwiLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gRGF0YVRhYmxlcyBjYWxjdWxhdGVzIHRoZSBjb2x1bW4gd2lkdGhzIHRvIGFzc2lnbiB0byBlYWNoIGNvbHVtbixcbiAgICAgICAgICAgICAqIGl0IGZpbmRzIHRoZSBsb25nZXN0IHN0cmluZyBpbiBlYWNoIGNvbHVtbiBhbmQgdGhlbiBjb25zdHJ1Y3RzIGFcbiAgICAgICAgICAgICAqIHRlbXBvcmFyeSB0YWJsZSBhbmQgcmVhZHMgdGhlIHdpZHRocyBmcm9tIHRoYXQuIFRoZSBwcm9ibGVtIHdpdGggdGhpc1xuICAgICAgICAgICAgICogaXMgdGhhdCBcIm1tbVwiIGlzIG11Y2ggd2lkZXIgdGhlbiBcImlpaWlcIiwgYnV0IHRoZSBsYXR0ZXIgaXMgYSBsb25nZXJcbiAgICAgICAgICAgICAqIHN0cmluZyAtIHRodXMgdGhlIGNhbGN1bGF0aW9uIGNhbiBnbyB3cm9uZyAoZG9pbmcgaXQgcHJvcGVybHkgYW5kIHB1dHRpbmdcbiAgICAgICAgICAgICAqIGl0IGludG8gYW4gRE9NIG9iamVjdCBhbmQgbWVhc3VyaW5nIHRoYXQgaXMgaG9ycmlibHkoISkgc2xvdykuIFRodXMgYXNcbiAgICAgICAgICAgICAqIGEgXCJ3b3JrIGFyb3VuZFwiIHdlIHByb3ZpZGUgdGhpcyBvcHRpb24uIEl0IHdpbGwgYXBwZW5kIGl0cyB2YWx1ZSB0byB0aGVcbiAgICAgICAgICAgICAqIHRleHQgdGhhdCBpcyBmb3VuZCB0byBiZSB0aGUgbG9uZ2VzdCBzdHJpbmcgZm9yIHRoZSBjb2x1bW4gLSBpLmUuIHBhZGRpbmcuXG4gICAgICAgICAgICAgKiBHZW5lcmFsbHkgeW91IHNob3VsZG4ndCBuZWVkIHRoaXMhXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgPGk+RW1wdHkgc3RyaW5nPGk+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4uY29udGVudFBhZGRpbmdcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIHtcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJjb250ZW50UGFkZGluZ1wiOiBcIm1tbVwiXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0NvbnRlbnRQYWRkaW5nXCI6IFwiXCIsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbGxvd3MgYSBkZWZhdWx0IHZhbHVlIHRvIGJlIGdpdmVuIGZvciBhIGNvbHVtbidzIGRhdGEsIGFuZCB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAqIHdoZW5ldmVyIGEgbnVsbCBkYXRhIHNvdXJjZSBpcyBlbmNvdW50ZXJlZCAodGhpcyBjYW4gYmUgYmVjYXVzZSBgZGF0YWBcbiAgICAgICAgICAgICAqIGlzIHNldCB0byBudWxsLCBvciBiZWNhdXNlIHRoZSBkYXRhIHNvdXJjZSBpdHNlbGYgaXMgbnVsbCkuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLmRlZmF1bHRDb250ZW50XG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7XG4gICAgICAgICAgICAgKiAgICAgICAgICAgIFwiZGF0YVwiOiBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcImRlZmF1bHRDb250ZW50XCI6IFwiRWRpdFwiLFxuICAgICAgICAgICAgICogICAgICAgICAgICBcInRhcmdldHNcIjogWyAtMSBdXG4gICAgICAgICAgICAgKiAgICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAge1xuICAgICAgICAgICAgICogICAgICAgICAgICBcImRhdGFcIjogbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgICAgXCJkZWZhdWx0Q29udGVudFwiOiBcIkVkaXRcIlxuICAgICAgICAgICAgICogICAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNEZWZhdWx0Q29udGVudFwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSB1c2VkIGluIERhdGFUYWJsZXMnIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuIEl0IGNhblxuICAgICAgICAgICAgICogYmUgZXhjZXB0aW9uYWxseSB1c2VmdWwgdG8ga25vdyB3aGF0IGNvbHVtbnMgYXJlIGJlaW5nIGRpc3BsYXllZCBvbiB0aGVcbiAgICAgICAgICAgICAqIGNsaWVudCBzaWRlLCBhbmQgdG8gbWFwIHRoZXNlIHRvIGRhdGFiYXNlIGZpZWxkcy4gV2hlbiBkZWZpbmVkLCB0aGUgbmFtZXNcbiAgICAgICAgICAgICAqIGFsc28gYWxsb3cgRGF0YVRhYmxlcyB0byByZW9yZGVyIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZlciBpZiBpdCBjb21lc1xuICAgICAgICAgICAgICogYmFjayBpbiBhbiB1bmV4cGVjdGVkIG9yZGVyIChpLmUuIGlmIHlvdSBzd2l0Y2ggeW91ciBjb2x1bW5zIGFyb3VuZCBvbiB0aGVcbiAgICAgICAgICAgICAqIGNsaWVudC1zaWRlLCB5b3VyIHNlcnZlci1zaWRlIGNvZGUgZG9lcyBub3QgYWxzbyBuZWVkIHVwZGF0aW5nKS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4ubmFtZVxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJlbmdpbmVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImJyb3dzZXJcIiwgXCJ0YXJnZXRzXCI6IFsgMSBdIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIsIFwidGFyZ2V0c1wiOiBbIDIgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJ2ZXJzaW9uXCIsIFwidGFyZ2V0c1wiOiBbIDMgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm5hbWVcIjogXCJncmFkZVwiLCBcInRhcmdldHNcIjogWyA0IF0gfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiZW5naW5lXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwiYnJvd3NlclwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcInBsYXRmb3JtXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJuYW1lXCI6IFwidmVyc2lvblwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwibmFtZVwiOiBcImdyYWRlXCIgfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNOYW1lXCI6IFwiXCIsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWZpbmVzIGEgZGF0YSBzb3VyY2UgdHlwZSBmb3IgdGhlIG9yZGVyaW5nIHdoaWNoIGNhbiBiZSB1c2VkIHRvIHJlYWRcbiAgICAgICAgICAgICAqIHJlYWwtdGltZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSB0YWJsZSAodXBkYXRpbmcgdGhlIGludGVybmFsbHkgY2FjaGVkXG4gICAgICAgICAgICAgKiB2ZXJzaW9uKSBwcmlvciB0byBvcmRlcmluZy4gVGhpcyBhbGxvd3Mgb3JkZXJpbmcgdG8gb2NjdXIgb24gdXNlclxuICAgICAgICAgICAgICogZWRpdGFibGUgZWxlbWVudHMgc3VjaCBhcyBmb3JtIGlucHV0cy5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBzdGRcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlLmRlZmF1bHRzLmNvbHVtbi5vcmRlckRhdGFUeXBlXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS10ZXh0XCIsIFwidGFyZ2V0c1wiOiBbIDIsIDMgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcInR5cGVcIjogXCJudW1lcmljXCIsIFwidGFyZ2V0c1wiOiBbIDMgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tc2VsZWN0XCIsIFwidGFyZ2V0c1wiOiBbIDQgXSB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tY2hlY2tib3hcIiwgXCJ0YXJnZXRzXCI6IFsgNSBdIH1cbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXRleHRcIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgeyBcIm9yZGVyRGF0YVR5cGVcIjogXCJkb20tdGV4dFwiLCBcInR5cGVcIjogXCJudW1lcmljXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJvcmRlckRhdGFUeXBlXCI6IFwiZG9tLXNlbGVjdFwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwib3JkZXJEYXRhVHlwZVwiOiBcImRvbS1jaGVja2JveFwiIH1cbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzU29ydERhdGFUeXBlXCI6IFwic3RkXCIsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdGl0bGUgb2YgdGhpcyBjb2x1bW4uXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5EZXJpdmVkIGZyb20gdGhlICdUSCcgdmFsdWUgZm9yIHRoaXMgY29sdW1uIGluIHRoZVxuICAgICAgICAgICAgICogICAgb3JpZ2luYWwgSFRNTCB0YWJsZS48L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udGl0bGVcbiAgICAgICAgICAgICAqICBAZHRvcHQgQ29sdW1uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbkRlZnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5EZWZzXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiLCBcInRhcmdldHNcIjogWyAwIF0gfVxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gVXNpbmcgYGNvbHVtbnNgXG4gICAgICAgICAgICAgKiAgICAkKGRvY3VtZW50KS5yZWFkeSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgKiAgICAgICQoJyNleGFtcGxlJykuZGF0YVRhYmxlKCB7XG4gICAgICAgICAgICAgKiAgICAgICAgXCJjb2x1bW5zXCI6IFtcbiAgICAgICAgICAgICAqICAgICAgICAgIHsgXCJ0aXRsZVwiOiBcIk15IGNvbHVtbiB0aXRsZVwiIH0sXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1RpdGxlXCI6IG51bGwsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdHlwZSBhbGxvd3MgeW91IHRvIHNwZWNpZnkgaG93IHRoZSBkYXRhIGZvciB0aGlzIGNvbHVtbiB3aWxsIGJlXG4gICAgICAgICAgICAgKiBvcmRlcmVkLiBGb3VyIHR5cGVzIChzdHJpbmcsIG51bWVyaWMsIGRhdGUgYW5kIGh0bWwgKHdoaWNoIHdpbGwgc3RyaXBcbiAgICAgICAgICAgICAqIEhUTUwgdGFncyBiZWZvcmUgb3JkZXJpbmcpKSBhcmUgY3VycmVudGx5IGF2YWlsYWJsZS4gTm90ZSB0aGF0IG9ubHkgZGF0ZVxuICAgICAgICAgICAgICogZm9ybWF0cyB1bmRlcnN0b29kIGJ5IEphdmFzY3JpcHQncyBEYXRlKCkgb2JqZWN0IHdpbGwgYmUgYWNjZXB0ZWQgYXMgdHlwZVxuICAgICAgICAgICAgICogZGF0ZS4gRm9yIGV4YW1wbGU6IFwiTWFyIDI2LCAyMDA4IDU6MDMgUE1cIi4gTWF5IHRha2UgdGhlIHZhbHVlczogJ3N0cmluZycsXG4gICAgICAgICAgICAgKiAnbnVtZXJpYycsICdkYXRlJyBvciAnaHRtbCcgKGJ5IGRlZmF1bHQpLiBGdXJ0aGVyIHR5cGVzIGNhbiBiZSBhZGRpbmdcbiAgICAgICAgICAgICAqIHRocm91Z2ggcGx1Zy1pbnMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbCA8aT5BdXRvLWRldGVjdGVkIGZyb20gcmF3IGRhdGE8L2k+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4udHlwZVxuICAgICAgICAgICAgICogIEBkdG9wdCBDb2x1bW5zXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uRGVmc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbkRlZnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcInR5cGVcIjogXCJodG1sXCIsIFwidGFyZ2V0c1wiOiBbIDAgXSB9XG4gICAgICAgICAgICAgKiAgICAgICAgXVxuICAgICAgICAgICAgICogICAgICB9ICk7XG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBVc2luZyBgY29sdW1uc2BcbiAgICAgICAgICAgICAqICAgICQoZG9jdW1lbnQpLnJlYWR5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAqICAgICAgJCgnI2V4YW1wbGUnKS5kYXRhVGFibGUoIHtcbiAgICAgICAgICAgICAqICAgICAgICBcImNvbHVtbnNcIjogW1xuICAgICAgICAgICAgICogICAgICAgICAgeyBcInR5cGVcIjogXCJodG1sXCIgfSxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzVHlwZVwiOiBudWxsLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVmaW5pbmcgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4sIHRoaXMgcGFyYW1ldGVyIG1heSB0YWtlIGFueSBDU1MgdmFsdWVcbiAgICAgICAgICAgICAqICgzZW0sIDIwcHggZXRjKS4gRGF0YVRhYmxlcyBhcHBsaWVzICdzbWFydCcgd2lkdGhzIHRvIGNvbHVtbnMgd2hpY2ggaGF2ZSBub3RcbiAgICAgICAgICAgICAqIGJlZW4gZ2l2ZW4gYSBzcGVjaWZpYyB3aWR0aCB0aHJvdWdoIHRoaXMgaW50ZXJmYWNlIGVuc3VyaW5nIHRoYXQgdGhlIHRhYmxlXG4gICAgICAgICAgICAgKiByZW1haW5zIHJlYWRhYmxlLlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGwgPGk+QXV0b21hdGljPC9pPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUuZGVmYXVsdHMuY29sdW1uLndpZHRoXG4gICAgICAgICAgICAgKiAgQGR0b3B0IENvbHVtbnNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5EZWZzYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uRGVmc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiwgXCJ0YXJnZXRzXCI6IFsgMCBdIH1cbiAgICAgICAgICAgICAqICAgICAgICBdXG4gICAgICAgICAgICAgKiAgICAgIH0gKTtcbiAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFVzaW5nIGBjb2x1bW5zYFxuICAgICAgICAgICAgICogICAgJChkb2N1bWVudCkucmVhZHkoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICogICAgICAkKCcjZXhhbXBsZScpLmRhdGFUYWJsZSgge1xuICAgICAgICAgICAgICogICAgICAgIFwiY29sdW1uc1wiOiBbXG4gICAgICAgICAgICAgKiAgICAgICAgICB7IFwid2lkdGhcIjogXCIyMCVcIiB9LFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAqICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgKiAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICogICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICogICAgICAgIF1cbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfSApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInNXaWR0aFwiOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwKERhdGFUYWJsZS5kZWZhdWx0cy5jb2x1bW4pO1xuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3QgLSB0aGlzIGhvbGRzIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkIGZvciBhXG4gICAgICAgICAqIGdpdmVuIHRhYmxlLCBpbmNsdWRpbmcgY29uZmlndXJhdGlvbiwgZGF0YSBhbmQgY3VycmVudCBhcHBsaWNhdGlvbiBvZiB0aGVcbiAgICAgICAgICogdGFibGUgb3B0aW9ucy4gRGF0YVRhYmxlcyBkb2VzIG5vdCBoYXZlIGEgc2luZ2xlIGluc3RhbmNlIGZvciBlYWNoIERhdGFUYWJsZVxuICAgICAgICAgKiB3aXRoIHRoZSBzZXR0aW5ncyBhdHRhY2hlZCB0byB0aGF0IGluc3RhbmNlLCBidXQgcmF0aGVyIGluc3RhbmNlcyBvZiB0aGVcbiAgICAgICAgICogRGF0YVRhYmxlIFwiY2xhc3NcIiBhcmUgY3JlYXRlZCBvbi10aGUtZmx5IGFzIG5lZWRlZCAodHlwaWNhbGx5IGJ5IGFcbiAgICAgICAgICogJCgpLmRhdGFUYWJsZSgpIGNhbGwpIGFuZCB0aGUgc2V0dGluZ3Mgb2JqZWN0IGlzIHRoZW4gYXBwbGllZCB0byB0aGF0XG4gICAgICAgICAqIGluc3RhbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBvYmplY3QgaXMgcmVsYXRlZCB0byB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfSBidXQgdGhpc1xuICAgICAgICAgKiBvbmUgaXMgdGhlIGludGVybmFsIGRhdGEgc3RvcmUgZm9yIERhdGFUYWJsZXMncyBjYWNoZSBvZiBjb2x1bW5zLiBJdCBzaG91bGRcbiAgICAgICAgICogTk9UIGJlIG1hbmlwdWxhdGVkIG91dHNpZGUgb2YgRGF0YVRhYmxlcy4gQW55IGNvbmZpZ3VyYXRpb24gc2hvdWxkIGJlIGRvbmVcbiAgICAgICAgICogdGhyb3VnaCB0aGUgaW5pdGlhbGlzYXRpb24gb3B0aW9ucy5cbiAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICogIEB0b2RvIFJlYWxseSBzaG91bGQgYXR0YWNoIHRoZSBzZXR0aW5ncyBvYmplY3QgdG8gaW5kaXZpZHVhbCBpbnN0YW5jZXMgc28gd2VcbiAgICAgICAgICogICAgZG9uJ3QgbmVlZCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvbiBlYWNoICQoKS5kYXRhVGFibGUoKSBjYWxsIChpZiB0aGVcbiAgICAgICAgICogICAgdGFibGUgYWxyZWFkeSBleGlzdHMpLiBJdCB3b3VsZCBhbHNvIHNhdmUgcGFzc2luZyBvU2V0dGluZ3MgYXJvdW5kIGFuZFxuICAgICAgICAgKiAgICBpbnRvIGV2ZXJ5IHNpbmdsZSBmdW5jdGlvbi4gSG93ZXZlciwgdGhpcyBpcyBhIHZlcnkgc2lnbmlmaWNhbnRcbiAgICAgICAgICogICAgYXJjaGl0ZWN0dXJlIGNoYW5nZSBmb3IgRGF0YVRhYmxlcyBhbmQgd2lsbCBhbG1vc3QgY2VydGFpbmx5IGJyZWFrXG4gICAgICAgICAqICAgIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgaW5zdGFsbGF0aW9ucy4gVGhpcyBpcyBzb21ldGhpbmcgdGhhdFxuICAgICAgICAgKiAgICB3aWxsIGJlIGRvbmUgaW4gMi4wLlxuICAgICAgICAgKi9cbiAgICAgICAgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByaW1hcnkgZmVhdHVyZXMgb2YgRGF0YVRhYmxlcyBhbmQgdGhlaXIgZW5hYmxlbWVudCBzdGF0ZS5cbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwib0ZlYXR1cmVzXCI6IHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZsYWcgdG8gc2F5IGlmIERhdGFUYWJsZXMgc2hvdWxkIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIGNhbGN1bGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgKiBvcHRpbXVtIHRhYmxlIGFuZCBjb2x1bW5zIHdpZHRocyAodHJ1ZSkgb3Igbm90IChmYWxzZSkuXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJiQXV0b1dpZHRoXCI6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBEZWxheSB0aGUgY3JlYXRpb24gb2YgVFIgYW5kIFREIGVsZW1lbnRzIHVudGlsIHRoZXkgYXJlIGFjdHVhbGx5XG4gICAgICAgICAgICAgICAgICogbmVlZGVkIGJ5IGEgZHJpdmVuIHBhZ2UgZHJhdy4gVGhpcyBjYW4gZ2l2ZSBhIHNpZ25pZmljYW50IHNwZWVkXG4gICAgICAgICAgICAgICAgICogaW5jcmVhc2UgZm9yIEFqYXggc291cmNlIGFuZCBKYXZhc2NyaXB0IHNvdXJjZSBkYXRhLCBidXQgbWFrZXMgbm9cbiAgICAgICAgICAgICAgICAgKiBkaWZmZXJlbmNlIGF0IGFsbCBmcm8gRE9NIGFuZCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRhYmxlcy5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJEZWZlclJlbmRlclwiOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRW5hYmxlIGZpbHRlcmluZyBvbiB0aGUgdGFibGUgb3Igbm90LiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBkaXNhYmxlZFxuICAgICAgICAgICAgICAgICAqIHRoZW4gdGhlcmUgaXMgbm8gZmlsdGVyaW5nIGF0IGFsbCBvbiB0aGUgdGFibGUsIGluY2x1ZGluZyBmbkZpbHRlci5cbiAgICAgICAgICAgICAgICAgKiBUbyBqdXN0IHJlbW92ZSB0aGUgZmlsdGVyaW5nIGlucHV0IHVzZSBzRG9tIGFuZCByZW1vdmUgdGhlICdmJyBvcHRpb24uXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJiRmlsdGVyXCI6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUYWJsZSBpbmZvcm1hdGlvbiBlbGVtZW50ICh0aGUgJ1Nob3dpbmcgeCBvZiB5IHJlY29yZHMnIGRpdikgZW5hYmxlXG4gICAgICAgICAgICAgICAgICogZmxhZy5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJJbmZvXCI6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQcmVzZW50IGEgdXNlciBjb250cm9sIGFsbG93aW5nIHRoZSBlbmQgdXNlciB0byBjaGFuZ2UgdGhlIHBhZ2Ugc2l6ZVxuICAgICAgICAgICAgICAgICAqIHdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLlxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwiYkxlbmd0aENoYW5nZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUGFnaW5hdGlvbiBlbmFibGVkIG9yIG5vdC4gTm90ZSB0aGF0IGlmIHRoaXMgaXMgZGlzYWJsZWQgdGhlbiBsZW5ndGhcbiAgICAgICAgICAgICAgICAgKiBjaGFuZ2luZyBtdXN0IGFsc28gYmUgZGlzYWJsZWQuXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJiUGFnaW5hdGVcIjogbnVsbCxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFByb2Nlc3NpbmcgaW5kaWNhdG9yIGVuYWJsZSBmbGFnIHdoZW5ldmVyIERhdGFUYWJsZXMgaXMgZW5hY3RpbmcgYVxuICAgICAgICAgICAgICAgICAqIHVzZXIgcmVxdWVzdCAtIHR5cGljYWxseSBhbiBBamF4IHJlcXVlc3QgZm9yIHNlcnZlci1zaWRlIHByb2Nlc3NpbmcuXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJiUHJvY2Vzc2luZ1wiOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyBlbmFibGVkIGZsYWcgLSB3aGVuIGVuYWJsZWQgRGF0YVRhYmxlcyB3aWxsXG4gICAgICAgICAgICAgICAgICogZ2V0IGFsbCBkYXRhIGZyb20gdGhlIHNlcnZlciBmb3IgZXZlcnkgZHJhdyAtIHRoZXJlIGlzIG5vIGZpbHRlcmluZyxcbiAgICAgICAgICAgICAgICAgKiBzb3J0aW5nIG9yIHBhZ2luZyBkb25lIG9uIHRoZSBjbGllbnQtc2lkZS5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJTZXJ2ZXJTaWRlXCI6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTb3J0aW5nIGVuYWJsZW1lbnQgZmxhZy5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJTb3J0XCI6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNdWx0aS1jb2x1bW4gc29ydGluZ1xuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwiYlNvcnRNdWx0aVwiOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQXBwbHkgYSBjbGFzcyB0byB0aGUgY29sdW1ucyB3aGljaCBhcmUgYmVpbmcgc29ydGVkIHRvIHByb3ZpZGUgYVxuICAgICAgICAgICAgICAgICAqIHZpc3VhbCBoaWdobGlnaHQgb3Igbm90LiBUaGlzIGNhbiBzbG93IHRoaW5ncyBkb3duIHdoZW4gZW5hYmxlZCBzaW5jZVxuICAgICAgICAgICAgICAgICAqIHRoZXJlIGlzIGEgbG90IG9mIERPTSBpbnRlcmFjdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJTb3J0Q2xhc3Nlc1wiOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3RhdGUgc2F2aW5nIGVuYWJsZW1lbnQgZmxhZy5cbiAgICAgICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJTdGF0ZVNhdmVcIjogbnVsbFxuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNjcm9sbGluZyBzZXR0aW5ncyBmb3IgYSB0YWJsZS5cbiAgICAgICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwib1Njcm9sbFwiOiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2hlbiB0aGUgdGFibGUgaXMgc2hvcnRlciBpbiBoZWlnaHQgdGhhbiBzU2Nyb2xsWSwgY29sbGFwc2UgdGhlXG4gICAgICAgICAgICAgICAgICogdGFibGUgY29udGFpbmVyIGRvd24gdG8gdGhlIGhlaWdodCBvZiB0aGUgdGFibGUgKHdoZW4gdHJ1ZSkuXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJiQ29sbGFwc2VcIjogbnVsbCxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdpZHRoIG9mIHRoZSBzY3JvbGxiYXIgZm9yIHRoZSB3ZWItYnJvd3NlcidzIHBsYXRmb3JtLiBDYWxjdWxhdGVkXG4gICAgICAgICAgICAgICAgICogZHVyaW5nIHRhYmxlIGluaXRpYWxpc2F0aW9uLlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIFwiaUJhcldpZHRoXCI6IDAsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBWaWV3cG9ydCB3aWR0aCBmb3IgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIEhvcml6b250YWwgc2Nyb2xsaW5nIGlzXG4gICAgICAgICAgICAgICAgICogZGlzYWJsZWQgaWYgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzWFwiOiBudWxsLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2lkdGggdG8gZXhwYW5kIHRoZSB0YWJsZSB0byB3aGVuIHVzaW5nIHgtc2Nyb2xsaW5nLiBUeXBpY2FsbHkgeW91XG4gICAgICAgICAgICAgICAgICogc2hvdWxkIG5vdCBuZWVkIHRvIHVzZSB0aGlzLlxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICogIEBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzWElubmVyXCI6IG51bGwsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBWaWV3cG9ydCBoZWlnaHQgZm9yIHZlcnRpY2FsIHNjcm9sbGluZy4gVmVydGljYWwgc2Nyb2xsaW5nIGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICogaWYgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJzWVwiOiBudWxsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExhbmd1YWdlIGluZm9ybWF0aW9uIGZvciB0aGUgdGFibGUuXG4gICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxuICAgICAgICAgICAgICogIEBleHRlbmRzIERhdGFUYWJsZS5kZWZhdWx0cy5vTGFuZ3VhZ2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJvTGFuZ3VhZ2VcIjoge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEluZm9ybWF0aW9uIGNhbGxiYWNrIGZ1bmN0aW9uLiBTZWVcbiAgICAgICAgICAgICAgICAgKiB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzLmZuSW5mb0NhbGxiYWNrfVxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJmbkluZm9DYWxsYmFja1wiOiBudWxsXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJyb3dzZXIgc3VwcG9ydCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiAgQG5hbWVzcGFjZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm9Ccm93c2VyXCI6IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJbmRpY2F0ZSBpZiB0aGUgYnJvd3NlciBpbmNvcnJlY3RseSBjYWxjdWxhdGVzIHdpZHRoOjEwMCUgaW5zaWRlIGFcbiAgICAgICAgICAgICAgICAgKiBzY3JvbGxpbmcgZWxlbWVudCAoSUU2LzcpXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJTY3JvbGxPdmVyc2l6ZVwiOiBmYWxzZSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERldGVybWluZSBpZiB0aGUgdmVydGljYWwgc2Nyb2xsYmFyIGlzIG9uIHRoZSByaWdodCBvciBsZWZ0IG9mIHRoZVxuICAgICAgICAgICAgICAgICAqIHNjcm9sbGluZyBjb250YWluZXIgLSBuZWVkZWQgZm9yIHJ0bCBsYW5ndWFnZSBsYXlvdXQsIGFsdGhvdWdoIG5vdFxuICAgICAgICAgICAgICAgICAqIGFsbCBicm93c2VycyBtb3ZlIHRoZSBzY3JvbGxiYXIgKFNhZmFyaSkuXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJTY3JvbGxiYXJMZWZ0XCI6IGZhbHNlLFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRmxhZyBmb3IgaWYgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgaXMgZnVsbHkgc3VwcG9ydGVkIG9yIG5vdFxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgXCJiQm91bmRpbmdcIjogZmFsc2UsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBCcm93c2VyIHNjcm9sbGJhciB3aWR0aFxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBpbnRlZ2VyXG4gICAgICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBcImJhcldpZHRoXCI6IDBcbiAgICAgICAgICAgIH0sXG5cblxuICAgICAgICAgICAgXCJhamF4XCI6IG51bGwsXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcnJheSByZWZlcmVuY2luZyB0aGUgbm9kZXMgd2hpY2ggYXJlIHVzZWQgZm9yIHRoZSBmZWF0dXJlcy4gVGhlXG4gICAgICAgICAgICAgKiBwYXJhbWV0ZXJzIG9mIHRoaXMgb2JqZWN0IG1hdGNoIHdoYXQgaXMgYWxsb3dlZCBieSBzRG9tIC0gaS5lLlxuICAgICAgICAgICAgICogICA8dWw+XG4gICAgICAgICAgICAgKiAgICAgPGxpPidsJyAtIExlbmd0aCBjaGFuZ2luZzwvbGk+XG4gICAgICAgICAgICAgKiAgICAgPGxpPidmJyAtIEZpbHRlcmluZyBpbnB1dDwvbGk+XG4gICAgICAgICAgICAgKiAgICAgPGxpPid0JyAtIFRoZSB0YWJsZSE8L2xpPlxuICAgICAgICAgICAgICogICAgIDxsaT4naScgLSBJbmZvcm1hdGlvbjwvbGk+XG4gICAgICAgICAgICAgKiAgICAgPGxpPidwJyAtIFBhZ2luYXRpb248L2xpPlxuICAgICAgICAgICAgICogICAgIDxsaT4ncicgLSBwUm9jZXNzaW5nPC9saT5cbiAgICAgICAgICAgICAqICAgPC91bD5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYWFuRmVhdHVyZXNcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmUgZGF0YSBpbmZvcm1hdGlvbiAtIHNlZSB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vUm93fSBmb3IgZGV0YWlsZWRcbiAgICAgICAgICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb0RhdGFcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXJyYXkgb2YgaW5kZXhlcyB3aGljaCBhcmUgaW4gdGhlIGN1cnJlbnQgZGlzcGxheSAoYWZ0ZXIgZmlsdGVyaW5nIGV0YylcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYWlEaXNwbGF5XCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFycmF5IG9mIGluZGV4ZXMgZm9yIGRpc3BsYXkgLSBubyBmaWx0ZXJpbmdcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYWlEaXNwbGF5TWFzdGVyXCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hcCBvZiByb3cgaWRzIHRvIGRhdGEgaW5kZXhlc1xuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYUlkc1wiOiB7fSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCBlYWNoIGNvbHVtbiB0aGF0IGlzIGluIHVzZVxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb0NvbHVtbnNcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHRhYmxlJ3MgaGVhZGVyXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvSGVhZGVyXCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0b3JlIGluZm9ybWF0aW9uIGFib3V0IHRoZSB0YWJsZSdzIGZvb3RlclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb0Zvb3RlclwiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9yZSB0aGUgYXBwbGllZCBnbG9iYWwgc2VhcmNoIGluZm9ybWF0aW9uIGluIGNhc2Ugd2Ugd2FudCB0byBmb3JjZSBhXG4gICAgICAgICAgICAgKiByZXNlYXJjaCBvciBjb21wYXJlIHRoZSBvbGQgc2VhcmNoIHRvIGEgbmV3IG9uZS5cbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICogIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAqICBAZXh0ZW5kcyBEYXRhVGFibGUubW9kZWxzLm9TZWFyY2hcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJvUHJldmlvdXNTZWFyY2hcIjoge30sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmUgdGhlIGFwcGxpZWQgc2VhcmNoIGZvciBlYWNoIGNvbHVtbiAtIHNlZVxuICAgICAgICAgICAgICoge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NlYXJjaH0gZm9yIHRoZSBmb3JtYXQgdGhhdCBpcyB1c2VkIGZvciB0aGVcbiAgICAgICAgICAgICAqIGZpbHRlcmluZyBpbmZvcm1hdGlvbiBmb3IgZWFjaCBjb2x1bW4uXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvUHJlU2VhcmNoQ29sc1wiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb3J0aW5nIHRoYXQgaXMgYXBwbGllZCB0byB0aGUgdGFibGUuIE5vdGUgdGhhdCB0aGUgaW5uZXIgYXJyYXlzIGFyZVxuICAgICAgICAgICAgICogdXNlZCBpbiB0aGUgZm9sbG93aW5nIG1hbm5lcjpcbiAgICAgICAgICAgICAqIDx1bD5cbiAgICAgICAgICAgICAqICAgPGxpPkluZGV4IDAgLSBjb2x1bW4gbnVtYmVyPC9saT5cbiAgICAgICAgICAgICAqICAgPGxpPkluZGV4IDEgLSBjdXJyZW50IHNvcnRpbmcgZGlyZWN0aW9uPC9saT5cbiAgICAgICAgICAgICAqIDwvdWw+XG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEB0b2RvIFRoZXNlIGlubmVyIGFycmF5cyBzaG91bGQgcmVhbGx5IGJlIG9iamVjdHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhYVNvcnRpbmdcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb3J0aW5nIHRoYXQgaXMgYWx3YXlzIGFwcGxpZWQgdG8gdGhlIHRhYmxlIChpLmUuIHByZWZpeGVkIGluIGZyb250IG9mXG4gICAgICAgICAgICAgKiBhYVNvcnRpbmcpLlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFhU29ydGluZ0ZpeGVkXCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsYXNzZXMgdG8gdXNlIGZvciB0aGUgc3RyaXBpbmcgb2YgYSB0YWJsZS5cbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhc1N0cmlwZUNsYXNzZXNcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyBzdHJpcGluZyBjbGFzc2VzIGFzIHdlbGxcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYXNEZXN0cm95U3RyaXBlc1wiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiByZXN0b3JpbmcgYSB0YWJsZSAtIHdlIHNob3VsZCByZXN0b3JlIGl0cyB3aWR0aFxuICAgICAgICAgICAgICogIEB0eXBlIGludFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzRGVzdHJveVdpZHRoXCI6IDAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGFycmF5IGZvciBldmVyeSB0aW1lIGEgcm93IGlzIGluc2VydGVkIChpLmUuIG9uIGEgZHJhdykuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvUm93Q2FsbGJhY2tcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2sgZnVuY3Rpb25zIGZvciB0aGUgaGVhZGVyIG9uIGVhY2ggZHJhdy5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYW9IZWFkZXJDYWxsYmFja1wiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgdGhlIGZvb3RlciBvbiBlYWNoIGRyYXcuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvRm9vdGVyQ2FsbGJhY2tcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXJyYXkgb2YgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBkcmF3IGNhbGxiYWNrIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb0RyYXdDYWxsYmFja1wiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHJvdyBjcmVhdGVkIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvUm93Q3JlYXRlZENhbGxiYWNrXCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9ucyBmb3IganVzdCBiZWZvcmUgdGhlIHRhYmxlIGlzIHJlZHJhd24uIEEgcmV0dXJuIG9mXG4gICAgICAgICAgICAgKiBmYWxzZSB3aWxsIGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBkcmF3LlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb1ByZURyYXdDYWxsYmFja1wiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbnMgZm9yIHdoZW4gdGhlIHRhYmxlIGhhcyBiZWVuIGluaXRpYWxpc2VkLlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb0luaXRDb21wbGV0ZVwiOiBbXSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxiYWNrcyBmb3IgbW9kaWZ5aW5nIHRoZSBzZXR0aW5ncyB0byBiZSBzdG9yZWQgZm9yIHN0YXRlIHNhdmluZywgcHJpb3IgdG9cbiAgICAgICAgICAgICAqIHNhdmluZyBzdGF0ZS5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYW9TdGF0ZVNhdmVQYXJhbXNcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2tzIGZvciBtb2RpZnlpbmcgdGhlIHNldHRpbmdzIHRoYXQgaGF2ZSBiZWVuIHN0b3JlZCBmb3Igc3RhdGUgc2F2aW5nXG4gICAgICAgICAgICAgKiBwcmlvciB0byB1c2luZyB0aGUgc3RvcmVkIHZhbHVlcyB0byByZXN0b3JlIHRoZSBzdGF0ZS5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYW9TdGF0ZUxvYWRQYXJhbXNcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsbGJhY2tzIGZvciBvcGVyYXRpbmcgb24gdGhlIHNldHRpbmdzIG9iamVjdCBvbmNlIHRoZSBzYXZlZCBzdGF0ZSBoYXMgYmVlblxuICAgICAgICAgICAgICogbG9hZGVkXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvU3RhdGVMb2FkZWRcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FjaGUgdGhlIHRhYmxlIElEIGZvciBxdWljayBhY2Nlc3NcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCA8aT5FbXB0eSBzdHJpbmc8L2k+XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1RhYmxlSWRcIjogXCJcIixcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgVEFCTEUgbm9kZSBmb3IgdGhlIG1haW4gdGFibGVcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5UYWJsZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRoZWFkIGVsZW1lbnRcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5USGVhZFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRmb290IGVsZW1lbnQgLSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5URm9vdFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcm1hbmVudCByZWYgdG8gdGhlIHRib2R5IGVsZW1lbnRcbiAgICAgICAgICAgICAqICBAdHlwZSBub2RlXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5UQm9keVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhY2hlIHRoZSB3cmFwcGVyIG5vZGUgKGNvbnRhaW5zIGFsbCBEYXRhVGFibGVzIGNvbnRyb2xsZWQgZWxlbWVudHMpXG4gICAgICAgICAgICAgKiAgQHR5cGUgbm9kZVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJuVGFibGVXcmFwcGVyXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGUgaWYgd2hlbiB1c2luZyBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nIHRoZSBsb2FkaW5nIG9mIGRhdGFcbiAgICAgICAgICAgICAqIHNob3VsZCBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgc2Vjb25kIGRyYXcuXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiRGVmZXJMb2FkaW5nXCI6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZGljYXRlIGlmIGFsbCByZXF1aXJlZCBpbmZvcm1hdGlvbiBoYXMgYmVlbiByZWFkIGluXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYkluaXRpYWxpc2VkXCI6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluZm9ybWF0aW9uIGFib3V0IG9wZW4gcm93cy4gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5IGhhcyB0aGUgcGFyYW1ldGVyc1xuICAgICAgICAgICAgICogJ25UcicgYW5kICduUGFyZW50J1xuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb09wZW5Sb3dzXCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpY3RhdGUgdGhlIHBvc2l0aW9uaW5nIG9mIERhdGFUYWJsZXMnIGNvbnRyb2wgZWxlbWVudHMgLSBzZWVcbiAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUubW9kZWwub0luaXQuc0RvbX0uXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0RvbVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlYXJjaCBkZWxheSAoaW4gbVMpXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50ZWdlclxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzZWFyY2hEZWxheVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoaWNoIHR5cGUgb2YgcGFnaW5hdGlvbiBzaG91bGQgYmUgdXNlZC5cbiAgICAgICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHBhcmFtZXRlciB3aWxsIGJlIHNldCBieSB0aGUgaW5pdGlhbGlzYXRpb24gcm91dGluZS4gVG9cbiAgICAgICAgICAgICAqIHNldCBhIGRlZmF1bHQgdXNlIHtAbGluayBEYXRhVGFibGUuZGVmYXVsdHN9LlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IHR3b19idXR0b25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzUGFnaW5hdGlvblR5cGVcIjogXCJ0d29fYnV0dG9uXCIsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHN0YXRlIGR1cmF0aW9uIChmb3IgYHN0YXRlU2F2ZWApIGluIHNlY29uZHMuXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiaVN0YXRlRHVyYXRpb25cIjogMCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcnJheSBvZiBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHN0YXRlIHNhdmluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG4gICAgICAgICAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgKiAgIDx1bD5cbiAgICAgICAgICAgICAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG4gICAgICAgICAgICAgKiAgICAgICBhbmQgdGhlIEpTT04gc3RyaW5nIHRvIHNhdmUgdGhhdCBoYXMgYmVlbiB0aHVzIGZhciBjcmVhdGVkLiBSZXR1cm5zXG4gICAgICAgICAgICAgKiAgICAgICBhIEpTT04gc3RyaW5nIHRvIGJlIGluc2VydGVkIGludG8gYSBqc29uIG9iamVjdFxuICAgICAgICAgICAgICogICAgICAgKGkuZS4gJ1wicGFyYW1cIjogWyAwLCAxLCAyXScpPC9saT5cbiAgICAgICAgICAgICAqICAgICA8bGk+c3RyaW5nOnNOYW1lIC0gbmFtZSBvZiBjYWxsYmFjazwvbGk+XG4gICAgICAgICAgICAgKiAgIDwvdWw+XG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFvU3RhdGVTYXZlXCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFycmF5IG9mIGNhbGxiYWNrIGZ1bmN0aW9ucyBmb3Igc3RhdGUgbG9hZGluZy4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGFuXG4gICAgICAgICAgICAgKiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgKiAgIDx1bD5cbiAgICAgICAgICAgICAqICAgICA8bGk+ZnVuY3Rpb246Zm4gLSBmdW5jdGlvbiB0byBjYWxsLiBUYWtlcyB0d28gcGFyYW1ldGVycywgb1NldHRpbmdzXG4gICAgICAgICAgICAgKiAgICAgICBhbmQgdGhlIG9iamVjdCBzdG9yZWQuIE1heSByZXR1cm4gZmFsc2UgdG8gY2FuY2VsIHN0YXRlIGxvYWRpbmc8L2xpPlxuICAgICAgICAgICAgICogICAgIDxsaT5zdHJpbmc6c05hbWUgLSBuYW1lIG9mIGNhbGxiYWNrPC9saT5cbiAgICAgICAgICAgICAqICAgPC91bD5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYW9TdGF0ZUxvYWRcIjogW10sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RhdGUgdGhhdCB3YXMgc2F2ZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2VcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwib1NhdmVkU3RhdGVcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGF0ZSB0aGF0IHdhcyBsb2FkZWQuIFVzZWZ1bCBmb3IgYmFjayByZWZlcmVuY2VcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwib0xvYWRlZFN0YXRlXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU291cmNlIHVybCBmb3IgQUpBWCBkYXRhIGZvciB0aGUgdGFibGUuXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0FqYXhTb3VyY2VcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gb2JqZWN0IGZyb20gd2hpY2ggdG8gcmVhZCB0aGUgdGFibGUgZGF0YSBmcm9tLiBUaGlzXG4gICAgICAgICAgICAgKiBjYW4gYmUgYW4gZW1wdHkgc3RyaW5nICh3aGVuIG5vdCBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nKSwgaW4gd2hpY2ggY2FzZVxuICAgICAgICAgICAgICogaXQgaXMgIGFzc3VtZWQgYW4gYW4gYXJyYXkgaXMgZ2l2ZW4gZGlyZWN0bHkuXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzQWpheERhdGFQcm9wXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm90ZSBpZiBkcmF3IHNob3VsZCBiZSBibG9ja2VkIHdoaWxlIGdldHRpbmcgZGF0YVxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB0cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYkFqYXhEYXRhR2V0XCI6IHRydWUsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIGxhc3QgalF1ZXJ5IFhIUiBvYmplY3QgdGhhdCB3YXMgdXNlZCBmb3Igc2VydmVyLXNpZGUgZGF0YSBnYXRoZXJpbmcuXG4gICAgICAgICAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIGZvciB3b3JraW5nIHdpdGggdGhlIFhIUiBpbmZvcm1hdGlvbiBpbiBvbmUgb2YgdGhlXG4gICAgICAgICAgICAgKiBjYWxsYmFja3NcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwianFYSFJcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBKU09OIHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiB0aGUgbGFzdCBBamF4IHJlcXVlc3RcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB1bmRlZmluZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJqc29uXCI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEYXRhIHN1Ym1pdHRlZCBhcyBwYXJ0IG9mIHRoZSBsYXN0IEFqYXggcmVxdWVzdFxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHVuZGVmaW5lZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm9BamF4RGF0YVwiOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRnVuY3Rpb24gdG8gZ2V0IHRoZSBzZXJ2ZXItc2lkZSBkYXRhLlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmblNlcnZlckRhdGFcIjogbnVsbCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGdW5jdGlvbnMgd2hpY2ggYXJlIGNhbGxlZCBwcmlvciB0byBzZW5kaW5nIGFuIEFqYXggcmVxdWVzdCBzbyBleHRyYVxuICAgICAgICAgICAgICogcGFyYW1ldGVycyBjYW4gZWFzaWx5IGJlIHNlbnQgdG8gdGhlIHNlcnZlclxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJhb1NlcnZlclBhcmFtc1wiOiBbXSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZW5kIHRoZSBYSFIgSFRUUCBtZXRob2QgLSBHRVQgb3IgUE9TVCAoY291bGQgYmUgUFVUIG9yIERFTEVURSBpZlxuICAgICAgICAgICAgICogcmVxdWlyZWQpLlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic1NlcnZlck1ldGhvZFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvcm1hdCBudW1iZXJzIGZvciBkaXNwbGF5LlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmbkZvcm1hdE51bWJlclwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExpc3Qgb2Ygb3B0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIGZvciB0aGUgdXNlciBzZWxlY3RhYmxlIGxlbmd0aCBtZW51LlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgcGFyYW1ldGVyIHdpbGwgYmUgc2V0IGJ5IHRoZSBpbml0aWFsaXNhdGlvbiByb3V0aW5lLiBUb1xuICAgICAgICAgICAgICogc2V0IGEgZGVmYXVsdCB1c2Uge0BsaW5rIERhdGFUYWJsZS5kZWZhdWx0c30uXG4gICAgICAgICAgICAgKiAgQHR5cGUgYXJyYXlcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBbXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImFMZW5ndGhNZW51XCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ291bnRlciBmb3IgdGhlIGRyYXdzIHRoYXQgdGhlIHRhYmxlIGRvZXMuIEFsc28gdXNlZCBhcyBhIHRyYWNrZXIgZm9yXG4gICAgICAgICAgICAgKiBzZXJ2ZXItc2lkZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlEcmF3XCI6IDAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGUgaWYgYSByZWRyYXcgaXMgYmVpbmcgZG9uZSAtIHVzZWZ1bCBmb3IgQWpheFxuICAgICAgICAgICAgICogIEB0eXBlIGJvb2xlYW5cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJEcmF3aW5nXCI6IGZhbHNlLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERyYXcgaW5kZXggKGlEcmF3KSBvZiB0aGUgbGFzdCBlcnJvciB3aGVuIHBhcnNpbmcgdGhlIHJldHVybmVkIGRhdGFcbiAgICAgICAgICAgICAqICBAdHlwZSBpbnRcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCAtMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImlEcmF3RXJyb3JcIjogLTEsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFnaW5nIGRpc3BsYXkgbGVuZ3RoXG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgMTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJfaURpc3BsYXlMZW5ndGhcIjogMTAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGFnaW5nIHN0YXJ0IHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG4gICAgICAgICAgICAgKiAgQHR5cGUgaW50XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIl9pRGlzcGxheVN0YXJ0XCI6IDAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSByZXN1bHQgc2V0XG4gICAgICAgICAgICAgKiAoaS5lLiBiZWZvcmUgZmlsdGVyaW5nKSwgVXNlIGZuUmVjb3Jkc1RvdGFsIHJhdGhlciB0aGFuXG4gICAgICAgICAgICAgKiB0aGlzIHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWUgb2YgdGhlIG51bWJlciBvZiByZWNvcmRzLCByZWdhcmRsZXNzIG9mXG4gICAgICAgICAgICAgKiB0aGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZyBzZXR0aW5nLlxuICAgICAgICAgICAgICogIEB0eXBlIGludFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IDBcbiAgICAgICAgICAgICAqICBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIl9pUmVjb3Jkc1RvdGFsXCI6IDAsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VydmVyLXNpZGUgcHJvY2Vzc2luZyAtIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IGRpc3BsYXkgc2V0XG4gICAgICAgICAgICAgKiAoaS5lLiBhZnRlciBmaWx0ZXJpbmcpLiBVc2UgZm5SZWNvcmRzRGlzcGxheSByYXRoZXIgdGhhblxuICAgICAgICAgICAgICogdGhpcyBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mIHRoZSBudW1iZXIgb2YgcmVjb3JkcywgcmVnYXJkbGVzcyBvZlxuICAgICAgICAgICAgICogdGhlIHNlcnZlci1zaWRlIHByb2Nlc3Npbmcgc2V0dGluZy5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgMFxuICAgICAgICAgICAgICogIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiX2lSZWNvcmRzRGlzcGxheVwiOiAwLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBjbGFzc2VzIHRvIHVzZSBmb3IgdGhlIHRhYmxlXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJvQ2xhc3Nlc1wiOiB7fSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIGF0dGFjaGVkIHRvIHRoZSBzZXR0aW5ncyBvYmplY3Qgc28geW91IGNhbiBjaGVjayBpbiB0aGUgZHJhd1xuICAgICAgICAgICAgICogY2FsbGJhY2sgaWYgZmlsdGVyaW5nIGhhcyBiZWVuIGRvbmUgaW4gdGhlIGRyYXcuIERlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mXG4gICAgICAgICAgICAgKiBldmVudHMuXG4gICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGZhbHNlXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJiRmlsdGVyZWRcIjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyBhdHRhY2hlZCB0byB0aGUgc2V0dGluZ3Mgb2JqZWN0IHNvIHlvdSBjYW4gY2hlY2sgaW4gdGhlIGRyYXdcbiAgICAgICAgICAgICAqIGNhbGxiYWNrIGlmIHNvcnRpbmcgaGFzIGJlZW4gZG9uZSBpbiB0aGUgZHJhdy4gRGVwcmVjYXRlZCBpbiBmYXZvdXIgb2ZcbiAgICAgICAgICAgICAqIGV2ZW50cy5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImJTb3J0ZWRcIjogZmFsc2UsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kaWNhdGUgdGhhdCBpZiBtdWx0aXBsZSByb3dzIGFyZSBpbiB0aGUgaGVhZGVyIGFuZCB0aGVyZSBpcyBtb3JlIHRoYW5cbiAgICAgICAgICAgICAqIG9uZSB1bmlxdWUgY2VsbCBwZXIgY29sdW1uLCBpZiB0aGUgdG9wIG9uZSAodHJ1ZSkgb3IgYm90dG9tIG9uZSAoZmFsc2UpXG4gICAgICAgICAgICAgKiBzaG91bGQgYmUgdXNlZCBmb3Igc29ydGluZyAvIHRpdGxlIGJ5IERhdGFUYWJsZXMuXG4gICAgICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBwYXJhbWV0ZXIgd2lsbCBiZSBzZXQgYnkgdGhlIGluaXRpYWxpc2F0aW9uIHJvdXRpbmUuIFRvXG4gICAgICAgICAgICAgKiBzZXQgYSBkZWZhdWx0IHVzZSB7QGxpbmsgRGF0YVRhYmxlLmRlZmF1bHRzfS5cbiAgICAgICAgICAgICAqICBAdHlwZSBib29sZWFuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYlNvcnRDZWxsc1RvcFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluaXRpYWxpc2F0aW9uIG9iamVjdCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZVxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJvSW5pdFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlc3Ryb3kgY2FsbGJhY2sgZnVuY3Rpb25zIC0gZm9yIHBsdWctaW5zIHRvIGF0dGFjaCB0aGVtc2VsdmVzIHRvIHRoZVxuICAgICAgICAgICAgICogZGVzdHJveSBzbyB0aGV5IGNhbiBjbGVhbiB1cCBtYXJrdXAgYW5kIGV2ZW50cy5cbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYW9EZXN0cm95Q2FsbGJhY2tcIjogW10sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGJlZm9yZSBmaWx0ZXJpbmdcbiAgICAgICAgICAgICAqICBAdHlwZSBmdW5jdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcImZuUmVjb3Jkc1RvdGFsXCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2ZuRGF0YVNvdXJjZSh0aGlzKSA9PSAnc3NwJyA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lSZWNvcmRzVG90YWwgKiAxIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5haURpc3BsYXlNYXN0ZXIubGVuZ3RoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIG51bWJlciBvZiByZWNvcmRzIGluIHRoZSBjdXJyZW50IHJlY29yZCBzZXQsIGFmdGVyIGZpbHRlcmluZ1xuICAgICAgICAgICAgICogIEB0eXBlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZm5SZWNvcmRzRGlzcGxheVwiOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mbkRhdGFTb3VyY2UodGhpcykgPT0gJ3NzcCcgP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pUmVjb3Jkc0Rpc3BsYXkgKiAxIDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5haURpc3BsYXkubGVuZ3RoO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGRpc3BsYXkgZW5kIHBvaW50IC0gYWlEaXNwbGF5IGluZGV4XG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmbkRpc3BsYXlFbmRcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBsZW4gPSB0aGlzLl9pRGlzcGxheUxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9pRGlzcGxheVN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBjYWxjID0gc3RhcnQgKyBsZW4sXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZHMgPSB0aGlzLmFpRGlzcGxheS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gdGhpcy5vRmVhdHVyZXMsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2luYXRlID0gZmVhdHVyZXMuYlBhZ2luYXRlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmVzLmJTZXJ2ZXJTaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYWdpbmF0ZSA9PT0gZmFsc2UgfHwgbGVuID09PSAtMSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydCArIHJlY29yZHMgOlxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oc3RhcnQgKyBsZW4sIHRoaXMuX2lSZWNvcmRzRGlzcGxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXBhZ2luYXRlIHx8IGNhbGMgPiByZWNvcmRzIHx8IGxlbiA9PT0gLTEgP1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkcyA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIERhdGFUYWJsZXMgb2JqZWN0IGZvciB0aGlzIHRhYmxlXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgbnVsbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm9JbnN0YW5jZVwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVuaXF1ZSBpZGVudGlmaWVyIGZvciBlYWNoIGluc3RhbmNlIG9mIHRoZSBEYXRhVGFibGVzIG9iamVjdC4gSWYgdGhlcmVcbiAgICAgICAgICAgICAqIGlzIGFuIElEIG9uIHRoZSB0YWJsZSBub2RlLCB0aGVuIGl0IHRha2VzIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBhblxuICAgICAgICAgICAgICogaW5jcmVtZW50aW5nIGludGVybmFsIGNvdW50ZXIgaXMgdXNlZC5cbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic0luc3RhbmNlXCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogdGFiaW5kZXggYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgYWRkZWQgdG8gRGF0YVRhYmxlcyBjb250cm9sIGVsZW1lbnRzLCBhbGxvd2luZ1xuICAgICAgICAgICAgICoga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgdGFibGUgYW5kIGl0cyBjb250cm9scy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJpVGFiSW5kZXhcIjogMCxcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBESVYgY29udGFpbmVyIGZvciB0aGUgZm9vdGVyIHNjcm9sbGluZyB0YWJsZSBpZiBzY3JvbGxpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJuU2Nyb2xsSGVhZFwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERJViBjb250YWluZXIgZm9yIHRoZSBmb290ZXIgc2Nyb2xsaW5nIHRhYmxlIGlmIHNjcm9sbGluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIm5TY3JvbGxGb290XCI6IG51bGwsXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGFzdCBhcHBsaWVkIHNvcnRcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICogIEBkZWZhdWx0IFtdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiYUxhc3RTb3J0XCI6IFtdLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0b3JlZCBwbHVnLWluIGluc3RhbmNlc1xuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwib1BsdWdpbnNcIjoge30sXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRnVuY3Rpb24gdXNlZCB0byBnZXQgYSByb3cncyBpZCBmcm9tIHRoZSByb3cncyBkYXRhXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwicm93SWRGblwiOiBudWxsLFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERhdGEgbG9jYXRpb24gd2hlcmUgdG8gc3RvcmUgYSByb3cncyBpZFxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ1xuICAgICAgICAgICAgICogIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJyb3dJZFwiOiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV4dGVuc2lvbiBvYmplY3QgZm9yIERhdGFUYWJsZXMgdGhhdCBpcyB1c2VkIHRvIHByb3ZpZGUgYWxsIGV4dGVuc2lvblxuICAgICAgICAgKiBvcHRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGBEYXRhVGFibGUuZXh0YCBvYmplY3QgaXMgYXZhaWxhYmxlIHRocm91Z2hcbiAgICAgICAgICogYGpRdWVyeS5mbi5kYXRhVGFibGUuZXh0YCB3aGVyZSBpdCBtYXkgYmUgYWNjZXNzZWQgYW5kIG1hbmlwdWxhdGVkLiBJdCBpc1xuICAgICAgICAgKiBhbHNvIGFsaWFzZWQgdG8gYGpRdWVyeS5mbi5kYXRhVGFibGVFeHRgIGZvciBoaXN0b3JpYyByZWFzb25zLlxuICAgICAgICAgKiAgQG5hbWVzcGFjZVxuICAgICAgICAgKiAgQGV4dGVuZHMgRGF0YVRhYmxlLm1vZGVscy5leHRcbiAgICAgICAgICovXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YVRhYmxlcyBleHRlbnNpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbmFtZXNwYWNlIGFjdHMgYXMgYSBjb2xsZWN0aW9uIGFyZWEgZm9yIHBsdWctaW5zIHRoYXQgY2FuIGJlIHVzZWQgdG9cbiAgICAgICAgICogZXh0ZW5kIERhdGFUYWJsZXMgY2FwYWJpbGl0aWVzLiBJbmRlZWQgbWFueSBvZiB0aGUgYnVpbGQgaW4gbWV0aG9kc1xuICAgICAgICAgKiB1c2UgdGhpcyBtZXRob2QgdG8gcHJvdmlkZSB0aGVpciBvd24gY2FwYWJpbGl0aWVzIChzb3J0aW5nIG1ldGhvZHMgZm9yXG4gICAgICAgICAqIGV4YW1wbGUpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhpcyBuYW1lc3BhY2UgaXMgYWxpYXNlZCB0byBgalF1ZXJ5LmZuLmRhdGFUYWJsZUV4dGAgZm9yIGxlZ2FjeVxuICAgICAgICAgKiByZWFzb25zXG4gICAgICAgICAqXG4gICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUuZXh0ID0gX2V4dCA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnV0dG9ucy4gRm9yIHVzZSB3aXRoIHRoZSBCdXR0b25zIGV4dGVuc2lvbiBmb3IgRGF0YVRhYmxlcy4gVGhpcyBpc1xuICAgICAgICAgICAgICogZGVmaW5lZCBoZXJlIHNvIG90aGVyIGV4dGVuc2lvbnMgY2FuIGRlZmluZSBidXR0b25zIHJlZ2FyZGxlc3Mgb2YgbG9hZFxuICAgICAgICAgICAgICogb3JkZXIuIEl0IGlzIF9ub3RfIHVzZWQgYnkgRGF0YVRhYmxlcyBjb3JlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBidXR0b25zOiB7fSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVsZW1lbnQgY2xhc3MgbmFtZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2xhc3Nlczoge30sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEYXRhVGFibGVzIGJ1aWxkIHR5cGUgKGV4cGFuZGVkIGJ5IHRoZSBkb3dubG9hZCBidWlsZGVyKVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAdHlwZSBzdHJpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYnVpbGRlcjogXCItc291cmNlLVwiLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXJyb3IgcmVwb3J0aW5nLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEhvdyBzaG91bGQgRGF0YVRhYmxlcyByZXBvcnQgYW4gZXJyb3IuIENhbiB0YWtlIHRoZSB2YWx1ZSAnYWxlcnQnLFxuICAgICAgICAgICAgICogJ3Rocm93JywgJ25vbmUnIG9yIGEgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEB0eXBlIHN0cmluZ3xmdW5jdGlvblxuICAgICAgICAgICAgICogIEBkZWZhdWx0IGFsZXJ0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVyck1vZGU6IFwiYWxlcnRcIixcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZlYXR1cmUgcGx1Zy1pbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhpcyBpcyBhbiBhcnJheSBvZiBvYmplY3RzIHdoaWNoIGRlc2NyaWJlIHRoZSBmZWF0dXJlIHBsdWctaW5zIHRoYXQgYXJlXG4gICAgICAgICAgICAgKiBhdmFpbGFibGUgdG8gRGF0YVRhYmxlcy4gVGhlc2UgZmVhdHVyZSBwbHVnLWlucyBhcmUgdGhlbiBhdmFpbGFibGUgZm9yXG4gICAgICAgICAgICAgKiB1c2UgdGhyb3VnaCB0aGUgYGRvbWAgaW5pdGlhbGlzYXRpb24gb3B0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEVhY2ggZmVhdHVyZSBwbHVnLWluIGlzIGRlc2NyaWJlZCBieSBhbiBvYmplY3Qgd2hpY2ggbXVzdCBoYXZlIHRoZVxuICAgICAgICAgICAgICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBgZm5Jbml0YCAtIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBpbml0aWFsaXNlIHRoZSBwbHVnLWluLFxuICAgICAgICAgICAgICogKiBgY0ZlYXR1cmVgIC0gYSBjaGFyYWN0ZXIgc28gdGhlIGZlYXR1cmUgY2FuIGJlIGVuYWJsZWQgYnkgdGhlIGBkb21gXG4gICAgICAgICAgICAgKiAgIGluc3RpbGxhdGlvbiBvcHRpb24uIFRoaXMgaXMgY2FzZSBzZW5zaXRpdmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIGBmbkluaXRgIGZ1bmN0aW9uIGhhcyB0aGUgZm9sbG93aW5nIGlucHV0IHBhcmFtZXRlcnM6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogMS4gYHtvYmplY3R9YCBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdDogc2VlXG4gICAgICAgICAgICAgKiAgICB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQW5kIHRoZSBmb2xsb3dpbmcgcmV0dXJuIGlzIGV4cGVjdGVkOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICoge25vZGV8bnVsbH0gVGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgeW91ciBmZWF0dXJlLiBOb3RlIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiAgIHJldHVybiBtYXkgYWxzbyBiZSB2b2lkIGlmIHlvdXIgcGx1Zy1pbiBkb2VzIG5vdCByZXF1aXJlIHRvIGluamVjdCBhbnlcbiAgICAgICAgICAgICAqICAgRE9NIGVsZW1lbnRzIGludG8gRGF0YVRhYmxlcyBjb250cm9sIChgZG9tYCkgLSBmb3IgZXhhbXBsZSB0aGlzIG1pZ2h0XG4gICAgICAgICAgICAgKiAgIGJlIHVzZWZ1bCB3aGVuIGRldmVsb3BpbmcgYSBwbHVnLWluIHdoaWNoIGFsbG93cyB0YWJsZSBjb250cm9sIHZpYVxuICAgICAgICAgICAgICogICBrZXlib2FyZCBlbnRyeVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAdHlwZSBhcnJheVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGUuZXh0LmZlYXR1cmVzLnB1c2goIHtcbiAgICAgICAgICAgICAqICAgICAgXCJmbkluaXRcIjogZnVuY3Rpb24oIG9TZXR0aW5ncyApIHtcbiAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gbmV3IFRhYmxlVG9vbHMoIHsgXCJvRFRTZXR0aW5nc1wiOiBvU2V0dGluZ3MgfSApO1xuICAgICAgICAgICAgICogICAgICB9LFxuICAgICAgICAgICAgICogICAgICBcImNGZWF0dXJlXCI6IFwiVFwiXG4gICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZlYXR1cmU6IFtdLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUm93IHNlYXJjaGluZy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIG1ldGhvZCBvZiBzZWFyY2hpbmcgaXMgY29tcGxpbWVudGFyeSB0byB0aGUgZGVmYXVsdCB0eXBlIGJhc2VkXG4gICAgICAgICAgICAgKiBzZWFyY2hpbmcsIGFuZCBhIGxvdCBtb3JlIGNvbXByZWhlbnNpdmUgYXMgaXQgYWxsb3dzIHlvdSBjb21wbGV0ZSBjb250cm9sXG4gICAgICAgICAgICAgKiBvdmVyIHRoZSBzZWFyY2hpbmcgbG9naWMuIEVhY2ggZWxlbWVudCBpbiB0aGlzIGFycmF5IGlzIGEgZnVuY3Rpb25cbiAgICAgICAgICAgICAqIChwYXJhbWV0ZXJzIGRlc2NyaWJlZCBiZWxvdykgdGhhdCBpcyBjYWxsZWQgZm9yIGV2ZXJ5IHJvdyBpbiB0aGUgdGFibGUsXG4gICAgICAgICAgICAgKiBhbmQgeW91ciBsb2dpYyBkZWNpZGVzIGlmIGl0IHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgc2VhcmNoaW5nIGRhdGEgc2V0XG4gICAgICAgICAgICAgKiBvciBub3QuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU2VhcmNoaW5nIGZ1bmN0aW9ucyBoYXZlIHRoZSBmb2xsb3dpbmcgaW5wdXQgcGFyYW1ldGVyczpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAxLiBge29iamVjdH1gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0OiBzZWVcbiAgICAgICAgICAgICAqICAgIHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICAgICAqIDIuIGB7YXJyYXl8b2JqZWN0fWAgRGF0YSBmb3IgdGhlIHJvdyB0byBiZSBwcm9jZXNzZWQgKHNhbWUgYXMgdGhlXG4gICAgICAgICAgICAgKiAgICBvcmlnaW5hbCBmb3JtYXQgdGhhdCB3YXMgcGFzc2VkIGluIGFzIHRoZSBkYXRhIHNvdXJjZSwgb3IgYW4gYXJyYXlcbiAgICAgICAgICAgICAqICAgIGZyb20gYSBET00gZGF0YSBzb3VyY2VcbiAgICAgICAgICAgICAqIDMuIGB7aW50fWAgUm93IGluZGV4ICh7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3MuYW9EYXRhfSksIHdoaWNoXG4gICAgICAgICAgICAgKiAgICBjYW4gYmUgdXNlZnVsIHRvIHJldHJpZXZlIHRoZSBgVFJgIGVsZW1lbnQgaWYgeW91IG5lZWQgRE9NIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEFuZCB0aGUgZm9sbG93aW5nIHJldHVybiBpcyBleHBlY3RlZDpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqIHtib29sZWFufSBJbmNsdWRlIHRoZSByb3cgaW4gdGhlIHNlYXJjaGVkIHJlc3VsdCBzZXQgKHRydWUpIG9yIG5vdFxuICAgICAgICAgICAgICogICAoZmFsc2UpXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IGFzIHdpdGggdGhlIG1haW4gc2VhcmNoIGFiaWxpdHkgaW4gRGF0YVRhYmxlcywgdGVjaG5pY2FsbHkgdGhpc1xuICAgICAgICAgICAgICogaXMgXCJmaWx0ZXJpbmdcIiwgc2luY2UgaXQgaXMgc3VidHJhY3RpdmUuIEhvd2V2ZXIsIGZvciBjb25zaXN0ZW5jeSBpblxuICAgICAgICAgICAgICogbmFtaW5nIHdlIGNhbGwgaXQgc2VhcmNoaW5nIGhlcmUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKiAgQGRlZmF1bHQgW11cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAqICAgIC8vIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBjdXN0b20gc2VhcmNoIGJlaW5nIGFwcGxpZWQgdG8gdGhlXG4gICAgICAgICAgICAgKiAgICAvLyBmb3VydGggY29sdW1uIChpLmUuIHRoZSBkYXRhWzNdIGluZGV4KSBiYXNlZCBvbiB0d28gaW5wdXQgdmFsdWVzXG4gICAgICAgICAgICAgKiAgICAvLyBmcm9tIHRoZSBlbmQtdXNlciwgbWF0Y2hpbmcgdGhlIGRhdGEgaW4gYSBjZXJ0YWluIHJhbmdlLlxuICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGUuZXh0LnNlYXJjaC5wdXNoKFxuICAgICAgICAgICAgICogICAgICBmdW5jdGlvbiggc2V0dGluZ3MsIGRhdGEsIGRhdGFJbmRleCApIHtcbiAgICAgICAgICAgICAqICAgICAgICB2YXIgbWluID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pbicpLnZhbHVlICogMTtcbiAgICAgICAgICAgICAqICAgICAgICB2YXIgbWF4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21heCcpLnZhbHVlICogMTtcbiAgICAgICAgICAgICAqICAgICAgICB2YXIgdmVyc2lvbiA9IGRhdGFbM10gPT0gXCItXCIgPyAwIDogZGF0YVszXSoxO1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICAgICAgICBpZiAoIG1pbiA9PSBcIlwiICYmIG1heCA9PSBcIlwiICkge1xuICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPT0gXCJcIiAmJiB2ZXJzaW9uIDwgbWF4ICkge1xuICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIFwiXCIgPT0gbWF4ICkge1xuICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgKiAgICAgICAgfVxuICAgICAgICAgICAgICogICAgICAgIGVsc2UgaWYgKCBtaW4gPCB2ZXJzaW9uICYmIHZlcnNpb24gPCBtYXggKSB7XG4gICAgICAgICAgICAgKiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAqICAgICAgICB9XG4gICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICogICAgICB9XG4gICAgICAgICAgICAgKiAgICApO1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZWFyY2g6IFtdLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VsZWN0b3IgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBgc2VsZWN0b3JgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBleHRlbmQgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIGZvciB0aGVcbiAgICAgICAgICAgICAqIHNlbGVjdG9yIG1vZGlmaWVyIG9wdGlvbnMgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IGRhdGEgdHlwZSkgdGhhdFxuICAgICAgICAgICAgICogZWFjaCBvZiB0aGUgdGhyZWUgYnVpbHQgaW4gc2VsZWN0b3IgdHlwZXMgb2ZmZXIgKHJvdywgY29sdW1uIGFuZCBjZWxsICtcbiAgICAgICAgICAgICAqIHRoZWlyIHBsdXJhbCBjb3VudGVycGFydHMpLiBGb3IgZXhhbXBsZSB0aGUgU2VsZWN0IGV4dGVuc2lvbiB1c2VzIHRoaXNcbiAgICAgICAgICAgICAqIG1lY2hhbmlzbSB0byBwcm92aWRlIGFuIG9wdGlvbiB0byBzZWxlY3Qgb25seSByb3dzLCBjb2x1bW5zIGFuZCBjZWxsc1xuICAgICAgICAgICAgICogdGhhdCBoYXZlIGJlZW4gbWFya2VkIGFzIHNlbGVjdGVkIGJ5IHRoZSBlbmQgdXNlciAoYHtzZWxlY3RlZDogdHJ1ZX1gKSxcbiAgICAgICAgICAgICAqIHdoaWNoIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIGJ1aWx0IGluIHNlbGVjdG9yXG4gICAgICAgICAgICAgKiBvcHRpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEVhY2ggcHJvcGVydHkgaXMgYW4gYXJyYXkgdG8gd2hpY2ggZnVuY3Rpb25zIGNhbiBiZSBwdXNoZWQuIFRoZSBmdW5jdGlvbnNcbiAgICAgICAgICAgICAqIHRha2UgdGhyZWUgYXR0cmlidXRlczpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqIFNldHRpbmdzIG9iamVjdCBmb3IgdGhlIGhvc3QgdGFibGVcbiAgICAgICAgICAgICAqICogT3B0aW9ucyBvYmplY3QgKGBzZWxlY3Rvci1tb2RpZmllcmAgb2JqZWN0IHR5cGUpXG4gICAgICAgICAgICAgKiAqIEFycmF5IG9mIHNlbGVjdGVkIGl0ZW0gaW5kZXhlc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSByZXR1cm4gaXMgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdGluZyBpdGVtIGluZGV4ZXMgYWZ0ZXIgdGhlIGN1c3RvbVxuICAgICAgICAgICAgICogc2VsZWN0b3IgaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAgQHR5cGUgb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNlbGVjdG9yOiB7XG4gICAgICAgICAgICAgICAgY2VsbDogW10sXG4gICAgICAgICAgICAgICAgY29sdW1uOiBbXSxcbiAgICAgICAgICAgICAgICByb3c6IFtdXG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW50ZXJuYWwgZnVuY3Rpb25zLCBleHBvc2VkIGZvciB1c2VkIGluIHBsdWctaW5zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFBsZWFzZSBub3RlIHRoYXQgeW91IHNob3VsZCBub3QgbmVlZCB0byB1c2UgdGhlIGludGVybmFsIG1ldGhvZHMgZm9yXG4gICAgICAgICAgICAgKiBhbnl0aGluZyBvdGhlciB0aGFuIGEgcGx1Zy1pbiAoYW5kIGV2ZW4gdGhlbiwgdHJ5IHRvIGF2b2lkIGlmIHBvc3NpYmxlKS5cbiAgICAgICAgICAgICAqIFRoZSBpbnRlcm5hbCBmdW5jdGlvbiBtYXkgY2hhbmdlIGJldHdlZW4gcmVsZWFzZXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICogIEBkZWZhdWx0IHt9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGludGVybmFsOiB7fSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExlZ2FjeSBjb25maWd1cmF0aW9uIG9wdGlvbnMuIEVuYWJsZSBhbmQgZGlzYWJsZSBsZWdhY3kgb3B0aW9ucyB0aGF0XG4gICAgICAgICAgICAgKiBhcmUgYXZhaWxhYmxlIGluIERhdGFUYWJsZXMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZWdhY3k6IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbmFibGUgLyBkaXNhYmxlIERhdGFUYWJsZXMgMS45IGNvbXBhdGlibGUgc2VydmVyLXNpZGUgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgICAqIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQHR5cGUgYm9vbGVhblxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCBudWxsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYWpheDogbnVsbFxuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhZ2luYXRpb24gcGx1Zy1pbiBtZXRob2RzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEVhY2ggZW50cnkgaW4gdGhpcyBvYmplY3QgaXMgYSBmdW5jdGlvbiBhbmQgZGVmaW5lcyB3aGljaCBidXR0b25zIHNob3VsZFxuICAgICAgICAgICAgICogYmUgc2hvd24gYnkgdGhlIHBhZ2luYXRpb24gcmVuZGVyaW5nIG1ldGhvZCB0aGF0IGlzIHVzZWQgZm9yIHRoZSB0YWJsZTpcbiAgICAgICAgICAgICAqIHtAbGluayBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLnBhZ2VCdXR0b259LiBUaGUgcmVuZGVyZXIgYWRkcmVzc2VzIGhvdyB0aGVcbiAgICAgICAgICAgICAqIGJ1dHRvbnMgYXJlIGRpc3BsYXllZCBpbiB0aGUgZG9jdW1lbnQsIHdoaWxlIHRoZSBmdW5jdGlvbnMgaGVyZSB0ZWxsIGl0XG4gICAgICAgICAgICAgKiB3aGF0IGJ1dHRvbnMgdG8gZGlzcGxheS4gVGhpcyBpcyBkb25lIGJ5IHJldHVybmluZyBhbiBhcnJheSBvZiBidXR0b25cbiAgICAgICAgICAgICAqIGRlc2NyaXB0aW9ucyAod2hhdCBlYWNoIGJ1dHRvbiB3aWxsIGRvKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBQYWdpbmF0aW9uIHR5cGVzICh0aGUgZm91ciBidWlsdCBpbiBvcHRpb25zIGFuZCBhbnkgYWRkaXRpb25hbCBwbHVnLWluXG4gICAgICAgICAgICAgKiBvcHRpb25zIGRlZmluZWQgaGVyZSkgY2FuIGJlIHVzZWQgdGhyb3VnaCB0aGUgYHBhZ2luYXRpb25UeXBlYFxuICAgICAgICAgICAgICogaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDEuIGB7aW50fSBwYWdlYCBUaGUgY3VycmVudCBwYWdlIGluZGV4XG4gICAgICAgICAgICAgKiAyLiBge2ludH0gcGFnZXNgIFRoZSBudW1iZXIgb2YgcGFnZXMgaW4gdGhlIHRhYmxlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IG9mIHRoZVxuICAgICAgICAgICAgICogYXJyYXkgY2FuIGJlIG9uZSBvZjpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAqIGBmaXJzdGAgLSBKdW1wIHRvIGZpcnN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcbiAgICAgICAgICAgICAqICogYGxhc3RgIC0gSnVtcCB0byBsYXN0IHBhZ2Ugd2hlbiBhY3RpdmF0ZWRcbiAgICAgICAgICAgICAqICogYHByZXZpb3VzYCAtIFNob3cgcHJldmlvdXMgcGFnZSB3aGVuIGFjdGl2YXRlZFxuICAgICAgICAgICAgICogKiBgbmV4dGAgLSBTaG93IG5leHQgcGFnZSB3aGVuIGFjdGl2YXRlZFxuICAgICAgICAgICAgICogKiBge2ludH1gIC0gU2hvdyBwYWdlIG9mIHRoZSBpbmRleCBnaXZlblxuICAgICAgICAgICAgICogKiBge2FycmF5fWAgLSBBIG5lc3RlZCBhcnJheSBjb250YWluaW5nIHRoZSBhYm92ZSBlbGVtZW50cyB0byBhZGQgYVxuICAgICAgICAgICAgICogICBjb250YWluaW5nICdESVYnIGVsZW1lbnQgKG1pZ2h0IGJlIHVzZWZ1bCBmb3Igc3R5bGluZykuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTm90ZSB0aGF0IERhdGFUYWJsZXMgdjEuOS0gdXNlZCB0aGlzIG9iamVjdCBzbGlnaHRseSBkaWZmZXJlbnRseSB3aGVyZWJ5XG4gICAgICAgICAgICAgKiBhbiBvYmplY3Qgd2l0aCB0d28gZnVuY3Rpb25zIHdvdWxkIGJlIGRlZmluZWQgZm9yIGVhY2ggcGx1Zy1pbi4gVGhhdFxuICAgICAgICAgICAgICogYWJpbGl0eSBpcyBzdGlsbCBzdXBwb3J0ZWQgYnkgRGF0YVRhYmxlcyAxLjEwKyB0byBwcm92aWRlIGJhY2t3YXJkc1xuICAgICAgICAgICAgICogY29tcGF0aWJpbGl0eSwgYnV0IHRoaXMgb3B0aW9uIG9mIHVzZSBpcyBub3cgZGVjcmVtZW50ZWQgYW5kIG5vIGxvbmdlclxuICAgICAgICAgICAgICogZG9jdW1lbnRlZCBpbiBEYXRhVGFibGVzIDEuMTArLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgLy8gU2hvdyBwcmV2aW91cywgbmV4dCBhbmQgY3VycmVudCBwYWdlIGJ1dHRvbnMgb25seVxuICAgICAgICAgICAgICogICAgJC5mbi5kYXRhVGFibGVFeHQub1BhZ2luYXRpb24uY3VycmVudCA9IGZ1bmN0aW9uICggcGFnZSwgcGFnZXMgKSB7XG4gICAgICAgICAgICAgKiAgICAgIHJldHVybiBbICdwcmV2aW91cycsIHBhZ2UsICduZXh0JyBdO1xuICAgICAgICAgICAgICogICAgfTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGFnZXI6IHt9LFxuXG5cbiAgICAgICAgICAgIHJlbmRlcmVyOiB7XG4gICAgICAgICAgICAgICAgcGFnZUJ1dHRvbjoge30sXG4gICAgICAgICAgICAgICAgaGVhZGVyOiB7fVxuICAgICAgICAgICAgfSxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9yZGVyaW5nIHBsdWctaW5zIC0gY3VzdG9tIGRhdGEgc291cmNlXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVGhlIGV4dGVuc2lvbiBvcHRpb25zIGZvciBvcmRlcmluZyBvZiBkYXRhIGF2YWlsYWJsZSBoZXJlIGlzIGNvbXBsaW1lbnRhcnlcbiAgICAgICAgICAgICAqIHRvIHRoZSBkZWZhdWx0IHR5cGUgYmFzZWQgb3JkZXJpbmcgdGhhdCBEYXRhVGFibGVzIHR5cGljYWxseSB1c2VzLiBJdFxuICAgICAgICAgICAgICogYWxsb3dzIG11Y2ggZ3JlYXRlciBjb250cm9sIG92ZXIgdGhlIHRoZSBkYXRhIHRoYXQgaXMgYmVpbmcgdXNlZCB0b1xuICAgICAgICAgICAgICogb3JkZXIgYSBjb2x1bW4sIGJ1dCBpcyBuZWNlc3NhcmlseSB0aGVyZWZvcmUgbW9yZSBjb21wbGV4LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoaXMgdHlwZSBvZiBvcmRlcmluZyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZG8gb3JkZXJpbmcgYmFzZWQgb24gZGF0YVxuICAgICAgICAgICAgICogbGl2ZSBmcm9tIHRoZSBET00gKGZvciBleGFtcGxlIHRoZSBjb250ZW50cyBvZiBhbiAnaW5wdXQnIGVsZW1lbnQpIHJhdGhlclxuICAgICAgICAgICAgICogdGhhbiBqdXN0IHRoZSBzdGF0aWMgc3RyaW5nIHRoYXQgRGF0YVRhYmxlcyBrbm93cyBvZi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgd2F5IHRoZXNlIHBsdWctaW5zIHdvcmsgaXMgdGhhdCB5b3UgY3JlYXRlIGFuIGFycmF5IG9mIHRoZSB2YWx1ZXMgeW91XG4gICAgICAgICAgICAgKiB3aXNoIHRvIGJlIG9yZGVyaW5nIGZvciB0aGUgY29sdW1uIGluIHF1ZXN0aW9uIGFuZCB0aGVuIHJldHVybiB0aGF0XG4gICAgICAgICAgICAgKiBhcnJheS4gVGhlIGRhdGEgaW4gdGhlIGFycmF5IG11Y2ggYmUgaW4gdGhlIGluZGV4IG9yZGVyIG9mIHRoZSByb3dzIGluXG4gICAgICAgICAgICAgKiB0aGUgdGFibGUgKG5vdCB0aGUgY3VycmVudGx5IG9yZGVyaW5nIG9yZGVyISkuIFdoaWNoIG9yZGVyIGRhdGEgZ2F0aGVyaW5nXG4gICAgICAgICAgICAgKiBmdW5jdGlvbiBpcyBydW4gaGVyZSBkZXBlbmRzIG9uIHRoZSBgZHQtaW5pdCBjb2x1bW5zLm9yZGVyRGF0YVR5cGVgXG4gICAgICAgICAgICAgKiBwYXJhbWV0ZXIgdGhhdCBpcyB1c2VkIGZvciB0aGUgY29sdW1uIChpZiBhbnkpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDEuIGB7b2JqZWN0fWAgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Q6IHNlZVxuICAgICAgICAgICAgICogICAge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuICAgICAgICAgICAgICogMi4gYHtpbnR9YCBUYXJnZXQgY29sdW1uIGluZGV4XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogRWFjaCBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byByZXR1cm4gYW4gYXJyYXk6XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogKiBge2FycmF5fWAgRGF0YSBmb3IgdGhlIGNvbHVtbiB0byBiZSBvcmRlcmluZyB1cG9uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAvLyBPcmRlcmluZyB1c2luZyBgaW5wdXRgIG5vZGUgdmFsdWVzXG4gICAgICAgICAgICAgKiAgICAkLmZuLmRhdGFUYWJsZS5leHQub3JkZXJbJ2RvbS10ZXh0J10gPSBmdW5jdGlvbiAgKCBzZXR0aW5ncywgY29sIClcbiAgICAgICAgICAgICAqICAgIHtcbiAgICAgICAgICAgICAqICAgICAgcmV0dXJuIHRoaXMuYXBpKCkuY29sdW1uKCBjb2wsIHtvcmRlcjonaW5kZXgnfSApLm5vZGVzKCkubWFwKCBmdW5jdGlvbiAoIHRkLCBpICkge1xuICAgICAgICAgICAgICogICAgICAgIHJldHVybiAkKCdpbnB1dCcsIHRkKS52YWwoKTtcbiAgICAgICAgICAgICAqICAgICAgfSApO1xuICAgICAgICAgICAgICogICAgfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvcmRlcjoge30sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUeXBlIGJhc2VkIHBsdWctaW5zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEVhY2ggY29sdW1uIGluIERhdGFUYWJsZXMgaGFzIGEgdHlwZSBhc3NpZ25lZCB0byBpdCwgZWl0aGVyIGJ5IGF1dG9tYXRpY1xuICAgICAgICAgICAgICogZGV0ZWN0aW9uIG9yIGJ5IGRpcmVjdCBhc3NpZ25tZW50IHVzaW5nIHRoZSBgdHlwZWAgb3B0aW9uIGZvciB0aGUgY29sdW1uLlxuICAgICAgICAgICAgICogVGhlIHR5cGUgb2YgYSBjb2x1bW4gd2lsbCBlZmZlY3QgaG93IGl0IGlzIG9yZGVyaW5nIGFuZCBzZWFyY2ggKHBsdWctaW5zXG4gICAgICAgICAgICAgKiBjYW4gYWxzbyBtYWtlIHVzZSBvZiB0aGUgY29sdW1uIHR5cGUgaWYgcmVxdWlyZWQpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFR5cGUgZGV0ZWN0aW9uIGZ1bmN0aW9ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgdXNlZCB0byBhdXRvbWF0aWNhbGx5IGRldGVjdFxuICAgICAgICAgICAgICAgICAqIGEgY29sdW1uJ3MgdHlwZSwgbWFraW5nIGluaXRpYWxpc2F0aW9uIG9mIERhdGFUYWJsZXMgc3VwZXIgZWFzeSwgZXZlblxuICAgICAgICAgICAgICAgICAqIHdoZW4gY29tcGxleCBkYXRhIGlzIGluIHRoZSB0YWJsZS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIHR3byBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgZnJvbSB0aGUgY29sdW1uIGNlbGwgdG8gYmUgYW5hbHlzZWRcbiAgICAgICAgICAgICAgICAgKiAgMi4gYHtzZXR0aW5nc31gIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0LiBUaGlzIGNhbiBiZSB1c2VkIHRvXG4gICAgICAgICAgICAgICAgICogICAgIHBlcmZvcm0gY29udGV4dCBzcGVjaWZpYyB0eXBlIGRldGVjdGlvbiAtIGZvciBleGFtcGxlIGRldGVjdGlvblxuICAgICAgICAgICAgICAgICAqICAgICBiYXNlZCBvbiBsYW5ndWFnZSBzZXR0aW5ncyBzdWNoIGFzIHVzaW5nIGEgY29tbWEgZm9yIGEgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAqICAgICBwbGFjZS4gR2VuZXJhbGx5IHNwZWFraW5nIHRoZSBvcHRpb25zIGZyb20gdGhlIHNldHRpbmdzIHdpbGwgbm90XG4gICAgICAgICAgICAgICAgICogICAgIGJlIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybjpcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICogYHtzdHJpbmd8bnVsbH1gIERhdGEgdHlwZSBkZXRlY3RlZCwgb3IgbnVsbCBpZiB1bmtub3duIChhbmQgdGh1c1xuICAgICAgICAgICAgICAgICAqICAgcGFzcyBpdCBvbiB0byB0aGUgb3RoZXIgdHlwZSBkZXRlY3Rpb24gZnVuY3Rpb25zLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIGFycmF5XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICAgICAgICAgKiAgICAvLyBDdXJyZW5jeSB0eXBlIGRldGVjdGlvbiBwbHVnLWluOlxuICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLmRldGVjdC5wdXNoKFxuICAgICAgICAgICAgICAgICAqICAgICAgZnVuY3Rpb24gKCBkYXRhLCBzZXR0aW5ncyApIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgLy8gQ2hlY2sgdGhlIG51bWVyaWMgcGFydFxuICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoICEgZGF0YS5zdWJzdHJpbmcoMSkubWF0Y2goL1swLTldLykgKSB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICAgICAgICAvLyBDaGVjayBwcmVmaXhlZCBieSBjdXJyZW5jeVxuICAgICAgICAgICAgICAgICAqICAgICAgICBpZiAoIGRhdGEuY2hhckF0KDApID09ICckJyB8fCBkYXRhLmNoYXJBdCgwKSA9PSAnJnBvdW5kOycgKSB7XG4gICAgICAgICAgICAgICAgICogICAgICAgICAgcmV0dXJuICdjdXJyZW5jeSc7XG4gICAgICAgICAgICAgICAgICogICAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICogICAgICB9XG4gICAgICAgICAgICAgICAgICogICAgKTtcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkZXRlY3Q6IFtdLFxuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUeXBlIGJhc2VkIHNlYXJjaCBmb3JtYXR0aW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlIHR5cGUgYmFzZWQgc2VhcmNoaW5nIGZ1bmN0aW9ucyBjYW4gYmUgdXNlZCB0byBwcmUtZm9ybWF0IHRoZVxuICAgICAgICAgICAgICAgICAqIGRhdGEgdG8gYmUgc2VhcmNoIG9uLiBGb3IgZXhhbXBsZSwgaXQgY2FuIGJlIHVzZWQgdG8gc3RyaXAgSFRNTFxuICAgICAgICAgICAgICAgICAqIHRhZ3Mgb3IgdG8gZGUtZm9ybWF0IHRlbGVwaG9uZSBudW1iZXJzIGZvciBudW1lcmljIG9ubHkgc2VhcmNoaW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTm90ZSB0aGF0IGlzIGEgc2VhcmNoIGlzIG5vdCBkZWZpbmVkIGZvciBhIGNvbHVtbiBvZiBhIGdpdmVuIHR5cGUsXG4gICAgICAgICAgICAgICAgICogbm8gc2VhcmNoIGZvcm1hdHRpbmcgd2lsbCBiZSBwZXJmb3JtZWQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBQcmUtcHJvY2Vzc2luZyBvZiBzZWFyY2hpbmcgZGF0YSBwbHVnLWlucyAtIFdoZW4geW91IGFzc2lnbiB0aGUgc1R5cGVcbiAgICAgICAgICAgICAgICAgKiBmb3IgYSBjb2x1bW4gKG9yIGhhdmUgaXQgYXV0b21hdGljYWxseSBkZXRlY3RlZCBmb3IgeW91IGJ5IERhdGFUYWJsZXNcbiAgICAgICAgICAgICAgICAgKiBvciBhIHR5cGUgZGV0ZWN0aW9uIHBsdWctaW4pLCB5b3Ugd2lsbCB0eXBpY2FsbHkgYmUgdXNpbmcgdGhpcyBmb3JcbiAgICAgICAgICAgICAgICAgKiBjdXN0b20gc29ydGluZywgYnV0IGl0IGNhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBjdXN0b20gc2VhcmNoaW5nXG4gICAgICAgICAgICAgICAgICogYnkgYWxsb3dpbmcgeW91IHRvIHByZS1wcm9jZXNzaW5nIHRoZSBkYXRhIGFuZCByZXR1cm5pbmcgdGhlIGRhdGEgaW5cbiAgICAgICAgICAgICAgICAgKiB0aGUgZm9ybWF0IHRoYXQgc2hvdWxkIGJlIHNlYXJjaGVkIHVwb24uIFRoaXMgaXMgZG9uZSBieSBhZGRpbmdcbiAgICAgICAgICAgICAgICAgKiBmdW5jdGlvbnMgdGhpcyBvYmplY3Qgd2l0aCBhIHBhcmFtZXRlciBuYW1lIHdoaWNoIG1hdGNoZXMgdGhlIHNUeXBlXG4gICAgICAgICAgICAgICAgICogZm9yIHRoYXQgdGFyZ2V0IGNvbHVtbi4gVGhpcyBpcyB0aGUgY29yb2xsYXJ5IG9mIDxpPmFmblNvcnREYXRhPC9pPlxuICAgICAgICAgICAgICAgICAqIGZvciBzZWFyY2hpbmcgZGF0YS5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCB0YWtlIGEgc2luZ2xlIHBhcmFtZXRlcjpcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICAxLiBgeyp9YCBEYXRhIGZyb20gdGhlIGNvbHVtbiBjZWxsIHRvIGJlIHByZXBhcmVkIGZvciBzZWFyY2hpbmdcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhwZWN0ZWQgdG8gcmV0dXJuOlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogKiBge3N0cmluZ3xudWxsfWAgRm9ybWF0dGVkIHN0cmluZyB0aGF0IHdpbGwgYmUgdXNlZCBmb3IgdGhlIHNlYXJjaGluZy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgKiAgQGRlZmF1bHQge31cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgICQuZm4uZGF0YVRhYmxlLmV4dC50eXBlLnNlYXJjaFsndGl0bGUtbnVtZXJpYyddID0gZnVuY3Rpb24gKCBkICkge1xuICAgICAgICAgICAgICAgICAqICAgICAgcmV0dXJuIGQucmVwbGFjZSgvXFxuL2csXCIgXCIpLnJlcGxhY2UoIC88Lio/Pi9nLCBcIlwiICk7XG4gICAgICAgICAgICAgICAgICogICAgfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHNlYXJjaDoge30sXG5cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFR5cGUgYmFzZWQgb3JkZXJpbmcuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGUgY29sdW1uIHR5cGUgdGVsbHMgRGF0YVRhYmxlcyB3aGF0IG9yZGVyaW5nIHRvIGFwcGx5IHRvIHRoZSB0YWJsZVxuICAgICAgICAgICAgICAgICAqIHdoZW4gYSBjb2x1bW4gaXMgc29ydGVkIHVwb24uIFRoZSBvcmRlciBmb3IgZWFjaCB0eXBlIHRoYXQgaXMgZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgKiBpcyBkZWZpbmVkIGJ5IHRoZSBmdW5jdGlvbnMgYXZhaWxhYmxlIGluIHRoaXMgb2JqZWN0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogRWFjaCBvcmRlcmluZyBvcHRpb24gY2FuIGJlIGRlc2NyaWJlZCBieSB0aHJlZSBwcm9wZXJ0aWVzIGFkZGVkIHRvXG4gICAgICAgICAgICAgICAgICogdGhpcyBvYmplY3Q6XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAqIGB7dHlwZX0tcHJlYCAtIFByZS1mb3JtYXR0aW5nIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICogKiBge3R5cGV9LWFzY2AgLSBBc2NlbmRpbmcgb3JkZXIgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgKiAqIGB7dHlwZX0tZGVzY2AgLSBEZXNjZW5kaW5nIG9yZGVyIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBBbGwgdGhyZWUgY2FuIGJlIHVzZWQgdG9nZXRoZXIsIG9ubHkgYHt0eXBlfS1wcmVgIG9yIG9ubHlcbiAgICAgICAgICAgICAgICAgKiBge3R5cGV9LWFzY2AgYW5kIGB7dHlwZX0tZGVzY2AgdG9nZXRoZXIuIEl0IGlzIGdlbmVyYWxseSByZWNvbW1lbmRlZFxuICAgICAgICAgICAgICAgICAqIHRoYXQgb25seSBge3R5cGV9LXByZWAgaXMgdXNlZCwgYXMgdGhpcyBwcm92aWRlcyB0aGUgb3B0aW1hbFxuICAgICAgICAgICAgICAgICAqIGltcGxlbWVudGF0aW9uIGluIHRlcm1zIG9mIHNwZWVkLCBhbHRob3VnaCB0aGUgb3RoZXJzIGFyZSBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAqIGZvciBjb21wYXRpYmlsaXR5IHdpdGggZXhpc3RpbmcgSmF2YXNjcmlwdCBzb3J0IGZ1bmN0aW9ucy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIGB7dHlwZX0tcHJlYDogRnVuY3Rpb25zIGRlZmluZWQgdGFrZSBhIHNpbmdsZSBwYXJhbWV0ZXI6XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAgMS4gYHsqfWAgRGF0YSBmcm9tIHRoZSBjb2x1bW4gY2VsbCB0byBiZSBwcmVwYXJlZCBmb3Igb3JkZXJpbmdcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEFuZCByZXR1cm46XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiAqIGB7Kn1gIERhdGEgdG8gYmUgc29ydGVkIHVwb25cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIGB7dHlwZX0tYXNjYCBhbmQgYHt0eXBlfS1kZXNjYDogRnVuY3Rpb25zIGFyZSB0eXBpY2FsIEphdmFzY3JpcHQgc29ydFxuICAgICAgICAgICAgICAgICAqIGZ1bmN0aW9ucywgdGFraW5nIHR3byBwYXJhbWV0ZXJzOlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIDEuIGB7Kn1gIERhdGEgdG8gY29tcGFyZSB0byB0aGUgc2Vjb25kIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAqICAyLiBgeyp9YCBEYXRhIHRvIGNvbXBhcmUgdG8gdGhlIGZpcnN0IHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQW5kIHJldHVybmluZzpcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICogYHsqfWAgT3JkZXJpbmcgbWF0Y2g6IDwwIGlmIGZpcnN0IHBhcmFtZXRlciBzaG91bGQgYmUgc29ydGVkIGxvd2VyXG4gICAgICAgICAgICAgICAgICogICB0aGFuIHRoZSBzZWNvbmQgcGFyYW1ldGVyLCA9PT0wIGlmIHRoZSB0d28gcGFyYW1ldGVycyBhcmUgZXF1YWwgYW5kXG4gICAgICAgICAgICAgICAgICogICA+MCBpZiB0aGUgZmlyc3QgcGFyYW1ldGVyIHNob3VsZCBiZSBzb3J0ZWQgaGVpZ2h0IHRoYW4gdGhlIHNlY29uZFxuICAgICAgICAgICAgICAgICAqICAgcGFyYW1ldGVyLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEB0eXBlIG9iamVjdFxuICAgICAgICAgICAgICAgICAqICBAZGVmYXVsdCB7fVxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogIEBleGFtcGxlXG4gICAgICAgICAgICAgICAgICogICAgLy8gTnVtZXJpYyBvcmRlcmluZyBvZiBmb3JtYXR0ZWQgbnVtYmVycyB3aXRoIGEgcHJlLWZvcm1hdHRlclxuICAgICAgICAgICAgICAgICAqICAgICQuZXh0ZW5kKCAkLmZuLmRhdGFUYWJsZS5leHQudHlwZS5vcmRlciwge1xuICAgICAgICAgICAgICAgICAqICAgICAgXCJzdHJpbmctcHJlXCI6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgYSA9IChhID09PSBcIi1cIiB8fCBhID09PSBcIlwiKSA/IDAgOiBhLnJlcGxhY2UoIC9bXlxcZFxcLVxcLl0vZywgXCJcIiApO1xuICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCggYSApO1xuICAgICAgICAgICAgICAgICAqICAgICAgfVxuICAgICAgICAgICAgICAgICAqICAgIH0gKTtcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgICAgICAgICAqICAgIC8vIENhc2Utc2Vuc2l0aXZlIHN0cmluZyBvcmRlcmluZywgd2l0aCBubyBwcmUtZm9ybWF0dGluZyBtZXRob2RcbiAgICAgICAgICAgICAgICAgKiAgICAkLmV4dGVuZCggJC5mbi5kYXRhVGFibGUuZXh0Lm9yZGVyLCB7XG4gICAgICAgICAgICAgICAgICogICAgICBcInN0cmluZy1jYXNlLWFzY1wiOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgcmV0dXJuICgoeCA8IHkpID8gLTEgOiAoKHggPiB5KSA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgICogICAgICB9LFxuICAgICAgICAgICAgICAgICAqICAgICAgXCJzdHJpbmctY2FzZS1kZXNjXCI6IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgICAgICAqICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcbiAgICAgICAgICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICAgICAgICAgKiAgICB9ICk7XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgb3JkZXI6IHt9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVuaXF1ZSBEYXRhVGFibGVzIGluc3RhbmNlIGNvdW50ZXJcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAdHlwZSBpbnRcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIF91bmlxdWU6IDAsXG5cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIERlcHJlY2lhdGVkXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJsaXR5IG9ubHkuXG4gICAgICAgICAgICAvLyBUaGUgc2hvdWxkIG5vdCBiZSB1c2VkIGluIG5ldyBwcm9qZWN0cyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlXG4gICAgICAgICAgICAvLyB2ZXJzaW9uXG4gICAgICAgICAgICAvL1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlcnNpb24gY2hlY2sgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKiAgQHR5cGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAqICBAZGVwcmVjaWF0ZWQgU2luY2UgMS4xMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmblZlcnNpb25DaGVjazogRGF0YVRhYmxlLmZuVmVyc2lvbkNoZWNrLFxuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5kZXggZm9yIHdoYXQgJ3RoaXMnIGluZGV4IEFQSSBmdW5jdGlvbnMgc2hvdWxkIHVzZVxuICAgICAgICAgICAgICogIEB0eXBlIGludFxuICAgICAgICAgICAgICogIEBkZXByZWNhdGVkIFNpbmNlIHYxLjEwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlBcGlJbmRleDogMCxcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGpRdWVyeSBVSSBjbGFzcyBjb250YWluZXJcbiAgICAgICAgICAgICAqICBAdHlwZSBvYmplY3RcbiAgICAgICAgICAgICAqICBAZGVwcmVjYXRlZCBTaW5jZSB2MS4xMFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvSlVJQ2xhc3Nlczoge30sXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb2Z0d2FyZSB2ZXJzaW9uXG4gICAgICAgICAgICAgKiAgQHR5cGUgc3RyaW5nXG4gICAgICAgICAgICAgKiAgQGRlcHJlY2F0ZWQgU2luY2UgdjEuMTBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc1ZlcnNpb246IERhdGFUYWJsZS52ZXJzaW9uXG4gICAgICAgIH07XG5cblxuICAgICAgICAvL1xuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gQWxpYXMgdG8gcHJlIDEuMTAgSHVuZ2FyaWFuIG5vdGF0aW9uIGNvdW50ZXIgcGFydHNcbiAgICAgICAgLy9cbiAgICAgICAgJC5leHRlbmQoX2V4dCwge1xuICAgICAgICAgICAgYWZuRmlsdGVyaW5nOiBfZXh0LnNlYXJjaCxcbiAgICAgICAgICAgIGFUeXBlczogX2V4dC50eXBlLmRldGVjdCxcbiAgICAgICAgICAgIG9mblNlYXJjaDogX2V4dC50eXBlLnNlYXJjaCxcbiAgICAgICAgICAgIG9Tb3J0OiBfZXh0LnR5cGUub3JkZXIsXG4gICAgICAgICAgICBhZm5Tb3J0RGF0YTogX2V4dC5vcmRlcixcbiAgICAgICAgICAgIGFvRmVhdHVyZXM6IF9leHQuZmVhdHVyZSxcbiAgICAgICAgICAgIG9BcGk6IF9leHQuaW50ZXJuYWwsXG4gICAgICAgICAgICBvU3RkQ2xhc3NlczogX2V4dC5jbGFzc2VzLFxuICAgICAgICAgICAgb1BhZ2luYXRpb246IF9leHQucGFnZXJcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LmNsYXNzZXMsIHtcbiAgICAgICAgICAgIFwic1RhYmxlXCI6IFwiZGF0YVRhYmxlXCIsXG4gICAgICAgICAgICBcInNOb0Zvb3RlclwiOiBcIm5vLWZvb3RlclwiLFxuXG4gICAgICAgICAgICAvKiBQYWdpbmcgYnV0dG9ucyAqL1xuICAgICAgICAgICAgXCJzUGFnZUJ1dHRvblwiOiBcInBhZ2luYXRlX2J1dHRvblwiLFxuICAgICAgICAgICAgXCJzUGFnZUJ1dHRvbkFjdGl2ZVwiOiBcImN1cnJlbnRcIixcbiAgICAgICAgICAgIFwic1BhZ2VCdXR0b25EaXNhYmxlZFwiOiBcImRpc2FibGVkXCIsXG5cbiAgICAgICAgICAgIC8qIFN0cmlwaW5nIGNsYXNzZXMgKi9cbiAgICAgICAgICAgIFwic1N0cmlwZU9kZFwiOiBcIm9kZFwiLFxuICAgICAgICAgICAgXCJzU3RyaXBlRXZlblwiOiBcImV2ZW5cIixcblxuICAgICAgICAgICAgLyogRW1wdHkgcm93ICovXG4gICAgICAgICAgICBcInNSb3dFbXB0eVwiOiBcImRhdGFUYWJsZXNfZW1wdHlcIixcblxuICAgICAgICAgICAgLyogRmVhdHVyZXMgKi9cbiAgICAgICAgICAgIFwic1dyYXBwZXJcIjogXCJkYXRhVGFibGVzX3dyYXBwZXJcIixcbiAgICAgICAgICAgIFwic0ZpbHRlclwiOiBcImRhdGFUYWJsZXNfZmlsdGVyXCIsXG4gICAgICAgICAgICBcInNJbmZvXCI6IFwiZGF0YVRhYmxlc19pbmZvXCIsXG4gICAgICAgICAgICBcInNQYWdpbmdcIjogXCJkYXRhVGFibGVzX3BhZ2luYXRlIHBhZ2luZ19cIiwgLyogTm90ZSB0aGF0IHRoZSB0eXBlIGlzIHBvc3RmaXhlZCAqL1xuICAgICAgICAgICAgXCJzTGVuZ3RoXCI6IFwiZGF0YVRhYmxlc19sZW5ndGhcIixcbiAgICAgICAgICAgIFwic1Byb2Nlc3NpbmdcIjogXCJkYXRhVGFibGVzX3Byb2Nlc3NpbmdcIixcblxuICAgICAgICAgICAgLyogU29ydGluZyAqL1xuICAgICAgICAgICAgXCJzU29ydEFzY1wiOiBcInNvcnRpbmdfYXNjXCIsXG4gICAgICAgICAgICBcInNTb3J0RGVzY1wiOiBcInNvcnRpbmdfZGVzY1wiLFxuICAgICAgICAgICAgXCJzU29ydGFibGVcIjogXCJzb3J0aW5nXCIsIC8qIFNvcnRhYmxlIGluIGJvdGggZGlyZWN0aW9ucyAqL1xuICAgICAgICAgICAgXCJzU29ydGFibGVBc2NcIjogXCJzb3J0aW5nX2FzY19kaXNhYmxlZFwiLFxuICAgICAgICAgICAgXCJzU29ydGFibGVEZXNjXCI6IFwic29ydGluZ19kZXNjX2Rpc2FibGVkXCIsXG4gICAgICAgICAgICBcInNTb3J0YWJsZU5vbmVcIjogXCJzb3J0aW5nX2Rpc2FibGVkXCIsXG4gICAgICAgICAgICBcInNTb3J0Q29sdW1uXCI6IFwic29ydGluZ19cIiwgLyogTm90ZSB0aGF0IGFuIGludCBpcyBwb3N0Zml4ZWQgZm9yIHRoZSBzb3J0aW5nIG9yZGVyICovXG5cbiAgICAgICAgICAgIC8qIEZpbHRlcmluZyAqL1xuICAgICAgICAgICAgXCJzRmlsdGVySW5wdXRcIjogXCJcIixcblxuICAgICAgICAgICAgLyogUGFnZSBsZW5ndGggKi9cbiAgICAgICAgICAgIFwic0xlbmd0aFNlbGVjdFwiOiBcIlwiLFxuXG4gICAgICAgICAgICAvKiBTY3JvbGxpbmcgKi9cbiAgICAgICAgICAgIFwic1Njcm9sbFdyYXBwZXJcIjogXCJkYXRhVGFibGVzX3Njcm9sbFwiLFxuICAgICAgICAgICAgXCJzU2Nyb2xsSGVhZFwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsSGVhZFwiLFxuICAgICAgICAgICAgXCJzU2Nyb2xsSGVhZElubmVyXCI6IFwiZGF0YVRhYmxlc19zY3JvbGxIZWFkSW5uZXJcIixcbiAgICAgICAgICAgIFwic1Njcm9sbEJvZHlcIjogXCJkYXRhVGFibGVzX3Njcm9sbEJvZHlcIixcbiAgICAgICAgICAgIFwic1Njcm9sbEZvb3RcIjogXCJkYXRhVGFibGVzX3Njcm9sbEZvb3RcIixcbiAgICAgICAgICAgIFwic1Njcm9sbEZvb3RJbm5lclwiOiBcImRhdGFUYWJsZXNfc2Nyb2xsRm9vdElubmVyXCIsXG5cbiAgICAgICAgICAgIC8qIE1pc2MgKi9cbiAgICAgICAgICAgIFwic0hlYWRlclRIXCI6IFwiXCIsXG4gICAgICAgICAgICBcInNGb290ZXJUSFwiOiBcIlwiLFxuXG4gICAgICAgICAgICAvLyBEZXByZWNhdGVkXG4gICAgICAgICAgICBcInNTb3J0SlVJQXNjXCI6IFwiXCIsXG4gICAgICAgICAgICBcInNTb3J0SlVJRGVzY1wiOiBcIlwiLFxuICAgICAgICAgICAgXCJzU29ydEpVSVwiOiBcIlwiLFxuICAgICAgICAgICAgXCJzU29ydEpVSUFzY0FsbG93ZWRcIjogXCJcIixcbiAgICAgICAgICAgIFwic1NvcnRKVUlEZXNjQWxsb3dlZFwiOiBcIlwiLFxuICAgICAgICAgICAgXCJzU29ydEpVSVdyYXBwZXJcIjogXCJcIixcbiAgICAgICAgICAgIFwic1NvcnRJY29uXCI6IFwiXCIsXG4gICAgICAgICAgICBcInNKVUlIZWFkZXJcIjogXCJcIixcbiAgICAgICAgICAgIFwic0pVSUZvb3RlclwiOiBcIlwiXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgdmFyIGV4dFBhZ2luYXRpb24gPSBEYXRhVGFibGUuZXh0LnBhZ2VyO1xuXG4gICAgICAgIGZ1bmN0aW9uIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBudW1iZXJzID0gW10sXG4gICAgICAgICAgICAgICAgYnV0dG9ucyA9IGV4dFBhZ2luYXRpb24ubnVtYmVyc19sZW5ndGgsXG4gICAgICAgICAgICAgICAgaGFsZiA9IE1hdGguZmxvb3IoYnV0dG9ucyAvIDIpLFxuICAgICAgICAgICAgICAgIGkgPSAxO1xuXG4gICAgICAgICAgICBpZiAocGFnZXMgPD0gYnV0dG9ucykge1xuICAgICAgICAgICAgICAgIG51bWJlcnMgPSBfcmFuZ2UoMCwgcGFnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFnZSA8PSBoYWxmKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVycyA9IF9yYW5nZSgwLCBidXR0b25zIC0gMik7XG4gICAgICAgICAgICAgICAgbnVtYmVycy5wdXNoKCdlbGxpcHNpcycpO1xuICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaChwYWdlcyAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFnZSA+PSBwYWdlcyAtIDEgLSBoYWxmKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVycyA9IF9yYW5nZShwYWdlcyAtIChidXR0b25zIC0gMiksIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAnZWxsaXBzaXMnKTsgLy8gbm8gdW5zaGlmdCBpbiBpZTZcbiAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bWJlcnMgPSBfcmFuZ2UocGFnZSAtIGhhbGYgKyAyLCBwYWdlICsgaGFsZiAtIDEpO1xuICAgICAgICAgICAgICAgIG51bWJlcnMucHVzaCgnZWxsaXBzaXMnKTtcbiAgICAgICAgICAgICAgICBudW1iZXJzLnB1c2gocGFnZXMgLSAxKTtcbiAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAnZWxsaXBzaXMnKTtcbiAgICAgICAgICAgICAgICBudW1iZXJzLnNwbGljZSgwLCAwLCAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbnVtYmVycy5EVF9lbCA9ICdzcGFuJztcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJzO1xuICAgICAgICB9XG5cblxuICAgICAgICAkLmV4dGVuZChleHRQYWdpbmF0aW9uLCB7XG4gICAgICAgICAgICBzaW1wbGU6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ3ByZXZpb3VzJywgJ25leHQnXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGZ1bGw6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ2ZpcnN0JywgJ3ByZXZpb3VzJywgJ25leHQnLCAnbGFzdCddO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbnVtYmVyczogZnVuY3Rpb24gKHBhZ2UsIHBhZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtfbnVtYmVycyhwYWdlLCBwYWdlcyldO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2ltcGxlX251bWJlcnM6IGZ1bmN0aW9uIChwYWdlLCBwYWdlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbJ3ByZXZpb3VzJywgX251bWJlcnMocGFnZSwgcGFnZXMpLCAnbmV4dCddO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZnVsbF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmaXJzdCcsICdwcmV2aW91cycsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ25leHQnLCAnbGFzdCddO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmlyc3RfbGFzdF9udW1iZXJzOiBmdW5jdGlvbiAocGFnZSwgcGFnZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydmaXJzdCcsIF9udW1iZXJzKHBhZ2UsIHBhZ2VzKSwgJ2xhc3QnXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEZvciB0ZXN0aW5nIGFuZCBwbHVnLWlucyB0byB1c2VcbiAgICAgICAgICAgIF9udW1iZXJzOiBfbnVtYmVycyxcblxuICAgICAgICAgICAgLy8gTnVtYmVyIG9mIG51bWJlciBidXR0b25zIChpbmNsdWRpbmcgZWxsaXBzaXMpIHRvIHNob3cuIF9NdXN0IGJlIG9kZCFfXG4gICAgICAgICAgICBudW1iZXJzX2xlbmd0aDogN1xuICAgICAgICB9KTtcblxuXG4gICAgICAgICQuZXh0ZW5kKHRydWUsIERhdGFUYWJsZS5leHQucmVuZGVyZXIsIHtcbiAgICAgICAgICAgIHBhZ2VCdXR0b246IHtcbiAgICAgICAgICAgICAgICBfOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGhvc3QsIGlkeCwgYnV0dG9ucywgcGFnZSwgcGFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzZXMgPSBzZXR0aW5ncy5vQ2xhc3NlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmcgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uub1BhZ2luYXRlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXJpYSA9IHNldHRpbmdzLm9MYW5ndWFnZS5vQXJpYS5wYWdpbmF0ZSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ0bkRpc3BsYXksIGJ0bkNsYXNzLCBjb3VudGVyID0gMDtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0YWNoID0gZnVuY3Rpb24gKGNvbnRhaW5lciwgYnV0dG9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGllbiwgbm9kZSwgYnV0dG9uLCB0YWJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXNhYmxlZENsYXNzID0gY2xhc3Nlcy5zUGFnZUJ1dHRvbkRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2ZuUGFnZUNoYW5nZShzZXR0aW5ncywgZS5kYXRhLmFjdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBpZW4gPSBidXR0b25zLmxlbmd0aDsgaSA8IGllbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1dHRvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlubmVyID0gJCgnPCcgKyAoYnV0dG9uLkRUX2VsIHx8ICdkaXYnKSArICcvPicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXBwZW5kVG8oY29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoKGlubmVyLCBidXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IHNldHRpbmdzLmlUYWJJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZWxsaXBzaXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmQoJzxzcGFuIGNsYXNzPVwiZWxsaXBzaXNcIj4mI3gyMDI2Ozwvc3Bhbj4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmlyc3QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNGaXJzdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYWdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcmV2aW91cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IGxhbmcuc1ByZXZpb3VzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFiSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuQ2xhc3MgKz0gJyAnICsgZGlzYWJsZWRDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBsYW5nLnNOZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhZ2VzID09PSAwIHx8IHBhZ2UgPT09IHBhZ2VzIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWJJbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyArPSAnICcgKyBkaXNhYmxlZENsYXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGFzdCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnRuRGlzcGxheSA9IGxhbmcuc0xhc3Q7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFnZXMgPT09IDAgfHwgcGFnZSA9PT0gcGFnZXMgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkNsYXNzICs9ICcgJyArIGRpc2FibGVkQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0bkRpc3BsYXkgPSBzZXR0aW5ncy5mbkZvcm1hdE51bWJlcihidXR0b24gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidG5DbGFzcyA9IHBhZ2UgPT09IGJ1dHRvbiA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1BhZ2VCdXR0b25BY3RpdmUgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidG5EaXNwbGF5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gJCgnPGE+Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjbGFzcyc6IGNsYXNzZXMuc1BhZ2VCdXR0b24gKyAnICcgKyBidG5DbGFzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IHNldHRpbmdzLnNUYWJsZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogYXJpYVtidXR0b25dLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLWR0LWlkeCc6IGNvdW50ZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3RhYmluZGV4JzogdGFiSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2lkJzogaWR4ID09PSAwICYmIHR5cGVvZiBidXR0b24gPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3Muc1RhYmxlSWQgKyAnXycgKyBidXR0b24gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5odG1sKGJ0bkRpc3BsYXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZFRvKGNvbnRhaW5lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mbkJpbmRBY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSwgeyBhY3Rpb246IGJ1dHRvbiB9LCBjbGlja0hhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJRTkgdGhyb3dzIGFuICd1bmtub3duIGVycm9yJyBpZiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5zaWRlIGFuIGlmcmFtZSBvciBmcmFtZS4gVHJ5IC8gY2F0Y2ggdGhlIGVycm9yLiBOb3QgZ29vZCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gYWNjZXNzaWJpbGl0eSwgYnV0IG5laXRoZXIgYXJlIGZyYW1lcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUVsO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIHRoaXMgYXBwcm9hY2ggaXMgZGVzdHJveWluZyBhbmQgcmVjcmVhdGluZyB0aGUgcGFnaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50cywgZm9jdXMgaXMgbG9zdCBvbiB0aGUgc2VsZWN0IGJ1dHRvbiB3aGljaCBpcyBiYWQgZm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY2Nlc3NpYmlsaXR5LiBTbyB3ZSB3YW50IHRvIHJlc3RvcmUgZm9jdXMgb25jZSB0aGUgZHJhdyBoYXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBsZXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlRWwgPSAkKGhvc3QpLmZpbmQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuZGF0YSgnZHQtaWR4Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaCgkKGhvc3QpLmVtcHR5KCksIGJ1dHRvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkKGhvc3QpLmZpbmQoJ1tkYXRhLWR0LWlkeD0nICsgYWN0aXZlRWwgKyAnXScpLnRyaWdnZXIoJ2ZvY3VzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG5cblxuICAgICAgICAvLyBCdWlsdCBpbiB0eXBlIGRldGVjdGlvbi4gU2VlIG1vZGVsLmV4dC5hVHlwZXMgZm9yIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICAgIC8vIHdoYXQgaXMgcmVxdWlyZWQgZnJvbSB0aGlzIG1ldGhvZHMuXG4gICAgICAgICQuZXh0ZW5kKERhdGFUYWJsZS5leHQudHlwZS5kZXRlY3QsIFtcbiAgICAgICAgICAgIC8vIFBsYWluIG51bWJlcnMgLSBmaXJzdCBzaW5jZSBWOCBkZXRlY3RzIHNvbWUgcGxhaW4gbnVtYmVycyBhcyBkYXRlc1xuICAgICAgICAgICAgLy8gZS5nLiBEYXRlLnBhcnNlKCc1NScpIChidXQgbm90IGFsbCwgZS5nLiBEYXRlLnBhcnNlKCcyMicpLi4uKS5cbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXNOdW1iZXIoZCwgZGVjaW1hbCkgPyAnbnVtJyArIGRlY2ltYWwgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRGF0ZXMgKG9ubHkgdGhvc2UgcmVjb2duaXNlZCBieSB0aGUgYnJvd3NlcidzIERhdGUucGFyc2UpXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBWOCB0cmllcyBfdmVyeV8gaGFyZCB0byBtYWtlIGEgc3RyaW5nIHBhc3NlZCBpbnRvIGBEYXRlLnBhcnNlKClgXG4gICAgICAgICAgICAgICAgLy8gdmFsaWQsIHNvIHdlIG5lZWQgdG8gdXNlIGEgcmVnZXggdG8gcmVzdHJpY3QgZGF0ZSBmb3JtYXRzLiBVc2UgYVxuICAgICAgICAgICAgICAgIC8vIHBsdWctaW4gZm9yIGFueXRoaW5nIG90aGVyIHRoYW4gSVNPODYwMSBzdHlsZSBzdHJpbmdzXG4gICAgICAgICAgICAgICAgaWYgKGQgJiYgIShkIGluc3RhbmNlb2YgRGF0ZSkgJiYgIV9yZV9kYXRlLnRlc3QoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBEYXRlLnBhcnNlKGQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAocGFyc2VkICE9PSBudWxsICYmICFpc05hTihwYXJzZWQpKSB8fCBfZW1wdHkoZCkgPyAnZGF0ZScgOiBudWxsO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gRm9ybWF0dGVkIG51bWJlcnNcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBzZXR0aW5ncykge1xuICAgICAgICAgICAgICAgIHZhciBkZWNpbWFsID0gc2V0dGluZ3Mub0xhbmd1YWdlLnNEZWNpbWFsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfaXNOdW1iZXIoZCwgZGVjaW1hbCwgdHJ1ZSkgPyAnbnVtLWZtdCcgKyBkZWNpbWFsIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpY1xuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY2ltYWwgPSBzZXR0aW5ncy5vTGFuZ3VhZ2Uuc0RlY2ltYWw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9odG1sTnVtZXJpYyhkLCBkZWNpbWFsKSA/ICdodG1sLW51bScgKyBkZWNpbWFsIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEhUTUwgbnVtZXJpYywgZm9ybWF0dGVkXG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgc2V0dGluZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVjaW1hbCA9IHNldHRpbmdzLm9MYW5ndWFnZS5zRGVjaW1hbDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2h0bWxOdW1lcmljKGQsIGRlY2ltYWwsIHRydWUpID8gJ2h0bWwtbnVtLWZtdCcgKyBkZWNpbWFsIDogbnVsbDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIEhUTUwgKHRoaXMgaXMgc3RyaWN0IGNoZWNraW5nIC0gdGhlcmUgbXVzdCBiZSBodG1sKVxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eShkKSB8fCAodHlwZW9mIGQgPT09ICdzdHJpbmcnICYmIGQuaW5kZXhPZignPCcpICE9PSAtMSkgP1xuICAgICAgICAgICAgICAgICAgICAnaHRtbCcgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICBdKTtcblxuXG5cbiAgICAgICAgLy8gRmlsdGVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zLiBTZWUgbW9kZWwuZXh0Lm9mblNlYXJjaCBmb3IgaW5mb3JtYXRpb24gYWJvdXRcbiAgICAgICAgLy8gd2hhdCBpcyByZXF1aXJlZCBmcm9tIHRoZXNlIG1ldGhvZHMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGUgdGhhdCBhZGRpdGlvbmFsIHNlYXJjaCBtZXRob2RzIGFyZSBhZGRlZCBmb3IgdGhlIGh0bWwgbnVtYmVycyBhbmRcbiAgICAgICAgLy8gaHRtbCBmb3JtYXR0ZWQgbnVtYmVycyBieSBgX2FkZE51bWVyaWNTb3J0KClgIHdoZW4gd2Uga25vdyB3aGF0IHRoZSBkZWNpbWFsXG4gICAgICAgIC8vIHBsYWNlIGlzXG5cblxuICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LnR5cGUuc2VhcmNoLCB7XG4gICAgICAgICAgICBodG1sOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoZGF0YSkgP1xuICAgICAgICAgICAgICAgICAgICBkYXRhIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShfcmVfbmV3X2xpbmVzLCBcIiBcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShfcmVfaHRtbCwgXCJcIikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdHJpbmc6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eShkYXRhKSA/XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgOlxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5yZXBsYWNlKF9yZV9uZXdfbGluZXMsIFwiIFwiKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG5cbiAgICAgICAgdmFyIF9fbnVtZXJpY1JlcGxhY2UgPSBmdW5jdGlvbiAoZCwgZGVjaW1hbFBsYWNlLCByZTEsIHJlMikge1xuICAgICAgICAgICAgaWYgKGQgIT09IDAgJiYgKCFkIHx8IGQgPT09ICctJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLUluZmluaXR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBhIGRlY2ltYWwgcGxhY2Ugb3RoZXIgdGhhbiBgLmAgaXMgdXNlZCwgaXQgbmVlZHMgdG8gYmUgZ2l2ZW4gdG8gdGhlXG4gICAgICAgICAgICAvLyBmdW5jdGlvbiBzbyB3ZSBjYW4gZGV0ZWN0IGl0IGFuZCByZXBsYWNlIHdpdGggYSBgLmAgd2hpY2ggaXMgdGhlIG9ubHlcbiAgICAgICAgICAgIC8vIGRlY2ltYWwgcGxhY2UgSmF2YXNjcmlwdCByZWNvZ25pc2VzIC0gaXQgaXMgbm90IGxvY2FsZSBhd2FyZS5cbiAgICAgICAgICAgIGlmIChkZWNpbWFsUGxhY2UpIHtcbiAgICAgICAgICAgICAgICBkID0gX251bVRvRGVjaW1hbChkLCBkZWNpbWFsUGxhY2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZC5yZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlMSkge1xuICAgICAgICAgICAgICAgICAgICBkID0gZC5yZXBsYWNlKHJlMSwgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGQucmVwbGFjZShyZTIsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBkICogMTtcbiAgICAgICAgfTtcblxuXG4gICAgICAgIC8vIEFkZCB0aGUgbnVtZXJpYyAnZGVmb3JtYXR0aW5nJyBmdW5jdGlvbnMgZm9yIHNvcnRpbmcgYW5kIHNlYXJjaC4gVGhpcyBpcyBkb25lXG4gICAgICAgIC8vIGluIGEgZnVuY3Rpb24gdG8gcHJvdmlkZSBhbiBlYXN5IGFiaWxpdHkgZm9yIHRoZSBsYW5ndWFnZSBvcHRpb25zIHRvIGFkZFxuICAgICAgICAvLyBhZGRpdGlvbmFsIG1ldGhvZHMgaWYgYSBub24tcGVyaW9kIGRlY2ltYWwgcGxhY2UgaXMgdXNlZC5cbiAgICAgICAgZnVuY3Rpb24gX2FkZE51bWVyaWNTb3J0KGRlY2ltYWxQbGFjZSkge1xuICAgICAgICAgICAgJC5lYWNoKFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhaW4gbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICBcIm51bVwiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoZCwgZGVjaW1hbFBsYWNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBGb3JtYXR0ZWQgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICBcIm51bS1mbXRcIjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX251bWVyaWNSZXBsYWNlKGQsIGRlY2ltYWxQbGFjZSwgX3JlX2Zvcm1hdHRlZF9udW1lcmljKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgICAgICAvLyBIVE1MIG51bWVyaWNcbiAgICAgICAgICAgICAgICAgICAgXCJodG1sLW51bVwiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fbnVtZXJpY1JlcGxhY2UoZCwgZGVjaW1hbFBsYWNlLCBfcmVfaHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSFRNTCBudW1lcmljLCBmb3JtYXR0ZWRcbiAgICAgICAgICAgICAgICAgICAgXCJodG1sLW51bS1mbXRcIjogZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX251bWVyaWNSZXBsYWNlKGQsIGRlY2ltYWxQbGFjZSwgX3JlX2h0bWwsIF9yZV9mb3JtYXR0ZWRfbnVtZXJpYyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChrZXksIGZuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgb3JkZXJpbmcgbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIF9leHQudHlwZS5vcmRlcltrZXkgKyBkZWNpbWFsUGxhY2UgKyAnLXByZSddID0gZm47XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIEhUTUwgdHlwZXMgYWRkIGEgc2VhcmNoIGZvcm1hdHRlciB0aGF0IHdpbGwgc3RyaXAgdGhlIEhUTUxcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5tYXRjaCgvXmh0bWxcXC0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V4dC50eXBlLnNlYXJjaFtrZXkgKyBkZWNpbWFsUGxhY2VdID0gX2V4dC50eXBlLnNlYXJjaC5odG1sO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gRGVmYXVsdCBzb3J0IG1ldGhvZHNcbiAgICAgICAgJC5leHRlbmQoX2V4dC50eXBlLm9yZGVyLCB7XG4gICAgICAgICAgICAvLyBEYXRlc1xuICAgICAgICAgICAgXCJkYXRlLXByZVwiOiBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgIHZhciB0cyA9IERhdGUucGFyc2UoZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTmFOKHRzKSA/IC1JbmZpbml0eSA6IHRzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gaHRtbFxuICAgICAgICAgICAgXCJodG1sLXByZVwiOiBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZW1wdHkoYSkgP1xuICAgICAgICAgICAgICAgICAgICAnJyA6XG4gICAgICAgICAgICAgICAgICAgIGEucmVwbGFjZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBhLnJlcGxhY2UoLzwuKj8+L2csIFwiXCIpLnRvTG93ZXJDYXNlKCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYSArICcnO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gc3RyaW5nXG4gICAgICAgICAgICBcInN0cmluZy1wcmVcIjogZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbGl0dGxlIGNvbXBsZXgsIGJ1dCBmYXN0ZXIgdGhhbiBhbHdheXMgY2FsbGluZyB0b1N0cmluZyxcbiAgICAgICAgICAgICAgICAvLyBodHRwOi8vanNwZXJmLmNvbS90b3N0cmluZy12LWNoZWNrXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9lbXB0eShhKSA/XG4gICAgICAgICAgICAgICAgICAgICcnIDpcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGEgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGEudG9Mb3dlckNhc2UoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAhYS50b1N0cmluZyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIHN0cmluZy1hc2MgYW5kIC1kZXNjIGFyZSByZXRhaW5lZCBvbmx5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggdGhlIG9sZFxuICAgICAgICAgICAgLy8gc29ydCBtZXRob2RzXG4gICAgICAgICAgICBcInN0cmluZy1hc2NcIjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAtMSA6ICgoeCA+IHkpID8gMSA6IDApKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIFwic3RyaW5nLWRlc2NcIjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh4IDwgeSkgPyAxIDogKCh4ID4geSkgPyAtMSA6IDApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBOdW1lcmljIHNvcnRpbmcgdHlwZXMgLSBvcmRlciBkb2Vzbid0IG1hdHRlciBoZXJlXG4gICAgICAgIF9hZGROdW1lcmljU29ydCgnJyk7XG5cblxuICAgICAgICAkLmV4dGVuZCh0cnVlLCBEYXRhVGFibGUuZXh0LnJlbmRlcmVyLCB7XG4gICAgICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICAgICAgICBfOiBmdW5jdGlvbiAoc2V0dGluZ3MsIGNlbGwsIGNvbHVtbiwgY2xhc3Nlcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRpdGlvbmFsIG1hcmstdXAgcmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIGEgc29ydCBsaXN0ZW5lciB0byB1cGRhdGUgb24gc29ydCAtIG5vdGUgdGhhdCB1c2luZyB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYERUYCBuYW1lc3BhY2Ugd2lsbCBhbGxvdyB0aGUgZXZlbnQgdG8gYmUgcmVtb3ZlZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uIGRlc3Ryb3ksIHdoaWxlIHRoZSBgZHRgIG5hbWVzcGFjZWQgZXZlbnQgaXMgdGhlIG9uZSB3ZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIGZvclxuICAgICAgICAgICAgICAgICAgICAkKHNldHRpbmdzLm5UYWJsZSkub24oJ29yZGVyLmR0LkRUJywgZnVuY3Rpb24gKGUsIGN0eCwgc29ydGluZywgY29sdW1ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICE9PSBjdHgpIHsgLy8gbmVlZCB0byBjaGVjayB0aGlzIHRoaXMgaXMgdGhlIGhvc3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47ICAgICAgICAgICAgICAgLy8gdGFibGUsIG5vdCBhIG5lc3RlZCBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zU29ydGluZ0NsYXNzICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEFzYyArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnREZXNjXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0QXNjIDogY29sdW1uc1tjb2xJZHhdID09ICdkZXNjJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0RGVzYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBqcXVlcnl1aTogZnVuY3Rpb24gKHNldHRpbmdzLCBjZWxsLCBjb2x1bW4sIGNsYXNzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnPGRpdi8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjbGFzc2VzLnNTb3J0SlVJV3JhcHBlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmQoY2VsbC5jb250ZW50cygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmFwcGVuZCgkKCc8c3Bhbi8+JylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3MoY2xhc3Nlcy5zU29ydEljb24gKyAnICcgKyBjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5hcHBlbmRUbyhjZWxsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBdHRhY2ggYSBzb3J0IGxpc3RlbmVyIHRvIHVwZGF0ZSBvbiBzb3J0XG4gICAgICAgICAgICAgICAgICAgICQoc2V0dGluZ3MublRhYmxlKS5vbignb3JkZXIuZHQuRFQnLCBmdW5jdGlvbiAoZSwgY3R4LCBzb3J0aW5nLCBjb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MgIT09IGN0eCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbElkeCA9IGNvbHVtbi5pZHg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoY2xhc3Nlcy5zU29ydEFzYyArIFwiIFwiICsgY2xhc3Nlcy5zU29ydERlc2MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKGNvbHVtbnNbY29sSWR4XSA9PSAnYXNjJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRBc2MgOiBjb2x1bW5zW2NvbElkeF0gPT0gJ2Rlc2MnID9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnREZXNjIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbi5zU29ydGluZ0NsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5kKCdzcGFuLicgKyBjbGFzc2VzLnNTb3J0SWNvbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlBc2MgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMuc1NvcnRKVUlEZXNjICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJQXNjQWxsb3dlZCArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5zU29ydEpVSURlc2NBbGxvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGRDbGFzcyhjb2x1bW5zW2NvbElkeF0gPT0gJ2FzYycgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJQXNjIDogY29sdW1uc1tjb2xJZHhdID09ICdkZXNjJyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnNTb3J0SlVJRGVzYyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc1NvcnRpbmdDbGFzc0pVSVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogUHVibGljIGhlbHBlciBmdW5jdGlvbnMuIFRoZXNlIGFyZW4ndCB1c2VkIGludGVybmFsbHkgYnkgRGF0YVRhYmxlcywgb3JcbiAgICAgICAgICogY2FsbGVkIGJ5IGFueSBvZiB0aGUgb3B0aW9ucyBwYXNzZWQgaW50byBEYXRhVGFibGVzLCBidXQgdGhleSBjYW4gYmUgdXNlZFxuICAgICAgICAgKiBleHRlcm5hbGx5IGJ5IGRldmVsb3BlcnMgd29ya2luZyB3aXRoIERhdGFUYWJsZXMuIFRoZXkgYXJlIGhlbHBlciBmdW5jdGlvbnNcbiAgICAgICAgICogdG8gbWFrZSB3b3JraW5nIHdpdGggRGF0YVRhYmxlcyBhIGxpdHRsZSBiaXQgZWFzaWVyLlxuICAgICAgICAgKi9cblxuICAgICAgICB2YXIgX19odG1sRXNjYXBlRW50aXRpZXMgPSBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgZFxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSA6XG4gICAgICAgICAgICAgICAgZDtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGVscGVycyBmb3IgYGNvbHVtbnMucmVuZGVyYC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG9wdGlvbnMgZGVmaW5lZCBoZXJlIGNhbiBiZSB1c2VkIHdpdGggdGhlIGBjb2x1bW5zLnJlbmRlcmAgaW5pdGlhbGlzYXRpb25cbiAgICAgICAgICogb3B0aW9uIHRvIHByb3ZpZGUgYSBkaXNwbGF5IHJlbmRlcmVyLiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBhcmUgZGVmaW5lZDpcbiAgICAgICAgICpcbiAgICAgICAgICogKiBgbnVtYmVyYCAtIFdpbGwgZm9ybWF0IG51bWVyaWMgZGF0YSAoZGVmaW5lZCBieSBgY29sdW1ucy5kYXRhYCkgZm9yXG4gICAgICAgICAqICAgZGlzcGxheSwgcmV0YWluaW5nIHRoZSBvcmlnaW5hbCB1bmZvcm1hdHRlZCBkYXRhIGZvciBzb3J0aW5nIGFuZCBmaWx0ZXJpbmcuXG4gICAgICAgICAqICAgSXQgdGFrZXMgNSBwYXJhbWV0ZXJzOlxuICAgICAgICAgKiAgICogYHN0cmluZ2AgLSBUaG91c2FuZHMgZ3JvdXBpbmcgc2VwYXJhdG9yXG4gICAgICAgICAqICAgKiBgc3RyaW5nYCAtIERlY2ltYWwgcG9pbnQgaW5kaWNhdG9yXG4gICAgICAgICAqICAgKiBgaW50ZWdlcmAgLSBOdW1iZXIgb2YgZGVjaW1hbCBwb2ludHMgdG8gc2hvd1xuICAgICAgICAgKiAgICogYHN0cmluZ2AgKG9wdGlvbmFsKSAtIFByZWZpeC5cbiAgICAgICAgICogICAqIGBzdHJpbmdgIChvcHRpb25hbCkgLSBQb3N0Zml4ICgvc3VmZml4KS5cbiAgICAgICAgICogKiBgdGV4dGAgLSBFc2NhcGUgSFRNTCB0byBoZWxwIHByZXZlbnQgWFNTIGF0dGFja3MuIEl0IGhhcyBubyBvcHRpb25hbFxuICAgICAgICAgKiAgIHBhcmFtZXRlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICAgLy8gQ29sdW1uIGRlZmluaXRpb24gdXNpbmcgdGhlIG51bWJlciByZW5kZXJlclxuICAgICAgICAgKiAgIHtcbiAgICAgICAgICogICAgIGRhdGE6IFwic2FsYXJ5XCIsXG4gICAgICAgICAqICAgICByZW5kZXI6ICQuZm4uZGF0YVRhYmxlLnJlbmRlci5udW1iZXIoICdcXCcnLCAnLicsIDAsICckJyApXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKlxuICAgICAgICAgKiBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICBEYXRhVGFibGUucmVuZGVyID0ge1xuICAgICAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAodGhvdXNhbmRzLCBkZWNpbWFsLCBwcmVjaXNpb24sIHByZWZpeCwgcG9zdGZpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGQgIT09ICdudW1iZXInICYmIHR5cGVvZiBkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVnYXRpdmUgPSBkIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZsbyA9IHBhcnNlRmxvYXQoZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIE5hTiB0aGVuIHRoZXJlIGlzbid0IG11Y2ggZm9ybWF0dGluZyB0aGF0IHdlIGNhbiBkbyAtIGp1c3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJldHVybiBpbW1lZGlhdGVseSwgZXNjYXBpbmcgYW55IEhUTUwgKHRoaXMgd2FzIHN1cHBvc2VkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiZSBhIG51bWJlciBhZnRlciBhbGwpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4oZmxvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2h0bWxFc2NhcGVFbnRpdGllcyhkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgZmxvID0gZmxvLnRvRml4ZWQocHJlY2lzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQgPSBNYXRoLmFicyhmbG8pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW50UGFydCA9IHBhcnNlSW50KGQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmbG9hdFBhcnQgPSBwcmVjaXNpb24gP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWwgKyAoZCAtIGludFBhcnQpLnRvRml4ZWQocHJlY2lzaW9uKS5zdWJzdHJpbmcoMikgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmVnYXRpdmUgKyAocHJlZml4IHx8ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50UGFydC50b1N0cmluZygpLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9cXEIoPz0oXFxkezN9KSsoPyFcXGQpKS9nLCB0aG91c2FuZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbG9hdFBhcnQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb3N0Zml4IHx8ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB0ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogX19odG1sRXNjYXBlRW50aXRpZXMsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogX19odG1sRXNjYXBlRW50aXRpZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyByZWFsbHkgYSBnb29kIGJpdCBydWJiaXNoIHRoaXMgbWV0aG9kIG9mIGV4cG9zaW5nIHRoZSBpbnRlcm5hbCBtZXRob2RzXG4gICAgICAgICAqIHB1YmxpY2x5Li4uIC0gVG8gYmUgZml4ZWQgaW4gMi4wIHVzaW5nIG1ldGhvZHMgb24gdGhlIHByb3RvdHlwZVxuICAgICAgICAgKi9cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGUgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBleHBvcnRpbmcgYW4gaW50ZXJuYWwgZnVuY3Rpb25zIHRvIGFuIGV4dGVybmFsIEFQSS5cbiAgICAgICAgICogIEBwYXJhbSB7c3RyaW5nfSBmbiBBUEkgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgKiAgQHJldHVybnMge2Z1bmN0aW9ufSB3cmFwcGVkIGZ1bmN0aW9uXG4gICAgICAgICAqICBAbWVtYmVyb2YgRGF0YVRhYmxlI2ludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBfZm5FeHRlcm5BcGlGdW5jKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW19mblNldHRpbmdzRnJvbU5vZGUodGhpc1tEYXRhVGFibGUuZXh0LmlBcGlJbmRleF0pXS5jb25jYXQoXG4gICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJldHVybiBEYXRhVGFibGUuZXh0LmludGVybmFsW2ZuXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gaW50ZXJuYWwgZnVuY3Rpb25zIGZvciB1c2UgYnkgcGx1Zy1pbiBkZXZlbG9wZXJzLiBOb3RlIHRoYXRcbiAgICAgICAgICogdGhlc2UgbWV0aG9kcyBhcmUgcmVmZXJlbmNlcyB0byBpbnRlcm5hbCBmdW5jdGlvbnMgYW5kIGFyZSBjb25zaWRlcmVkIHRvIGJlXG4gICAgICAgICAqIHByaXZhdGUuIElmIHlvdSB1c2UgdGhlc2UgbWV0aG9kcywgYmUgYXdhcmUgdGhhdCB0aGV5IGFyZSBsaWFibGUgdG8gY2hhbmdlXG4gICAgICAgICAqIGJldHdlZW4gdmVyc2lvbnMuXG4gICAgICAgICAqICBAbmFtZXNwYWNlXG4gICAgICAgICAqL1xuICAgICAgICAkLmV4dGVuZChEYXRhVGFibGUuZXh0LmludGVybmFsLCB7XG4gICAgICAgICAgICBfZm5FeHRlcm5BcGlGdW5jOiBfZm5FeHRlcm5BcGlGdW5jLFxuICAgICAgICAgICAgX2ZuQnVpbGRBamF4OiBfZm5CdWlsZEFqYXgsXG4gICAgICAgICAgICBfZm5BamF4VXBkYXRlOiBfZm5BamF4VXBkYXRlLFxuICAgICAgICAgICAgX2ZuQWpheFBhcmFtZXRlcnM6IF9mbkFqYXhQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgX2ZuQWpheFVwZGF0ZURyYXc6IF9mbkFqYXhVcGRhdGVEcmF3LFxuICAgICAgICAgICAgX2ZuQWpheERhdGFTcmM6IF9mbkFqYXhEYXRhU3JjLFxuICAgICAgICAgICAgX2ZuQWRkQ29sdW1uOiBfZm5BZGRDb2x1bW4sXG4gICAgICAgICAgICBfZm5Db2x1bW5PcHRpb25zOiBfZm5Db2x1bW5PcHRpb25zLFxuICAgICAgICAgICAgX2ZuQWRqdXN0Q29sdW1uU2l6aW5nOiBfZm5BZGp1c3RDb2x1bW5TaXppbmcsXG4gICAgICAgICAgICBfZm5WaXNpYmxlVG9Db2x1bW5JbmRleDogX2ZuVmlzaWJsZVRvQ29sdW1uSW5kZXgsXG4gICAgICAgICAgICBfZm5Db2x1bW5JbmRleFRvVmlzaWJsZTogX2ZuQ29sdW1uSW5kZXhUb1Zpc2libGUsXG4gICAgICAgICAgICBfZm5WaXNibGVDb2x1bW5zOiBfZm5WaXNibGVDb2x1bW5zLFxuICAgICAgICAgICAgX2ZuR2V0Q29sdW1uczogX2ZuR2V0Q29sdW1ucyxcbiAgICAgICAgICAgIF9mbkNvbHVtblR5cGVzOiBfZm5Db2x1bW5UeXBlcyxcbiAgICAgICAgICAgIF9mbkFwcGx5Q29sdW1uRGVmczogX2ZuQXBwbHlDb2x1bW5EZWZzLFxuICAgICAgICAgICAgX2ZuSHVuZ2FyaWFuTWFwOiBfZm5IdW5nYXJpYW5NYXAsXG4gICAgICAgICAgICBfZm5DYW1lbFRvSHVuZ2FyaWFuOiBfZm5DYW1lbFRvSHVuZ2FyaWFuLFxuICAgICAgICAgICAgX2ZuTGFuZ3VhZ2VDb21wYXQ6IF9mbkxhbmd1YWdlQ29tcGF0LFxuICAgICAgICAgICAgX2ZuQnJvd3NlckRldGVjdDogX2ZuQnJvd3NlckRldGVjdCxcbiAgICAgICAgICAgIF9mbkFkZERhdGE6IF9mbkFkZERhdGEsXG4gICAgICAgICAgICBfZm5BZGRUcjogX2ZuQWRkVHIsXG4gICAgICAgICAgICBfZm5Ob2RlVG9EYXRhSW5kZXg6IF9mbk5vZGVUb0RhdGFJbmRleCxcbiAgICAgICAgICAgIF9mbk5vZGVUb0NvbHVtbkluZGV4OiBfZm5Ob2RlVG9Db2x1bW5JbmRleCxcbiAgICAgICAgICAgIF9mbkdldENlbGxEYXRhOiBfZm5HZXRDZWxsRGF0YSxcbiAgICAgICAgICAgIF9mblNldENlbGxEYXRhOiBfZm5TZXRDZWxsRGF0YSxcbiAgICAgICAgICAgIF9mblNwbGl0T2JqTm90YXRpb246IF9mblNwbGl0T2JqTm90YXRpb24sXG4gICAgICAgICAgICBfZm5HZXRPYmplY3REYXRhRm46IF9mbkdldE9iamVjdERhdGFGbixcbiAgICAgICAgICAgIF9mblNldE9iamVjdERhdGFGbjogX2ZuU2V0T2JqZWN0RGF0YUZuLFxuICAgICAgICAgICAgX2ZuR2V0RGF0YU1hc3RlcjogX2ZuR2V0RGF0YU1hc3RlcixcbiAgICAgICAgICAgIF9mbkNsZWFyVGFibGU6IF9mbkNsZWFyVGFibGUsXG4gICAgICAgICAgICBfZm5EZWxldGVJbmRleDogX2ZuRGVsZXRlSW5kZXgsXG4gICAgICAgICAgICBfZm5JbnZhbGlkYXRlOiBfZm5JbnZhbGlkYXRlLFxuICAgICAgICAgICAgX2ZuR2V0Um93RWxlbWVudHM6IF9mbkdldFJvd0VsZW1lbnRzLFxuICAgICAgICAgICAgX2ZuQ3JlYXRlVHI6IF9mbkNyZWF0ZVRyLFxuICAgICAgICAgICAgX2ZuQnVpbGRIZWFkOiBfZm5CdWlsZEhlYWQsXG4gICAgICAgICAgICBfZm5EcmF3SGVhZDogX2ZuRHJhd0hlYWQsXG4gICAgICAgICAgICBfZm5EcmF3OiBfZm5EcmF3LFxuICAgICAgICAgICAgX2ZuUmVEcmF3OiBfZm5SZURyYXcsXG4gICAgICAgICAgICBfZm5BZGRPcHRpb25zSHRtbDogX2ZuQWRkT3B0aW9uc0h0bWwsXG4gICAgICAgICAgICBfZm5EZXRlY3RIZWFkZXI6IF9mbkRldGVjdEhlYWRlcixcbiAgICAgICAgICAgIF9mbkdldFVuaXF1ZVRoczogX2ZuR2V0VW5pcXVlVGhzLFxuICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxGaWx0ZXI6IF9mbkZlYXR1cmVIdG1sRmlsdGVyLFxuICAgICAgICAgICAgX2ZuRmlsdGVyQ29tcGxldGU6IF9mbkZpbHRlckNvbXBsZXRlLFxuICAgICAgICAgICAgX2ZuRmlsdGVyQ3VzdG9tOiBfZm5GaWx0ZXJDdXN0b20sXG4gICAgICAgICAgICBfZm5GaWx0ZXJDb2x1bW46IF9mbkZpbHRlckNvbHVtbixcbiAgICAgICAgICAgIF9mbkZpbHRlcjogX2ZuRmlsdGVyLFxuICAgICAgICAgICAgX2ZuRmlsdGVyQ3JlYXRlU2VhcmNoOiBfZm5GaWx0ZXJDcmVhdGVTZWFyY2gsXG4gICAgICAgICAgICBfZm5Fc2NhcGVSZWdleDogX2ZuRXNjYXBlUmVnZXgsXG4gICAgICAgICAgICBfZm5GaWx0ZXJEYXRhOiBfZm5GaWx0ZXJEYXRhLFxuICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxJbmZvOiBfZm5GZWF0dXJlSHRtbEluZm8sXG4gICAgICAgICAgICBfZm5VcGRhdGVJbmZvOiBfZm5VcGRhdGVJbmZvLFxuICAgICAgICAgICAgX2ZuSW5mb01hY3JvczogX2ZuSW5mb01hY3JvcyxcbiAgICAgICAgICAgIF9mbkluaXRpYWxpc2U6IF9mbkluaXRpYWxpc2UsXG4gICAgICAgICAgICBfZm5Jbml0Q29tcGxldGU6IF9mbkluaXRDb21wbGV0ZSxcbiAgICAgICAgICAgIF9mbkxlbmd0aENoYW5nZTogX2ZuTGVuZ3RoQ2hhbmdlLFxuICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxMZW5ndGg6IF9mbkZlYXR1cmVIdG1sTGVuZ3RoLFxuICAgICAgICAgICAgX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZTogX2ZuRmVhdHVyZUh0bWxQYWdpbmF0ZSxcbiAgICAgICAgICAgIF9mblBhZ2VDaGFuZ2U6IF9mblBhZ2VDaGFuZ2UsXG4gICAgICAgICAgICBfZm5GZWF0dXJlSHRtbFByb2Nlc3Npbmc6IF9mbkZlYXR1cmVIdG1sUHJvY2Vzc2luZyxcbiAgICAgICAgICAgIF9mblByb2Nlc3NpbmdEaXNwbGF5OiBfZm5Qcm9jZXNzaW5nRGlzcGxheSxcbiAgICAgICAgICAgIF9mbkZlYXR1cmVIdG1sVGFibGU6IF9mbkZlYXR1cmVIdG1sVGFibGUsXG4gICAgICAgICAgICBfZm5TY3JvbGxEcmF3OiBfZm5TY3JvbGxEcmF3LFxuICAgICAgICAgICAgX2ZuQXBwbHlUb0NoaWxkcmVuOiBfZm5BcHBseVRvQ2hpbGRyZW4sXG4gICAgICAgICAgICBfZm5DYWxjdWxhdGVDb2x1bW5XaWR0aHM6IF9mbkNhbGN1bGF0ZUNvbHVtbldpZHRocyxcbiAgICAgICAgICAgIF9mblRocm90dGxlOiBfZm5UaHJvdHRsZSxcbiAgICAgICAgICAgIF9mbkNvbnZlcnRUb1dpZHRoOiBfZm5Db252ZXJ0VG9XaWR0aCxcbiAgICAgICAgICAgIF9mbkdldFdpZGVzdE5vZGU6IF9mbkdldFdpZGVzdE5vZGUsXG4gICAgICAgICAgICBfZm5HZXRNYXhMZW5TdHJpbmc6IF9mbkdldE1heExlblN0cmluZyxcbiAgICAgICAgICAgIF9mblN0cmluZ1RvQ3NzOiBfZm5TdHJpbmdUb0NzcyxcbiAgICAgICAgICAgIF9mblNvcnRGbGF0dGVuOiBfZm5Tb3J0RmxhdHRlbixcbiAgICAgICAgICAgIF9mblNvcnQ6IF9mblNvcnQsXG4gICAgICAgICAgICBfZm5Tb3J0QXJpYTogX2ZuU29ydEFyaWEsXG4gICAgICAgICAgICBfZm5Tb3J0TGlzdGVuZXI6IF9mblNvcnRMaXN0ZW5lcixcbiAgICAgICAgICAgIF9mblNvcnRBdHRhY2hMaXN0ZW5lcjogX2ZuU29ydEF0dGFjaExpc3RlbmVyLFxuICAgICAgICAgICAgX2ZuU29ydGluZ0NsYXNzZXM6IF9mblNvcnRpbmdDbGFzc2VzLFxuICAgICAgICAgICAgX2ZuU29ydERhdGE6IF9mblNvcnREYXRhLFxuICAgICAgICAgICAgX2ZuU2F2ZVN0YXRlOiBfZm5TYXZlU3RhdGUsXG4gICAgICAgICAgICBfZm5Mb2FkU3RhdGU6IF9mbkxvYWRTdGF0ZSxcbiAgICAgICAgICAgIF9mblNldHRpbmdzRnJvbU5vZGU6IF9mblNldHRpbmdzRnJvbU5vZGUsXG4gICAgICAgICAgICBfZm5Mb2c6IF9mbkxvZyxcbiAgICAgICAgICAgIF9mbk1hcDogX2ZuTWFwLFxuICAgICAgICAgICAgX2ZuQmluZEFjdGlvbjogX2ZuQmluZEFjdGlvbixcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrUmVnOiBfZm5DYWxsYmFja1JlZyxcbiAgICAgICAgICAgIF9mbkNhbGxiYWNrRmlyZTogX2ZuQ2FsbGJhY2tGaXJlLFxuICAgICAgICAgICAgX2ZuTGVuZ3RoT3ZlcmZsb3c6IF9mbkxlbmd0aE92ZXJmbG93LFxuICAgICAgICAgICAgX2ZuUmVuZGVyZXI6IF9mblJlbmRlcmVyLFxuICAgICAgICAgICAgX2ZuRGF0YVNvdXJjZTogX2ZuRGF0YVNvdXJjZSxcbiAgICAgICAgICAgIF9mblJvd0F0dHJpYnV0ZXM6IF9mblJvd0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICBfZm5FeHRlbmQ6IF9mbkV4dGVuZCxcbiAgICAgICAgICAgIF9mbkNhbGN1bGF0ZUVuZDogZnVuY3Rpb24gKCkgeyB9IC8vIFVzZWQgYnkgYSBsb3Qgb2YgcGx1Zy1pbnMsIGJ1dCByZWR1bmRhbnRcbiAgICAgICAgICAgIC8vIGluIDEuMTAsIHNvIHRoaXMgZGVhZC1lbmQgZnVuY3Rpb24gaXNcbiAgICAgICAgICAgIC8vIGFkZGVkIHRvIHByZXZlbnQgZXJyb3JzXG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgLy8galF1ZXJ5IGFjY2Vzc1xuICAgICAgICAkLmZuLmRhdGFUYWJsZSA9IERhdGFUYWJsZTtcblxuICAgICAgICAvLyBQcm92aWRlIGFjY2VzcyB0byB0aGUgaG9zdCBqUXVlcnkgb2JqZWN0IChjaXJjdWxhciByZWZlcmVuY2UpXG4gICAgICAgIERhdGFUYWJsZS4kID0gJDtcblxuICAgICAgICAvLyBMZWdhY3kgYWxpYXNlc1xuICAgICAgICAkLmZuLmRhdGFUYWJsZVNldHRpbmdzID0gRGF0YVRhYmxlLnNldHRpbmdzO1xuICAgICAgICAkLmZuLmRhdGFUYWJsZUV4dCA9IERhdGFUYWJsZS5leHQ7XG5cbiAgICAgICAgLy8gV2l0aCBhIGNhcGl0YWwgYERgIHdlIHJldHVybiBhIERhdGFUYWJsZXMgQVBJIGluc3RhbmNlIHJhdGhlciB0aGFuIGFcbiAgICAgICAgLy8galF1ZXJ5IG9iamVjdFxuICAgICAgICAkLmZuLkRhdGFUYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5kYXRhVGFibGUob3B0cykuYXBpKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWxsIHByb3BlcnRpZXMgdGhhdCBhcmUgYXZhaWxhYmxlIHRvICQuZm4uZGF0YVRhYmxlIHNob3VsZCBhbHNvIGJlXG4gICAgICAgIC8vIGF2YWlsYWJsZSBvbiAkLmZuLkRhdGFUYWJsZVxuICAgICAgICAkLmVhY2goRGF0YVRhYmxlLCBmdW5jdGlvbiAocHJvcCwgdmFsKSB7XG4gICAgICAgICAgICAkLmZuLkRhdGFUYWJsZVtwcm9wXSA9IHZhbDtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyBJbmZvcm1hdGlvbiBhYm91dCBldmVudHMgZmlyZWQgYnkgRGF0YVRhYmxlcyAtIGZvciBkb2N1bWVudGF0aW9uLlxuICAgICAgICAvKipcbiAgICAgICAgICogRHJhdyBldmVudCwgZmlyZWQgd2hlbmV2ZXIgdGhlIHRhYmxlIGlzIHJlZHJhd24gb24gdGhlIHBhZ2UsIGF0IHRoZSBzYW1lXG4gICAgICAgICAqIHBvaW50IGFzIGZuRHJhd0NhbGxiYWNrLiBUaGlzIG1heSBiZSB1c2VmdWwgZm9yIGJpbmRpbmcgZXZlbnRzIG9yXG4gICAgICAgICAqIHBlcmZvcm1pbmcgY2FsY3VsYXRpb25zIHdoZW4gdGhlIHRhYmxlIGlzIGFsdGVyZWQgYXQgYWxsLlxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2RyYXcuZHRcbiAgICAgICAgICogIEBldmVudFxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZWFyY2ggZXZlbnQsIGZpcmVkIHdoZW4gdGhlIHNlYXJjaGluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSAodXNpbmcgdGhlXG4gICAgICAgICAqIGJ1aWx0LWluIGdsb2JhbCBzZWFyY2gsIG9yIGNvbHVtbiBmaWx0ZXJzKSBpcyBhbHRlcmVkLlxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3NlYXJjaC5kdFxuICAgICAgICAgKiAgQGV2ZW50XG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhZ2UgY2hhbmdlIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBwYWdpbmcgb2YgdGhlIHRhYmxlIGlzIGFsdGVyZWQuXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjcGFnZS5kdFxuICAgICAgICAgKiAgQGV2ZW50XG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9yZGVyIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBvcmRlcmluZyBhcHBsaWVkIHRvIHRoZSB0YWJsZSBpcyBhbHRlcmVkLlxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI29yZGVyLmR0XG4gICAgICAgICAqICBAZXZlbnRcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG8gRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3Qge0BsaW5rIERhdGFUYWJsZS5tb2RlbHMub1NldHRpbmdzfVxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGF0YVRhYmxlcyBpbml0aWFsaXNhdGlvbiBjb21wbGV0ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaXMgZnVsbHlcbiAgICAgICAgICogZHJhd24sIGluY2x1ZGluZyBBamF4IGRhdGEgbG9hZGVkLCBpZiBBamF4IGRhdGEgaXMgcmVxdWlyZWQuXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjaW5pdC5kdFxuICAgICAgICAgKiAgQGV2ZW50XG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvU2V0dGluZ3MgRGF0YVRhYmxlcyBzZXR0aW5ncyBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIFRoZSBKU09OIG9iamVjdCByZXF1ZXN0IGZyb20gdGhlIHNlcnZlciAtIG9ubHlcbiAgICAgICAgICogICAgcHJlc2VudCBpZiBjbGllbnQtc2lkZSBBamF4IHNvdXJjZWQgZGF0YSBpcyB1c2VkPC9saT48L29sPlxuICAgICAgICAgKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhdGUgc2F2ZSBldmVudCwgZmlyZWQgd2hlbiB0aGUgdGFibGUgaGFzIGNoYW5nZWQgc3RhdGUgYSBuZXcgc3RhdGUgc2F2ZVxuICAgICAgICAgKiBpcyByZXF1aXJlZC4gVGhpcyBldmVudCBhbGxvd3MgbW9kaWZpY2F0aW9uIG9mIHRoZSBzdGF0ZSBzYXZpbmcgb2JqZWN0XG4gICAgICAgICAqIHByaW9yIHRvIGFjdHVhbGx5IGRvaW5nIHRoZSBzYXZlLCBpbmNsdWRpbmcgYWRkaXRpb24gb3Igb3RoZXIgc3RhdGVcbiAgICAgICAgICogcHJvcGVydGllcyAoZm9yIHBsdWctaW5zKSBvciBtb2RpZmljYXRpb24gb2YgYSBEYXRhVGFibGVzIGNvcmUgcHJvcGVydHkuXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVTYXZlUGFyYW1zLmR0XG4gICAgICAgICAqICBAZXZlbnRcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IGpzb24gVGhlIHN0YXRlIGluZm9ybWF0aW9uIHRvIGJlIHNhdmVkXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGF0ZSBsb2FkIGV2ZW50LCBmaXJlZCB3aGVuIHRoZSB0YWJsZSBpcyBsb2FkaW5nIHN0YXRlIGZyb20gdGhlIHN0b3JlZFxuICAgICAgICAgKiBkYXRhLCBidXQgcHJpb3IgdG8gdGhlIHNldHRpbmdzIG9iamVjdCBiZWluZyBtb2RpZmllZCBieSB0aGUgc2F2ZWQgc3RhdGVcbiAgICAgICAgICogLSBhbGxvd2luZyBtb2RpZmljYXRpb24gb2YgdGhlIHNhdmVkIHN0YXRlIGlzIHJlcXVpcmVkIG9yIGxvYWRpbmcgb2ZcbiAgICAgICAgICogc3RhdGUgZm9yIGEgcGx1Zy1pbi5cbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNzdGF0ZUxvYWRQYXJhbXMuZHRcbiAgICAgICAgICogIEBldmVudFxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0YXRlIGxvYWRlZCBldmVudCwgZmlyZWQgd2hlbiBzdGF0ZSBoYXMgYmVlbiBsb2FkZWQgZnJvbSBzdG9yZWQgZGF0YSBhbmRcbiAgICAgICAgICogdGhlIHNldHRpbmdzIG9iamVjdCBoYXMgYmVlbiBtb2RpZmllZCBieSB0aGUgbG9hZGVkIGRhdGEuXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjc3RhdGVMb2FkZWQuZHRcbiAgICAgICAgICogIEBldmVudFxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gb1NldHRpbmdzIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0ganNvbiBUaGUgc2F2ZWQgc3RhdGUgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2Nlc3NpbmcgZXZlbnQsIGZpcmVkIHdoZW4gRGF0YVRhYmxlcyBpcyBkb2luZyBzb21lIGtpbmQgb2YgcHJvY2Vzc2luZ1xuICAgICAgICAgKiAoYmUgaXQsIG9yZGVyLCBzZWFyY2ggb3IgYW55dGhpbmcgZWxzZSkuIEl0IGNhbiBiZSB1c2VkIHRvIGluZGljYXRlIHRvXG4gICAgICAgICAqIHRoZSBlbmQgdXNlciB0aGF0IHRoZXJlIGlzIHNvbWV0aGluZyBoYXBwZW5pbmcsIG9yIHRoYXQgc29tZXRoaW5nIGhhc1xuICAgICAgICAgKiBmaW5pc2hlZC5cbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNwcm9jZXNzaW5nLmR0XG4gICAgICAgICAqICBAZXZlbnRcbiAgICAgICAgICogIEBwYXJhbSB7ZXZlbnR9IGUgalF1ZXJ5IGV2ZW50IG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtvYmplY3R9IG9TZXR0aW5ncyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgKiAgQHBhcmFtIHtib29sZWFufSBiU2hvdyBGbGFnIGZvciBpZiBEYXRhVGFibGVzIGlzIGRvaW5nIHByb2Nlc3Npbmcgb3Igbm90XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBamF4IChYSFIpIGV2ZW50LCBmaXJlZCB3aGVuZXZlciBhbiBBamF4IHJlcXVlc3QgaXMgY29tcGxldGVkIGZyb20gYVxuICAgICAgICAgKiByZXF1ZXN0IHRvIG1hZGUgdG8gdGhlIHNlcnZlciBmb3IgbmV3IGRhdGEuIFRoaXMgZXZlbnQgaXMgY2FsbGVkIGJlZm9yZVxuICAgICAgICAgKiBEYXRhVGFibGVzIHByb2Nlc3NlZCB0aGUgcmV0dXJuZWQgZGF0YSwgc28gaXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcmUtXG4gICAgICAgICAqIHByb2Nlc3MgdGhlIGRhdGEgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyLCBpZiBuZWVkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHRyaWdnZXIgaXMgY2FsbGVkIGluIGBmblNlcnZlckRhdGFgLCBpZiB5b3Ugb3ZlcnJpZGVcbiAgICAgICAgICogYGZuU2VydmVyRGF0YWAgYW5kIHdoaWNoIHRvIHVzZSB0aGlzIGV2ZW50LCB5b3UgbmVlZCB0byB0cmlnZ2VyIGl0IGluIHlvdVxuICAgICAgICAgKiBzdWNjZXNzIGZ1bmN0aW9uLlxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI3hoci5kdFxuICAgICAgICAgKiAgQGV2ZW50XG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBqc29uIEpTT04gcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyXG4gICAgICAgICAqXG4gICAgICAgICAqICBAZXhhbXBsZVxuICAgICAgICAgKiAgICAgLy8gVXNlIGEgY3VzdG9tIHByb3BlcnR5IHJldHVybmVkIGZyb20gdGhlIHNlcnZlciBpbiBhbm90aGVyIERPTSBlbGVtZW50XG4gICAgICAgICAqICAgICAkKCcjdGFibGUnKS5kYXRhVGFibGUoKS5vbigneGhyLmR0JywgZnVuY3Rpb24gKGUsIHNldHRpbmdzLCBqc29uKSB7XG4gICAgICAgICAqICAgICAgICQoJyNzdGF0dXMnKS5odG1sKCBqc29uLnN0YXR1cyApO1xuICAgICAgICAgKiAgICAgfSApO1xuICAgICAgICAgKlxuICAgICAgICAgKiAgQGV4YW1wbGVcbiAgICAgICAgICogICAgIC8vIFByZS1wcm9jZXNzIHRoZSBkYXRhIHJldHVybmVkIGZyb20gdGhlIHNlcnZlclxuICAgICAgICAgKiAgICAgJCgnI3RhYmxlJykuZGF0YVRhYmxlKCkub24oJ3hoci5kdCcsIGZ1bmN0aW9uIChlLCBzZXR0aW5ncywganNvbikge1xuICAgICAgICAgKiAgICAgICBmb3IgKCB2YXIgaT0wLCBpZW49anNvbi5hYURhdGEubGVuZ3RoIDsgaTxpZW4gOyBpKysgKSB7XG4gICAgICAgICAqICAgICAgICAganNvbi5hYURhdGFbaV0uc3VtID0ganNvbi5hYURhdGFbaV0ub25lICsganNvbi5hYURhdGFbaV0udHdvO1xuICAgICAgICAgKiAgICAgICB9XG4gICAgICAgICAqICAgICAgIC8vIE5vdGUgbm8gcmV0dXJuIC0gbWFuaXB1bGF0ZSB0aGUgZGF0YSBkaXJlY3RseSBpbiB0aGUgSlNPTiBvYmplY3QuXG4gICAgICAgICAqICAgICB9ICk7XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXN0cm95IGV2ZW50LCBmaXJlZCB3aGVuIHRoZSBEYXRhVGFibGUgaXMgZGVzdHJveWVkIGJ5IGNhbGxpbmcgZm5EZXN0cm95XG4gICAgICAgICAqIG9yIHBhc3NpbmcgdGhlIGJEZXN0cm95OnRydWUgcGFyYW1ldGVyIGluIHRoZSBpbml0aWFsaXNhdGlvbiBvYmplY3QuIFRoaXNcbiAgICAgICAgICogY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGJvdW5kIGV2ZW50cywgYWRkZWQgRE9NIG5vZGVzLCBldGMuXG4gICAgICAgICAqICBAbmFtZSBEYXRhVGFibGUjZGVzdHJveS5kdFxuICAgICAgICAgKiAgQGV2ZW50XG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhZ2UgbGVuZ3RoIGNoYW5nZSBldmVudCwgZmlyZWQgd2hlbiBudW1iZXIgb2YgcmVjb3JkcyB0byBzaG93IG9uIGVhY2hcbiAgICAgICAgICogcGFnZSAodGhlIGxlbmd0aCkgaXMgY2hhbmdlZC5cbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNsZW5ndGguZHRcbiAgICAgICAgICogIEBldmVudFxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG4gICAgICAgICAqICBAcGFyYW0ge2ludGVnZXJ9IGxlbiBOZXcgbGVuZ3RoXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2x1bW4gc2l6aW5nIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgKiAgQG5hbWUgRGF0YVRhYmxlI2NvbHVtbi1zaXppbmcuZHRcbiAgICAgICAgICogIEBldmVudFxuICAgICAgICAgKiAgQHBhcmFtIHtldmVudH0gZSBqUXVlcnkgZXZlbnQgb2JqZWN0XG4gICAgICAgICAqICBAcGFyYW0ge29iamVjdH0gbyBEYXRhVGFibGVzIHNldHRpbmdzIG9iamVjdCB7QGxpbmsgRGF0YVRhYmxlLm1vZGVscy5vU2V0dGluZ3N9XG4gICAgICAgICAqL1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb2x1bW4gdmlzaWJpbGl0eSBoYXMgY2hhbmdlZC5cbiAgICAgICAgICogIEBuYW1lIERhdGFUYWJsZSNjb2x1bW4tdmlzaWJpbGl0eS5kdFxuICAgICAgICAgKiAgQGV2ZW50XG4gICAgICAgICAqICBAcGFyYW0ge2V2ZW50fSBlIGpRdWVyeSBldmVudCBvYmplY3RcbiAgICAgICAgICogIEBwYXJhbSB7b2JqZWN0fSBvIERhdGFUYWJsZXMgc2V0dGluZ3Mgb2JqZWN0IHtAbGluayBEYXRhVGFibGUubW9kZWxzLm9TZXR0aW5nc31cbiAgICAgICAgICogIEBwYXJhbSB7aW50fSBjb2x1bW4gQ29sdW1uIGluZGV4XG4gICAgICAgICAqICBAcGFyYW0ge2Jvb2x9IHZpcyBgZmFsc2VgIGlmIGNvbHVtbiBub3cgaGlkZGVuLCBvciBgdHJ1ZWAgaWYgdmlzaWJsZVxuICAgICAgICAgKi9cblxuICAgICAgICByZXR1cm4gJC5mbi5kYXRhVGFibGU7XG4gICAgfSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/datatables.net/js/jquery.dataTables.js\n");

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * jQuery JavaScript Library v3.5.1\n * https://jquery.com/\n *\n * Includes Sizzle.js\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://jquery.org/license\n *\n * Date: 2020-05-04T22:49Z\n */\n( function( global, factory ) {\n\n\t\"use strict\";\n\n\tif (  true && typeof module.exports === \"object\" ) {\n\n\t\t// For CommonJS and CommonJS-like environments where a proper `window`\n\t\t// is present, execute the factory and get jQuery.\n\t\t// For environments that do not have a `window` with a `document`\n\t\t// (such as Node.js), expose a factory as module.exports.\n\t\t// This accentuates the need for the creation of a real `window`.\n\t\t// e.g. var jQuery = require(\"jquery\")(window);\n\t\t// See ticket #14549 for more info.\n\t\tmodule.exports = global.document ?\n\t\t\tfactory( global, true ) :\n\t\t\tfunction( w ) {\n\t\t\t\tif ( !w.document ) {\n\t\t\t\t\tthrow new Error( \"jQuery requires a window with a document\" );\n\t\t\t\t}\n\t\t\t\treturn factory( w );\n\t\t\t};\n\t} else {\n\t\tfactory( global );\n\t}\n\n// Pass this if window is not defined yet\n} )( typeof window !== \"undefined\" ? window : this, function( window, noGlobal ) {\n\n// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1\n// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode\n// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common\n// enough that all such attempts are guarded in a try block.\n\"use strict\";\n\nvar arr = [];\n\nvar getProto = Object.getPrototypeOf;\n\nvar slice = arr.slice;\n\nvar flat = arr.flat ? function( array ) {\n\treturn arr.flat.call( array );\n} : function( array ) {\n\treturn arr.concat.apply( [], array );\n};\n\n\nvar push = arr.push;\n\nvar indexOf = arr.indexOf;\n\nvar class2type = {};\n\nvar toString = class2type.toString;\n\nvar hasOwn = class2type.hasOwnProperty;\n\nvar fnToString = hasOwn.toString;\n\nvar ObjectFunctionString = fnToString.call( Object );\n\nvar support = {};\n\nvar isFunction = function isFunction( obj ) {\n\n      // Support: Chrome <=57, Firefox <=52\n      // In some browsers, typeof returns \"function\" for HTML <object> elements\n      // (i.e., `typeof document.createElement( \"object\" ) === \"function\"`).\n      // We don't want to classify *any* DOM node as a function.\n      return typeof obj === \"function\" && typeof obj.nodeType !== \"number\";\n  };\n\n\nvar isWindow = function isWindow( obj ) {\n\t\treturn obj != null && obj === obj.window;\n\t};\n\n\nvar document = window.document;\n\n\n\n\tvar preservedScriptAttributes = {\n\t\ttype: true,\n\t\tsrc: true,\n\t\tnonce: true,\n\t\tnoModule: true\n\t};\n\n\tfunction DOMEval( code, node, doc ) {\n\t\tdoc = doc || document;\n\n\t\tvar i, val,\n\t\t\tscript = doc.createElement( \"script\" );\n\n\t\tscript.text = code;\n\t\tif ( node ) {\n\t\t\tfor ( i in preservedScriptAttributes ) {\n\n\t\t\t\t// Support: Firefox 64+, Edge 18+\n\t\t\t\t// Some browsers don't support the \"nonce\" property on scripts.\n\t\t\t\t// On the other hand, just using `getAttribute` is not enough as\n\t\t\t\t// the `nonce` attribute is reset to an empty string whenever it\n\t\t\t\t// becomes browsing-context connected.\n\t\t\t\t// See https://github.com/whatwg/html/issues/2369\n\t\t\t\t// See https://html.spec.whatwg.org/#nonce-attributes\n\t\t\t\t// The `node.getAttribute` check was added for the sake of\n\t\t\t\t// `jQuery.globalEval` so that it can fake a nonce-containing node\n\t\t\t\t// via an object.\n\t\t\t\tval = node[ i ] || node.getAttribute && node.getAttribute( i );\n\t\t\t\tif ( val ) {\n\t\t\t\t\tscript.setAttribute( i, val );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdoc.head.appendChild( script ).parentNode.removeChild( script );\n\t}\n\n\nfunction toType( obj ) {\n\tif ( obj == null ) {\n\t\treturn obj + \"\";\n\t}\n\n\t// Support: Android <=2.3 only (functionish RegExp)\n\treturn typeof obj === \"object\" || typeof obj === \"function\" ?\n\t\tclass2type[ toString.call( obj ) ] || \"object\" :\n\t\ttypeof obj;\n}\n/* global Symbol */\n// Defining this global in .eslintrc.json would create a danger of using the global\n// unguarded in another place, it seems safer to define global only for this module\n\n\n\nvar\n\tversion = \"3.5.1\",\n\n\t// Define a local copy of jQuery\n\tjQuery = function( selector, context ) {\n\n\t\t// The jQuery object is actually just the init constructor 'enhanced'\n\t\t// Need init if jQuery is called (just allow error to be thrown if not included)\n\t\treturn new jQuery.fn.init( selector, context );\n\t};\n\njQuery.fn = jQuery.prototype = {\n\n\t// The current version of jQuery being used\n\tjquery: version,\n\n\tconstructor: jQuery,\n\n\t// The default length of a jQuery object is 0\n\tlength: 0,\n\n\ttoArray: function() {\n\t\treturn slice.call( this );\n\t},\n\n\t// Get the Nth element in the matched element set OR\n\t// Get the whole matched element set as a clean array\n\tget: function( num ) {\n\n\t\t// Return all the elements in a clean array\n\t\tif ( num == null ) {\n\t\t\treturn slice.call( this );\n\t\t}\n\n\t\t// Return just the one element from the set\n\t\treturn num < 0 ? this[ num + this.length ] : this[ num ];\n\t},\n\n\t// Take an array of elements and push it onto the stack\n\t// (returning the new matched element set)\n\tpushStack: function( elems ) {\n\n\t\t// Build a new jQuery matched element set\n\t\tvar ret = jQuery.merge( this.constructor(), elems );\n\n\t\t// Add the old object onto the stack (as a reference)\n\t\tret.prevObject = this;\n\n\t\t// Return the newly-formed element set\n\t\treturn ret;\n\t},\n\n\t// Execute a callback for every element in the matched set.\n\teach: function( callback ) {\n\t\treturn jQuery.each( this, callback );\n\t},\n\n\tmap: function( callback ) {\n\t\treturn this.pushStack( jQuery.map( this, function( elem, i ) {\n\t\t\treturn callback.call( elem, i, elem );\n\t\t} ) );\n\t},\n\n\tslice: function() {\n\t\treturn this.pushStack( slice.apply( this, arguments ) );\n\t},\n\n\tfirst: function() {\n\t\treturn this.eq( 0 );\n\t},\n\n\tlast: function() {\n\t\treturn this.eq( -1 );\n\t},\n\n\teven: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn ( i + 1 ) % 2;\n\t\t} ) );\n\t},\n\n\todd: function() {\n\t\treturn this.pushStack( jQuery.grep( this, function( _elem, i ) {\n\t\t\treturn i % 2;\n\t\t} ) );\n\t},\n\n\teq: function( i ) {\n\t\tvar len = this.length,\n\t\t\tj = +i + ( i < 0 ? len : 0 );\n\t\treturn this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );\n\t},\n\n\tend: function() {\n\t\treturn this.prevObject || this.constructor();\n\t},\n\n\t// For internal use only.\n\t// Behaves like an Array's method, not like a jQuery method.\n\tpush: push,\n\tsort: arr.sort,\n\tsplice: arr.splice\n};\n\njQuery.extend = jQuery.fn.extend = function() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\t\ttarget = arguments[ 0 ] || {},\n\t\ti = 1,\n\t\tlength = arguments.length,\n\t\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\n\t\t// Skip the boolean and the target\n\t\ttarget = arguments[ i ] || {};\n\t\ti++;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !isFunction( target ) ) {\n\t\ttarget = {};\n\t}\n\n\t// Extend jQuery itself if only one argument is passed\n\tif ( i === length ) {\n\t\ttarget = this;\n\t\ti--;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\n\t\t// Only deal with non-null/undefined values\n\t\tif ( ( options = arguments[ i ] ) != null ) {\n\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent Object.prototype pollution\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( name === \"__proto__\" || target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject( copy ) ||\n\t\t\t\t\t( copyIsArray = Array.isArray( copy ) ) ) ) {\n\t\t\t\t\tsrc = target[ name ];\n\n\t\t\t\t\t// Ensure proper type for the source value\n\t\t\t\t\tif ( copyIsArray && !Array.isArray( src ) ) {\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {\n\t\t\t\t\t\tclone = {};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src;\n\t\t\t\t\t}\n\t\t\t\t\tcopyIsArray = false;\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\njQuery.extend( {\n\n\t// Unique for each copy of jQuery on the page\n\texpando: \"jQuery\" + ( version + Math.random() ).replace( /\\D/g, \"\" ),\n\n\t// Assume jQuery is ready without the ready module\n\tisReady: true,\n\n\terror: function( msg ) {\n\t\tthrow new Error( msg );\n\t},\n\n\tnoop: function() {},\n\n\tisPlainObject: function( obj ) {\n\t\tvar proto, Ctor;\n\n\t\t// Detect obvious negatives\n\t\t// Use toString instead of jQuery.type to catch host objects\n\t\tif ( !obj || toString.call( obj ) !== \"[object Object]\" ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tproto = getProto( obj );\n\n\t\t// Objects with no prototype (e.g., `Object.create( null )`) are plain\n\t\tif ( !proto ) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// Objects with prototype are plain iff they were constructed by a global Object function\n\t\tCtor = hasOwn.call( proto, \"constructor\" ) && proto.constructor;\n\t\treturn typeof Ctor === \"function\" && fnToString.call( Ctor ) === ObjectFunctionString;\n\t},\n\n\tisEmptyObject: function( obj ) {\n\t\tvar name;\n\n\t\tfor ( name in obj ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t},\n\n\t// Evaluates a script in a provided context; falls back to the global one\n\t// if not specified.\n\tglobalEval: function( code, options, doc ) {\n\t\tDOMEval( code, { nonce: options && options.nonce }, doc );\n\t},\n\n\teach: function( obj, callback ) {\n\t\tvar length, i = 0;\n\n\t\tif ( isArrayLike( obj ) ) {\n\t\t\tlength = obj.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( i in obj ) {\n\t\t\t\tif ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t// results is for internal usage only\n\tmakeArray: function( arr, results ) {\n\t\tvar ret = results || [];\n\n\t\tif ( arr != null ) {\n\t\t\tif ( isArrayLike( Object( arr ) ) ) {\n\t\t\t\tjQuery.merge( ret,\n\t\t\t\t\ttypeof arr === \"string\" ?\n\t\t\t\t\t[ arr ] : arr\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tpush.call( ret, arr );\n\t\t\t}\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\tinArray: function( elem, arr, i ) {\n\t\treturn arr == null ? -1 : indexOf.call( arr, elem, i );\n\t},\n\n\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t// push.apply(_, arraylike) throws on ancient WebKit\n\tmerge: function( first, second ) {\n\t\tvar len = +second.length,\n\t\t\tj = 0,\n\t\t\ti = first.length;\n\n\t\tfor ( ; j < len; j++ ) {\n\t\t\tfirst[ i++ ] = second[ j ];\n\t\t}\n\n\t\tfirst.length = i;\n\n\t\treturn first;\n\t},\n\n\tgrep: function( elems, callback, invert ) {\n\t\tvar callbackInverse,\n\t\t\tmatches = [],\n\t\t\ti = 0,\n\t\t\tlength = elems.length,\n\t\t\tcallbackExpect = !invert;\n\n\t\t// Go through the array, only saving the items\n\t\t// that pass the validator function\n\t\tfor ( ; i < length; i++ ) {\n\t\t\tcallbackInverse = !callback( elems[ i ], i );\n\t\t\tif ( callbackInverse !== callbackExpect ) {\n\t\t\t\tmatches.push( elems[ i ] );\n\t\t\t}\n\t\t}\n\n\t\treturn matches;\n\t},\n\n\t// arg is for internal usage only\n\tmap: function( elems, callback, arg ) {\n\t\tvar length, value,\n\t\t\ti = 0,\n\t\t\tret = [];\n\n\t\t// Go through the array, translating each of the items to their new values\n\t\tif ( isArrayLike( elems ) ) {\n\t\t\tlength = elems.length;\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Go through every key on the object,\n\t\t} else {\n\t\t\tfor ( i in elems ) {\n\t\t\t\tvalue = callback( elems[ i ], i, arg );\n\n\t\t\t\tif ( value != null ) {\n\t\t\t\t\tret.push( value );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Flatten any nested arrays\n\t\treturn flat( ret );\n\t},\n\n\t// A global GUID counter for objects\n\tguid: 1,\n\n\t// jQuery.support is not used in Core but other projects attach their\n\t// properties to it so it needs to exist.\n\tsupport: support\n} );\n\nif ( typeof Symbol === \"function\" ) {\n\tjQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];\n}\n\n// Populate the class2type map\njQuery.each( \"Boolean Number String Function Array Date RegExp Object Error Symbol\".split( \" \" ),\nfunction( _i, name ) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n} );\n\nfunction isArrayLike( obj ) {\n\n\t// Support: real iOS 8.2 only (not reproducible in simulator)\n\t// `in` check used to prevent JIT error (gh-2145)\n\t// hasOwn isn't used here due to false negatives\n\t// regarding Nodelist length in IE\n\tvar length = !!obj && \"length\" in obj && obj.length,\n\t\ttype = toType( obj );\n\n\tif ( isFunction( obj ) || isWindow( obj ) ) {\n\t\treturn false;\n\t}\n\n\treturn type === \"array\" || length === 0 ||\n\t\ttypeof length === \"number\" && length > 0 && ( length - 1 ) in obj;\n}\nvar Sizzle =\n/*!\n * Sizzle CSS Selector Engine v2.3.5\n * https://sizzlejs.com/\n *\n * Copyright JS Foundation and other contributors\n * Released under the MIT license\n * https://js.foundation/\n *\n * Date: 2020-03-14\n */\n( function( window ) {\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tnonnativeSelectorCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// Instance methods\n\thasOwn = ( {} ).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpushNative = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\n\t// Use a stripped-down indexOf as it's faster than native\n\t// https://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[ i ] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|\" +\n\t\t\"ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram\n\tidentifier = \"(?:\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace +\n\t\t\"?|\\\\\\\\[^\\\\r\\\\n\\\\f]|[\\\\w-]|[^\\0-\\\\x7f])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\n\t\t// \"Attribute values must be CSS identifiers [capture 5]\n\t\t// or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" +\n\t\twhitespace + \"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" +\n\t\twhitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace +\n\t\t\"*\" ),\n\trdescend = new RegExp( whitespace + \"|>\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" +\n\t\t\twhitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" +\n\t\t\twhitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace +\n\t\t\t\"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace +\n\t\t\t\"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trhtml = /HTML$/i,\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\n\t// CSS escapes\n\t// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\[\\\\da-fA-F]{1,6}\" + whitespace + \"?|\\\\\\\\([^\\\\r\\\\n\\\\f])\", \"g\" ),\n\tfunescape = function( escape, nonHex ) {\n\t\tvar high = \"0x\" + escape.slice( 1 ) - 0x10000;\n\n\t\treturn nonHex ?\n\n\t\t\t// Strip the backslash prefix from a non-hex escape sequence\n\t\t\tnonHex :\n\n\t\t\t// Replace a hexadecimal escape sequence with the encoded Unicode code point\n\t\t\t// Support: IE <=11+\n\t\t\t// For values outside the Basic Multilingual Plane (BMP), manually construct a\n\t\t\t// surrogate pair\n\t\t\thigh < 0 ?\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// CSS string/identifier serialization\n\t// https://drafts.csswg.org/cssom/#common-serializing-idioms\n\trcssescape = /([\\0-\\x1f\\x7f]|^-?\\d)|^-$|[^\\0-\\x1f\\x7f-\\uFFFF\\w-]/g,\n\tfcssescape = function( ch, asCodePoint ) {\n\t\tif ( asCodePoint ) {\n\n\t\t\t// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER\n\t\t\tif ( ch === \"\\0\" ) {\n\t\t\t\treturn \"\\uFFFD\";\n\t\t\t}\n\n\t\t\t// Control characters and (dependent upon position) numbers get escaped as code points\n\t\t\treturn ch.slice( 0, -1 ) + \"\\\\\" +\n\t\t\t\tch.charCodeAt( ch.length - 1 ).toString( 16 ) + \" \";\n\t\t}\n\n\t\t// Other potentially-special ASCII characters get backslash-escaped\n\t\treturn \"\\\\\" + ch;\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t},\n\n\tinDisabledFieldset = addCombinator(\n\t\tfunction( elem ) {\n\t\t\treturn elem.disabled === true && elem.nodeName.toLowerCase() === \"fieldset\";\n\t\t},\n\t\t{ dir: \"parentNode\", next: \"legend\" }\n\t);\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t( arr = slice.call( preferredDoc.childNodes ) ),\n\t\tpreferredDoc.childNodes\n\t);\n\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\t// eslint-disable-next-line no-unused-expressions\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpushNative.apply( target, slice.call( els ) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( ( target[ j++ ] = els[ i++ ] ) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\t\tsetDocument( context );\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( ( m = match[ 1 ] ) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( ( elem = context.getElementById( m ) ) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && ( elem = newContext.getElementById( m ) ) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[ 2 ] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!nonnativeSelectorCache[ selector + \" \" ] &&\n\t\t\t\t( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&\n\n\t\t\t\t// Support: IE 8 only\n\t\t\t\t// Exclude object elements\n\t\t\t\t( nodeType !== 1 || context.nodeName.toLowerCase() !== \"object\" ) ) {\n\n\t\t\t\tnewSelector = selector;\n\t\t\t\tnewContext = context;\n\n\t\t\t\t// qSA considers elements outside a scoping root when evaluating child or\n\t\t\t\t// descendant combinators, which is not what we want.\n\t\t\t\t// In such cases, we work around the behavior by prefixing every selector in the\n\t\t\t\t// list with an ID selector referencing the scope context.\n\t\t\t\t// The technique has to be used as well when a leading combinator is used\n\t\t\t\t// as such selectors are not recognized by querySelectorAll.\n\t\t\t\t// Thanks to Andrew Dupont for this technique.\n\t\t\t\tif ( nodeType === 1 &&\n\t\t\t\t\t( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\n\t\t\t\t\t// We can use :scope instead of the ID hack if the browser\n\t\t\t\t\t// supports it & if we're not changing the context.\n\t\t\t\t\tif ( newContext !== context || !support.scope ) {\n\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif ( ( nid = context.getAttribute( \"id\" ) ) ) {\n\t\t\t\t\t\t\tnid = nid.replace( rcssescape, fcssescape );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute( \"id\", ( nid = expando ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[ i ] = ( nid ? \"#\" + nid : \":scope\" ) + \" \" +\n\t\t\t\t\t\t\ttoSelector( groups[ i ] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t);\n\t\t\t\t\treturn results;\n\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\tnonnativeSelectorCache( selector, true );\n\t\t\t\t} finally {\n\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn ( cache[ key + \" \" ] = value );\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result\n */\nfunction assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t} catch ( e ) {\n\t\treturn false;\n\t} finally {\n\n\t\t// Remove from its parent by default\n\t\tif ( el.parentNode ) {\n\t\t\tel.parentNode.removeChild( el );\n\t\t}\n\n\t\t// release memory in IE\n\t\tel = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split( \"|\" ),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[ i ] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\ta.sourceIndex - b.sourceIndex;\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( ( cur = cur.nextSibling ) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn ( name === \"input\" || name === \"button\" ) && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled\n */\nfunction createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn elem.disabled === disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Support: IE 6 - 11\n\t\t\t\t// Use the isDisabled shortcut property to check for disabled fieldset ancestors\n\t\t\t\treturn elem.isDisabled === disabled ||\n\n\t\t\t\t\t// Where there is no isDisabled, check manually\n\t\t\t\t\t/* jshint -W018 */\n\t\t\t\t\telem.isDisabled !== !disabled &&\n\t\t\t\t\tinDisabledFieldset( elem ) === disabled;\n\t\t\t}\n\n\t\t\treturn elem.disabled === disabled;\n\n\t\t// Try to winnow out elements that can't be disabled before trusting the disabled property.\n\t\t// Some victims get caught in our net (label, legend, menu, track), but it shouldn't\n\t\t// even exist on them, let alone have a boolean value.\n\t\t} else if ( \"label\" in elem ) {\n\t\t\treturn elem.disabled === disabled;\n\t\t}\n\n\t\t// Remaining elements are neither :enabled nor :disabled\n\t\treturn false;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t} );\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\tvar namespace = elem.namespaceURI,\n\t\tdocElem = ( elem.ownerDocument || elem ).documentElement;\n\n\t// Support: IE <=8\n\t// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes\n\t// https://bugs.jquery.com/ticket/4833\n\treturn !rhtml.test( namespace || docElem && docElem.nodeName || \"HTML\" );\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( preferredDoc != document &&\n\t\t( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {\n\n\t\t// Support: IE 11, Edge\n\t\tif ( subWindow.addEventListener ) {\n\t\t\tsubWindow.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( subWindow.attachEvent ) {\n\t\t\tsubWindow.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,\n\t// Safari 4 - 5 only, Opera <=11.6 - 12.x only\n\t// IE/Edge & older browsers don't support the :scope pseudo-class.\n\t// Support: Safari 6.0 only\n\t// Safari 6.0 supports :scope but it's an alias of :root there.\n\tsupport.scope = assert( function( el ) {\n\t\tdocElem.appendChild( el ).appendChild( document.createElement( \"div\" ) );\n\t\treturn typeof el.querySelectorAll !== \"undefined\" &&\n\t\t\t!el.querySelectorAll( \":scope fieldset div\" ).length;\n\t} );\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert( function( el ) {\n\t\tel.className = \"i\";\n\t\treturn !el.getAttribute( \"className\" );\n\t} );\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert( function( el ) {\n\t\tel.appendChild( document.createComment( \"\" ) );\n\t\treturn !el.getElementsByTagName( \"*\" ).length;\n\t} );\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programmatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert( function( el ) {\n\t\tdocElem.appendChild( el ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t} );\n\n\t// ID filter and find\n\tif ( support.getById ) {\n\t\tExpr.filter[ \"ID\" ] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute( \"id\" ) === attrId;\n\t\t\t};\n\t\t};\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar elem = context.getElementById( id );\n\t\t\t\treturn elem ? [ elem ] : [];\n\t\t\t}\n\t\t};\n\t} else {\n\t\tExpr.filter[ \"ID\" ] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode( \"id\" );\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\n\t\t// Support: IE 6 - 7 only\n\t\t// getElementById is not reliable as a find shortcut\n\t\tExpr.find[ \"ID\" ] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar node, i, elems,\n\t\t\t\t\telem = context.getElementById( id );\n\n\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t// Verify the id attribute\n\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Fall back on getElementsByName\n\t\t\t\t\telems = context.getElementsByName( id );\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile ( ( elem = elems[ i++ ] ) ) {\n\t\t\t\t\t\tnode = elem.getAttributeNode( \"id\" );\n\t\t\t\t\t\tif ( node && node.value === id ) {\n\t\t\t\t\t\t\treturn [ elem ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn [];\n\t\t\t}\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[ \"TAG\" ] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[ \"CLASS\" ] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See https://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {\n\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert( function( el ) {\n\n\t\t\tvar input;\n\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// https://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( el ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( el.querySelectorAll( \"[msallowcapture^='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !el.querySelectorAll( \"[selected]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !el.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"~=\" );\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 15 - 18+\n\t\t\t// IE 11/Edge don't find elements on a `[name='']` query in some cases.\n\t\t\t// Adding a temporary attribute to the document before the selection works\n\t\t\t// around the issue.\n\t\t\t// Interestingly, IE 10 & older don't seem to have the issue.\n\t\t\tinput = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"name\", \"\" );\n\t\t\tel.appendChild( input );\n\t\t\tif ( !el.querySelectorAll( \"[name='']\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*name\" + whitespace + \"*=\" +\n\t\t\t\t\twhitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !el.querySelectorAll( \":checked\" ).length ) {\n\t\t\t\trbuggyQSA.push( \":checked\" );\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibling-combinator selector` fails\n\t\t\tif ( !el.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push( \".#.+[+~]\" );\n\t\t\t}\n\n\t\t\t// Support: Firefox <=3.6 - 5 only\n\t\t\t// Old Firefox doesn't throw on a badly-escaped identifier.\n\t\t\tel.querySelectorAll( \"\\\\\\f\" );\n\t\t\trbuggyQSA.push( \"[\\\\r\\\\n\\\\f]\" );\n\t\t} );\n\n\t\tassert( function( el ) {\n\t\t\tel.innerHTML = \"<a href='' disabled='disabled'></a>\" +\n\t\t\t\t\"<select disabled='disabled'><option/></select>\";\n\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement( \"input\" );\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tel.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( el.querySelectorAll( \"[name=d]\" ).length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( el.querySelectorAll( \":enabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: IE9-11+\n\t\t\t// IE's :disabled selector does not pick up the children of disabled fieldsets\n\t\t\tdocElem.appendChild( el ).disabled = true;\n\t\t\tif ( el.querySelectorAll( \":disabled\" ).length !== 2 ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Support: Opera 10 - 11 only\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tel.querySelectorAll( \"*,:x\" );\n\t\t\trbuggyQSA.push( \",.*:\" );\n\t\t} );\n\t}\n\n\tif ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector ) ) ) ) {\n\n\t\tassert( function( el ) {\n\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( el, \"*\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( el, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t} );\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( \"|\" ) );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( \"|\" ) );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t) );\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( ( b = b.parentNode ) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t// two documents; shallow comparisons work.\n\t\t// eslint-disable-next-line eqeqeq\n\t\tcompare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( a == document || a.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, a ) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\tif ( b == document || b.ownerDocument == preferredDoc &&\n\t\t\t\tcontains( preferredDoc, b ) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\treturn a == document ? -1 :\n\t\t\t\tb == document ? 1 :\n\t\t\t\t/* eslint-enable eqeqeq */\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( ( cur = cur.parentNode ) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[ i ] === bp[ i ] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[ i ], bp[ i ] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t// two documents; shallow comparisons work.\n\t\t\t/* eslint-disable eqeqeq */\n\t\t\tap[ i ] == preferredDoc ? -1 :\n\t\t\tbp[ i ] == preferredDoc ? 1 :\n\t\t\t/* eslint-enable eqeqeq */\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\tsetDocument( elem );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!nonnativeSelectorCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\n\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch ( e ) {\n\t\t\tnonnativeSelectorCache( expr, true );\n\t\t}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( context.ownerDocument || context ) != document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\n\t// Set document vars if needed\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( ( elem.ownerDocument || elem ) != document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.escape = function( sel ) {\n\treturn ( sel + \"\" ).replace( rcssescape, fcssescape );\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( ( elem = results[ i++ ] ) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( ( node = elem[ i++ ] ) ) {\n\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[ 1 ] = match[ 1 ].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[ 3 ] = ( match[ 3 ] || match[ 4 ] ||\n\t\t\t\tmatch[ 5 ] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[ 2 ] === \"~=\" ) {\n\t\t\t\tmatch[ 3 ] = \" \" + match[ 3 ] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[ 1 ] = match[ 1 ].toLowerCase();\n\n\t\t\tif ( match[ 1 ].slice( 0, 3 ) === \"nth\" ) {\n\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[ 3 ] ) {\n\t\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[ 4 ] = +( match[ 4 ] ?\n\t\t\t\t\tmatch[ 5 ] + ( match[ 6 ] || 1 ) :\n\t\t\t\t\t2 * ( match[ 3 ] === \"even\" || match[ 3 ] === \"odd\" ) );\n\t\t\t\tmatch[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === \"odd\" );\n\n\t\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[ 3 ] ) {\n\t\t\t\tSizzle.error( match[ 0 ] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[ 6 ] && match[ 2 ];\n\n\t\t\tif ( matchExpr[ \"CHILD\" ].test( match[ 0 ] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[ 3 ] ) {\n\t\t\t\tmatch[ 2 ] = match[ 4 ] || match[ 5 ] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t( excess = tokenize( unquoted, true ) ) &&\n\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t( excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length ) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[ 0 ] = match[ 0 ].slice( 0, excess );\n\t\t\t\tmatch[ 2 ] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() {\n\t\t\t\t\treturn true;\n\t\t\t\t} :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t( pattern = new RegExp( \"(^|\" + whitespace +\n\t\t\t\t\t\")\" + className + \"(\" + whitespace + \"|$)\" ) ) && classCache(\n\t\t\t\t\t\tclassName, function( elem ) {\n\t\t\t\t\t\t\treturn pattern.test(\n\t\t\t\t\t\t\t\ttypeof elem.className === \"string\" && elem.className ||\n\t\t\t\t\t\t\t\ttypeof elem.getAttribute !== \"undefined\" &&\n\t\t\t\t\t\t\t\t\telem.getAttribute( \"class\" ) ||\n\t\t\t\t\t\t\t\t\"\"\n\t\t\t\t\t\t\t);\n\t\t\t\t} );\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\t/* eslint-disable max-len */\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t\t/* eslint-enable max-len */\n\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, _argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( ( node = node[ dir ] ) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || ( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( ( node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t( diff = nodeIndex = 0 ) || start.pop() ) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( node[ expando ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t( outerCache[ node.uniqueID ] = {} );\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction( function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[ i ] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[ i ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t} ) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction( function( selector ) {\n\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction( function( seed, matches, _context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\t\t\t\t\tseed[ i ] = !( matches[ i ] = elem );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} ) :\n\t\t\t\tfunction( elem, _context, xml ) {\n\t\t\t\t\tinput[ 0 ] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[ 0 ] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t} ),\n\n\t\t\"has\": markFunction( function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t} ),\n\n\t\t\"contains\": markFunction( function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t} ),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test( lang || \"\" ) ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( ( elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute( \"xml:lang\" ) || elem.getAttribute( \"lang\" ) ) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t} ),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement &&\n\t\t\t\t( !document.hasFocus || document.hasFocus() ) &&\n\t\t\t\t!!( elem.type || elem.href || ~elem.tabIndex );\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": createDisabledPseudo( false ),\n\t\t\"disabled\": createDisabledPseudo( true ),\n\n\t\t\"checked\": function( elem ) {\n\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn ( nodeName === \"input\" && !!elem.checked ) ||\n\t\t\t\t( nodeName === \"option\" && !!elem.selected );\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\t// eslint-disable-next-line no-unused-expressions\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[ \"empty\" ]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( ( attr = elem.getAttribute( \"type\" ) ) == null ||\n\t\t\t\t\tattr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo( function() {\n\t\t\treturn [ 0 ];\n\t\t} ),\n\n\t\t\"last\": createPositionalPseudo( function( _matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t} ),\n\n\t\t\"eq\": createPositionalPseudo( function( _matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t} ),\n\n\t\t\"even\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"odd\": createPositionalPseudo( function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"lt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ?\n\t\t\t\targument + length :\n\t\t\t\targument > length ?\n\t\t\t\t\tlength :\n\t\t\t\t\targument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} ),\n\n\t\t\"gt\": createPositionalPseudo( function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t} )\n\t}\n};\n\nExpr.pseudos[ \"nth\" ] = Expr.pseudos[ \"eq\" ];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || ( match = rcomma.exec( soFar ) ) ) {\n\t\t\tif ( match ) {\n\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[ 0 ].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( ( tokens = [] ) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( ( match = rcombinators.exec( soFar ) ) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push( {\n\t\t\t\tvalue: matched,\n\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[ 0 ].replace( rtrim, \" \" )\n\t\t\t} );\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||\n\t\t\t\t( match = preFilters[ type ]( match ) ) ) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push( {\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t} );\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[ i ].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tskip = combinator.next,\n\t\tkey = skip || dir,\n\t\tcheckNonElements = base && key === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( ( elem = elem[ dir ] ) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || ( elem[ expando ] = {} );\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] ||\n\t\t\t\t\t\t\t( outerCache[ elem.uniqueID ] = {} );\n\n\t\t\t\t\t\tif ( skip && skip === elem.nodeName.toLowerCase() ) {\n\t\t\t\t\t\t\telem = elem[ dir ] || elem;\n\t\t\t\t\t\t} else if ( ( oldCache = uniqueCache[ key ] ) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn ( newCache[ 2 ] = oldCache[ 2 ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ key ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[ i ]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[ 0 ];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[ i ], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( elem = unmatched[ i ] ) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction( function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(\n\t\t\t\tselector || \"*\",\n\t\t\t\tcontext.nodeType ? [ context ] : context,\n\t\t\t\t[]\n\t\t\t),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( ( elem = temp[ i ] ) ) {\n\t\t\t\t\tmatcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) ) {\n\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( ( matcherIn[ i ] = elem ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, ( matcherOut = [] ), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( ( elem = matcherOut[ i ] ) &&\n\t\t\t\t\t\t( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {\n\n\t\t\t\t\t\tseed[ temp ] = !( results[ temp ] = elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t} );\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[ 0 ].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[ \" \" ],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t( checkContext = context ).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {\n\t\t\tmatchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[ j ].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\n\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens\n\t\t\t\t\t\t.slice( 0, i - 1 )\n\t\t\t\t\t\t.concat( { value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" } )\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[ \"TAG\" ]( \"*\", outermost ),\n\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\n\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\toutermostContext = context == document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\t// Support: IE 11+, Edge 17 - 18+\n\t\t\t\t\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t\t\t\t\t// two documents; shallow comparisons work.\n\t\t\t\t\t// eslint-disable-next-line eqeqeq\n\t\t\t\t\tif ( !context && elem.ownerDocument != document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( ( matcher = elementMatchers[ j++ ] ) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml ) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( ( elem = !matcher && elem ) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( ( matcher = setMatchers[ j++ ] ) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !( unmatched[ i ] || setMatched[ i ] ) ) {\n\t\t\t\t\t\t\t\tsetMatched[ i ] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[ i ] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache(\n\t\t\tselector,\n\t\t\tmatcherFromGroupMatchers( elementMatchers, setMatchers )\n\t\t);\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find[ \"ID\" ]( token.matches[ 0 ]\n\t\t\t\t.replace( runescape, funescape ), context ) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[ \"needsContext\" ].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[ i ];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ ( type = token.type ) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( ( find = Expr.find[ type ] ) ) {\n\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( ( seed = find(\n\t\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext\n\t\t\t\t) ) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split( \"\" ).sort( sortOrder ).join( \"\" ) === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert( function( el ) {\n\n\t// Should return 1, but returns 4 (following)\n\treturn el.compareDocumentPosition( document.createElement( \"fieldset\" ) ) & 1;\n} );\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert( function( el ) {\n\tel.innerHTML = \"<a href='#'></a>\";\n\treturn el.firstChild.getAttribute( \"href\" ) === \"#\";\n} ) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert( function( el ) {\n\tel.innerHTML = \"<input/>\";\n\tel.firstChild.setAttribute( \"value\", \"\" );\n\treturn el.firstChild.getAttribute( \"value\" ) === \"\";\n} ) ) {\n\taddHandle( \"value\", function( elem, _name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t} );\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert( function( el ) {\n\treturn el.getAttribute( \"disabled\" ) == null;\n} ) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t( val = elem.getAttributeNode( name ) ) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\t\tnull;\n\t\t}\n\t} );\n}\n\nreturn Sizzle;\n\n} )( window );\n\n\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\n\n// Deprecated\njQuery.expr[ \":\" ] = jQuery.expr.pseudos;\njQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\njQuery.escapeSelector = Sizzle.escape;\n\n\n\n\nvar dir = function( elem, dir, until ) {\n\tvar matched = [],\n\t\ttruncate = until !== undefined;\n\n\twhile ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {\n\t\tif ( elem.nodeType === 1 ) {\n\t\t\tif ( truncate && jQuery( elem ).is( until ) ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmatched.push( elem );\n\t\t}\n\t}\n\treturn matched;\n};\n\n\nvar siblings = function( n, elem ) {\n\tvar matched = [];\n\n\tfor ( ; n; n = n.nextSibling ) {\n\t\tif ( n.nodeType === 1 && n !== elem ) {\n\t\t\tmatched.push( n );\n\t\t}\n\t}\n\n\treturn matched;\n};\n\n\nvar rneedsContext = jQuery.expr.match.needsContext;\n\n\n\nfunction nodeName( elem, name ) {\n\n  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n\n};\nvar rsingleTag = ( /^<([a-z][^\\/\\0>:\\x20\\t\\r\\n\\f]*)[\\x20\\t\\r\\n\\f]*\\/?>(?:<\\/\\1>|)$/i );\n\n\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n\tif ( isFunction( qualifier ) ) {\n\t\treturn jQuery.grep( elements, function( elem, i ) {\n\t\t\treturn !!qualifier.call( elem, i, elem ) !== not;\n\t\t} );\n\t}\n\n\t// Single element\n\tif ( qualifier.nodeType ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( elem === qualifier ) !== not;\n\t\t} );\n\t}\n\n\t// Arraylike of elements (jQuery, arguments, Array)\n\tif ( typeof qualifier !== \"string\" ) {\n\t\treturn jQuery.grep( elements, function( elem ) {\n\t\t\treturn ( indexOf.call( qualifier, elem ) > -1 ) !== not;\n\t\t} );\n\t}\n\n\t// Filtered directly for both simple and complex selectors\n\treturn jQuery.filter( qualifier, elements, not );\n}\n\njQuery.filter = function( expr, elems, not ) {\n\tvar elem = elems[ 0 ];\n\n\tif ( not ) {\n\t\texpr = \":not(\" + expr + \")\";\n\t}\n\n\tif ( elems.length === 1 && elem.nodeType === 1 ) {\n\t\treturn jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];\n\t}\n\n\treturn jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n\t\treturn elem.nodeType === 1;\n\t} ) );\n};\n\njQuery.fn.extend( {\n\tfind: function( selector ) {\n\t\tvar i, ret,\n\t\t\tlen = this.length,\n\t\t\tself = this;\n\n\t\tif ( typeof selector !== \"string\" ) {\n\t\t\treturn this.pushStack( jQuery( selector ).filter( function() {\n\t\t\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\t\t\tif ( jQuery.contains( self[ i ], this ) ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} ) );\n\t\t}\n\n\t\tret = this.pushStack( [] );\n\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\tjQuery.find( selector, self[ i ], ret );\n\t\t}\n\n\t\treturn len > 1 ? jQuery.uniqueSort( ret ) : ret;\n\t},\n\tfilter: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], false ) );\n\t},\n\tnot: function( selector ) {\n\t\treturn this.pushStack( winnow( this, selector || [], true ) );\n\t},\n\tis: function( selector ) {\n\t\treturn !!winnow(\n\t\t\tthis,\n\n\t\t\t// If this is a positional/relative selector, check membership in the returned set\n\t\t\t// so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n\t\t\ttypeof selector === \"string\" && rneedsContext.test( selector ) ?\n\t\t\t\tjQuery( selector ) :\n\t\t\t\tselector || [],\n\t\t\tfalse\n\t\t).length;\n\t}\n} );\n\n\n// Initialize a jQuery object\n\n\n// A central reference to the root jQuery(document)\nvar rootjQuery,\n\n\t// A simple way to check for HTML strings\n\t// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n\t// Strict HTML recognition (#11290: must start with <)\n\t// Shortcut simple #id case for speed\n\trquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]+))$/,\n\n\tinit = jQuery.fn.init = function( selector, context, root ) {\n\t\tvar match, elem;\n\n\t\t// HANDLE: $(\"\"), $(null), $(undefined), $(false)\n\t\tif ( !selector ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Method init() accepts an alternate rootjQuery\n\t\t// so migrate can support jQuery.sub (gh-2101)\n\t\troot = root || rootjQuery;\n\n\t\t// Handle HTML strings\n\t\tif ( typeof selector === \"string\" ) {\n\t\t\tif ( selector[ 0 ] === \"<\" &&\n\t\t\t\tselector[ selector.length - 1 ] === \">\" &&\n\t\t\t\tselector.length >= 3 ) {\n\n\t\t\t\t// Assume that strings that start and end with <> are HTML and skip the regex check\n\t\t\t\tmatch = [ null, selector, null ];\n\n\t\t\t} else {\n\t\t\t\tmatch = rquickExpr.exec( selector );\n\t\t\t}\n\n\t\t\t// Match html or make sure no context is specified for #id\n\t\t\tif ( match && ( match[ 1 ] || !context ) ) {\n\n\t\t\t\t// HANDLE: $(html) -> $(array)\n\t\t\t\tif ( match[ 1 ] ) {\n\t\t\t\t\tcontext = context instanceof jQuery ? context[ 0 ] : context;\n\n\t\t\t\t\t// Option to run scripts is true for back-compat\n\t\t\t\t\t// Intentionally let the error be thrown if parseHTML is not present\n\t\t\t\t\tjQuery.merge( this, jQuery.parseHTML(\n\t\t\t\t\t\tmatch[ 1 ],\n\t\t\t\t\t\tcontext && context.nodeType ? context.ownerDocument || context : document,\n\t\t\t\t\t\ttrue\n\t\t\t\t\t) );\n\n\t\t\t\t\t// HANDLE: $(html, props)\n\t\t\t\t\tif ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {\n\t\t\t\t\t\tfor ( match in context ) {\n\n\t\t\t\t\t\t\t// Properties of context are called as methods if possible\n\t\t\t\t\t\t\tif ( isFunction( this[ match ] ) ) {\n\t\t\t\t\t\t\t\tthis[ match ]( context[ match ] );\n\n\t\t\t\t\t\t\t// ...and otherwise set as attributes\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.attr( match, context[ match ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\n\t\t\t\t// HANDLE: $(#id)\n\t\t\t\t} else {\n\t\t\t\t\telem = document.getElementById( match[ 2 ] );\n\n\t\t\t\t\tif ( elem ) {\n\n\t\t\t\t\t\t// Inject the element directly into the jQuery object\n\t\t\t\t\t\tthis[ 0 ] = elem;\n\t\t\t\t\t\tthis.length = 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t// HANDLE: $(expr, $(...))\n\t\t\t} else if ( !context || context.jquery ) {\n\t\t\t\treturn ( context || root ).find( selector );\n\n\t\t\t// HANDLE: $(expr, context)\n\t\t\t// (which is just equivalent to: $(context).find(expr)\n\t\t\t} else {\n\t\t\t\treturn this.constructor( context ).find( selector );\n\t\t\t}\n\n\t\t// HANDLE: $(DOMElement)\n\t\t} else if ( selector.nodeType ) {\n\t\t\tthis[ 0 ] = selector;\n\t\t\tthis.length = 1;\n\t\t\treturn this;\n\n\t\t// HANDLE: $(function)\n\t\t// Shortcut for document ready\n\t\t} else if ( isFunction( selector ) ) {\n\t\t\treturn root.ready !== undefined ?\n\t\t\t\troot.ready( selector ) :\n\n\t\t\t\t// Execute immediately if ready is not present\n\t\t\t\tselector( jQuery );\n\t\t}\n\n\t\treturn jQuery.makeArray( selector, this );\n\t};\n\n// Give the init function the jQuery prototype for later instantiation\ninit.prototype = jQuery.fn;\n\n// Initialize central reference\nrootjQuery = jQuery( document );\n\n\nvar rparentsprev = /^(?:parents|prev(?:Until|All))/,\n\n\t// Methods guaranteed to produce a unique set when starting from a unique set\n\tguaranteedUnique = {\n\t\tchildren: true,\n\t\tcontents: true,\n\t\tnext: true,\n\t\tprev: true\n\t};\n\njQuery.fn.extend( {\n\thas: function( target ) {\n\t\tvar targets = jQuery( target, this ),\n\t\t\tl = targets.length;\n\n\t\treturn this.filter( function() {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tif ( jQuery.contains( this, targets[ i ] ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\tclosest: function( selectors, context ) {\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\tl = this.length,\n\t\t\tmatched = [],\n\t\t\ttargets = typeof selectors !== \"string\" && jQuery( selectors );\n\n\t\t// Positional selectors never match, since there's no _selection_ context\n\t\tif ( !rneedsContext.test( selectors ) ) {\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tfor ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {\n\n\t\t\t\t\t// Always skip document fragments\n\t\t\t\t\tif ( cur.nodeType < 11 && ( targets ?\n\t\t\t\t\t\ttargets.index( cur ) > -1 :\n\n\t\t\t\t\t\t// Don't pass non-elements to Sizzle\n\t\t\t\t\t\tcur.nodeType === 1 &&\n\t\t\t\t\t\t\tjQuery.find.matchesSelector( cur, selectors ) ) ) {\n\n\t\t\t\t\t\tmatched.push( cur );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );\n\t},\n\n\t// Determine the position of an element within the set\n\tindex: function( elem ) {\n\n\t\t// No argument, return index in parent\n\t\tif ( !elem ) {\n\t\t\treturn ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;\n\t\t}\n\n\t\t// Index in selector\n\t\tif ( typeof elem === \"string\" ) {\n\t\t\treturn indexOf.call( jQuery( elem ), this[ 0 ] );\n\t\t}\n\n\t\t// Locate the position of the desired element\n\t\treturn indexOf.call( this,\n\n\t\t\t// If it receives a jQuery object, the first element is used\n\t\t\telem.jquery ? elem[ 0 ] : elem\n\t\t);\n\t},\n\n\tadd: function( selector, context ) {\n\t\treturn this.pushStack(\n\t\t\tjQuery.uniqueSort(\n\t\t\t\tjQuery.merge( this.get(), jQuery( selector, context ) )\n\t\t\t)\n\t\t);\n\t},\n\n\taddBack: function( selector ) {\n\t\treturn this.add( selector == null ?\n\t\t\tthis.prevObject : this.prevObject.filter( selector )\n\t\t);\n\t}\n} );\n\nfunction sibling( cur, dir ) {\n\twhile ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}\n\treturn cur;\n}\n\njQuery.each( {\n\tparent: function( elem ) {\n\t\tvar parent = elem.parentNode;\n\t\treturn parent && parent.nodeType !== 11 ? parent : null;\n\t},\n\tparents: function( elem ) {\n\t\treturn dir( elem, \"parentNode\" );\n\t},\n\tparentsUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"parentNode\", until );\n\t},\n\tnext: function( elem ) {\n\t\treturn sibling( elem, \"nextSibling\" );\n\t},\n\tprev: function( elem ) {\n\t\treturn sibling( elem, \"previousSibling\" );\n\t},\n\tnextAll: function( elem ) {\n\t\treturn dir( elem, \"nextSibling\" );\n\t},\n\tprevAll: function( elem ) {\n\t\treturn dir( elem, \"previousSibling\" );\n\t},\n\tnextUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"nextSibling\", until );\n\t},\n\tprevUntil: function( elem, _i, until ) {\n\t\treturn dir( elem, \"previousSibling\", until );\n\t},\n\tsiblings: function( elem ) {\n\t\treturn siblings( ( elem.parentNode || {} ).firstChild, elem );\n\t},\n\tchildren: function( elem ) {\n\t\treturn siblings( elem.firstChild );\n\t},\n\tcontents: function( elem ) {\n\t\tif ( elem.contentDocument != null &&\n\n\t\t\t// Support: IE 11+\n\t\t\t// <object> elements with no `data` attribute has an object\n\t\t\t// `contentDocument` with a `null` prototype.\n\t\t\tgetProto( elem.contentDocument ) ) {\n\n\t\t\treturn elem.contentDocument;\n\t\t}\n\n\t\t// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only\n\t\t// Treat the template element as a regular one in browsers that\n\t\t// don't support it.\n\t\tif ( nodeName( elem, \"template\" ) ) {\n\t\t\telem = elem.content || elem;\n\t\t}\n\n\t\treturn jQuery.merge( [], elem.childNodes );\n\t}\n}, function( name, fn ) {\n\tjQuery.fn[ name ] = function( until, selector ) {\n\t\tvar matched = jQuery.map( this, fn, until );\n\n\t\tif ( name.slice( -5 ) !== \"Until\" ) {\n\t\t\tselector = until;\n\t\t}\n\n\t\tif ( selector && typeof selector === \"string\" ) {\n\t\t\tmatched = jQuery.filter( selector, matched );\n\t\t}\n\n\t\tif ( this.length > 1 ) {\n\n\t\t\t// Remove duplicates\n\t\t\tif ( !guaranteedUnique[ name ] ) {\n\t\t\t\tjQuery.uniqueSort( matched );\n\t\t\t}\n\n\t\t\t// Reverse order for parents* and prev-derivatives\n\t\t\tif ( rparentsprev.test( name ) ) {\n\t\t\t\tmatched.reverse();\n\t\t\t}\n\t\t}\n\n\t\treturn this.pushStack( matched );\n\t};\n} );\nvar rnothtmlwhite = ( /[^\\x20\\t\\r\\n\\f]+/g );\n\n\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the master Deferred\n\t\t\tmaster = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tmaster.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( master.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn master.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), master.reject );\n\t\t}\n\n\t\treturn master.promise();\n\t}\n} );\n\n\n// These usually indicate a programmer mistake during development,\n// warn about them ASAP rather than swallowing them by default.\nvar rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;\n\njQuery.Deferred.exceptionHook = function( error, stack ) {\n\n\t// Support: IE 8 - 9 only\n\t// Console exists when dev tools are open, which can happen at any time\n\tif ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {\n\t\twindow.console.warn( \"jQuery.Deferred exception: \" + error.message, error.stack, stack );\n\t}\n};\n\n\n\n\njQuery.readyException = function( error ) {\n\twindow.setTimeout( function() {\n\t\tthrow error;\n\t} );\n};\n\n\n\n\n// The deferred used on DOM ready\nvar readyList = jQuery.Deferred();\n\njQuery.fn.ready = function( fn ) {\n\n\treadyList\n\t\t.then( fn )\n\n\t\t// Wrap jQuery.readyException in a function so that the lookup\n\t\t// happens at the time of error handling instead of callback\n\t\t// registration.\n\t\t.catch( function( error ) {\n\t\t\tjQuery.readyException( error );\n\t\t} );\n\n\treturn this;\n};\n\njQuery.extend( {\n\n\t// Is the DOM ready to be used? Set to true once it occurs.\n\tisReady: false,\n\n\t// A counter to track how many items to wait for before\n\t// the ready event fires. See #6781\n\treadyWait: 1,\n\n\t// Handle when the DOM is ready\n\tready: function( wait ) {\n\n\t\t// Abort if there are pending holds or we're already ready\n\t\tif ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Remember that the DOM is ready\n\t\tjQuery.isReady = true;\n\n\t\t// If a normal DOM Ready event fired, decrement, and wait if need be\n\t\tif ( wait !== true && --jQuery.readyWait > 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are functions bound, to execute\n\t\treadyList.resolveWith( document, [ jQuery ] );\n\t}\n} );\n\njQuery.ready.then = readyList.then;\n\n// The ready event handler and self cleanup method\nfunction completed() {\n\tdocument.removeEventListener( \"DOMContentLoaded\", completed );\n\twindow.removeEventListener( \"load\", completed );\n\tjQuery.ready();\n}\n\n// Catch cases where $(document).ready() is called\n// after the browser event has already occurred.\n// Support: IE <=9 - 10 only\n// Older IE sometimes signals \"interactive\" too soon\nif ( document.readyState === \"complete\" ||\n\t( document.readyState !== \"loading\" && !document.documentElement.doScroll ) ) {\n\n\t// Handle it asynchronously to allow scripts the opportunity to delay ready\n\twindow.setTimeout( jQuery.ready );\n\n} else {\n\n\t// Use the handy event callback\n\tdocument.addEventListener( \"DOMContentLoaded\", completed );\n\n\t// A fallback to window.onload, that will always work\n\twindow.addEventListener( \"load\", completed );\n}\n\n\n\n\n// Multifunctional method to get and set values of a collection\n// The value/s can optionally be executed if it's a function\nvar access = function( elems, fn, key, value, chainable, emptyGet, raw ) {\n\tvar i = 0,\n\t\tlen = elems.length,\n\t\tbulk = key == null;\n\n\t// Sets many values\n\tif ( toType( key ) === \"object\" ) {\n\t\tchainable = true;\n\t\tfor ( i in key ) {\n\t\t\taccess( elems, fn, i, key[ i ], true, emptyGet, raw );\n\t\t}\n\n\t// Sets one value\n\t} else if ( value !== undefined ) {\n\t\tchainable = true;\n\n\t\tif ( !isFunction( value ) ) {\n\t\t\traw = true;\n\t\t}\n\n\t\tif ( bulk ) {\n\n\t\t\t// Bulk operations run against the entire set\n\t\t\tif ( raw ) {\n\t\t\t\tfn.call( elems, value );\n\t\t\t\tfn = null;\n\n\t\t\t// ...except when executing function values\n\t\t\t} else {\n\t\t\t\tbulk = fn;\n\t\t\t\tfn = function( elem, _key, value ) {\n\t\t\t\t\treturn bulk.call( jQuery( elem ), value );\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif ( fn ) {\n\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\tfn(\n\t\t\t\t\telems[ i ], key, raw ?\n\t\t\t\t\tvalue :\n\t\t\t\t\tvalue.call( elems[ i ], i, fn( elems[ i ], key ) )\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( chainable ) {\n\t\treturn elems;\n\t}\n\n\t// Gets\n\tif ( bulk ) {\n\t\treturn fn.call( elems );\n\t}\n\n\treturn len ? fn( elems[ 0 ], key ) : emptyGet;\n};\n\n\n// Matches dashed string for camelizing\nvar rmsPrefix = /^-ms-/,\n\trdashAlpha = /-([a-z])/g;\n\n// Used by camelCase as callback to replace()\nfunction fcamelCase( _all, letter ) {\n\treturn letter.toUpperCase();\n}\n\n// Convert dashed to camelCase; used by the css and data modules\n// Support: IE <=9 - 11, Edge 12 - 15\n// Microsoft forgot to hump their vendor prefix (#9572)\nfunction camelCase( string ) {\n\treturn string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n}\nvar acceptData = function( owner ) {\n\n\t// Accepts only:\n\t//  - Node\n\t//    - Node.ELEMENT_NODE\n\t//    - Node.DOCUMENT_NODE\n\t//  - Object\n\t//    - Any\n\treturn owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );\n};\n\n\n\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tcache: function( owner ) {\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\t// Always use camelCase key (gh-2257)\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ camelCase( data ) ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ camelCase( prop ) ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\n\t\t\t// Always use camelCase key (gh-2257)\n\t\t\towner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];\n\t},\n\taccess: function( owner, key, value ) {\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\treturn this.get( owner, key );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key !== undefined ) {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( Array.isArray( key ) ) {\n\n\t\t\t\t// If key is an array of keys...\n\t\t\t\t// We always set camelCase keys, so remove that.\n\t\t\t\tkey = key.map( camelCase );\n\t\t\t} else {\n\t\t\t\tkey = camelCase( key );\n\n\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\tkey = key in cache ?\n\t\t\t\t\t[ key ] :\n\t\t\t\t\t( key.match( rnothtmlwhite ) || [] );\n\t\t\t}\n\n\t\t\ti = key.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ key[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <=35 - 45\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\nvar dataPriv = new Data();\n\nvar dataUser = new Data();\n\n\n\n//\tImplementation Summary\n//\n//\t1. Enforce API surface and semantic compatibility with 1.9.x branch\n//\t2. Improve the module's maintainability by reducing the storage\n//\t\tpaths to a single mechanism.\n//\t3. Use the same single mechanism to support \"private\" and \"user\" data.\n//\t4. _Never_ expose \"private\" data to user code (TODO: Drop _data, _removeData)\n//\t5. Avoid exposing implementation details on user objects (eg. expando properties)\n//\t6. Provide a clear path for implementation upgrade to WeakMap in 2014\n\nvar rbrace = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n\trmultiDash = /[A-Z]/g;\n\nfunction getData( data ) {\n\tif ( data === \"true\" ) {\n\t\treturn true;\n\t}\n\n\tif ( data === \"false\" ) {\n\t\treturn false;\n\t}\n\n\tif ( data === \"null\" ) {\n\t\treturn null;\n\t}\n\n\t// Only convert to a number if it doesn't change the string\n\tif ( data === +data + \"\" ) {\n\t\treturn +data;\n\t}\n\n\tif ( rbrace.test( data ) ) {\n\t\treturn JSON.parse( data );\n\t}\n\n\treturn data;\n}\n\nfunction dataAttr( elem, key, data ) {\n\tvar name;\n\n\t// If nothing was found internally, try to fetch any\n\t// data from the HTML5 data-* attribute\n\tif ( data === undefined && elem.nodeType === 1 ) {\n\t\tname = \"data-\" + key.replace( rmultiDash, \"-$&\" ).toLowerCase();\n\t\tdata = elem.getAttribute( name );\n\n\t\tif ( typeof data === \"string\" ) {\n\t\t\ttry {\n\t\t\t\tdata = getData( data );\n\t\t\t} catch ( e ) {}\n\n\t\t\t// Make sure we set the data so it isn't changed later\n\t\t\tdataUser.set( elem, key, data );\n\t\t} else {\n\t\t\tdata = undefined;\n\t\t}\n\t}\n\treturn data;\n}\n\njQuery.extend( {\n\thasData: function( elem ) {\n\t\treturn dataUser.hasData( elem ) || dataPriv.hasData( elem );\n\t},\n\n\tdata: function( elem, name, data ) {\n\t\treturn dataUser.access( elem, name, data );\n\t},\n\n\tremoveData: function( elem, name ) {\n\t\tdataUser.remove( elem, name );\n\t},\n\n\t// TODO: Now that all calls to _data and _removeData have been replaced\n\t// with direct calls to dataPriv methods, these can be deprecated.\n\t_data: function( elem, name, data ) {\n\t\treturn dataPriv.access( elem, name, data );\n\t},\n\n\t_removeData: function( elem, name ) {\n\t\tdataPriv.remove( elem, name );\n\t}\n} );\n\njQuery.fn.extend( {\n\tdata: function( key, value ) {\n\t\tvar i, name, data,\n\t\t\telem = this[ 0 ],\n\t\t\tattrs = elem && elem.attributes;\n\n\t\t// Gets all values\n\t\tif ( key === undefined ) {\n\t\t\tif ( this.length ) {\n\t\t\t\tdata = dataUser.get( elem );\n\n\t\t\t\tif ( elem.nodeType === 1 && !dataPriv.get( elem, \"hasDataAttrs\" ) ) {\n\t\t\t\t\ti = attrs.length;\n\t\t\t\t\twhile ( i-- ) {\n\n\t\t\t\t\t\t// Support: IE 11 only\n\t\t\t\t\t\t// The attrs elements can be null (#14894)\n\t\t\t\t\t\tif ( attrs[ i ] ) {\n\t\t\t\t\t\t\tname = attrs[ i ].name;\n\t\t\t\t\t\t\tif ( name.indexOf( \"data-\" ) === 0 ) {\n\t\t\t\t\t\t\t\tname = camelCase( name.slice( 5 ) );\n\t\t\t\t\t\t\t\tdataAttr( elem, name, data[ name ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataPriv.set( elem, \"hasDataAttrs\", true );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn data;\n\t\t}\n\n\t\t// Sets multiple values\n\t\tif ( typeof key === \"object\" ) {\n\t\t\treturn this.each( function() {\n\t\t\t\tdataUser.set( this, key );\n\t\t\t} );\n\t\t}\n\n\t\treturn access( this, function( value ) {\n\t\t\tvar data;\n\n\t\t\t// The calling jQuery object (element matches) is not empty\n\t\t\t// (and therefore has an element appears at this[ 0 ]) and the\n\t\t\t// `value` parameter was not undefined. An empty jQuery object\n\t\t\t// will result in `undefined` for elem = this[ 0 ] which will\n\t\t\t// throw an exception if an attempt to read a data cache is made.\n\t\t\tif ( elem && value === undefined ) {\n\n\t\t\t\t// Attempt to get data from the cache\n\t\t\t\t// The key will always be camelCased in Data\n\t\t\t\tdata = dataUser.get( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// Attempt to \"discover\" the data in\n\t\t\t\t// HTML5 custom data-* attrs\n\t\t\t\tdata = dataAttr( elem, key );\n\t\t\t\tif ( data !== undefined ) {\n\t\t\t\t\treturn data;\n\t\t\t\t}\n\n\t\t\t\t// We tried really hard, but the data doesn't exist.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Set the data...\n\t\t\tthis.each( function() {\n\n\t\t\t\t// We always store the camelCased key\n\t\t\t\tdataUser.set( this, key, value );\n\t\t\t} );\n\t\t}, null, value, arguments.length > 1, null, true );\n\t},\n\n\tremoveData: function( key ) {\n\t\treturn this.each( function() {\n\t\t\tdataUser.remove( this, key );\n\t\t} );\n\t}\n} );\n\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\nvar pnum = ( /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/ ).source;\n\nvar rcssNum = new RegExp( \"^(?:([+-])=|)(\" + pnum + \")([a-z%]*)$\", \"i\" );\n\n\nvar cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ];\n\nvar documentElement = document.documentElement;\n\n\n\n\tvar isAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem );\n\t\t},\n\t\tcomposed = { composed: true };\n\n\t// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only\n\t// Check attachment across shadow DOM boundaries when possible (gh-3504)\n\t// Support: iOS 10.0-10.2 only\n\t// Early iOS 10 versions support `attachShadow` but not `getRootNode`,\n\t// leading to errors. We need to check for `getRootNode`.\n\tif ( documentElement.getRootNode ) {\n\t\tisAttached = function( elem ) {\n\t\t\treturn jQuery.contains( elem.ownerDocument, elem ) ||\n\t\t\t\telem.getRootNode( composed ) === elem.ownerDocument;\n\t\t};\n\t}\nvar isHiddenWithinTree = function( elem, el ) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" ||\n\t\t\telem.style.display === \"\" &&\n\n\t\t\t// Otherwise, check computed style\n\t\t\t// Support: Firefox <=43 - 45\n\t\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t\t// in the document.\n\t\t\tisAttached( elem ) &&\n\n\t\t\tjQuery.css( elem, \"display\" ) === \"none\";\n\t};\n\n\n\nfunction adjustCSS( elem, prop, valueParts, tween ) {\n\tvar adjusted, scale,\n\t\tmaxIterations = 20,\n\t\tcurrentValue = tween ?\n\t\t\tfunction() {\n\t\t\t\treturn tween.cur();\n\t\t\t} :\n\t\t\tfunction() {\n\t\t\t\treturn jQuery.css( elem, prop, \"\" );\n\t\t\t},\n\t\tinitial = currentValue(),\n\t\tunit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n\t\t// Starting value computation is required for potential unit mismatches\n\t\tinitialInUnit = elem.nodeType &&\n\t\t\t( jQuery.cssNumber[ prop ] || unit !== \"px\" && +initial ) &&\n\t\t\trcssNum.exec( jQuery.css( elem, prop ) );\n\n\tif ( initialInUnit && initialInUnit[ 3 ] !== unit ) {\n\n\t\t// Support: Firefox <=54\n\t\t// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)\n\t\tinitial = initial / 2;\n\n\t\t// Trust units reported by jQuery.css\n\t\tunit = unit || initialInUnit[ 3 ];\n\n\t\t// Iteratively approximate from a nonzero starting point\n\t\tinitialInUnit = +initial || 1;\n\n\t\twhile ( maxIterations-- ) {\n\n\t\t\t// Evaluate and update our best guess (doubling guesses that zero out).\n\t\t\t// Finish if the scale equals or crosses 1 (making the old*new product non-positive).\n\t\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\t\t\tif ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {\n\t\t\t\tmaxIterations = 0;\n\t\t\t}\n\t\t\tinitialInUnit = initialInUnit / scale;\n\n\t\t}\n\n\t\tinitialInUnit = initialInUnit * 2;\n\t\tjQuery.style( elem, prop, initialInUnit + unit );\n\n\t\t// Make sure we update the tween properties later on\n\t\tvalueParts = valueParts || [];\n\t}\n\n\tif ( valueParts ) {\n\t\tinitialInUnit = +initialInUnit || +initial || 0;\n\n\t\t// Apply relative offset (+=/-=) if specified\n\t\tadjusted = valueParts[ 1 ] ?\n\t\t\tinitialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :\n\t\t\t+valueParts[ 2 ];\n\t\tif ( tween ) {\n\t\t\ttween.unit = unit;\n\t\t\ttween.start = initialInUnit;\n\t\t\ttween.end = adjusted;\n\t\t}\n\t}\n\treturn adjusted;\n}\n\n\nvar defaultDisplayMap = {};\n\nfunction getDefaultDisplay( elem ) {\n\tvar temp,\n\t\tdoc = elem.ownerDocument,\n\t\tnodeName = elem.nodeName,\n\t\tdisplay = defaultDisplayMap[ nodeName ];\n\n\tif ( display ) {\n\t\treturn display;\n\t}\n\n\ttemp = doc.body.appendChild( doc.createElement( nodeName ) );\n\tdisplay = jQuery.css( temp, \"display\" );\n\n\ttemp.parentNode.removeChild( temp );\n\n\tif ( display === \"none\" ) {\n\t\tdisplay = \"block\";\n\t}\n\tdefaultDisplayMap[ nodeName ] = display;\n\n\treturn display;\n}\n\nfunction showHide( elements, show ) {\n\tvar display, elem,\n\t\tvalues = [],\n\t\tindex = 0,\n\t\tlength = elements.length;\n\n\t// Determine new display value for elements that need to change\n\tfor ( ; index < length; index++ ) {\n\t\telem = elements[ index ];\n\t\tif ( !elem.style ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdisplay = elem.style.display;\n\t\tif ( show ) {\n\n\t\t\t// Since we force visibility upon cascade-hidden elements, an immediate (and slow)\n\t\t\t// check is required in this first loop unless we have a nonempty display value (either\n\t\t\t// inline or about-to-be-restored)\n\t\t\tif ( display === \"none\" ) {\n\t\t\t\tvalues[ index ] = dataPriv.get( elem, \"display\" ) || null;\n\t\t\t\tif ( !values[ index ] ) {\n\t\t\t\t\telem.style.display = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( elem.style.display === \"\" && isHiddenWithinTree( elem ) ) {\n\t\t\t\tvalues[ index ] = getDefaultDisplay( elem );\n\t\t\t}\n\t\t} else {\n\t\t\tif ( display !== \"none\" ) {\n\t\t\t\tvalues[ index ] = \"none\";\n\n\t\t\t\t// Remember what we're overwriting\n\t\t\t\tdataPriv.set( elem, \"display\", display );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Set the display of the elements in a second loop to avoid constant reflow\n\tfor ( index = 0; index < length; index++ ) {\n\t\tif ( values[ index ] != null ) {\n\t\t\telements[ index ].style.display = values[ index ];\n\t\t}\n\t}\n\n\treturn elements;\n}\n\njQuery.fn.extend( {\n\tshow: function() {\n\t\treturn showHide( this, true );\n\t},\n\thide: function() {\n\t\treturn showHide( this );\n\t},\n\ttoggle: function( state ) {\n\t\tif ( typeof state === \"boolean\" ) {\n\t\t\treturn state ? this.show() : this.hide();\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tif ( isHiddenWithinTree( this ) ) {\n\t\t\t\tjQuery( this ).show();\n\t\t\t} else {\n\t\t\t\tjQuery( this ).hide();\n\t\t\t}\n\t\t} );\n\t}\n} );\nvar rcheckableType = ( /^(?:checkbox|radio)$/i );\n\nvar rtagName = ( /<([a-z][^\\/\\0>\\x20\\t\\r\\n\\f]*)/i );\n\nvar rscriptType = ( /^$|^module$|\\/(?:java|ecma)script/i );\n\n\n\n( function() {\n\tvar fragment = document.createDocumentFragment(),\n\t\tdiv = fragment.appendChild( document.createElement( \"div\" ) ),\n\t\tinput = document.createElement( \"input\" );\n\n\t// Support: Android 4.0 - 4.3 only\n\t// Check state lost if the name is set (#11217)\n\t// Support: Windows Web Apps (WWA)\n\t// `name` and `type` must use .setAttribute for WWA (#14901)\n\tinput.setAttribute( \"type\", \"radio\" );\n\tinput.setAttribute( \"checked\", \"checked\" );\n\tinput.setAttribute( \"name\", \"t\" );\n\n\tdiv.appendChild( input );\n\n\t// Support: Android <=4.1 only\n\t// Older WebKit doesn't clone checked state correctly in fragments\n\tsupport.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n\t// Support: IE <=11 only\n\t// Make sure textarea (and checkbox) defaultValue is properly cloned\n\tdiv.innerHTML = \"<textarea>x</textarea>\";\n\tsupport.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;\n\n\t// Support: IE <=9 only\n\t// IE <=9 replaces <option> tags with their contents when inserted outside of\n\t// the select element.\n\tdiv.innerHTML = \"<option></option>\";\n\tsupport.option = !!div.lastChild;\n} )();\n\n\n// We have to close these tags to support XHTML (#13200)\nvar wrapMap = {\n\n\t// XHTML parsers do not magically insert elements in the\n\t// same way that tag soup parsers do. So we cannot shorten\n\t// this by omitting <tbody> or other required elements.\n\tthead: [ 1, \"<table>\", \"</table>\" ],\n\tcol: [ 2, \"<table><colgroup>\", \"</colgroup></table>\" ],\n\ttr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n\ttd: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n\t_default: [ 0, \"\", \"\" ]\n};\n\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support: IE <=9 only\nif ( !support.option ) {\n\twrapMap.optgroup = wrapMap.option = [ 1, \"<select multiple='multiple'>\", \"</select>\" ];\n}\n\n\nfunction getAll( context, tag ) {\n\n\t// Support: IE <=9 - 11 only\n\t// Use typeof to avoid zero-argument method invocation on host objects (#15151)\n\tvar ret;\n\n\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\tret = context.getElementsByTagName( tag || \"*\" );\n\n\t} else if ( typeof context.querySelectorAll !== \"undefined\" ) {\n\t\tret = context.querySelectorAll( tag || \"*\" );\n\n\t} else {\n\t\tret = [];\n\t}\n\n\tif ( tag === undefined || tag && nodeName( context, tag ) ) {\n\t\treturn jQuery.merge( [ context ], ret );\n\t}\n\n\treturn ret;\n}\n\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n\tvar i = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\tdataPriv.set(\n\t\t\telems[ i ],\n\t\t\t\"globalEval\",\n\t\t\t!refElements || dataPriv.get( refElements[ i ], \"globalEval\" )\n\t\t);\n\t}\n}\n\n\nvar rhtml = /<|&#?\\w+;/;\n\nfunction buildFragment( elems, context, scripts, selection, ignored ) {\n\tvar elem, tmp, tag, wrap, attached, j,\n\t\tfragment = context.createDocumentFragment(),\n\t\tnodes = [],\n\t\ti = 0,\n\t\tl = elems.length;\n\n\tfor ( ; i < l; i++ ) {\n\t\telem = elems[ i ];\n\n\t\tif ( elem || elem === 0 ) {\n\n\t\t\t// Add nodes directly\n\t\t\tif ( toType( elem ) === \"object\" ) {\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n\t\t\t// Convert non-html into a text node\n\t\t\t} else if ( !rhtml.test( elem ) ) {\n\t\t\t\tnodes.push( context.createTextNode( elem ) );\n\n\t\t\t// Convert html into DOM nodes\n\t\t\t} else {\n\t\t\t\ttmp = tmp || fragment.appendChild( context.createElement( \"div\" ) );\n\n\t\t\t\t// Deserialize a standard representation\n\t\t\t\ttag = ( rtagName.exec( elem ) || [ \"\", \"\" ] )[ 1 ].toLowerCase();\n\t\t\t\twrap = wrapMap[ tag ] || wrapMap._default;\n\t\t\t\ttmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];\n\n\t\t\t\t// Descend through wrappers to the right content\n\t\t\t\tj = wrap[ 0 ];\n\t\t\t\twhile ( j-- ) {\n\t\t\t\t\ttmp = tmp.lastChild;\n\t\t\t\t}\n\n\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\tjQuery.merge( nodes, tmp.childNodes );\n\n\t\t\t\t// Remember the top-level container\n\t\t\t\ttmp = fragment.firstChild;\n\n\t\t\t\t// Ensure the created nodes are orphaned (#12392)\n\t\t\t\ttmp.textContent = \"\";\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove wrapper from fragment\n\tfragment.textContent = \"\";\n\n\ti = 0;\n\twhile ( ( elem = nodes[ i++ ] ) ) {\n\n\t\t// Skip elements already in the context collection (trac-4087)\n\t\tif ( selection && jQuery.inArray( elem, selection ) > -1 ) {\n\t\t\tif ( ignored ) {\n\t\t\t\tignored.push( elem );\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tattached = isAttached( elem );\n\n\t\t// Append to fragment\n\t\ttmp = getAll( fragment.appendChild( elem ), \"script\" );\n\n\t\t// Preserve script evaluation history\n\t\tif ( attached ) {\n\t\t\tsetGlobalEval( tmp );\n\t\t}\n\n\t\t// Capture executables\n\t\tif ( scripts ) {\n\t\t\tj = 0;\n\t\t\twhile ( ( elem = tmp[ j++ ] ) ) {\n\t\t\t\tif ( rscriptType.test( elem.type || \"\" ) ) {\n\t\t\t\t\tscripts.push( elem );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn fragment;\n}\n\n\nvar\n\trkeyEvent = /^key/,\n\trmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n\trtypenamespace = /^([^.]*)(?:\\.(.+)|)/;\n\nfunction returnTrue() {\n\treturn true;\n}\n\nfunction returnFalse() {\n\treturn false;\n}\n\n// Support: IE <=9 - 11+\n// focus() and blur() are asynchronous, except when they are no-op.\n// So expect focus to be synchronous when the element is already active,\n// and blur to be synchronous when the element is not already active.\n// (focus and blur are always synchronous in other supported browsers,\n// this just defines when we can count on it).\nfunction expectSync( elem, type ) {\n\treturn ( elem === safeActiveElement() ) === ( type === \"focus\" );\n}\n\n// Support: IE <=9 only\n// Accessing document.activeElement can throw unexpectedly\n// https://bugs.jquery.com/ticket/13393\nfunction safeActiveElement() {\n\ttry {\n\t\treturn document.activeElement;\n\t} catch ( err ) { }\n}\n\nfunction on( elem, types, selector, data, fn, one ) {\n\tvar origFn, type;\n\n\t// Types can be a map of types/handlers\n\tif ( typeof types === \"object\" ) {\n\n\t\t// ( types-Object, selector, data )\n\t\tif ( typeof selector !== \"string\" ) {\n\n\t\t\t// ( types-Object, data )\n\t\t\tdata = data || selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tfor ( type in types ) {\n\t\t\ton( elem, type, selector, data, types[ type ], one );\n\t\t}\n\t\treturn elem;\n\t}\n\n\tif ( data == null && fn == null ) {\n\n\t\t// ( types, fn )\n\t\tfn = selector;\n\t\tdata = selector = undefined;\n\t} else if ( fn == null ) {\n\t\tif ( typeof selector === \"string\" ) {\n\n\t\t\t// ( types, selector, fn )\n\t\t\tfn = data;\n\t\t\tdata = undefined;\n\t\t} else {\n\n\t\t\t// ( types, data, fn )\n\t\t\tfn = data;\n\t\t\tdata = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t}\n\tif ( fn === false ) {\n\t\tfn = returnFalse;\n\t} else if ( !fn ) {\n\t\treturn elem;\n\t}\n\n\tif ( one === 1 ) {\n\t\torigFn = fn;\n\t\tfn = function( event ) {\n\n\t\t\t// Can use an empty set, since event contains the info\n\t\t\tjQuery().off( event );\n\t\t\treturn origFn.apply( this, arguments );\n\t\t};\n\n\t\t// Use same guid so caller can remove using origFn\n\t\tfn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n\t}\n\treturn elem.each( function() {\n\t\tjQuery.event.add( this, types, fn, data, selector );\n\t} );\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n\tglobal: {},\n\n\tadd: function( elem, types, handler, data, selector ) {\n\n\t\tvar handleObjIn, eventHandle, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.get( elem );\n\n\t\t// Only attach events to objects that accept data\n\t\tif ( !acceptData( elem ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Caller can pass in an object of custom data in lieu of the handler\n\t\tif ( handler.handler ) {\n\t\t\thandleObjIn = handler;\n\t\t\thandler = handleObjIn.handler;\n\t\t\tselector = handleObjIn.selector;\n\t\t}\n\n\t\t// Ensure that invalid selectors throw exceptions at attach time\n\t\t// Evaluate against documentElement in case elem is a non-element node (e.g., document)\n\t\tif ( selector ) {\n\t\t\tjQuery.find.matchesSelector( documentElement, selector );\n\t\t}\n\n\t\t// Make sure that the handler has a unique ID, used to find/remove it later\n\t\tif ( !handler.guid ) {\n\t\t\thandler.guid = jQuery.guid++;\n\t\t}\n\n\t\t// Init the element's event structure and main handler, if this is the first\n\t\tif ( !( events = elemData.events ) ) {\n\t\t\tevents = elemData.events = Object.create( null );\n\t\t}\n\t\tif ( !( eventHandle = elemData.handle ) ) {\n\t\t\teventHandle = elemData.handle = function( e ) {\n\n\t\t\t\t// Discard the second event of a jQuery.event.trigger() and\n\t\t\t\t// when an event is called after a page has unloaded\n\t\t\t\treturn typeof jQuery !== \"undefined\" && jQuery.event.triggered !== e.type ?\n\t\t\t\t\tjQuery.event.dispatch.apply( elem, arguments ) : undefined;\n\t\t\t};\n\t\t}\n\n\t\t// Handle multiple events separated by a space\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// There *must* be a type, no attaching namespace-only handlers\n\t\t\tif ( !type ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// If event changes its type, use the special event handlers for the changed type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// If selector defined, determine special event api type, otherwise given type\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\n\t\t\t// Update special based on newly reset type\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\n\t\t\t// handleObj is passed to all event handlers\n\t\t\thandleObj = jQuery.extend( {\n\t\t\t\ttype: type,\n\t\t\t\torigType: origType,\n\t\t\t\tdata: data,\n\t\t\t\thandler: handler,\n\t\t\t\tguid: handler.guid,\n\t\t\t\tselector: selector,\n\t\t\t\tneedsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n\t\t\t\tnamespace: namespaces.join( \".\" )\n\t\t\t}, handleObjIn );\n\n\t\t\t// Init the event handler queue if we're the first\n\t\t\tif ( !( handlers = events[ type ] ) ) {\n\t\t\t\thandlers = events[ type ] = [];\n\t\t\t\thandlers.delegateCount = 0;\n\n\t\t\t\t// Only use addEventListener if the special events handler returns false\n\t\t\t\tif ( !special.setup ||\n\t\t\t\t\tspecial.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n\n\t\t\t\t\tif ( elem.addEventListener ) {\n\t\t\t\t\t\telem.addEventListener( type, eventHandle );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( special.add ) {\n\t\t\t\tspecial.add.call( elem, handleObj );\n\n\t\t\t\tif ( !handleObj.handler.guid ) {\n\t\t\t\t\thandleObj.handler.guid = handler.guid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Add to the element's handler list, delegates in front\n\t\t\tif ( selector ) {\n\t\t\t\thandlers.splice( handlers.delegateCount++, 0, handleObj );\n\t\t\t} else {\n\t\t\t\thandlers.push( handleObj );\n\t\t\t}\n\n\t\t\t// Keep track of which events have ever been used, for event optimization\n\t\t\tjQuery.event.global[ type ] = true;\n\t\t}\n\n\t},\n\n\t// Detach an event or set of events from an element\n\tremove: function( elem, types, handler, selector, mappedTypes ) {\n\n\t\tvar j, origCount, tmp,\n\t\t\tevents, t, handleObj,\n\t\t\tspecial, handlers, type, namespaces, origType,\n\t\t\telemData = dataPriv.hasData( elem ) && dataPriv.get( elem );\n\n\t\tif ( !elemData || !( events = elemData.events ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Once for each type.namespace in types; type may be omitted\n\t\ttypes = ( types || \"\" ).match( rnothtmlwhite ) || [ \"\" ];\n\t\tt = types.length;\n\t\twhile ( t-- ) {\n\t\t\ttmp = rtypenamespace.exec( types[ t ] ) || [];\n\t\t\ttype = origType = tmp[ 1 ];\n\t\t\tnamespaces = ( tmp[ 2 ] || \"\" ).split( \".\" ).sort();\n\n\t\t\t// Unbind all events (on this namespace, if provided) for the element\n\t\t\tif ( !type ) {\n\t\t\t\tfor ( type in events ) {\n\t\t\t\t\tjQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tspecial = jQuery.event.special[ type ] || {};\n\t\t\ttype = ( selector ? special.delegateType : special.bindType ) || type;\n\t\t\thandlers = events[ type ] || [];\n\t\t\ttmp = tmp[ 2 ] &&\n\t\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" );\n\n\t\t\t// Remove matching events\n\t\t\torigCount = j = handlers.length;\n\t\t\twhile ( j-- ) {\n\t\t\t\thandleObj = handlers[ j ];\n\n\t\t\t\tif ( ( mappedTypes || origType === handleObj.origType ) &&\n\t\t\t\t\t( !handler || handler.guid === handleObj.guid ) &&\n\t\t\t\t\t( !tmp || tmp.test( handleObj.namespace ) ) &&\n\t\t\t\t\t( !selector || selector === handleObj.selector ||\n\t\t\t\t\t\tselector === \"**\" && handleObj.selector ) ) {\n\t\t\t\t\thandlers.splice( j, 1 );\n\n\t\t\t\t\tif ( handleObj.selector ) {\n\t\t\t\t\t\thandlers.delegateCount--;\n\t\t\t\t\t}\n\t\t\t\t\tif ( special.remove ) {\n\t\t\t\t\t\tspecial.remove.call( elem, handleObj );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Remove generic event handler if we removed something and no more handlers exist\n\t\t\t// (avoids potential for endless recursion during removal of special event handlers)\n\t\t\tif ( origCount && !handlers.length ) {\n\t\t\t\tif ( !special.teardown ||\n\t\t\t\t\tspecial.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n\n\t\t\t\t\tjQuery.removeEvent( elem, type, elemData.handle );\n\t\t\t\t}\n\n\t\t\t\tdelete events[ type ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove data and the expando if it's no longer used\n\t\tif ( jQuery.isEmptyObject( events ) ) {\n\t\t\tdataPriv.remove( elem, \"handle events\" );\n\t\t}\n\t},\n\n\tdispatch: function( nativeEvent ) {\n\n\t\tvar i, j, ret, matched, handleObj, handlerQueue,\n\t\t\targs = new Array( arguments.length ),\n\n\t\t\t// Make a writable jQuery.Event from the native event object\n\t\t\tevent = jQuery.event.fix( nativeEvent ),\n\n\t\t\thandlers = (\n\t\t\t\t\tdataPriv.get( this, \"events\" ) || Object.create( null )\n\t\t\t\t)[ event.type ] || [],\n\t\t\tspecial = jQuery.event.special[ event.type ] || {};\n\n\t\t// Use the fix-ed jQuery.Event rather than the (read-only) native event\n\t\targs[ 0 ] = event;\n\n\t\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tevent.delegateTarget = this;\n\n\t\t// Call the preDispatch hook for the mapped type, and let it bail if desired\n\t\tif ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine handlers\n\t\thandlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n\t\t// Run delegates first; they may want to stop propagation beneath us\n\t\ti = 0;\n\t\twhile ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tevent.currentTarget = matched.elem;\n\n\t\t\tj = 0;\n\t\t\twhile ( ( handleObj = matched.handlers[ j++ ] ) &&\n\t\t\t\t!event.isImmediatePropagationStopped() ) {\n\n\t\t\t\t// If the event is namespaced, then each handler is only invoked if it is\n\t\t\t\t// specially universal or its namespaces are a superset of the event's.\n\t\t\t\tif ( !event.rnamespace || handleObj.namespace === false ||\n\t\t\t\t\tevent.rnamespace.test( handleObj.namespace ) ) {\n\n\t\t\t\t\tevent.handleObj = handleObj;\n\t\t\t\t\tevent.data = handleObj.data;\n\n\t\t\t\t\tret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||\n\t\t\t\t\t\thandleObj.handler ).apply( matched.elem, args );\n\n\t\t\t\t\tif ( ret !== undefined ) {\n\t\t\t\t\t\tif ( ( event.result = ret ) === false ) {\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Call the postDispatch hook for the mapped type\n\t\tif ( special.postDispatch ) {\n\t\t\tspecial.postDispatch.call( this, event );\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\thandlers: function( event, handlers ) {\n\t\tvar i, handleObj, sel, matchedHandlers, matchedSelectors,\n\t\t\thandlerQueue = [],\n\t\t\tdelegateCount = handlers.delegateCount,\n\t\t\tcur = event.target;\n\n\t\t// Find delegate handlers\n\t\tif ( delegateCount &&\n\n\t\t\t// Support: IE <=9\n\t\t\t// Black-hole SVG <use> instance trees (trac-13180)\n\t\t\tcur.nodeType &&\n\n\t\t\t// Support: Firefox <=42\n\t\t\t// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)\n\t\t\t// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click\n\t\t\t// Support: IE 11 only\n\t\t\t// ...but not arrow key \"clicks\" of radio inputs, which can have `button` -1 (gh-2343)\n\t\t\t!( event.type === \"click\" && event.button >= 1 ) ) {\n\n\t\t\tfor ( ; cur !== this; cur = cur.parentNode || this ) {\n\n\t\t\t\t// Don't check non-elements (#13208)\n\t\t\t\t// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n\t\t\t\tif ( cur.nodeType === 1 && !( event.type === \"click\" && cur.disabled === true ) ) {\n\t\t\t\t\tmatchedHandlers = [];\n\t\t\t\t\tmatchedSelectors = {};\n\t\t\t\t\tfor ( i = 0; i < delegateCount; i++ ) {\n\t\t\t\t\t\thandleObj = handlers[ i ];\n\n\t\t\t\t\t\t// Don't conflict with Object.prototype properties (#13203)\n\t\t\t\t\t\tsel = handleObj.selector + \" \";\n\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] === undefined ) {\n\t\t\t\t\t\t\tmatchedSelectors[ sel ] = handleObj.needsContext ?\n\t\t\t\t\t\t\t\tjQuery( sel, this ).index( cur ) > -1 :\n\t\t\t\t\t\t\t\tjQuery.find( sel, this, null, [ cur ] ).length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( matchedSelectors[ sel ] ) {\n\t\t\t\t\t\t\tmatchedHandlers.push( handleObj );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( matchedHandlers.length ) {\n\t\t\t\t\t\thandlerQueue.push( { elem: cur, handlers: matchedHandlers } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add the remaining (directly-bound) handlers\n\t\tcur = this;\n\t\tif ( delegateCount < handlers.length ) {\n\t\t\thandlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );\n\t\t}\n\n\t\treturn handlerQueue;\n\t},\n\n\taddProp: function( name, hook ) {\n\t\tObject.defineProperty( jQuery.Event.prototype, name, {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\n\t\t\tget: isFunction( hook ) ?\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn hook( this.originalEvent );\n\t\t\t\t\t}\n\t\t\t\t} :\n\t\t\t\tfunction() {\n\t\t\t\t\tif ( this.originalEvent ) {\n\t\t\t\t\t\t\treturn this.originalEvent[ name ];\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\tset: function( value ) {\n\t\t\t\tObject.defineProperty( this, name, {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tvalue: value\n\t\t\t\t} );\n\t\t\t}\n\t\t} );\n\t},\n\n\tfix: function( originalEvent ) {\n\t\treturn originalEvent[ jQuery.expando ] ?\n\t\t\toriginalEvent :\n\t\t\tnew jQuery.Event( originalEvent );\n\t},\n\n\tspecial: {\n\t\tload: {\n\n\t\t\t// Prevent triggered image.load events from bubbling to window.load\n\t\t\tnoBubble: true\n\t\t},\n\t\tclick: {\n\n\t\t\t// Utilize native event to ensure correct state for checkable inputs\n\t\t\tsetup: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Claim the first handler\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\t// dataPriv.set( el, \"click\", ... )\n\t\t\t\t\tleverageNative( el, \"click\", returnTrue );\n\t\t\t\t}\n\n\t\t\t\t// Return false to allow normal processing in the caller\n\t\t\t\treturn false;\n\t\t\t},\n\t\t\ttrigger: function( data ) {\n\n\t\t\t\t// For mutual compressibility with _default, replace `this` access with a local var.\n\t\t\t\t// `|| data` is dead code meant only to preserve the variable through minification.\n\t\t\t\tvar el = this || data;\n\n\t\t\t\t// Force setup before triggering a click\n\t\t\t\tif ( rcheckableType.test( el.type ) &&\n\t\t\t\t\tel.click && nodeName( el, \"input\" ) ) {\n\n\t\t\t\t\tleverageNative( el, \"click\" );\n\t\t\t\t}\n\n\t\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t// For cross-browser consistency, suppress native .click() on links\n\t\t\t// Also prevent it if we're currently inside a leveraged native-event stack\n\t\t\t_default: function( event ) {\n\t\t\t\tvar target = event.target;\n\t\t\t\treturn rcheckableType.test( target.type ) &&\n\t\t\t\t\ttarget.click && nodeName( target, \"input\" ) &&\n\t\t\t\t\tdataPriv.get( target, \"click\" ) ||\n\t\t\t\t\tnodeName( target, \"a\" );\n\t\t\t}\n\t\t},\n\n\t\tbeforeunload: {\n\t\t\tpostDispatch: function( event ) {\n\n\t\t\t\t// Support: Firefox 20+\n\t\t\t\t// Firefox doesn't alert if the returnValue field is not set.\n\t\t\t\tif ( event.result !== undefined && event.originalEvent ) {\n\t\t\t\t\tevent.originalEvent.returnValue = event.result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Ensure the presence of an event listener that handles manually-triggered\n// synthetic events by interrupting progress until reinvoked in response to\n// *native* events that it fires directly, ensuring that state changes have\n// already occurred before other listeners are invoked.\nfunction leverageNative( el, type, expectSync ) {\n\n\t// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add\n\tif ( !expectSync ) {\n\t\tif ( dataPriv.get( el, type ) === undefined ) {\n\t\t\tjQuery.event.add( el, type, returnTrue );\n\t\t}\n\t\treturn;\n\t}\n\n\t// Register the controller as a special universal handler for all event namespaces\n\tdataPriv.set( el, type, false );\n\tjQuery.event.add( el, type, {\n\t\tnamespace: false,\n\t\thandler: function( event ) {\n\t\t\tvar notAsync, result,\n\t\t\t\tsaved = dataPriv.get( this, type );\n\n\t\t\tif ( ( event.isTrigger & 1 ) && this[ type ] ) {\n\n\t\t\t\t// Interrupt processing of the outer synthetic .trigger()ed event\n\t\t\t\t// Saved data should be false in such cases, but might be a leftover capture object\n\t\t\t\t// from an async native handler (gh-4350)\n\t\t\t\tif ( !saved.length ) {\n\n\t\t\t\t\t// Store arguments for use when handling the inner native event\n\t\t\t\t\t// There will always be at least one argument (an event object), so this array\n\t\t\t\t\t// will not be confused with a leftover capture object.\n\t\t\t\t\tsaved = slice.call( arguments );\n\t\t\t\t\tdataPriv.set( this, type, saved );\n\n\t\t\t\t\t// Trigger the native event and capture its result\n\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t// focus() and blur() are asynchronous\n\t\t\t\t\tnotAsync = expectSync( this, type );\n\t\t\t\t\tthis[ type ]();\n\t\t\t\t\tresult = dataPriv.get( this, type );\n\t\t\t\t\tif ( saved !== result || notAsync ) {\n\t\t\t\t\t\tdataPriv.set( this, type, false );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult = {};\n\t\t\t\t\t}\n\t\t\t\t\tif ( saved !== result ) {\n\n\t\t\t\t\t\t// Cancel the outer synthetic event\n\t\t\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\treturn result.value;\n\t\t\t\t\t}\n\n\t\t\t\t// If this is an inner synthetic event for an event with a bubbling surrogate\n\t\t\t\t// (focus or blur), assume that the surrogate already propagated from triggering the\n\t\t\t\t// native event and prevent that from happening again here.\n\t\t\t\t// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the\n\t\t\t\t// bubbling surrogate propagates *after* the non-bubbling base), but that seems\n\t\t\t\t// less bad than duplication.\n\t\t\t\t} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t}\n\n\t\t\t// If this is a native event triggered above, everything is now in order\n\t\t\t// Fire an inner synthetic event with the original arguments\n\t\t\t} else if ( saved.length ) {\n\n\t\t\t\t// ...and capture the result\n\t\t\t\tdataPriv.set( this, type, {\n\t\t\t\t\tvalue: jQuery.event.trigger(\n\n\t\t\t\t\t\t// Support: IE <=9 - 11+\n\t\t\t\t\t\t// Extend with the prototype to reset the above stopImmediatePropagation()\n\t\t\t\t\t\tjQuery.extend( saved[ 0 ], jQuery.Event.prototype ),\n\t\t\t\t\t\tsaved.slice( 1 ),\n\t\t\t\t\t\tthis\n\t\t\t\t\t)\n\t\t\t\t} );\n\n\t\t\t\t// Abort handling of the native event\n\t\t\t\tevent.stopImmediatePropagation();\n\t\t\t}\n\t\t}\n\t} );\n}\n\njQuery.removeEvent = function( elem, type, handle ) {\n\n\t// This \"if\" is needed for plain objects\n\tif ( elem.removeEventListener ) {\n\t\telem.removeEventListener( type, handle );\n\t}\n};\n\njQuery.Event = function( src, props ) {\n\n\t// Allow instantiation without the 'new' keyword\n\tif ( !( this instanceof jQuery.Event ) ) {\n\t\treturn new jQuery.Event( src, props );\n\t}\n\n\t// Event object\n\tif ( src && src.type ) {\n\t\tthis.originalEvent = src;\n\t\tthis.type = src.type;\n\n\t\t// Events bubbling up the document may have been marked as prevented\n\t\t// by a handler lower down the tree; reflect the correct value.\n\t\tthis.isDefaultPrevented = src.defaultPrevented ||\n\t\t\t\tsrc.defaultPrevented === undefined &&\n\n\t\t\t\t// Support: Android <=2.3 only\n\t\t\t\tsrc.returnValue === false ?\n\t\t\treturnTrue :\n\t\t\treturnFalse;\n\n\t\t// Create target properties\n\t\t// Support: Safari <=6 - 7 only\n\t\t// Target should not be a text node (#504, #13143)\n\t\tthis.target = ( src.target && src.target.nodeType === 3 ) ?\n\t\t\tsrc.target.parentNode :\n\t\t\tsrc.target;\n\n\t\tthis.currentTarget = src.currentTarget;\n\t\tthis.relatedTarget = src.relatedTarget;\n\n\t// Event type\n\t} else {\n\t\tthis.type = src;\n\t}\n\n\t// Put explicitly provided properties onto the event object\n\tif ( props ) {\n\t\tjQuery.extend( this, props );\n\t}\n\n\t// Create a timestamp if incoming event doesn't have one\n\tthis.timeStamp = src && src.timeStamp || Date.now();\n\n\t// Mark it as fixed\n\tthis[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n\tconstructor: jQuery.Event,\n\tisDefaultPrevented: returnFalse,\n\tisPropagationStopped: returnFalse,\n\tisImmediatePropagationStopped: returnFalse,\n\tisSimulated: false,\n\n\tpreventDefault: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isDefaultPrevented = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.preventDefault();\n\t\t}\n\t},\n\tstopPropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isPropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopPropagation();\n\t\t}\n\t},\n\tstopImmediatePropagation: function() {\n\t\tvar e = this.originalEvent;\n\n\t\tthis.isImmediatePropagationStopped = returnTrue;\n\n\t\tif ( e && !this.isSimulated ) {\n\t\t\te.stopImmediatePropagation();\n\t\t}\n\n\t\tthis.stopPropagation();\n\t}\n};\n\n// Includes all common event props including KeyEvent and MouseEvent specific props\njQuery.each( {\n\taltKey: true,\n\tbubbles: true,\n\tcancelable: true,\n\tchangedTouches: true,\n\tctrlKey: true,\n\tdetail: true,\n\teventPhase: true,\n\tmetaKey: true,\n\tpageX: true,\n\tpageY: true,\n\tshiftKey: true,\n\tview: true,\n\t\"char\": true,\n\tcode: true,\n\tcharCode: true,\n\tkey: true,\n\tkeyCode: true,\n\tbutton: true,\n\tbuttons: true,\n\tclientX: true,\n\tclientY: true,\n\toffsetX: true,\n\toffsetY: true,\n\tpointerId: true,\n\tpointerType: true,\n\tscreenX: true,\n\tscreenY: true,\n\ttargetTouches: true,\n\ttoElement: true,\n\ttouches: true,\n\n\twhich: function( event ) {\n\t\tvar button = event.button;\n\n\t\t// Add which for key events\n\t\tif ( event.which == null && rkeyEvent.test( event.type ) ) {\n\t\t\treturn event.charCode != null ? event.charCode : event.keyCode;\n\t\t}\n\n\t\t// Add which for click: 1 === left; 2 === middle; 3 === right\n\t\tif ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {\n\t\t\tif ( button & 1 ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\tif ( button & 2 ) {\n\t\t\t\treturn 3;\n\t\t\t}\n\n\t\t\tif ( button & 4 ) {\n\t\t\t\treturn 2;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn event.which;\n\t}\n}, jQuery.event.addProp );\n\njQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( type, delegateType ) {\n\tjQuery.event.special[ type ] = {\n\n\t\t// Utilize native event if possible so blur/focus sequence is correct\n\t\tsetup: function() {\n\n\t\t\t// Claim the first handler\n\t\t\t// dataPriv.set( this, \"focus\", ... )\n\t\t\t// dataPriv.set( this, \"blur\", ... )\n\t\t\tleverageNative( this, type, expectSync );\n\n\t\t\t// Return false to allow normal processing in the caller\n\t\t\treturn false;\n\t\t},\n\t\ttrigger: function() {\n\n\t\t\t// Force setup before trigger\n\t\t\tleverageNative( this, type );\n\n\t\t\t// Return non-false to allow normal event-path propagation\n\t\t\treturn true;\n\t\t},\n\n\t\tdelegateType: delegateType\n\t};\n} );\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\n// so that event delegation works in jQuery.\n// Do the same for pointerenter/pointerleave and pointerover/pointerout\n//\n// Support: Safari 7 only\n// Safari sends mouseenter too often; see:\n// https://bugs.chromium.org/p/chromium/issues/detail?id=470258\n// for the description of the bug (it existed in older Chrome versions as well).\njQuery.each( {\n\tmouseenter: \"mouseover\",\n\tmouseleave: \"mouseout\",\n\tpointerenter: \"pointerover\",\n\tpointerleave: \"pointerout\"\n}, function( orig, fix ) {\n\tjQuery.event.special[ orig ] = {\n\t\tdelegateType: fix,\n\t\tbindType: fix,\n\n\t\thandle: function( event ) {\n\t\t\tvar ret,\n\t\t\t\ttarget = this,\n\t\t\t\trelated = event.relatedTarget,\n\t\t\t\thandleObj = event.handleObj;\n\n\t\t\t// For mouseenter/leave call the handler if related is outside the target.\n\t\t\t// NB: No relatedTarget if the mouse left/entered the browser window\n\t\t\tif ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {\n\t\t\t\tevent.type = handleObj.origType;\n\t\t\t\tret = handleObj.handler.apply( this, arguments );\n\t\t\t\tevent.type = fix;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t};\n} );\n\njQuery.fn.extend( {\n\n\ton: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn );\n\t},\n\tone: function( types, selector, data, fn ) {\n\t\treturn on( this, types, selector, data, fn, 1 );\n\t},\n\toff: function( types, selector, fn ) {\n\t\tvar handleObj, type;\n\t\tif ( types && types.preventDefault && types.handleObj ) {\n\n\t\t\t// ( event )  dispatched jQuery.Event\n\t\t\thandleObj = types.handleObj;\n\t\t\tjQuery( types.delegateTarget ).off(\n\t\t\t\thandleObj.namespace ?\n\t\t\t\t\thandleObj.origType + \".\" + handleObj.namespace :\n\t\t\t\t\thandleObj.origType,\n\t\t\t\thandleObj.selector,\n\t\t\t\thandleObj.handler\n\t\t\t);\n\t\t\treturn this;\n\t\t}\n\t\tif ( typeof types === \"object\" ) {\n\n\t\t\t// ( types-object [, selector] )\n\t\t\tfor ( type in types ) {\n\t\t\t\tthis.off( type, selector, types[ type ] );\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\tif ( selector === false || typeof selector === \"function\" ) {\n\n\t\t\t// ( types [, fn] )\n\t\t\tfn = selector;\n\t\t\tselector = undefined;\n\t\t}\n\t\tif ( fn === false ) {\n\t\t\tfn = returnFalse;\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.remove( this, types, fn, selector );\n\t\t} );\n\t}\n} );\n\n\nvar\n\n\t// Support: IE <=10 - 11, Edge 12 - 13 only\n\t// In IE/Edge using regex groups here causes severe slowdowns.\n\t// See https://connect.microsoft.com/IE/feedback/details/1736512/\n\trnoInnerhtml = /<script|<style|<link/i,\n\n\t// checked=\"checked\" or checked\n\trchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n\trcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;\n\n// Prefer a tbody over its parent table for containing new rows\nfunction manipulationTarget( elem, content ) {\n\tif ( nodeName( elem, \"table\" ) &&\n\t\tnodeName( content.nodeType !== 11 ? content : content.firstChild, \"tr\" ) ) {\n\n\t\treturn jQuery( elem ).children( \"tbody\" )[ 0 ] || elem;\n\t}\n\n\treturn elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n\telem.type = ( elem.getAttribute( \"type\" ) !== null ) + \"/\" + elem.type;\n\treturn elem;\n}\nfunction restoreScript( elem ) {\n\tif ( ( elem.type || \"\" ).slice( 0, 5 ) === \"true/\" ) {\n\t\telem.type = elem.type.slice( 5 );\n\t} else {\n\t\telem.removeAttribute( \"type\" );\n\t}\n\n\treturn elem;\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\tvar i, l, type, pdataOld, udataOld, udataCur, events;\n\n\tif ( dest.nodeType !== 1 ) {\n\t\treturn;\n\t}\n\n\t// 1. Copy private data: events, handlers, etc.\n\tif ( dataPriv.hasData( src ) ) {\n\t\tpdataOld = dataPriv.get( src );\n\t\tevents = pdataOld.events;\n\n\t\tif ( events ) {\n\t\t\tdataPriv.remove( dest, \"handle events\" );\n\n\t\t\tfor ( type in events ) {\n\t\t\t\tfor ( i = 0, l = events[ type ].length; i < l; i++ ) {\n\t\t\t\t\tjQuery.event.add( dest, type, events[ type ][ i ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// 2. Copy user data\n\tif ( dataUser.hasData( src ) ) {\n\t\tudataOld = dataUser.access( src );\n\t\tudataCur = jQuery.extend( {}, udataOld );\n\n\t\tdataUser.set( dest, udataCur );\n\t}\n}\n\n// Fix IE bugs, see support tests\nfunction fixInput( src, dest ) {\n\tvar nodeName = dest.nodeName.toLowerCase();\n\n\t// Fails to persist the checked state of a cloned checkbox or radio button.\n\tif ( nodeName === \"input\" && rcheckableType.test( src.type ) ) {\n\t\tdest.checked = src.checked;\n\n\t// Fails to return the selected option to the default selected state when cloning options\n\t} else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n\t\tdest.defaultValue = src.defaultValue;\n\t}\n}\n\nfunction domManip( collection, args, callback, ignored ) {\n\n\t// Flatten any nested arrays\n\targs = flat( args );\n\n\tvar fragment, first, scripts, hasScripts, node, doc,\n\t\ti = 0,\n\t\tl = collection.length,\n\t\tiNoClone = l - 1,\n\t\tvalue = args[ 0 ],\n\t\tvalueIsFunction = isFunction( value );\n\n\t// We can't cloneNode fragments that contain checked, in WebKit\n\tif ( valueIsFunction ||\n\t\t\t( l > 1 && typeof value === \"string\" &&\n\t\t\t\t!support.checkClone && rchecked.test( value ) ) ) {\n\t\treturn collection.each( function( index ) {\n\t\t\tvar self = collection.eq( index );\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\targs[ 0 ] = value.call( this, index, self.html() );\n\t\t\t}\n\t\t\tdomManip( self, args, callback, ignored );\n\t\t} );\n\t}\n\n\tif ( l ) {\n\t\tfragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );\n\t\tfirst = fragment.firstChild;\n\n\t\tif ( fragment.childNodes.length === 1 ) {\n\t\t\tfragment = first;\n\t\t}\n\n\t\t// Require either new content or an interest in ignored elements to invoke the callback\n\t\tif ( first || ignored ) {\n\t\t\tscripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n\t\t\thasScripts = scripts.length;\n\n\t\t\t// Use the original fragment for the last item\n\t\t\t// instead of the first because it can end up\n\t\t\t// being emptied incorrectly in certain situations (#8070).\n\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\tnode = fragment;\n\n\t\t\t\tif ( i !== iNoClone ) {\n\t\t\t\t\tnode = jQuery.clone( node, true, true );\n\n\t\t\t\t\t// Keep references to cloned scripts for later restoration\n\t\t\t\t\tif ( hasScripts ) {\n\n\t\t\t\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t\t\t\t// push.apply(_, arraylike) throws on ancient WebKit\n\t\t\t\t\t\tjQuery.merge( scripts, getAll( node, \"script\" ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcallback.call( collection[ i ], node, i );\n\t\t\t}\n\n\t\t\tif ( hasScripts ) {\n\t\t\t\tdoc = scripts[ scripts.length - 1 ].ownerDocument;\n\n\t\t\t\t// Reenable scripts\n\t\t\t\tjQuery.map( scripts, restoreScript );\n\n\t\t\t\t// Evaluate executable scripts on first document insertion\n\t\t\t\tfor ( i = 0; i < hasScripts; i++ ) {\n\t\t\t\t\tnode = scripts[ i ];\n\t\t\t\t\tif ( rscriptType.test( node.type || \"\" ) &&\n\t\t\t\t\t\t!dataPriv.access( node, \"globalEval\" ) &&\n\t\t\t\t\t\tjQuery.contains( doc, node ) ) {\n\n\t\t\t\t\t\tif ( node.src && ( node.type || \"\" ).toLowerCase()  !== \"module\" ) {\n\n\t\t\t\t\t\t\t// Optional AJAX dependency, but won't run scripts if not present\n\t\t\t\t\t\t\tif ( jQuery._evalUrl && !node.noModule ) {\n\t\t\t\t\t\t\t\tjQuery._evalUrl( node.src, {\n\t\t\t\t\t\t\t\t\tnonce: node.nonce || node.getAttribute( \"nonce\" )\n\t\t\t\t\t\t\t\t}, doc );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDOMEval( node.textContent.replace( rcleanScript, \"\" ), node, doc );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn collection;\n}\n\nfunction remove( elem, selector, keepData ) {\n\tvar node,\n\t\tnodes = selector ? jQuery.filter( selector, elem ) : elem,\n\t\ti = 0;\n\n\tfor ( ; ( node = nodes[ i ] ) != null; i++ ) {\n\t\tif ( !keepData && node.nodeType === 1 ) {\n\t\t\tjQuery.cleanData( getAll( node ) );\n\t\t}\n\n\t\tif ( node.parentNode ) {\n\t\t\tif ( keepData && isAttached( node ) ) {\n\t\t\t\tsetGlobalEval( getAll( node, \"script\" ) );\n\t\t\t}\n\t\t\tnode.parentNode.removeChild( node );\n\t\t}\n\t}\n\n\treturn elem;\n}\n\njQuery.extend( {\n\thtmlPrefilter: function( html ) {\n\t\treturn html;\n\t},\n\n\tclone: function( elem, dataAndEvents, deepDataAndEvents ) {\n\t\tvar i, l, srcElements, destElements,\n\t\t\tclone = elem.cloneNode( true ),\n\t\t\tinPage = isAttached( elem );\n\n\t\t// Fix IE cloning issues\n\t\tif ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&\n\t\t\t\t!jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2\n\t\t\tdestElements = getAll( clone );\n\t\t\tsrcElements = getAll( elem );\n\n\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\tfixInput( srcElements[ i ], destElements[ i ] );\n\t\t\t}\n\t\t}\n\n\t\t// Copy the events from the original to the clone\n\t\tif ( dataAndEvents ) {\n\t\t\tif ( deepDataAndEvents ) {\n\t\t\t\tsrcElements = srcElements || getAll( elem );\n\t\t\t\tdestElements = destElements || getAll( clone );\n\n\t\t\t\tfor ( i = 0, l = srcElements.length; i < l; i++ ) {\n\t\t\t\t\tcloneCopyEvent( srcElements[ i ], destElements[ i ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcloneCopyEvent( elem, clone );\n\t\t\t}\n\t\t}\n\n\t\t// Preserve script evaluation history\n\t\tdestElements = getAll( clone, \"script\" );\n\t\tif ( destElements.length > 0 ) {\n\t\t\tsetGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n\t\t}\n\n\t\t// Return the cloned set\n\t\treturn clone;\n\t},\n\n\tcleanData: function( elems ) {\n\t\tvar data, elem, type,\n\t\t\tspecial = jQuery.event.special,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {\n\t\t\tif ( acceptData( elem ) ) {\n\t\t\t\tif ( ( data = elem[ dataPriv.expando ] ) ) {\n\t\t\t\t\tif ( data.events ) {\n\t\t\t\t\t\tfor ( type in data.events ) {\n\t\t\t\t\t\t\tif ( special[ type ] ) {\n\t\t\t\t\t\t\t\tjQuery.event.remove( elem, type );\n\n\t\t\t\t\t\t\t// This is a shortcut to avoid jQuery.event.remove's overhead\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tjQuery.removeEvent( elem, type, data.handle );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataPriv.expando ] = undefined;\n\t\t\t\t}\n\t\t\t\tif ( elem[ dataUser.expando ] ) {\n\n\t\t\t\t\t// Support: Chrome <=35 - 45+\n\t\t\t\t\t// Assign undefined instead of using delete, see Data#remove\n\t\t\t\t\telem[ dataUser.expando ] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n} );\n\njQuery.fn.extend( {\n\tdetach: function( selector ) {\n\t\treturn remove( this, selector, true );\n\t},\n\n\tremove: function( selector ) {\n\t\treturn remove( this, selector );\n\t},\n\n\ttext: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\treturn value === undefined ?\n\t\t\t\tjQuery.text( this ) :\n\t\t\t\tthis.empty().each( function() {\n\t\t\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\t\t\tthis.textContent = value;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t}, null, value, arguments.length );\n\t},\n\n\tappend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.appendChild( elem );\n\t\t\t}\n\t\t} );\n\t},\n\n\tprepend: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n\t\t\t\tvar target = manipulationTarget( this, elem );\n\t\t\t\ttarget.insertBefore( elem, target.firstChild );\n\t\t\t}\n\t\t} );\n\t},\n\n\tbefore: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this );\n\t\t\t}\n\t\t} );\n\t},\n\n\tafter: function() {\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tif ( this.parentNode ) {\n\t\t\t\tthis.parentNode.insertBefore( elem, this.nextSibling );\n\t\t\t}\n\t\t} );\n\t},\n\n\tempty: function() {\n\t\tvar elem,\n\t\t\ti = 0;\n\n\t\tfor ( ; ( elem = this[ i ] ) != null; i++ ) {\n\t\t\tif ( elem.nodeType === 1 ) {\n\n\t\t\t\t// Prevent memory leaks\n\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\n\t\t\t\t// Remove any remaining nodes\n\t\t\t\telem.textContent = \"\";\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tclone: function( dataAndEvents, deepDataAndEvents ) {\n\t\tdataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n\t\tdeepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n\t\treturn this.map( function() {\n\t\t\treturn jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n\t\t} );\n\t},\n\n\thtml: function( value ) {\n\t\treturn access( this, function( value ) {\n\t\t\tvar elem = this[ 0 ] || {},\n\t\t\t\ti = 0,\n\t\t\t\tl = this.length;\n\n\t\t\tif ( value === undefined && elem.nodeType === 1 ) {\n\t\t\t\treturn elem.innerHTML;\n\t\t\t}\n\n\t\t\t// See if we can take a shortcut and just use innerHTML\n\t\t\tif ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n\t\t\t\t!wrapMap[ ( rtagName.exec( value ) || [ \"\", \"\" ] )[ 1 ].toLowerCase() ] ) {\n\n\t\t\t\tvalue = jQuery.htmlPrefilter( value );\n\n\t\t\t\ttry {\n\t\t\t\t\tfor ( ; i < l; i++ ) {\n\t\t\t\t\t\telem = this[ i ] || {};\n\n\t\t\t\t\t\t// Remove element nodes and prevent memory leaks\n\t\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\t\tjQuery.cleanData( getAll( elem, false ) );\n\t\t\t\t\t\t\telem.innerHTML = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\telem = 0;\n\n\t\t\t\t// If using innerHTML throws an exception, use the fallback method\n\t\t\t\t} catch ( e ) {}\n\t\t\t}\n\n\t\t\tif ( elem ) {\n\t\t\t\tthis.empty().append( value );\n\t\t\t}\n\t\t}, null, value, arguments.length );\n\t},\n\n\treplaceWith: function() {\n\t\tvar ignored = [];\n\n\t\t// Make the changes, replacing each non-ignored context element with the new content\n\t\treturn domManip( this, arguments, function( elem ) {\n\t\t\tvar parent = this.parentNode;\n\n\t\t\tif ( jQuery.inArray( this, ignored ) < 0 ) {\n\t\t\t\tjQuery.cleanData( getAll( this ) );\n\t\t\t\tif ( parent ) {\n\t\t\t\t\tparent.replaceChild( elem, this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Force callback invocation\n\t\t}, ignored );\n\t}\n} );\n\njQuery.each( {\n\tappendTo: \"append\",\n\tprependTo: \"prepend\",\n\tinsertBefore: \"before\",\n\tinsertAfter: \"after\",\n\treplaceAll: \"replaceWith\"\n}, function( name, original ) {\n\tjQuery.fn[ name ] = function( selector ) {\n\t\tvar elems,\n\t\t\tret = [],\n\t\t\tinsert = jQuery( selector ),\n\t\t\tlast = insert.length - 1,\n\t\t\ti = 0;\n\n\t\tfor ( ; i <= last; i++ ) {\n\t\t\telems = i === last ? this : this.clone( true );\n\t\t\tjQuery( insert[ i ] )[ original ]( elems );\n\n\t\t\t// Support: Android <=4.0 only, PhantomJS 1 only\n\t\t\t// .get() because push.apply(_, arraylike) throws on ancient WebKit\n\t\t\tpush.apply( ret, elems.get() );\n\t\t}\n\n\t\treturn this.pushStack( ret );\n\t};\n} );\nvar rnumnonpx = new RegExp( \"^(\" + pnum + \")(?!px)[a-z%]+$\", \"i\" );\n\nvar getStyles = function( elem ) {\n\n\t\t// Support: IE <=11 only, Firefox <=30 (#15098, #14150)\n\t\t// IE throws on elements created in popups\n\t\t// FF meanwhile throws on frame elements through \"defaultView.getComputedStyle\"\n\t\tvar view = elem.ownerDocument.defaultView;\n\n\t\tif ( !view || !view.opener ) {\n\t\t\tview = window;\n\t\t}\n\n\t\treturn view.getComputedStyle( elem );\n\t};\n\nvar swap = function( elem, options, callback ) {\n\tvar ret, name,\n\t\told = {};\n\n\t// Remember the old values, and insert the new ones\n\tfor ( name in options ) {\n\t\told[ name ] = elem.style[ name ];\n\t\telem.style[ name ] = options[ name ];\n\t}\n\n\tret = callback.call( elem );\n\n\t// Revert the old values\n\tfor ( name in options ) {\n\t\telem.style[ name ] = old[ name ];\n\t}\n\n\treturn ret;\n};\n\n\nvar rboxStyle = new RegExp( cssExpand.join( \"|\" ), \"i\" );\n\n\n\n( function() {\n\n\t// Executing both pixelPosition & boxSizingReliable tests require only one layout\n\t// so they're executed at the same time to save the second computation.\n\tfunction computeStyleTests() {\n\n\t\t// This is a singleton, we need to execute it only once\n\t\tif ( !div ) {\n\t\t\treturn;\n\t\t}\n\n\t\tcontainer.style.cssText = \"position:absolute;left:-11111px;width:60px;\" +\n\t\t\t\"margin-top:1px;padding:0;border:0\";\n\t\tdiv.style.cssText =\n\t\t\t\"position:relative;display:block;box-sizing:border-box;overflow:scroll;\" +\n\t\t\t\"margin:auto;border:1px;padding:1px;\" +\n\t\t\t\"width:60%;top:1%\";\n\t\tdocumentElement.appendChild( container ).appendChild( div );\n\n\t\tvar divStyle = window.getComputedStyle( div );\n\t\tpixelPositionVal = divStyle.top !== \"1%\";\n\n\t\t// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44\n\t\treliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;\n\n\t\t// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3\n\t\t// Some styles come back with percentage values, even though they shouldn't\n\t\tdiv.style.right = \"60%\";\n\t\tpixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;\n\n\t\t// Support: IE 9 - 11 only\n\t\t// Detect misreporting of content dimensions for box-sizing:border-box elements\n\t\tboxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;\n\n\t\t// Support: IE 9 only\n\t\t// Detect overflow:scroll screwiness (gh-3699)\n\t\t// Support: Chrome <=64\n\t\t// Don't get tricked when zoom affects offsetWidth (gh-4029)\n\t\tdiv.style.position = \"absolute\";\n\t\tscrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;\n\n\t\tdocumentElement.removeChild( container );\n\n\t\t// Nullify the div so it wouldn't be stored in the memory and\n\t\t// it will also be a sign that checks already performed\n\t\tdiv = null;\n\t}\n\n\tfunction roundPixelMeasures( measure ) {\n\t\treturn Math.round( parseFloat( measure ) );\n\t}\n\n\tvar pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,\n\t\treliableTrDimensionsVal, reliableMarginLeftVal,\n\t\tcontainer = document.createElement( \"div\" ),\n\t\tdiv = document.createElement( \"div\" );\n\n\t// Finish early in limited (non-browser) environments\n\tif ( !div.style ) {\n\t\treturn;\n\t}\n\n\t// Support: IE <=9 - 11 only\n\t// Style of cloned element affects source element cloned (#8908)\n\tdiv.style.backgroundClip = \"content-box\";\n\tdiv.cloneNode( true ).style.backgroundClip = \"\";\n\tsupport.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n\tjQuery.extend( support, {\n\t\tboxSizingReliable: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn boxSizingReliableVal;\n\t\t},\n\t\tpixelBoxStyles: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelBoxStylesVal;\n\t\t},\n\t\tpixelPosition: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn pixelPositionVal;\n\t\t},\n\t\treliableMarginLeft: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn reliableMarginLeftVal;\n\t\t},\n\t\tscrollboxSize: function() {\n\t\t\tcomputeStyleTests();\n\t\t\treturn scrollboxSizeVal;\n\t\t},\n\n\t\t// Support: IE 9 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Behavior in IE 9 is more subtle than in newer versions & it passes\n\t\t// some versions of this test; make sure not to make it pass there!\n\t\treliableTrDimensions: function() {\n\t\t\tvar table, tr, trChild, trStyle;\n\t\t\tif ( reliableTrDimensionsVal == null ) {\n\t\t\t\ttable = document.createElement( \"table\" );\n\t\t\t\ttr = document.createElement( \"tr\" );\n\t\t\t\ttrChild = document.createElement( \"div\" );\n\n\t\t\t\ttable.style.cssText = \"position:absolute;left:-11111px\";\n\t\t\t\ttr.style.height = \"1px\";\n\t\t\t\ttrChild.style.height = \"9px\";\n\n\t\t\t\tdocumentElement\n\t\t\t\t\t.appendChild( table )\n\t\t\t\t\t.appendChild( tr )\n\t\t\t\t\t.appendChild( trChild );\n\n\t\t\t\ttrStyle = window.getComputedStyle( tr );\n\t\t\t\treliableTrDimensionsVal = parseInt( trStyle.height ) > 3;\n\n\t\t\t\tdocumentElement.removeChild( table );\n\t\t\t}\n\t\t\treturn reliableTrDimensionsVal;\n\t\t}\n\t} );\n} )();\n\n\nfunction curCSS( elem, name, computed ) {\n\tvar width, minWidth, maxWidth, ret,\n\n\t\t// Support: Firefox 51+\n\t\t// Retrieving style before computed somehow\n\t\t// fixes an issue with getting wrong values\n\t\t// on detached elements\n\t\tstyle = elem.style;\n\n\tcomputed = computed || getStyles( elem );\n\n\t// getPropertyValue is needed for:\n\t//   .css('filter') (IE 9 only, #12537)\n\t//   .css('--customProperty) (#3144)\n\tif ( computed ) {\n\t\tret = computed.getPropertyValue( name ) || computed[ name ];\n\n\t\tif ( ret === \"\" && !isAttached( elem ) ) {\n\t\t\tret = jQuery.style( elem, name );\n\t\t}\n\n\t\t// A tribute to the \"awesome hack by Dean Edwards\"\n\t\t// Android Browser returns percentage for some values,\n\t\t// but width seems to be reliably pixels.\n\t\t// This is against the CSSOM draft spec:\n\t\t// https://drafts.csswg.org/cssom/#resolved-values\n\t\tif ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {\n\n\t\t\t// Remember the original values\n\t\t\twidth = style.width;\n\t\t\tminWidth = style.minWidth;\n\t\t\tmaxWidth = style.maxWidth;\n\n\t\t\t// Put in the new values to get a computed value out\n\t\t\tstyle.minWidth = style.maxWidth = style.width = ret;\n\t\t\tret = computed.width;\n\n\t\t\t// Revert the changed values\n\t\t\tstyle.width = width;\n\t\t\tstyle.minWidth = minWidth;\n\t\t\tstyle.maxWidth = maxWidth;\n\t\t}\n\t}\n\n\treturn ret !== undefined ?\n\n\t\t// Support: IE <=9 - 11 only\n\t\t// IE returns zIndex value as an integer.\n\t\tret + \"\" :\n\t\tret;\n}\n\n\nfunction addGetHookIf( conditionFn, hookFn ) {\n\n\t// Define the hook, we'll check on the first run if it's really needed.\n\treturn {\n\t\tget: function() {\n\t\t\tif ( conditionFn() ) {\n\n\t\t\t\t// Hook not needed (or it's not possible to use it due\n\t\t\t\t// to missing dependency), remove it.\n\t\t\t\tdelete this.get;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Hook needed; redefine it so that the support test is not executed again.\n\t\t\treturn ( this.get = hookFn ).apply( this, arguments );\n\t\t}\n\t};\n}\n\n\nvar cssPrefixes = [ \"Webkit\", \"Moz\", \"ms\" ],\n\temptyStyle = document.createElement( \"div\" ).style,\n\tvendorProps = {};\n\n// Return a vendor-prefixed property or undefined\nfunction vendorPropName( name ) {\n\n\t// Check for vendor prefixed names\n\tvar capName = name[ 0 ].toUpperCase() + name.slice( 1 ),\n\t\ti = cssPrefixes.length;\n\n\twhile ( i-- ) {\n\t\tname = cssPrefixes[ i ] + capName;\n\t\tif ( name in emptyStyle ) {\n\t\t\treturn name;\n\t\t}\n\t}\n}\n\n// Return a potentially-mapped jQuery.cssProps or vendor prefixed property\nfunction finalPropName( name ) {\n\tvar final = jQuery.cssProps[ name ] || vendorProps[ name ];\n\n\tif ( final ) {\n\t\treturn final;\n\t}\n\tif ( name in emptyStyle ) {\n\t\treturn name;\n\t}\n\treturn vendorProps[ name ] = vendorPropName( name ) || name;\n}\n\n\nvar\n\n\t// Swappable if display is none or starts with table\n\t// except \"table\", \"table-cell\", or \"table-caption\"\n\t// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n\trdisplayswap = /^(none|table(?!-c[ea]).+)/,\n\trcustomProp = /^--/,\n\tcssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n\tcssNormalTransform = {\n\t\tletterSpacing: \"0\",\n\t\tfontWeight: \"400\"\n\t};\n\nfunction setPositiveNumber( _elem, value, subtract ) {\n\n\t// Any relative (+/-) values have already been\n\t// normalized at this point\n\tvar matches = rcssNum.exec( value );\n\treturn matches ?\n\n\t\t// Guard against undefined \"subtract\", e.g., when used as in cssHooks\n\t\tMath.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || \"px\" ) :\n\t\tvalue;\n}\n\nfunction boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {\n\tvar i = dimension === \"width\" ? 1 : 0,\n\t\textra = 0,\n\t\tdelta = 0;\n\n\t// Adjustment may not be necessary\n\tif ( box === ( isBorderBox ? \"border\" : \"content\" ) ) {\n\t\treturn 0;\n\t}\n\n\tfor ( ; i < 4; i += 2 ) {\n\n\t\t// Both box models exclude margin\n\t\tif ( box === \"margin\" ) {\n\t\t\tdelta += jQuery.css( elem, box + cssExpand[ i ], true, styles );\n\t\t}\n\n\t\t// If we get here with a content-box, we're seeking \"padding\" or \"border\" or \"margin\"\n\t\tif ( !isBorderBox ) {\n\n\t\t\t// Add padding\n\t\t\tdelta += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n\t\t\t// For \"border\" or \"margin\", add border\n\t\t\tif ( box !== \"padding\" ) {\n\t\t\t\tdelta += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\n\t\t\t// But still keep track of it otherwise\n\t\t\t} else {\n\t\t\t\textra += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\n\t\t// If we get here with a border-box (content + padding + border), we're seeking \"content\" or\n\t\t// \"padding\" or \"margin\"\n\t\t} else {\n\n\t\t\t// For \"content\", subtract padding\n\t\t\tif ( box === \"content\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\t\t\t}\n\n\t\t\t// For \"content\" or \"padding\", subtract border\n\t\t\tif ( box !== \"margin\" ) {\n\t\t\t\tdelta -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n\t\t\t}\n\t\t}\n\t}\n\n\t// Account for positive content-box scroll gutter when requested by providing computedVal\n\tif ( !isBorderBox && computedVal >= 0 ) {\n\n\t\t// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border\n\t\t// Assuming integer scroll gutter, subtract the rest and round down\n\t\tdelta += Math.max( 0, Math.ceil(\n\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\tcomputedVal -\n\t\t\tdelta -\n\t\t\textra -\n\t\t\t0.5\n\n\t\t// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter\n\t\t// Use an explicit zero to avoid NaN (gh-3964)\n\t\t) ) || 0;\n\t}\n\n\treturn delta;\n}\n\nfunction getWidthOrHeight( elem, dimension, extra ) {\n\n\t// Start with computed style\n\tvar styles = getStyles( elem ),\n\n\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).\n\t\t// Fake content-box until we know it's needed to know the true value.\n\t\tboxSizingNeeded = !support.boxSizingReliable() || extra,\n\t\tisBorderBox = boxSizingNeeded &&\n\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\tvalueIsBorderBox = isBorderBox,\n\n\t\tval = curCSS( elem, dimension, styles ),\n\t\toffsetProp = \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );\n\n\t// Support: Firefox <=54\n\t// Return a confounding non-pixel value or feign ignorance, as appropriate.\n\tif ( rnumnonpx.test( val ) ) {\n\t\tif ( !extra ) {\n\t\t\treturn val;\n\t\t}\n\t\tval = \"auto\";\n\t}\n\n\n\t// Support: IE 9 - 11 only\n\t// Use offsetWidth/offsetHeight for when box sizing is unreliable.\n\t// In those cases, the computed value can be trusted to be border-box.\n\tif ( ( !support.boxSizingReliable() && isBorderBox ||\n\n\t\t// Support: IE 10 - 11+, Edge 15 - 18+\n\t\t// IE/Edge misreport `getComputedStyle` of table rows with width/height\n\t\t// set in CSS while `offset*` properties report correct values.\n\t\t// Interestingly, in some cases IE 9 doesn't suffer from this issue.\n\t\t!support.reliableTrDimensions() && nodeName( elem, \"tr\" ) ||\n\n\t\t// Fall back to offsetWidth/offsetHeight when value is \"auto\"\n\t\t// This happens for inline elements with no explicit setting (gh-3571)\n\t\tval === \"auto\" ||\n\n\t\t// Support: Android <=4.1 - 4.3 only\n\t\t// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)\n\t\t!parseFloat( val ) && jQuery.css( elem, \"display\", false, styles ) === \"inline\" ) &&\n\n\t\t// Make sure the element is visible & connected\n\t\telem.getClientRects().length ) {\n\n\t\tisBorderBox = jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n\t\t// Where available, offsetWidth/offsetHeight approximate border box dimensions.\n\t\t// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the\n\t\t// retrieved value as a content box dimension.\n\t\tvalueIsBorderBox = offsetProp in elem;\n\t\tif ( valueIsBorderBox ) {\n\t\t\tval = elem[ offsetProp ];\n\t\t}\n\t}\n\n\t// Normalize \"\" and auto\n\tval = parseFloat( val ) || 0;\n\n\t// Adjust for the element's box model\n\treturn ( val +\n\t\tboxModelAdjustment(\n\t\t\telem,\n\t\t\tdimension,\n\t\t\textra || ( isBorderBox ? \"border\" : \"content\" ),\n\t\t\tvalueIsBorderBox,\n\t\t\tstyles,\n\n\t\t\t// Provide the current computed size to request scroll gutter calculation (gh-3589)\n\t\t\tval\n\t\t)\n\t) + \"px\";\n}\n\njQuery.extend( {\n\n\t// Add in style property hooks for overriding the default\n\t// behavior of getting and setting a style property\n\tcssHooks: {\n\t\topacity: {\n\t\t\tget: function( elem, computed ) {\n\t\t\t\tif ( computed ) {\n\n\t\t\t\t\t// We should always get a number back from opacity\n\t\t\t\t\tvar ret = curCSS( elem, \"opacity\" );\n\t\t\t\t\treturn ret === \"\" ? \"1\" : ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Don't automatically add \"px\" to these possibly-unitless properties\n\tcssNumber: {\n\t\t\"animationIterationCount\": true,\n\t\t\"columnCount\": true,\n\t\t\"fillOpacity\": true,\n\t\t\"flexGrow\": true,\n\t\t\"flexShrink\": true,\n\t\t\"fontWeight\": true,\n\t\t\"gridArea\": true,\n\t\t\"gridColumn\": true,\n\t\t\"gridColumnEnd\": true,\n\t\t\"gridColumnStart\": true,\n\t\t\"gridRow\": true,\n\t\t\"gridRowEnd\": true,\n\t\t\"gridRowStart\": true,\n\t\t\"lineHeight\": true,\n\t\t\"opacity\": true,\n\t\t\"order\": true,\n\t\t\"orphans\": true,\n\t\t\"widows\": true,\n\t\t\"zIndex\": true,\n\t\t\"zoom\": true\n\t},\n\n\t// Add in properties whose names you wish to fix before\n\t// setting or getting the value\n\tcssProps: {},\n\n\t// Get and set the style property on a DOM Node\n\tstyle: function( elem, name, value, extra ) {\n\n\t\t// Don't set styles on text and comment nodes\n\t\tif ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Make sure that we're working with the right name\n\t\tvar ret, type, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name ),\n\t\t\tstyle = elem.style;\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to query the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Gets hook for the prefixed version, then unprefixed version\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// Check if we're setting a value\n\t\tif ( value !== undefined ) {\n\t\t\ttype = typeof value;\n\n\t\t\t// Convert \"+=\" or \"-=\" to relative numbers (#7345)\n\t\t\tif ( type === \"string\" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {\n\t\t\t\tvalue = adjustCSS( elem, name, ret );\n\n\t\t\t\t// Fixes bug #9237\n\t\t\t\ttype = \"number\";\n\t\t\t}\n\n\t\t\t// Make sure that null and NaN values aren't set (#7116)\n\t\t\tif ( value == null || value !== value ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If a number was passed in, add the unit (except for certain CSS properties)\n\t\t\t// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append\n\t\t\t// \"px\" to a few hardcoded values.\n\t\t\tif ( type === \"number\" && !isCustomProp ) {\n\t\t\t\tvalue += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? \"\" : \"px\" );\n\t\t\t}\n\n\t\t\t// background-* props affect original clone's values\n\t\t\tif ( !support.clearCloneStyle && value === \"\" && name.indexOf( \"background\" ) === 0 ) {\n\t\t\t\tstyle[ name ] = \"inherit\";\n\t\t\t}\n\n\t\t\t// If a hook was provided, use that value, otherwise just set the specified value\n\t\t\tif ( !hooks || !( \"set\" in hooks ) ||\n\t\t\t\t( value = hooks.set( elem, value, extra ) ) !== undefined ) {\n\n\t\t\t\tif ( isCustomProp ) {\n\t\t\t\t\tstyle.setProperty( name, value );\n\t\t\t\t} else {\n\t\t\t\t\tstyle[ name ] = value;\n\t\t\t\t}\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// If a hook was provided get the non-computed value from there\n\t\t\tif ( hooks && \"get\" in hooks &&\n\t\t\t\t( ret = hooks.get( elem, false, extra ) ) !== undefined ) {\n\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Otherwise just get the value from the style object\n\t\t\treturn style[ name ];\n\t\t}\n\t},\n\n\tcss: function( elem, name, extra, styles ) {\n\t\tvar val, num, hooks,\n\t\t\torigName = camelCase( name ),\n\t\t\tisCustomProp = rcustomProp.test( name );\n\n\t\t// Make sure that we're working with the right name. We don't\n\t\t// want to modify the value if it is a CSS custom property\n\t\t// since they are user-defined.\n\t\tif ( !isCustomProp ) {\n\t\t\tname = finalPropName( origName );\n\t\t}\n\n\t\t// Try prefixed name followed by the unprefixed name\n\t\thooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n\t\t// If a hook was provided get the computed value from there\n\t\tif ( hooks && \"get\" in hooks ) {\n\t\t\tval = hooks.get( elem, true, extra );\n\t\t}\n\n\t\t// Otherwise, if a way to get the computed value exists, use that\n\t\tif ( val === undefined ) {\n\t\t\tval = curCSS( elem, name, styles );\n\t\t}\n\n\t\t// Convert \"normal\" to computed value\n\t\tif ( val === \"normal\" && name in cssNormalTransform ) {\n\t\t\tval = cssNormalTransform[ name ];\n\t\t}\n\n\t\t// Make numeric if forced or a qualifier was provided and val looks numeric\n\t\tif ( extra === \"\" || extra ) {\n\t\t\tnum = parseFloat( val );\n\t\t\treturn extra === true || isFinite( num ) ? num || 0 : val;\n\t\t}\n\n\t\treturn val;\n\t}\n} );\n\njQuery.each( [ \"height\", \"width\" ], function( _i, dimension ) {\n\tjQuery.cssHooks[ dimension ] = {\n\t\tget: function( elem, computed, extra ) {\n\t\t\tif ( computed ) {\n\n\t\t\t\t// Certain elements can have dimension info if we invisibly show them\n\t\t\t\t// but it must have a current display style that would benefit\n\t\t\t\treturn rdisplayswap.test( jQuery.css( elem, \"display\" ) ) &&\n\n\t\t\t\t\t// Support: Safari 8+\n\t\t\t\t\t// Table columns in Safari have non-zero offsetWidth & zero\n\t\t\t\t\t// getBoundingClientRect().width unless display is changed.\n\t\t\t\t\t// Support: IE <=11 only\n\t\t\t\t\t// Running getBoundingClientRect on a disconnected node\n\t\t\t\t\t// in IE throws an error.\n\t\t\t\t\t( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?\n\t\t\t\t\t\tswap( elem, cssShow, function() {\n\t\t\t\t\t\t\treturn getWidthOrHeight( elem, dimension, extra );\n\t\t\t\t\t\t} ) :\n\t\t\t\t\t\tgetWidthOrHeight( elem, dimension, extra );\n\t\t\t}\n\t\t},\n\n\t\tset: function( elem, value, extra ) {\n\t\t\tvar matches,\n\t\t\t\tstyles = getStyles( elem ),\n\n\t\t\t\t// Only read styles.position if the test has a chance to fail\n\t\t\t\t// to avoid forcing a reflow.\n\t\t\t\tscrollboxSizeBuggy = !support.scrollboxSize() &&\n\t\t\t\t\tstyles.position === \"absolute\",\n\n\t\t\t\t// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)\n\t\t\t\tboxSizingNeeded = scrollboxSizeBuggy || extra,\n\t\t\t\tisBorderBox = boxSizingNeeded &&\n\t\t\t\t\tjQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n\t\t\t\tsubtract = extra ?\n\t\t\t\t\tboxModelAdjustment(\n\t\t\t\t\t\telem,\n\t\t\t\t\t\tdimension,\n\t\t\t\t\t\textra,\n\t\t\t\t\t\tisBorderBox,\n\t\t\t\t\t\tstyles\n\t\t\t\t\t) :\n\t\t\t\t\t0;\n\n\t\t\t// Account for unreliable border-box dimensions by comparing offset* to computed and\n\t\t\t// faking a content-box to get border and padding (gh-3699)\n\t\t\tif ( isBorderBox && scrollboxSizeBuggy ) {\n\t\t\t\tsubtract -= Math.ceil(\n\t\t\t\t\telem[ \"offset\" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -\n\t\t\t\t\tparseFloat( styles[ dimension ] ) -\n\t\t\t\t\tboxModelAdjustment( elem, dimension, \"border\", false, styles ) -\n\t\t\t\t\t0.5\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Convert to pixels if value adjustment is needed\n\t\t\tif ( subtract && ( matches = rcssNum.exec( value ) ) &&\n\t\t\t\t( matches[ 3 ] || \"px\" ) !== \"px\" ) {\n\n\t\t\t\telem.style[ dimension ] = value;\n\t\t\t\tvalue = jQuery.css( elem, dimension );\n\t\t\t}\n\n\t\t\treturn setPositiveNumber( elem, value, subtract );\n\t\t}\n\t};\n} );\n\njQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,\n\tfunction( elem, computed ) {\n\t\tif ( computed ) {\n\t\t\treturn ( parseFloat( curCSS( elem, \"marginLeft\" ) ) ||\n\t\t\t\telem.getBoundingClientRect().left -\n\t\t\t\t\tswap( elem, { marginLeft: 0 }, function() {\n\t\t\t\t\t\treturn elem.getBoundingClientRect().left;\n\t\t\t\t\t} )\n\t\t\t\t) + \"px\";\n\t\t}\n\t}\n);\n\n// These hooks are used by animate to expand properties\njQuery.each( {\n\tmargin: \"\",\n\tpadding: \"\",\n\tborder: \"Width\"\n}, function( prefix, suffix ) {\n\tjQuery.cssHooks[ prefix + suffix ] = {\n\t\texpand: function( value ) {\n\t\t\tvar i = 0,\n\t\t\t\texpanded = {},\n\n\t\t\t\t// Assumes a single number if not a string\n\t\t\t\tparts = typeof value === \"string\" ? value.split( \" \" ) : [ value ];\n\n\t\t\tfor ( ; i < 4; i++ ) {\n\t\t\t\texpanded[ prefix + cssExpand[ i ] + suffix ] =\n\t\t\t\t\tparts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n\t\t\t}\n\n\t\t\treturn expanded;\n\t\t}\n\t};\n\n\tif ( prefix !== \"margin\" ) {\n\t\tjQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n\t}\n} );\n\njQuery.fn.extend( {\n\tcss: function( name, value ) {\n\t\treturn access( this, function( elem, name, value ) {\n\t\t\tvar styles, len,\n\t\t\t\tmap = {},\n\t\t\t\ti = 0;\n\n\t\t\tif ( Array.isArray( name ) ) {\n\t\t\t\tstyles = getStyles( elem );\n\t\t\t\tlen = name.length;\n\n\t\t\t\tfor ( ; i < len; i++ ) {\n\t\t\t\t\tmap[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n\t\t\t\t}\n\n\t\t\t\treturn map;\n\t\t\t}\n\n\t\t\treturn value !== undefined ?\n\t\t\t\tjQuery.style( elem, name, value ) :\n\t\t\t\tjQuery.css( elem, name );\n\t\t}, name, value, arguments.length > 1 );\n\t}\n} );\n\n\nfunction Tween( elem, options, prop, end, easing ) {\n\treturn new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n\tconstructor: Tween,\n\tinit: function( elem, options, prop, end, easing, unit ) {\n\t\tthis.elem = elem;\n\t\tthis.prop = prop;\n\t\tthis.easing = easing || jQuery.easing._default;\n\t\tthis.options = options;\n\t\tthis.start = this.now = this.cur();\n\t\tthis.end = end;\n\t\tthis.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n\t},\n\tcur: function() {\n\t\tvar hooks = Tween.propHooks[ this.prop ];\n\n\t\treturn hooks && hooks.get ?\n\t\t\thooks.get( this ) :\n\t\t\tTween.propHooks._default.get( this );\n\t},\n\trun: function( percent ) {\n\t\tvar eased,\n\t\t\thooks = Tween.propHooks[ this.prop ];\n\n\t\tif ( this.options.duration ) {\n\t\t\tthis.pos = eased = jQuery.easing[ this.easing ](\n\t\t\t\tpercent, this.options.duration * percent, 0, 1, this.options.duration\n\t\t\t);\n\t\t} else {\n\t\t\tthis.pos = eased = percent;\n\t\t}\n\t\tthis.now = ( this.end - this.start ) * eased + this.start;\n\n\t\tif ( this.options.step ) {\n\t\t\tthis.options.step.call( this.elem, this.now, this );\n\t\t}\n\n\t\tif ( hooks && hooks.set ) {\n\t\t\thooks.set( this );\n\t\t} else {\n\t\t\tTween.propHooks._default.set( this );\n\t\t}\n\t\treturn this;\n\t}\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n\t_default: {\n\t\tget: function( tween ) {\n\t\t\tvar result;\n\n\t\t\t// Use a property on the element directly when it is not a DOM element,\n\t\t\t// or when there is no matching style property that exists.\n\t\t\tif ( tween.elem.nodeType !== 1 ||\n\t\t\t\ttween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {\n\t\t\t\treturn tween.elem[ tween.prop ];\n\t\t\t}\n\n\t\t\t// Passing an empty string as a 3rd parameter to .css will automatically\n\t\t\t// attempt a parseFloat and fallback to a string if the parse fails.\n\t\t\t// Simple values such as \"10px\" are parsed to Float;\n\t\t\t// complex values such as \"rotate(1rad)\" are returned as-is.\n\t\t\tresult = jQuery.css( tween.elem, tween.prop, \"\" );\n\n\t\t\t// Empty strings, null, undefined and \"auto\" are converted to 0.\n\t\t\treturn !result || result === \"auto\" ? 0 : result;\n\t\t},\n\t\tset: function( tween ) {\n\n\t\t\t// Use step hook for back compat.\n\t\t\t// Use cssHook if its there.\n\t\t\t// Use .style if available and use plain properties where available.\n\t\t\tif ( jQuery.fx.step[ tween.prop ] ) {\n\t\t\t\tjQuery.fx.step[ tween.prop ]( tween );\n\t\t\t} else if ( tween.elem.nodeType === 1 && (\n\t\t\t\t\tjQuery.cssHooks[ tween.prop ] ||\n\t\t\t\t\ttween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {\n\t\t\t\tjQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n\t\t\t} else {\n\t\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t\t}\n\t\t}\n\t}\n};\n\n// Support: IE <=9 only\n// Panic based approach to setting things on disconnected nodes\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n\tset: function( tween ) {\n\t\tif ( tween.elem.nodeType && tween.elem.parentNode ) {\n\t\t\ttween.elem[ tween.prop ] = tween.now;\n\t\t}\n\t}\n};\n\njQuery.easing = {\n\tlinear: function( p ) {\n\t\treturn p;\n\t},\n\tswing: function( p ) {\n\t\treturn 0.5 - Math.cos( p * Math.PI ) / 2;\n\t},\n\t_default: \"swing\"\n};\n\njQuery.fx = Tween.prototype.init;\n\n// Back compat <1.8 extension point\njQuery.fx.step = {};\n\n\n\n\nvar\n\tfxNow, inProgress,\n\trfxtypes = /^(?:toggle|show|hide)$/,\n\trrun = /queueHooks$/;\n\nfunction schedule() {\n\tif ( inProgress ) {\n\t\tif ( document.hidden === false && window.requestAnimationFrame ) {\n\t\t\twindow.requestAnimationFrame( schedule );\n\t\t} else {\n\t\t\twindow.setTimeout( schedule, jQuery.fx.interval );\n\t\t}\n\n\t\tjQuery.fx.tick();\n\t}\n}\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n\twindow.setTimeout( function() {\n\t\tfxNow = undefined;\n\t} );\n\treturn ( fxNow = Date.now() );\n}\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n\tvar which,\n\t\ti = 0,\n\t\tattrs = { height: type };\n\n\t// If we include width, step value is 1 to do all cssExpand values,\n\t// otherwise step value is 2 to skip over Left and Right\n\tincludeWidth = includeWidth ? 1 : 0;\n\tfor ( ; i < 4; i += 2 - includeWidth ) {\n\t\twhich = cssExpand[ i ];\n\t\tattrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n\t}\n\n\tif ( includeWidth ) {\n\t\tattrs.opacity = attrs.width = type;\n\t}\n\n\treturn attrs;\n}\n\nfunction createTween( value, prop, animation ) {\n\tvar tween,\n\t\tcollection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ \"*\" ] ),\n\t\tindex = 0,\n\t\tlength = collection.length;\n\tfor ( ; index < length; index++ ) {\n\t\tif ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {\n\n\t\t\t// We're done with this property\n\t\t\treturn tween;\n\t\t}\n\t}\n}\n\nfunction defaultPrefilter( elem, props, opts ) {\n\tvar prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,\n\t\tisBox = \"width\" in props || \"height\" in props,\n\t\tanim = this,\n\t\torig = {},\n\t\tstyle = elem.style,\n\t\thidden = elem.nodeType && isHiddenWithinTree( elem ),\n\t\tdataShow = dataPriv.get( elem, \"fxshow\" );\n\n\t// Queue-skipping animations hijack the fx hooks\n\tif ( !opts.queue ) {\n\t\thooks = jQuery._queueHooks( elem, \"fx\" );\n\t\tif ( hooks.unqueued == null ) {\n\t\t\thooks.unqueued = 0;\n\t\t\toldfire = hooks.empty.fire;\n\t\t\thooks.empty.fire = function() {\n\t\t\t\tif ( !hooks.unqueued ) {\n\t\t\t\t\toldfire();\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\thooks.unqueued++;\n\n\t\tanim.always( function() {\n\n\t\t\t// Ensure the complete handler is called before this completes\n\t\t\tanim.always( function() {\n\t\t\t\thooks.unqueued--;\n\t\t\t\tif ( !jQuery.queue( elem, \"fx\" ).length ) {\n\t\t\t\t\thooks.empty.fire();\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t// Detect show/hide animations\n\tfor ( prop in props ) {\n\t\tvalue = props[ prop ];\n\t\tif ( rfxtypes.test( value ) ) {\n\t\t\tdelete props[ prop ];\n\t\t\ttoggle = toggle || value === \"toggle\";\n\t\t\tif ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n\n\t\t\t\t// Pretend to be hidden if this is a \"show\" and\n\t\t\t\t// there is still data from a stopped show/hide\n\t\t\t\tif ( value === \"show\" && dataShow && dataShow[ prop ] !== undefined ) {\n\t\t\t\t\thidden = true;\n\n\t\t\t\t// Ignore all other no-op show/hide data\n\t\t\t\t} else {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\torig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n\t\t}\n\t}\n\n\t// Bail out if this is a no-op like .hide().hide()\n\tpropTween = !jQuery.isEmptyObject( props );\n\tif ( !propTween && jQuery.isEmptyObject( orig ) ) {\n\t\treturn;\n\t}\n\n\t// Restrict \"overflow\" and \"display\" styles during box animations\n\tif ( isBox && elem.nodeType === 1 ) {\n\n\t\t// Support: IE <=9 - 11, Edge 12 - 15\n\t\t// Record all 3 overflow attributes because IE does not infer the shorthand\n\t\t// from identically-valued overflowX and overflowY and Edge just mirrors\n\t\t// the overflowX value there.\n\t\topts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n\t\t// Identify a display type, preferring old show/hide data over the CSS cascade\n\t\trestoreDisplay = dataShow && dataShow.display;\n\t\tif ( restoreDisplay == null ) {\n\t\t\trestoreDisplay = dataPriv.get( elem, \"display\" );\n\t\t}\n\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\tif ( display === \"none\" ) {\n\t\t\tif ( restoreDisplay ) {\n\t\t\t\tdisplay = restoreDisplay;\n\t\t\t} else {\n\n\t\t\t\t// Get nonempty value(s) by temporarily forcing visibility\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t\trestoreDisplay = elem.style.display || restoreDisplay;\n\t\t\t\tdisplay = jQuery.css( elem, \"display\" );\n\t\t\t\tshowHide( [ elem ] );\n\t\t\t}\n\t\t}\n\n\t\t// Animate inline elements as inline-block\n\t\tif ( display === \"inline\" || display === \"inline-block\" && restoreDisplay != null ) {\n\t\t\tif ( jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n\t\t\t\t// Restore the original display value at the end of pure show/hide animations\n\t\t\t\tif ( !propTween ) {\n\t\t\t\t\tanim.done( function() {\n\t\t\t\t\t\tstyle.display = restoreDisplay;\n\t\t\t\t\t} );\n\t\t\t\t\tif ( restoreDisplay == null ) {\n\t\t\t\t\t\tdisplay = style.display;\n\t\t\t\t\t\trestoreDisplay = display === \"none\" ? \"\" : display;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstyle.display = \"inline-block\";\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( opts.overflow ) {\n\t\tstyle.overflow = \"hidden\";\n\t\tanim.always( function() {\n\t\t\tstyle.overflow = opts.overflow[ 0 ];\n\t\t\tstyle.overflowX = opts.overflow[ 1 ];\n\t\t\tstyle.overflowY = opts.overflow[ 2 ];\n\t\t} );\n\t}\n\n\t// Implement show/hide animations\n\tpropTween = false;\n\tfor ( prop in orig ) {\n\n\t\t// General show/hide setup for this element animation\n\t\tif ( !propTween ) {\n\t\t\tif ( dataShow ) {\n\t\t\t\tif ( \"hidden\" in dataShow ) {\n\t\t\t\t\thidden = dataShow.hidden;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdataShow = dataPriv.access( elem, \"fxshow\", { display: restoreDisplay } );\n\t\t\t}\n\n\t\t\t// Store hidden/visible for toggle so `.stop().toggle()` \"reverses\"\n\t\t\tif ( toggle ) {\n\t\t\t\tdataShow.hidden = !hidden;\n\t\t\t}\n\n\t\t\t// Show elements before animating them\n\t\t\tif ( hidden ) {\n\t\t\t\tshowHide( [ elem ], true );\n\t\t\t}\n\n\t\t\t/* eslint-disable no-loop-func */\n\n\t\t\tanim.done( function() {\n\n\t\t\t/* eslint-enable no-loop-func */\n\n\t\t\t\t// The final step of a \"hide\" animation is actually hiding the element\n\t\t\t\tif ( !hidden ) {\n\t\t\t\t\tshowHide( [ elem ] );\n\t\t\t\t}\n\t\t\t\tdataPriv.remove( elem, \"fxshow\" );\n\t\t\t\tfor ( prop in orig ) {\n\t\t\t\t\tjQuery.style( elem, prop, orig[ prop ] );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\n\t\t// Per-property setup\n\t\tpropTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\t\tif ( !( prop in dataShow ) ) {\n\t\t\tdataShow[ prop ] = propTween.start;\n\t\t\tif ( hidden ) {\n\t\t\t\tpropTween.end = propTween.start;\n\t\t\t\tpropTween.start = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction propFilter( props, specialEasing ) {\n\tvar index, name, easing, value, hooks;\n\n\t// camelCase, specialEasing and expand cssHook pass\n\tfor ( index in props ) {\n\t\tname = camelCase( index );\n\t\teasing = specialEasing[ name ];\n\t\tvalue = props[ index ];\n\t\tif ( Array.isArray( value ) ) {\n\t\t\teasing = value[ 1 ];\n\t\t\tvalue = props[ index ] = value[ 0 ];\n\t\t}\n\n\t\tif ( index !== name ) {\n\t\t\tprops[ name ] = value;\n\t\t\tdelete props[ index ];\n\t\t}\n\n\t\thooks = jQuery.cssHooks[ name ];\n\t\tif ( hooks && \"expand\" in hooks ) {\n\t\t\tvalue = hooks.expand( value );\n\t\t\tdelete props[ name ];\n\n\t\t\t// Not quite $.extend, this won't overwrite existing keys.\n\t\t\t// Reusing 'index' because we have the correct \"name\"\n\t\t\tfor ( index in value ) {\n\t\t\t\tif ( !( index in props ) ) {\n\t\t\t\t\tprops[ index ] = value[ index ];\n\t\t\t\t\tspecialEasing[ index ] = easing;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tspecialEasing[ name ] = easing;\n\t\t}\n\t}\n}\n\nfunction Animation( elem, properties, options ) {\n\tvar result,\n\t\tstopped,\n\t\tindex = 0,\n\t\tlength = Animation.prefilters.length,\n\t\tdeferred = jQuery.Deferred().always( function() {\n\n\t\t\t// Don't match elem in the :animated selector\n\t\t\tdelete tick.elem;\n\t\t} ),\n\t\ttick = function() {\n\t\t\tif ( stopped ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar currentTime = fxNow || createFxNow(),\n\t\t\t\tremaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n\n\t\t\t\t// Support: Android 2.3 only\n\t\t\t\t// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)\n\t\t\t\ttemp = remaining / animation.duration || 0,\n\t\t\t\tpercent = 1 - temp,\n\t\t\t\tindex = 0,\n\t\t\t\tlength = animation.tweens.length;\n\n\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\tanimation.tweens[ index ].run( percent );\n\t\t\t}\n\n\t\t\tdeferred.notifyWith( elem, [ animation, percent, remaining ] );\n\n\t\t\t// If there's more to do, yield\n\t\t\tif ( percent < 1 && length ) {\n\t\t\t\treturn remaining;\n\t\t\t}\n\n\t\t\t// If this was an empty animation, synthesize a final progress notification\n\t\t\tif ( !length ) {\n\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t}\n\n\t\t\t// Resolve the animation and report its conclusion\n\t\t\tdeferred.resolveWith( elem, [ animation ] );\n\t\t\treturn false;\n\t\t},\n\t\tanimation = deferred.promise( {\n\t\t\telem: elem,\n\t\t\tprops: jQuery.extend( {}, properties ),\n\t\t\topts: jQuery.extend( true, {\n\t\t\t\tspecialEasing: {},\n\t\t\t\teasing: jQuery.easing._default\n\t\t\t}, options ),\n\t\t\toriginalProperties: properties,\n\t\t\toriginalOptions: options,\n\t\t\tstartTime: fxNow || createFxNow(),\n\t\t\tduration: options.duration,\n\t\t\ttweens: [],\n\t\t\tcreateTween: function( prop, end ) {\n\t\t\t\tvar tween = jQuery.Tween( elem, animation.opts, prop, end,\n\t\t\t\t\t\tanimation.opts.specialEasing[ prop ] || animation.opts.easing );\n\t\t\t\tanimation.tweens.push( tween );\n\t\t\t\treturn tween;\n\t\t\t},\n\t\t\tstop: function( gotoEnd ) {\n\t\t\t\tvar index = 0,\n\n\t\t\t\t\t// If we are going to the end, we want to run all the tweens\n\t\t\t\t\t// otherwise we skip this part\n\t\t\t\t\tlength = gotoEnd ? animation.tweens.length : 0;\n\t\t\t\tif ( stopped ) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tstopped = true;\n\t\t\t\tfor ( ; index < length; index++ ) {\n\t\t\t\t\tanimation.tweens[ index ].run( 1 );\n\t\t\t\t}\n\n\t\t\t\t// Resolve when we played the last frame; otherwise, reject\n\t\t\t\tif ( gotoEnd ) {\n\t\t\t\t\tdeferred.notifyWith( elem, [ animation, 1, 0 ] );\n\t\t\t\t\tdeferred.resolveWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith( elem, [ animation, gotoEnd ] );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} ),\n\t\tprops = animation.props;\n\n\tpropFilter( props, animation.opts.specialEasing );\n\n\tfor ( ; index < length; index++ ) {\n\t\tresult = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );\n\t\tif ( result ) {\n\t\t\tif ( isFunction( result.stop ) ) {\n\t\t\t\tjQuery._queueHooks( animation.elem, animation.opts.queue ).stop =\n\t\t\t\t\tresult.stop.bind( result );\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\tjQuery.map( props, createTween, animation );\n\n\tif ( isFunction( animation.opts.start ) ) {\n\t\tanimation.opts.start.call( elem, animation );\n\t}\n\n\t// Attach callbacks from options\n\tanimation\n\t\t.progress( animation.opts.progress )\n\t\t.done( animation.opts.done, animation.opts.complete )\n\t\t.fail( animation.opts.fail )\n\t\t.always( animation.opts.always );\n\n\tjQuery.fx.timer(\n\t\tjQuery.extend( tick, {\n\t\t\telem: elem,\n\t\t\tanim: animation,\n\t\t\tqueue: animation.opts.queue\n\t\t} )\n\t);\n\n\treturn animation;\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n\ttweeners: {\n\t\t\"*\": [ function( prop, value ) {\n\t\t\tvar tween = this.createTween( prop, value );\n\t\t\tadjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );\n\t\t\treturn tween;\n\t\t} ]\n\t},\n\n\ttweener: function( props, callback ) {\n\t\tif ( isFunction( props ) ) {\n\t\t\tcallback = props;\n\t\t\tprops = [ \"*\" ];\n\t\t} else {\n\t\t\tprops = props.match( rnothtmlwhite );\n\t\t}\n\n\t\tvar prop,\n\t\t\tindex = 0,\n\t\t\tlength = props.length;\n\n\t\tfor ( ; index < length; index++ ) {\n\t\t\tprop = props[ index ];\n\t\t\tAnimation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];\n\t\t\tAnimation.tweeners[ prop ].unshift( callback );\n\t\t}\n\t},\n\n\tprefilters: [ defaultPrefilter ],\n\n\tprefilter: function( callback, prepend ) {\n\t\tif ( prepend ) {\n\t\t\tAnimation.prefilters.unshift( callback );\n\t\t} else {\n\t\t\tAnimation.prefilters.push( callback );\n\t\t}\n\t}\n} );\n\njQuery.speed = function( speed, easing, fn ) {\n\tvar opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n\t\tcomplete: fn || !fn && easing ||\n\t\t\tisFunction( speed ) && speed,\n\t\tduration: speed,\n\t\teasing: fn && easing || easing && !isFunction( easing ) && easing\n\t};\n\n\t// Go to the end state if fx are off\n\tif ( jQuery.fx.off ) {\n\t\topt.duration = 0;\n\n\t} else {\n\t\tif ( typeof opt.duration !== \"number\" ) {\n\t\t\tif ( opt.duration in jQuery.fx.speeds ) {\n\t\t\t\topt.duration = jQuery.fx.speeds[ opt.duration ];\n\n\t\t\t} else {\n\t\t\t\topt.duration = jQuery.fx.speeds._default;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normalize opt.queue - true/undefined/null -> \"fx\"\n\tif ( opt.queue == null || opt.queue === true ) {\n\t\topt.queue = \"fx\";\n\t}\n\n\t// Queueing\n\topt.old = opt.complete;\n\n\topt.complete = function() {\n\t\tif ( isFunction( opt.old ) ) {\n\t\t\topt.old.call( this );\n\t\t}\n\n\t\tif ( opt.queue ) {\n\t\t\tjQuery.dequeue( this, opt.queue );\n\t\t}\n\t};\n\n\treturn opt;\n};\n\njQuery.fn.extend( {\n\tfadeTo: function( speed, to, easing, callback ) {\n\n\t\t// Show any hidden elements after setting opacity to 0\n\t\treturn this.filter( isHiddenWithinTree ).css( \"opacity\", 0 ).show()\n\n\t\t\t// Animate to the value specified\n\t\t\t.end().animate( { opacity: to }, speed, easing, callback );\n\t},\n\tanimate: function( prop, speed, easing, callback ) {\n\t\tvar empty = jQuery.isEmptyObject( prop ),\n\t\t\toptall = jQuery.speed( speed, easing, callback ),\n\t\t\tdoAnimation = function() {\n\n\t\t\t\t// Operate on a copy of prop so per-property easing won't be lost\n\t\t\t\tvar anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n\t\t\t\t// Empty animations, or finishing resolves immediately\n\t\t\t\tif ( empty || dataPriv.get( this, \"finish\" ) ) {\n\t\t\t\t\tanim.stop( true );\n\t\t\t\t}\n\t\t\t};\n\t\t\tdoAnimation.finish = doAnimation;\n\n\t\treturn empty || optall.queue === false ?\n\t\t\tthis.each( doAnimation ) :\n\t\t\tthis.queue( optall.queue, doAnimation );\n\t},\n\tstop: function( type, clearQueue, gotoEnd ) {\n\t\tvar stopQueue = function( hooks ) {\n\t\t\tvar stop = hooks.stop;\n\t\t\tdelete hooks.stop;\n\t\t\tstop( gotoEnd );\n\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tgotoEnd = clearQueue;\n\t\t\tclearQueue = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\tif ( clearQueue ) {\n\t\t\tthis.queue( type || \"fx\", [] );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar dequeue = true,\n\t\t\t\tindex = type != null && type + \"queueHooks\",\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tdata = dataPriv.get( this );\n\n\t\t\tif ( index ) {\n\t\t\t\tif ( data[ index ] && data[ index ].stop ) {\n\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor ( index in data ) {\n\t\t\t\t\tif ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n\t\t\t\t\t\tstopQueue( data[ index ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this &&\n\t\t\t\t\t( type == null || timers[ index ].queue === type ) ) {\n\n\t\t\t\t\ttimers[ index ].anim.stop( gotoEnd );\n\t\t\t\t\tdequeue = false;\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Start the next in the queue if the last step wasn't forced.\n\t\t\t// Timers currently will call their complete callbacks, which\n\t\t\t// will dequeue but only if they were gotoEnd.\n\t\t\tif ( dequeue || !gotoEnd ) {\n\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t}\n\t\t} );\n\t},\n\tfinish: function( type ) {\n\t\tif ( type !== false ) {\n\t\t\ttype = type || \"fx\";\n\t\t}\n\t\treturn this.each( function() {\n\t\t\tvar index,\n\t\t\t\tdata = dataPriv.get( this ),\n\t\t\t\tqueue = data[ type + \"queue\" ],\n\t\t\t\thooks = data[ type + \"queueHooks\" ],\n\t\t\t\ttimers = jQuery.timers,\n\t\t\t\tlength = queue ? queue.length : 0;\n\n\t\t\t// Enable finishing flag on private data\n\t\t\tdata.finish = true;\n\n\t\t\t// Empty the queue first\n\t\t\tjQuery.queue( this, type, [] );\n\n\t\t\tif ( hooks && hooks.stop ) {\n\t\t\t\thooks.stop.call( this, true );\n\t\t\t}\n\n\t\t\t// Look for any active animations, and finish them\n\t\t\tfor ( index = timers.length; index--; ) {\n\t\t\t\tif ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n\t\t\t\t\ttimers[ index ].anim.stop( true );\n\t\t\t\t\ttimers.splice( index, 1 );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Look for any animations in the old queue and finish them\n\t\t\tfor ( index = 0; index < length; index++ ) {\n\t\t\t\tif ( queue[ index ] && queue[ index ].finish ) {\n\t\t\t\t\tqueue[ index ].finish.call( this );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Turn off finishing flag\n\t\t\tdelete data.finish;\n\t\t} );\n\t}\n} );\n\njQuery.each( [ \"toggle\", \"show\", \"hide\" ], function( _i, name ) {\n\tvar cssFn = jQuery.fn[ name ];\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn speed == null || typeof speed === \"boolean\" ?\n\t\t\tcssFn.apply( this, arguments ) :\n\t\t\tthis.animate( genFx( name, true ), speed, easing, callback );\n\t};\n} );\n\n// Generate shortcuts for custom animations\njQuery.each( {\n\tslideDown: genFx( \"show\" ),\n\tslideUp: genFx( \"hide\" ),\n\tslideToggle: genFx( \"toggle\" ),\n\tfadeIn: { opacity: \"show\" },\n\tfadeOut: { opacity: \"hide\" },\n\tfadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n\tjQuery.fn[ name ] = function( speed, easing, callback ) {\n\t\treturn this.animate( props, speed, easing, callback );\n\t};\n} );\n\njQuery.timers = [];\njQuery.fx.tick = function() {\n\tvar timer,\n\t\ti = 0,\n\t\ttimers = jQuery.timers;\n\n\tfxNow = Date.now();\n\n\tfor ( ; i < timers.length; i++ ) {\n\t\ttimer = timers[ i ];\n\n\t\t// Run the timer and safely remove it when done (allowing for external removal)\n\t\tif ( !timer() && timers[ i ] === timer ) {\n\t\t\ttimers.splice( i--, 1 );\n\t\t}\n\t}\n\n\tif ( !timers.length ) {\n\t\tjQuery.fx.stop();\n\t}\n\tfxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n\tjQuery.timers.push( timer );\n\tjQuery.fx.start();\n};\n\njQuery.fx.interval = 13;\njQuery.fx.start = function() {\n\tif ( inProgress ) {\n\t\treturn;\n\t}\n\n\tinProgress = true;\n\tschedule();\n};\n\njQuery.fx.stop = function() {\n\tinProgress = null;\n};\n\njQuery.fx.speeds = {\n\tslow: 600,\n\tfast: 200,\n\n\t// Default speed\n\t_default: 400\n};\n\n\n// Based off of the plugin by Clint Helfers, with permission.\n// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/\njQuery.fn.delay = function( time, type ) {\n\ttime = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n\ttype = type || \"fx\";\n\n\treturn this.queue( type, function( next, hooks ) {\n\t\tvar timeout = window.setTimeout( next, time );\n\t\thooks.stop = function() {\n\t\t\twindow.clearTimeout( timeout );\n\t\t};\n\t} );\n};\n\n\n( function() {\n\tvar input = document.createElement( \"input\" ),\n\t\tselect = document.createElement( \"select\" ),\n\t\topt = select.appendChild( document.createElement( \"option\" ) );\n\n\tinput.type = \"checkbox\";\n\n\t// Support: Android <=4.3 only\n\t// Default value for a checkbox should be \"on\"\n\tsupport.checkOn = input.value !== \"\";\n\n\t// Support: IE <=11 only\n\t// Must access selectedIndex to make default options select\n\tsupport.optSelected = opt.selected;\n\n\t// Support: IE <=11 only\n\t// An input loses its value after becoming a radio\n\tinput = document.createElement( \"input\" );\n\tinput.value = \"t\";\n\tinput.type = \"radio\";\n\tsupport.radioValue = input.value === \"t\";\n} )();\n\n\nvar boolHook,\n\tattrHandle = jQuery.expr.attrHandle;\n\njQuery.fn.extend( {\n\tattr: function( name, value ) {\n\t\treturn access( this, jQuery.attr, name, value, arguments.length > 1 );\n\t},\n\n\tremoveAttr: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.removeAttr( this, name );\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tattr: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set attributes on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Fallback to prop when attributes are not supported\n\t\tif ( typeof elem.getAttribute === \"undefined\" ) {\n\t\t\treturn jQuery.prop( elem, name, value );\n\t\t}\n\n\t\t// Attribute hooks are determined by the lowercase version\n\t\t// Grab necessary hook if one is defined\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\t\t\thooks = jQuery.attrHooks[ name.toLowerCase() ] ||\n\t\t\t\t( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( value === null ) {\n\t\t\t\tjQuery.removeAttr( elem, name );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\telem.setAttribute( name, value + \"\" );\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\tret = jQuery.find.attr( elem, name );\n\n\t\t// Non-existent attributes return null, we normalize to undefined\n\t\treturn ret == null ? undefined : ret;\n\t},\n\n\tattrHooks: {\n\t\ttype: {\n\t\t\tset: function( elem, value ) {\n\t\t\t\tif ( !support.radioValue && value === \"radio\" &&\n\t\t\t\t\tnodeName( elem, \"input\" ) ) {\n\t\t\t\t\tvar val = elem.value;\n\t\t\t\t\telem.setAttribute( \"type\", value );\n\t\t\t\t\tif ( val ) {\n\t\t\t\t\t\telem.value = val;\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tremoveAttr: function( elem, value ) {\n\t\tvar name,\n\t\t\ti = 0,\n\n\t\t\t// Attribute names can contain non-HTML whitespace characters\n\t\t\t// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n\t\t\tattrNames = value && value.match( rnothtmlwhite );\n\n\t\tif ( attrNames && elem.nodeType === 1 ) {\n\t\t\twhile ( ( name = attrNames[ i++ ] ) ) {\n\t\t\t\telem.removeAttribute( name );\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Hooks for boolean attributes\nboolHook = {\n\tset: function( elem, value, name ) {\n\t\tif ( value === false ) {\n\n\t\t\t// Remove boolean attributes when set to false\n\t\t\tjQuery.removeAttr( elem, name );\n\t\t} else {\n\t\t\telem.setAttribute( name, name );\n\t\t}\n\t\treturn name;\n\t}\n};\n\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( _i, name ) {\n\tvar getter = attrHandle[ name ] || jQuery.find.attr;\n\n\tattrHandle[ name ] = function( elem, name, isXML ) {\n\t\tvar ret, handle,\n\t\t\tlowercaseName = name.toLowerCase();\n\n\t\tif ( !isXML ) {\n\n\t\t\t// Avoid an infinite loop by temporarily removing this function from the getter\n\t\t\thandle = attrHandle[ lowercaseName ];\n\t\t\tattrHandle[ lowercaseName ] = ret;\n\t\t\tret = getter( elem, name, isXML ) != null ?\n\t\t\t\tlowercaseName :\n\t\t\t\tnull;\n\t\t\tattrHandle[ lowercaseName ] = handle;\n\t\t}\n\t\treturn ret;\n\t};\n} );\n\n\n\n\nvar rfocusable = /^(?:input|select|textarea|button)$/i,\n\trclickable = /^(?:a|area)$/i;\n\njQuery.fn.extend( {\n\tprop: function( name, value ) {\n\t\treturn access( this, jQuery.prop, name, value, arguments.length > 1 );\n\t},\n\n\tremoveProp: function( name ) {\n\t\treturn this.each( function() {\n\t\t\tdelete this[ jQuery.propFix[ name ] || name ];\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tprop: function( elem, name, value ) {\n\t\tvar ret, hooks,\n\t\t\tnType = elem.nodeType;\n\n\t\t// Don't get/set properties on text, comment and attribute nodes\n\t\tif ( nType === 3 || nType === 8 || nType === 2 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n\n\t\t\t// Fix name and attach hooks\n\t\t\tname = jQuery.propFix[ name ] || name;\n\t\t\thooks = jQuery.propHooks[ name ];\n\t\t}\n\n\t\tif ( value !== undefined ) {\n\t\t\tif ( hooks && \"set\" in hooks &&\n\t\t\t\t( ret = hooks.set( elem, value, name ) ) !== undefined ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn ( elem[ name ] = value );\n\t\t}\n\n\t\tif ( hooks && \"get\" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn elem[ name ];\n\t},\n\n\tpropHooks: {\n\t\ttabIndex: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\t// Support: IE <=9 - 11 only\n\t\t\t\t// elem.tabIndex doesn't always return the\n\t\t\t\t// correct value when it hasn't been explicitly set\n\t\t\t\t// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n\t\t\t\t// Use proper attribute retrieval(#12072)\n\t\t\t\tvar tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n\t\t\t\tif ( tabindex ) {\n\t\t\t\t\treturn parseInt( tabindex, 10 );\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\trfocusable.test( elem.nodeName ) ||\n\t\t\t\t\trclickable.test( elem.nodeName ) &&\n\t\t\t\t\telem.href\n\t\t\t\t) {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t},\n\n\tpropFix: {\n\t\t\"for\": \"htmlFor\",\n\t\t\"class\": \"className\"\n\t}\n} );\n\n// Support: IE <=11 only\n// Accessing the selectedIndex property\n// forces the browser to respect setting selected\n// on the option\n// The getter ensures a default option is selected\n// when in an optgroup\n// eslint rule \"no-unused-expressions\" is disabled for this code\n// since it considers such accessions noop\nif ( !support.optSelected ) {\n\tjQuery.propHooks.selected = {\n\t\tget: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent && parent.parentNode ) {\n\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\t\tset: function( elem ) {\n\n\t\t\t/* eslint no-unused-expressions: \"off\" */\n\n\t\t\tvar parent = elem.parentNode;\n\t\t\tif ( parent ) {\n\t\t\t\tparent.selectedIndex;\n\n\t\t\t\tif ( parent.parentNode ) {\n\t\t\t\t\tparent.parentNode.selectedIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\njQuery.each( [\n\t\"tabIndex\",\n\t\"readOnly\",\n\t\"maxLength\",\n\t\"cellSpacing\",\n\t\"cellPadding\",\n\t\"rowSpan\",\n\t\"colSpan\",\n\t\"useMap\",\n\t\"frameBorder\",\n\t\"contentEditable\"\n], function() {\n\tjQuery.propFix[ this.toLowerCase() ] = this;\n} );\n\n\n\n\n\t// Strip and collapse whitespace according to HTML spec\n\t// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace\n\tfunction stripAndCollapse( value ) {\n\t\tvar tokens = value.match( rnothtmlwhite ) || [];\n\t\treturn tokens.join( \" \" );\n\t}\n\n\nfunction getClass( elem ) {\n\treturn elem.getAttribute && elem.getAttribute( \"class\" ) || \"\";\n}\n\nfunction classesToArray( value ) {\n\tif ( Array.isArray( value ) ) {\n\t\treturn value;\n\t}\n\tif ( typeof value === \"string\" ) {\n\t\treturn value.match( rnothtmlwhite ) || [];\n\t}\n\treturn [];\n}\n\njQuery.fn.extend( {\n\taddClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).addClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\t\t\t\t\t\tif ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n\t\t\t\t\t\t\tcur += clazz + \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\tremoveClass: function( value ) {\n\t\tvar classes, elem, cur, curValue, clazz, j, finalValue,\n\t\t\ti = 0;\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( j ) {\n\t\t\t\tjQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );\n\t\t\t} );\n\t\t}\n\n\t\tif ( !arguments.length ) {\n\t\t\treturn this.attr( \"class\", \"\" );\n\t\t}\n\n\t\tclasses = classesToArray( value );\n\n\t\tif ( classes.length ) {\n\t\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\t\tcurValue = getClass( elem );\n\n\t\t\t\t// This expression is here for better compressibility (see addClass)\n\t\t\t\tcur = elem.nodeType === 1 && ( \" \" + stripAndCollapse( curValue ) + \" \" );\n\n\t\t\t\tif ( cur ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\twhile ( ( clazz = classes[ j++ ] ) ) {\n\n\t\t\t\t\t\t// Remove *all* instances\n\t\t\t\t\t\twhile ( cur.indexOf( \" \" + clazz + \" \" ) > -1 ) {\n\t\t\t\t\t\t\tcur = cur.replace( \" \" + clazz + \" \", \" \" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Only assign if different to avoid unneeded rendering.\n\t\t\t\t\tfinalValue = stripAndCollapse( cur );\n\t\t\t\t\tif ( curValue !== finalValue ) {\n\t\t\t\t\t\telem.setAttribute( \"class\", finalValue );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\ttoggleClass: function( value, stateVal ) {\n\t\tvar type = typeof value,\n\t\t\tisValidValue = type === \"string\" || Array.isArray( value );\n\n\t\tif ( typeof stateVal === \"boolean\" && isValidValue ) {\n\t\t\treturn stateVal ? this.addClass( value ) : this.removeClass( value );\n\t\t}\n\n\t\tif ( isFunction( value ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).toggleClass(\n\t\t\t\t\tvalue.call( this, i, getClass( this ), stateVal ),\n\t\t\t\t\tstateVal\n\t\t\t\t);\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar className, i, self, classNames;\n\n\t\t\tif ( isValidValue ) {\n\n\t\t\t\t// Toggle individual class names\n\t\t\t\ti = 0;\n\t\t\t\tself = jQuery( this );\n\t\t\t\tclassNames = classesToArray( value );\n\n\t\t\t\twhile ( ( className = classNames[ i++ ] ) ) {\n\n\t\t\t\t\t// Check each className given, space separated list\n\t\t\t\t\tif ( self.hasClass( className ) ) {\n\t\t\t\t\t\tself.removeClass( className );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.addClass( className );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t// Toggle whole class name\n\t\t\t} else if ( value === undefined || type === \"boolean\" ) {\n\t\t\t\tclassName = getClass( this );\n\t\t\t\tif ( className ) {\n\n\t\t\t\t\t// Store className if set\n\t\t\t\t\tdataPriv.set( this, \"__className__\", className );\n\t\t\t\t}\n\n\t\t\t\t// If the element has a class name or if we're passed `false`,\n\t\t\t\t// then remove the whole classname (if there was one, the above saved it).\n\t\t\t\t// Otherwise bring back whatever was previously saved (if anything),\n\t\t\t\t// falling back to the empty string if nothing was stored.\n\t\t\t\tif ( this.setAttribute ) {\n\t\t\t\t\tthis.setAttribute( \"class\",\n\t\t\t\t\t\tclassName || value === false ?\n\t\t\t\t\t\t\"\" :\n\t\t\t\t\t\tdataPriv.get( this, \"__className__\" ) || \"\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t},\n\n\thasClass: function( selector ) {\n\t\tvar className, elem,\n\t\t\ti = 0;\n\n\t\tclassName = \" \" + selector + \" \";\n\t\twhile ( ( elem = this[ i++ ] ) ) {\n\t\t\tif ( elem.nodeType === 1 &&\n\t\t\t\t( \" \" + stripAndCollapse( getClass( elem ) ) + \" \" ).indexOf( className ) > -1 ) {\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n} );\n\n\n\n\nvar rreturn = /\\r/g;\n\njQuery.fn.extend( {\n\tval: function( value ) {\n\t\tvar hooks, ret, valueIsFunction,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !arguments.length ) {\n\t\t\tif ( elem ) {\n\t\t\t\thooks = jQuery.valHooks[ elem.type ] ||\n\t\t\t\t\tjQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n\t\t\t\tif ( hooks &&\n\t\t\t\t\t\"get\" in hooks &&\n\t\t\t\t\t( ret = hooks.get( elem, \"value\" ) ) !== undefined\n\t\t\t\t) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tret = elem.value;\n\n\t\t\t\t// Handle most common string cases\n\t\t\t\tif ( typeof ret === \"string\" ) {\n\t\t\t\t\treturn ret.replace( rreturn, \"\" );\n\t\t\t\t}\n\n\t\t\t\t// Handle cases where value is null/undef or number\n\t\t\t\treturn ret == null ? \"\" : ret;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueIsFunction = isFunction( value );\n\n\t\treturn this.each( function( i ) {\n\t\t\tvar val;\n\n\t\t\tif ( this.nodeType !== 1 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( valueIsFunction ) {\n\t\t\t\tval = value.call( this, i, jQuery( this ).val() );\n\t\t\t} else {\n\t\t\t\tval = value;\n\t\t\t}\n\n\t\t\t// Treat null/undefined as \"\"; convert numbers to string\n\t\t\tif ( val == null ) {\n\t\t\t\tval = \"\";\n\n\t\t\t} else if ( typeof val === \"number\" ) {\n\t\t\t\tval += \"\";\n\n\t\t\t} else if ( Array.isArray( val ) ) {\n\t\t\t\tval = jQuery.map( val, function( value ) {\n\t\t\t\t\treturn value == null ? \"\" : value + \"\";\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\thooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n\t\t\t// If set returns undefined, fall back to normal setting\n\t\t\tif ( !hooks || !( \"set\" in hooks ) || hooks.set( this, val, \"value\" ) === undefined ) {\n\t\t\t\tthis.value = val;\n\t\t\t}\n\t\t} );\n\t}\n} );\n\njQuery.extend( {\n\tvalHooks: {\n\t\toption: {\n\t\t\tget: function( elem ) {\n\n\t\t\t\tvar val = jQuery.find.attr( elem, \"value\" );\n\t\t\t\treturn val != null ?\n\t\t\t\t\tval :\n\n\t\t\t\t\t// Support: IE <=10 - 11 only\n\t\t\t\t\t// option.text throws exceptions (#14686, #14858)\n\t\t\t\t\t// Strip and collapse whitespace\n\t\t\t\t\t// https://html.spec.whatwg.org/#strip-and-collapse-whitespace\n\t\t\t\t\tstripAndCollapse( jQuery.text( elem ) );\n\t\t\t}\n\t\t},\n\t\tselect: {\n\t\t\tget: function( elem ) {\n\t\t\t\tvar value, option, i,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tindex = elem.selectedIndex,\n\t\t\t\t\tone = elem.type === \"select-one\",\n\t\t\t\t\tvalues = one ? null : [],\n\t\t\t\t\tmax = one ? index + 1 : options.length;\n\n\t\t\t\tif ( index < 0 ) {\n\t\t\t\t\ti = max;\n\n\t\t\t\t} else {\n\t\t\t\t\ti = one ? index : 0;\n\t\t\t\t}\n\n\t\t\t\t// Loop through all the selected options\n\t\t\t\tfor ( ; i < max; i++ ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t// IE8-9 doesn't update selected after form reset (#2551)\n\t\t\t\t\tif ( ( option.selected || i === index ) &&\n\n\t\t\t\t\t\t\t// Don't return options that are disabled or in a disabled optgroup\n\t\t\t\t\t\t\t!option.disabled &&\n\t\t\t\t\t\t\t( !option.parentNode.disabled ||\n\t\t\t\t\t\t\t\t!nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n\t\t\t\t\t\t// Get the specific value for the option\n\t\t\t\t\t\tvalue = jQuery( option ).val();\n\n\t\t\t\t\t\t// We don't need an array for one selects\n\t\t\t\t\t\tif ( one ) {\n\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Multi-Selects return an array\n\t\t\t\t\t\tvalues.push( value );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn values;\n\t\t\t},\n\n\t\t\tset: function( elem, value ) {\n\t\t\t\tvar optionSet, option,\n\t\t\t\t\toptions = elem.options,\n\t\t\t\t\tvalues = jQuery.makeArray( value ),\n\t\t\t\t\ti = options.length;\n\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\toption = options[ i ];\n\n\t\t\t\t\t/* eslint-disable no-cond-assign */\n\n\t\t\t\t\tif ( option.selected =\n\t\t\t\t\t\tjQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\toptionSet = true;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* eslint-enable no-cond-assign */\n\t\t\t\t}\n\n\t\t\t\t// Force browsers to behave consistently when non-matching value is set\n\t\t\t\tif ( !optionSet ) {\n\t\t\t\t\telem.selectedIndex = -1;\n\t\t\t\t}\n\t\t\t\treturn values;\n\t\t\t}\n\t\t}\n\t}\n} );\n\n// Radios and checkboxes getter/setter\njQuery.each( [ \"radio\", \"checkbox\" ], function() {\n\tjQuery.valHooks[ this ] = {\n\t\tset: function( elem, value ) {\n\t\t\tif ( Array.isArray( value ) ) {\n\t\t\t\treturn ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );\n\t\t\t}\n\t\t}\n\t};\n\tif ( !support.checkOn ) {\n\t\tjQuery.valHooks[ this ].get = function( elem ) {\n\t\t\treturn elem.getAttribute( \"value\" ) === null ? \"on\" : elem.value;\n\t\t};\n\t}\n} );\n\n\n\n\n// Return jQuery for attributes-only inclusion\n\n\nsupport.focusin = \"onfocusin\" in window;\n\n\nvar rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n\tstopPropagationCallback = function( e ) {\n\t\te.stopPropagation();\n\t};\n\njQuery.extend( jQuery.event, {\n\n\ttrigger: function( event, data, elem, onlyHandlers ) {\n\n\t\tvar i, cur, tmp, bubbleType, ontype, handle, special, lastElement,\n\t\t\teventPath = [ elem || document ],\n\t\t\ttype = hasOwn.call( event, \"type\" ) ? event.type : event,\n\t\t\tnamespaces = hasOwn.call( event, \"namespace\" ) ? event.namespace.split( \".\" ) : [];\n\n\t\tcur = lastElement = tmp = elem = elem || document;\n\n\t\t// Don't do events on text and comment nodes\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// focus/blur morphs to focusin/out; ensure we're not firing them right now\n\t\tif ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( type.indexOf( \".\" ) > -1 ) {\n\n\t\t\t// Namespaced trigger; create a regexp to match event type in handle()\n\t\t\tnamespaces = type.split( \".\" );\n\t\t\ttype = namespaces.shift();\n\t\t\tnamespaces.sort();\n\t\t}\n\t\tontype = type.indexOf( \":\" ) < 0 && \"on\" + type;\n\n\t\t// Caller can pass in a jQuery.Event object, Object, or just an event type string\n\t\tevent = event[ jQuery.expando ] ?\n\t\t\tevent :\n\t\t\tnew jQuery.Event( type, typeof event === \"object\" && event );\n\n\t\t// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n\t\tevent.isTrigger = onlyHandlers ? 2 : 3;\n\t\tevent.namespace = namespaces.join( \".\" );\n\t\tevent.rnamespace = event.namespace ?\n\t\t\tnew RegExp( \"(^|\\\\.)\" + namespaces.join( \"\\\\.(?:.*\\\\.|)\" ) + \"(\\\\.|$)\" ) :\n\t\t\tnull;\n\n\t\t// Clean up the event in case it is being reused\n\t\tevent.result = undefined;\n\t\tif ( !event.target ) {\n\t\t\tevent.target = elem;\n\t\t}\n\n\t\t// Clone any incoming data and prepend the event, creating the handler arg list\n\t\tdata = data == null ?\n\t\t\t[ event ] :\n\t\t\tjQuery.makeArray( data, [ event ] );\n\n\t\t// Allow special events to draw outside the lines\n\t\tspecial = jQuery.event.special[ type ] || {};\n\t\tif ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Determine event propagation path in advance, per W3C events spec (#9951)\n\t\t// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n\t\tif ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {\n\n\t\t\tbubbleType = special.delegateType || type;\n\t\t\tif ( !rfocusMorph.test( bubbleType + type ) ) {\n\t\t\t\tcur = cur.parentNode;\n\t\t\t}\n\t\t\tfor ( ; cur; cur = cur.parentNode ) {\n\t\t\t\teventPath.push( cur );\n\t\t\t\ttmp = cur;\n\t\t\t}\n\n\t\t\t// Only add window if we got to document (e.g., not plain obj or detached DOM)\n\t\t\tif ( tmp === ( elem.ownerDocument || document ) ) {\n\t\t\t\teventPath.push( tmp.defaultView || tmp.parentWindow || window );\n\t\t\t}\n\t\t}\n\n\t\t// Fire handlers on the event path\n\t\ti = 0;\n\t\twhile ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {\n\t\t\tlastElement = cur;\n\t\t\tevent.type = i > 1 ?\n\t\t\t\tbubbleType :\n\t\t\t\tspecial.bindType || type;\n\n\t\t\t// jQuery handler\n\t\t\thandle = (\n\t\t\t\t\tdataPriv.get( cur, \"events\" ) || Object.create( null )\n\t\t\t\t)[ event.type ] &&\n\t\t\t\tdataPriv.get( cur, \"handle\" );\n\t\t\tif ( handle ) {\n\t\t\t\thandle.apply( cur, data );\n\t\t\t}\n\n\t\t\t// Native handler\n\t\t\thandle = ontype && cur[ ontype ];\n\t\t\tif ( handle && handle.apply && acceptData( cur ) ) {\n\t\t\t\tevent.result = handle.apply( cur, data );\n\t\t\t\tif ( event.result === false ) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tevent.type = type;\n\n\t\t// If nobody prevented the default action, do it now\n\t\tif ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n\t\t\tif ( ( !special._default ||\n\t\t\t\tspecial._default.apply( eventPath.pop(), data ) === false ) &&\n\t\t\t\tacceptData( elem ) ) {\n\n\t\t\t\t// Call a native DOM method on the target with the same name as the event.\n\t\t\t\t// Don't do default actions on window, that's where global variables be (#6170)\n\t\t\t\tif ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {\n\n\t\t\t\t\t// Don't re-trigger an onFOO event when we call its FOO() method\n\t\t\t\t\ttmp = elem[ ontype ];\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = null;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prevent re-triggering of the same event, since we already bubbled it above\n\t\t\t\t\tjQuery.event.triggered = type;\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.addEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\telem[ type ]();\n\n\t\t\t\t\tif ( event.isPropagationStopped() ) {\n\t\t\t\t\t\tlastElement.removeEventListener( type, stopPropagationCallback );\n\t\t\t\t\t}\n\n\t\t\t\t\tjQuery.event.triggered = undefined;\n\n\t\t\t\t\tif ( tmp ) {\n\t\t\t\t\t\telem[ ontype ] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn event.result;\n\t},\n\n\t// Piggyback on a donor event to simulate a different one\n\t// Used only for `focus(in | out)` events\n\tsimulate: function( type, elem, event ) {\n\t\tvar e = jQuery.extend(\n\t\t\tnew jQuery.Event(),\n\t\t\tevent,\n\t\t\t{\n\t\t\t\ttype: type,\n\t\t\t\tisSimulated: true\n\t\t\t}\n\t\t);\n\n\t\tjQuery.event.trigger( e, null, elem );\n\t}\n\n} );\n\njQuery.fn.extend( {\n\n\ttrigger: function( type, data ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.event.trigger( type, data, this );\n\t\t} );\n\t},\n\ttriggerHandler: function( type, data ) {\n\t\tvar elem = this[ 0 ];\n\t\tif ( elem ) {\n\t\t\treturn jQuery.event.trigger( type, data, elem, true );\n\t\t}\n\t}\n} );\n\n\n// Support: Firefox <=44\n// Firefox doesn't have focus(in | out) events\n// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787\n//\n// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1\n// focus(in | out) events fire after focus & blur events,\n// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order\n// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857\nif ( !support.focusin ) {\n\tjQuery.each( { focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n\t\t// Attach a single capturing handler on the document while someone wants focusin/focusout\n\t\tvar handler = function( event ) {\n\t\t\tjQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );\n\t\t};\n\n\t\tjQuery.event.special[ fix ] = {\n\t\t\tsetup: function() {\n\n\t\t\t\t// Handle: regular nodes (via `this.ownerDocument`), window\n\t\t\t\t// (via `this.document`) & document (via `this`).\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix );\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.addEventListener( orig, handler, true );\n\t\t\t\t}\n\t\t\t\tdataPriv.access( doc, fix, ( attaches || 0 ) + 1 );\n\t\t\t},\n\t\t\tteardown: function() {\n\t\t\t\tvar doc = this.ownerDocument || this.document || this,\n\t\t\t\t\tattaches = dataPriv.access( doc, fix ) - 1;\n\n\t\t\t\tif ( !attaches ) {\n\t\t\t\t\tdoc.removeEventListener( orig, handler, true );\n\t\t\t\t\tdataPriv.remove( doc, fix );\n\n\t\t\t\t} else {\n\t\t\t\t\tdataPriv.access( doc, fix, attaches );\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} );\n}\nvar location = window.location;\n\nvar nonce = { guid: Date.now() };\n\nvar rquery = ( /\\?/ );\n\n\n\n// Cross-browser xml parsing\njQuery.parseXML = function( data ) {\n\tvar xml;\n\tif ( !data || typeof data !== \"string\" ) {\n\t\treturn null;\n\t}\n\n\t// Support: IE 9 - 11 only\n\t// IE throws on parseFromString with invalid input.\n\ttry {\n\t\txml = ( new window.DOMParser() ).parseFromString( data, \"text/xml\" );\n\t} catch ( e ) {\n\t\txml = undefined;\n\t}\n\n\tif ( !xml || xml.getElementsByTagName( \"parsererror\" ).length ) {\n\t\tjQuery.error( \"Invalid XML: \" + data );\n\t}\n\treturn xml;\n};\n\n\nvar\n\trbracket = /\\[\\]$/,\n\trCRLF = /\\r?\\n/g,\n\trsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n\trsubmittable = /^(?:input|select|textarea|keygen)/i;\n\nfunction buildParams( prefix, obj, traditional, add ) {\n\tvar name;\n\n\tif ( Array.isArray( obj ) ) {\n\n\t\t// Serialize array item.\n\t\tjQuery.each( obj, function( i, v ) {\n\t\t\tif ( traditional || rbracket.test( prefix ) ) {\n\n\t\t\t\t// Treat each array item as a scalar.\n\t\t\t\tadd( prefix, v );\n\n\t\t\t} else {\n\n\t\t\t\t// Item is non-scalar (array or object), encode its numeric index.\n\t\t\t\tbuildParams(\n\t\t\t\t\tprefix + \"[\" + ( typeof v === \"object\" && v != null ? i : \"\" ) + \"]\",\n\t\t\t\t\tv,\n\t\t\t\t\ttraditional,\n\t\t\t\t\tadd\n\t\t\t\t);\n\t\t\t}\n\t\t} );\n\n\t} else if ( !traditional && toType( obj ) === \"object\" ) {\n\n\t\t// Serialize object item.\n\t\tfor ( name in obj ) {\n\t\t\tbuildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n\t\t}\n\n\t} else {\n\n\t\t// Serialize scalar item.\n\t\tadd( prefix, obj );\n\t}\n}\n\n// Serialize an array of form elements or a set of\n// key/values into a query string\njQuery.param = function( a, traditional ) {\n\tvar prefix,\n\t\ts = [],\n\t\tadd = function( key, valueOrFunction ) {\n\n\t\t\t// If value is a function, invoke it and use its return value\n\t\t\tvar value = isFunction( valueOrFunction ) ?\n\t\t\t\tvalueOrFunction() :\n\t\t\t\tvalueOrFunction;\n\n\t\t\ts[ s.length ] = encodeURIComponent( key ) + \"=\" +\n\t\t\t\tencodeURIComponent( value == null ? \"\" : value );\n\t\t};\n\n\tif ( a == null ) {\n\t\treturn \"\";\n\t}\n\n\t// If an array was passed in, assume that it is an array of form elements.\n\tif ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n\n\t\t// Serialize the form elements\n\t\tjQuery.each( a, function() {\n\t\t\tadd( this.name, this.value );\n\t\t} );\n\n\t} else {\n\n\t\t// If traditional, encode the \"old\" way (the way 1.3.2 or older\n\t\t// did it), otherwise encode params recursively.\n\t\tfor ( prefix in a ) {\n\t\t\tbuildParams( prefix, a[ prefix ], traditional, add );\n\t\t}\n\t}\n\n\t// Return the resulting serialization\n\treturn s.join( \"&\" );\n};\n\njQuery.fn.extend( {\n\tserialize: function() {\n\t\treturn jQuery.param( this.serializeArray() );\n\t},\n\tserializeArray: function() {\n\t\treturn this.map( function() {\n\n\t\t\t// Can add propHook for \"elements\" to filter or add form elements\n\t\t\tvar elements = jQuery.prop( this, \"elements\" );\n\t\t\treturn elements ? jQuery.makeArray( elements ) : this;\n\t\t} )\n\t\t.filter( function() {\n\t\t\tvar type = this.type;\n\n\t\t\t// Use .is( \":disabled\" ) so that fieldset[disabled] works\n\t\t\treturn this.name && !jQuery( this ).is( \":disabled\" ) &&\n\t\t\t\trsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n\t\t\t\t( this.checked || !rcheckableType.test( type ) );\n\t\t} )\n\t\t.map( function( _i, elem ) {\n\t\t\tvar val = jQuery( this ).val();\n\n\t\t\tif ( val == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ( Array.isArray( val ) ) {\n\t\t\t\treturn jQuery.map( val, function( val ) {\n\t\t\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\treturn { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n\t\t} ).get();\n\t}\n} );\n\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\toriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n\t\t\t\t\tuncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Use a noop converter for missing script\n\t\t\tif ( !isSuccess && jQuery.inArray( \"script\", s.dataTypes ) > -1 ) {\n\t\t\t\ts.converters[ \"text script\" ] = function() {};\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\njQuery.ajaxPrefilter( function( s ) {\n\tvar i;\n\tfor ( i in s.headers ) {\n\t\tif ( i.toLowerCase() === \"content-type\" ) {\n\t\t\ts.contentType = s.headers[ i ] || \"\";\n\t\t}\n\t}\n} );\n\n\njQuery._evalUrl = function( url, options, doc ) {\n\treturn jQuery.ajax( {\n\t\turl: url,\n\n\t\t// Make this explicit, since user can override this through ajaxSetup (#11264)\n\t\ttype: \"GET\",\n\t\tdataType: \"script\",\n\t\tcache: true,\n\t\tasync: false,\n\t\tglobal: false,\n\n\t\t// Only evaluate the response if it is successful (gh-4126)\n\t\t// dataFilter is not invoked for failure responses, so using it instead\n\t\t// of the default converter is kludgy but it works.\n\t\tconverters: {\n\t\t\t\"text script\": function() {}\n\t\t},\n\t\tdataFilter: function( response ) {\n\t\t\tjQuery.globalEval( response, options, doc );\n\t\t}\n\t} );\n};\n\n\njQuery.fn.extend( {\n\twrapAll: function( html ) {\n\t\tvar wrap;\n\n\t\tif ( this[ 0 ] ) {\n\t\t\tif ( isFunction( html ) ) {\n\t\t\t\thtml = html.call( this[ 0 ] );\n\t\t\t}\n\n\t\t\t// The elements to wrap the target around\n\t\t\twrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );\n\n\t\t\tif ( this[ 0 ].parentNode ) {\n\t\t\t\twrap.insertBefore( this[ 0 ] );\n\t\t\t}\n\n\t\t\twrap.map( function() {\n\t\t\t\tvar elem = this;\n\n\t\t\t\twhile ( elem.firstElementChild ) {\n\t\t\t\t\telem = elem.firstElementChild;\n\t\t\t\t}\n\n\t\t\t\treturn elem;\n\t\t\t} ).append( this );\n\t\t}\n\n\t\treturn this;\n\t},\n\n\twrapInner: function( html ) {\n\t\tif ( isFunction( html ) ) {\n\t\t\treturn this.each( function( i ) {\n\t\t\t\tjQuery( this ).wrapInner( html.call( this, i ) );\n\t\t\t} );\n\t\t}\n\n\t\treturn this.each( function() {\n\t\t\tvar self = jQuery( this ),\n\t\t\t\tcontents = self.contents();\n\n\t\t\tif ( contents.length ) {\n\t\t\t\tcontents.wrapAll( html );\n\n\t\t\t} else {\n\t\t\t\tself.append( html );\n\t\t\t}\n\t\t} );\n\t},\n\n\twrap: function( html ) {\n\t\tvar htmlIsFunction = isFunction( html );\n\n\t\treturn this.each( function( i ) {\n\t\t\tjQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );\n\t\t} );\n\t},\n\n\tunwrap: function( selector ) {\n\t\tthis.parent( selector ).not( \"body\" ).each( function() {\n\t\t\tjQuery( this ).replaceWith( this.childNodes );\n\t\t} );\n\t\treturn this;\n\t}\n} );\n\n\njQuery.expr.pseudos.hidden = function( elem ) {\n\treturn !jQuery.expr.pseudos.visible( elem );\n};\njQuery.expr.pseudos.visible = function( elem ) {\n\treturn !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );\n};\n\n\n\n\njQuery.ajaxSettings.xhr = function() {\n\ttry {\n\t\treturn new window.XMLHttpRequest();\n\t} catch ( e ) {}\n};\n\nvar xhrSuccessStatus = {\n\n\t\t// File protocol always yields status code 0, assume 200\n\t\t0: 200,\n\n\t\t// Support: IE <=9 only\n\t\t// #1450: sometimes IE returns 1223 when it should be 204\n\t\t1223: 204\n\t},\n\txhrSupported = jQuery.ajaxSettings.xhr();\n\nsupport.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nsupport.ajax = xhrSupported = !!xhrSupported;\n\njQuery.ajaxTransport( function( options ) {\n\tvar callback, errorCallback;\n\n\t// Cross domain only allowed if supported through XMLHttpRequest\n\tif ( support.cors || xhrSupported && !options.crossDomain ) {\n\t\treturn {\n\t\t\tsend: function( headers, complete ) {\n\t\t\t\tvar i,\n\t\t\t\t\txhr = options.xhr();\n\n\t\t\t\txhr.open(\n\t\t\t\t\toptions.type,\n\t\t\t\t\toptions.url,\n\t\t\t\t\toptions.async,\n\t\t\t\t\toptions.username,\n\t\t\t\t\toptions.password\n\t\t\t\t);\n\n\t\t\t\t// Apply custom fields if provided\n\t\t\t\tif ( options.xhrFields ) {\n\t\t\t\t\tfor ( i in options.xhrFields ) {\n\t\t\t\t\t\txhr[ i ] = options.xhrFields[ i ];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Override mime type if needed\n\t\t\t\tif ( options.mimeType && xhr.overrideMimeType ) {\n\t\t\t\t\txhr.overrideMimeType( options.mimeType );\n\t\t\t\t}\n\n\t\t\t\t// X-Requested-With header\n\t\t\t\t// For cross-domain requests, seeing as conditions for a preflight are\n\t\t\t\t// akin to a jigsaw puzzle, we simply never set it to be sure.\n\t\t\t\t// (it can always be set on a per-request basis or even using ajaxSetup)\n\t\t\t\t// For same-domain requests, won't change header if already provided.\n\t\t\t\tif ( !options.crossDomain && !headers[ \"X-Requested-With\" ] ) {\n\t\t\t\t\theaders[ \"X-Requested-With\" ] = \"XMLHttpRequest\";\n\t\t\t\t}\n\n\t\t\t\t// Set headers\n\t\t\t\tfor ( i in headers ) {\n\t\t\t\t\txhr.setRequestHeader( i, headers[ i ] );\n\t\t\t\t}\n\n\t\t\t\t// Callback\n\t\t\t\tcallback = function( type ) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\tcallback = errorCallback = xhr.onload =\n\t\t\t\t\t\t\t\txhr.onerror = xhr.onabort = xhr.ontimeout =\n\t\t\t\t\t\t\t\t\txhr.onreadystatechange = null;\n\n\t\t\t\t\t\t\tif ( type === \"abort\" ) {\n\t\t\t\t\t\t\t\txhr.abort();\n\t\t\t\t\t\t\t} else if ( type === \"error\" ) {\n\n\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t// On a manual native abort, IE9 throws\n\t\t\t\t\t\t\t\t// errors on any property access that is not readyState\n\t\t\t\t\t\t\t\tif ( typeof xhr.status !== \"number\" ) {\n\t\t\t\t\t\t\t\t\tcomplete( 0, \"error\" );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcomplete(\n\n\t\t\t\t\t\t\t\t\t\t// File: protocol always yields status 0; see #8605, #14207\n\t\t\t\t\t\t\t\t\t\txhr.status,\n\t\t\t\t\t\t\t\t\t\txhr.statusText\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcomplete(\n\t\t\t\t\t\t\t\t\txhrSuccessStatus[ xhr.status ] || xhr.status,\n\t\t\t\t\t\t\t\t\txhr.statusText,\n\n\t\t\t\t\t\t\t\t\t// Support: IE <=9 only\n\t\t\t\t\t\t\t\t\t// IE9 has no XHR2 but throws on binary (trac-11426)\n\t\t\t\t\t\t\t\t\t// For XHR2 non-text, let the caller handle it (gh-2498)\n\t\t\t\t\t\t\t\t\t( xhr.responseType || \"text\" ) !== \"text\"  ||\n\t\t\t\t\t\t\t\t\ttypeof xhr.responseText !== \"string\" ?\n\t\t\t\t\t\t\t\t\t\t{ binary: xhr.response } :\n\t\t\t\t\t\t\t\t\t\t{ text: xhr.responseText },\n\t\t\t\t\t\t\t\t\txhr.getAllResponseHeaders()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t};\n\n\t\t\t\t// Listen to events\n\t\t\t\txhr.onload = callback();\n\t\t\t\terrorCallback = xhr.onerror = xhr.ontimeout = callback( \"error\" );\n\n\t\t\t\t// Support: IE 9 only\n\t\t\t\t// Use onreadystatechange to replace onabort\n\t\t\t\t// to handle uncaught aborts\n\t\t\t\tif ( xhr.onabort !== undefined ) {\n\t\t\t\t\txhr.onabort = errorCallback;\n\t\t\t\t} else {\n\t\t\t\t\txhr.onreadystatechange = function() {\n\n\t\t\t\t\t\t// Check readyState before timeout as it changes\n\t\t\t\t\t\tif ( xhr.readyState === 4 ) {\n\n\t\t\t\t\t\t\t// Allow onerror to be called first,\n\t\t\t\t\t\t\t// but that will not handle a native abort\n\t\t\t\t\t\t\t// Also, save errorCallback to a variable\n\t\t\t\t\t\t\t// as xhr.onerror cannot be accessed\n\t\t\t\t\t\t\twindow.setTimeout( function() {\n\t\t\t\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\t\t\t\terrorCallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// Create the abort callback\n\t\t\t\tcallback = callback( \"abort\" );\n\n\t\t\t\ttry {\n\n\t\t\t\t\t// Do send the request (this may raise an exception)\n\t\t\t\t\txhr.send( options.hasContent && options.data || null );\n\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t// #14683: Only rethrow if this hasn't been notified as an error yet\n\t\t\t\t\tif ( callback ) {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\n// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)\njQuery.ajaxPrefilter( function( s ) {\n\tif ( s.crossDomain ) {\n\t\ts.contents.script = false;\n\t}\n} );\n\n// Install script dataType\njQuery.ajaxSetup( {\n\taccepts: {\n\t\tscript: \"text/javascript, application/javascript, \" +\n\t\t\t\"application/ecmascript, application/x-ecmascript\"\n\t},\n\tcontents: {\n\t\tscript: /\\b(?:java|ecma)script\\b/\n\t},\n\tconverters: {\n\t\t\"text script\": function( text ) {\n\t\t\tjQuery.globalEval( text );\n\t\t\treturn text;\n\t\t}\n\t}\n} );\n\n// Handle cache's special case and crossDomain\njQuery.ajaxPrefilter( \"script\", function( s ) {\n\tif ( s.cache === undefined ) {\n\t\ts.cache = false;\n\t}\n\tif ( s.crossDomain ) {\n\t\ts.type = \"GET\";\n\t}\n} );\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function( s ) {\n\n\t// This transport only deals with cross domain or forced-by-attrs requests\n\tif ( s.crossDomain || s.scriptAttrs ) {\n\t\tvar script, callback;\n\t\treturn {\n\t\t\tsend: function( _, complete ) {\n\t\t\t\tscript = jQuery( \"<script>\" )\n\t\t\t\t\t.attr( s.scriptAttrs || {} )\n\t\t\t\t\t.prop( { charset: s.scriptCharset, src: s.url } )\n\t\t\t\t\t.on( \"load error\", callback = function( evt ) {\n\t\t\t\t\t\tscript.remove();\n\t\t\t\t\t\tcallback = null;\n\t\t\t\t\t\tif ( evt ) {\n\t\t\t\t\t\t\tcomplete( evt.type === \"error\" ? 404 : 200, evt.type );\n\t\t\t\t\t\t}\n\t\t\t\t\t} );\n\n\t\t\t\t// Use native DOM manipulation to avoid our domManip AJAX trickery\n\t\t\t\tdocument.head.appendChild( script[ 0 ] );\n\t\t\t},\n\t\t\tabort: function() {\n\t\t\t\tif ( callback ) {\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n} );\n\n\n\n\nvar oldCallbacks = [],\n\trjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup( {\n\tjsonp: \"callback\",\n\tjsonpCallback: function() {\n\t\tvar callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( nonce.guid++ ) );\n\t\tthis[ callback ] = true;\n\t\treturn callback;\n\t}\n} );\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n\tvar callbackName, overwritten, responseContainer,\n\t\tjsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n\t\t\t\"url\" :\n\t\t\ttypeof s.data === \"string\" &&\n\t\t\t\t( s.contentType || \"\" )\n\t\t\t\t\t.indexOf( \"application/x-www-form-urlencoded\" ) === 0 &&\n\t\t\t\trjsonp.test( s.data ) && \"data\"\n\t\t);\n\n\t// Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n\tif ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n\t\t// Get callback name, remembering preexisting value associated with it\n\t\tcallbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?\n\t\t\ts.jsonpCallback() :\n\t\t\ts.jsonpCallback;\n\n\t\t// Insert callback into url or form data\n\t\tif ( jsonProp ) {\n\t\t\ts[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n\t\t} else if ( s.jsonp !== false ) {\n\t\t\ts.url += ( rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n\t\t}\n\n\t\t// Use data converter to retrieve json after script execution\n\t\ts.converters[ \"script json\" ] = function() {\n\t\t\tif ( !responseContainer ) {\n\t\t\t\tjQuery.error( callbackName + \" was not called\" );\n\t\t\t}\n\t\t\treturn responseContainer[ 0 ];\n\t\t};\n\n\t\t// Force json dataType\n\t\ts.dataTypes[ 0 ] = \"json\";\n\n\t\t// Install callback\n\t\toverwritten = window[ callbackName ];\n\t\twindow[ callbackName ] = function() {\n\t\t\tresponseContainer = arguments;\n\t\t};\n\n\t\t// Clean-up function (fires after converters)\n\t\tjqXHR.always( function() {\n\n\t\t\t// If previous value didn't exist - remove it\n\t\t\tif ( overwritten === undefined ) {\n\t\t\t\tjQuery( window ).removeProp( callbackName );\n\n\t\t\t// Otherwise restore preexisting value\n\t\t\t} else {\n\t\t\t\twindow[ callbackName ] = overwritten;\n\t\t\t}\n\n\t\t\t// Save back as free\n\t\t\tif ( s[ callbackName ] ) {\n\n\t\t\t\t// Make sure that re-using the options doesn't screw things around\n\t\t\t\ts.jsonpCallback = originalSettings.jsonpCallback;\n\n\t\t\t\t// Save the callback name for future use\n\t\t\t\toldCallbacks.push( callbackName );\n\t\t\t}\n\n\t\t\t// Call if it was a function and we have a response\n\t\t\tif ( responseContainer && isFunction( overwritten ) ) {\n\t\t\t\toverwritten( responseContainer[ 0 ] );\n\t\t\t}\n\n\t\t\tresponseContainer = overwritten = undefined;\n\t\t} );\n\n\t\t// Delegate to script\n\t\treturn \"script\";\n\t}\n} );\n\n\n\n\n// Support: Safari 8 only\n// In Safari 8 documents created via document.implementation.createHTMLDocument\n// collapse sibling forms: the second one becomes a child of the first one.\n// Because of that, this security measure has to be disabled in Safari 8.\n// https://bugs.webkit.org/show_bug.cgi?id=137337\nsupport.createHTMLDocument = ( function() {\n\tvar body = document.implementation.createHTMLDocument( \"\" ).body;\n\tbody.innerHTML = \"<form></form><form></form>\";\n\treturn body.childNodes.length === 2;\n} )();\n\n\n// Argument \"data\" should be string of html\n// context (optional): If specified, the fragment will be created in this context,\n// defaults to document\n// keepScripts (optional): If true, will include scripts passed in the html string\njQuery.parseHTML = function( data, context, keepScripts ) {\n\tif ( typeof data !== \"string\" ) {\n\t\treturn [];\n\t}\n\tif ( typeof context === \"boolean\" ) {\n\t\tkeepScripts = context;\n\t\tcontext = false;\n\t}\n\n\tvar base, parsed, scripts;\n\n\tif ( !context ) {\n\n\t\t// Stop scripts or inline event handlers from being executed immediately\n\t\t// by using document.implementation\n\t\tif ( support.createHTMLDocument ) {\n\t\t\tcontext = document.implementation.createHTMLDocument( \"\" );\n\n\t\t\t// Set the base href for the created document\n\t\t\t// so any parsed elements with URLs\n\t\t\t// are based on the document's URL (gh-2965)\n\t\t\tbase = context.createElement( \"base\" );\n\t\t\tbase.href = document.location.href;\n\t\t\tcontext.head.appendChild( base );\n\t\t} else {\n\t\t\tcontext = document;\n\t\t}\n\t}\n\n\tparsed = rsingleTag.exec( data );\n\tscripts = !keepScripts && [];\n\n\t// Single tag\n\tif ( parsed ) {\n\t\treturn [ context.createElement( parsed[ 1 ] ) ];\n\t}\n\n\tparsed = buildFragment( [ data ], context, scripts );\n\n\tif ( scripts && scripts.length ) {\n\t\tjQuery( scripts ).remove();\n\t}\n\n\treturn jQuery.merge( [], parsed.childNodes );\n};\n\n\n/**\n * Load a url into a page\n */\njQuery.fn.load = function( url, params, callback ) {\n\tvar selector, type, response,\n\t\tself = this,\n\t\toff = url.indexOf( \" \" );\n\n\tif ( off > -1 ) {\n\t\tselector = stripAndCollapse( url.slice( off ) );\n\t\turl = url.slice( 0, off );\n\t}\n\n\t// If it's a function\n\tif ( isFunction( params ) ) {\n\n\t\t// We assume that it's the callback\n\t\tcallback = params;\n\t\tparams = undefined;\n\n\t// Otherwise, build a param string\n\t} else if ( params && typeof params === \"object\" ) {\n\t\ttype = \"POST\";\n\t}\n\n\t// If we have elements to modify, make the request\n\tif ( self.length > 0 ) {\n\t\tjQuery.ajax( {\n\t\t\turl: url,\n\n\t\t\t// If \"type\" variable is undefined, then \"GET\" method will be used.\n\t\t\t// Make value of this field explicit since\n\t\t\t// user can override it through ajaxSetup method\n\t\t\ttype: type || \"GET\",\n\t\t\tdataType: \"html\",\n\t\t\tdata: params\n\t\t} ).done( function( responseText ) {\n\n\t\t\t// Save response for use in complete callback\n\t\t\tresponse = arguments;\n\n\t\t\tself.html( selector ?\n\n\t\t\t\t// If a selector was specified, locate the right elements in a dummy div\n\t\t\t\t// Exclude scripts to avoid IE 'Permission Denied' errors\n\t\t\t\tjQuery( \"<div>\" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n\t\t\t\t// Otherwise use the full result\n\t\t\t\tresponseText );\n\n\t\t// If the request succeeds, this function gets \"data\", \"status\", \"jqXHR\"\n\t\t// but they are ignored because response was set above.\n\t\t// If it fails, this function gets \"jqXHR\", \"status\", \"error\"\n\t\t} ).always( callback && function( jqXHR, status ) {\n\t\t\tself.each( function() {\n\t\t\t\tcallback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );\n\t\t\t} );\n\t\t} );\n\t}\n\n\treturn this;\n};\n\n\n\n\njQuery.expr.pseudos.animated = function( elem ) {\n\treturn jQuery.grep( jQuery.timers, function( fn ) {\n\t\treturn elem === fn.elem;\n\t} ).length;\n};\n\n\n\n\njQuery.offset = {\n\tsetOffset: function( elem, options, i ) {\n\t\tvar curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,\n\t\t\tposition = jQuery.css( elem, \"position\" ),\n\t\t\tcurElem = jQuery( elem ),\n\t\t\tprops = {};\n\n\t\t// Set position first, in-case top/left are set even on static elem\n\t\tif ( position === \"static\" ) {\n\t\t\telem.style.position = \"relative\";\n\t\t}\n\n\t\tcurOffset = curElem.offset();\n\t\tcurCSSTop = jQuery.css( elem, \"top\" );\n\t\tcurCSSLeft = jQuery.css( elem, \"left\" );\n\t\tcalculatePosition = ( position === \"absolute\" || position === \"fixed\" ) &&\n\t\t\t( curCSSTop + curCSSLeft ).indexOf( \"auto\" ) > -1;\n\n\t\t// Need to be able to calculate position if either\n\t\t// top or left is auto and position is either absolute or fixed\n\t\tif ( calculatePosition ) {\n\t\t\tcurPosition = curElem.position();\n\t\t\tcurTop = curPosition.top;\n\t\t\tcurLeft = curPosition.left;\n\n\t\t} else {\n\t\t\tcurTop = parseFloat( curCSSTop ) || 0;\n\t\t\tcurLeft = parseFloat( curCSSLeft ) || 0;\n\t\t}\n\n\t\tif ( isFunction( options ) ) {\n\n\t\t\t// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)\n\t\t\toptions = options.call( elem, i, jQuery.extend( {}, curOffset ) );\n\t\t}\n\n\t\tif ( options.top != null ) {\n\t\t\tprops.top = ( options.top - curOffset.top ) + curTop;\n\t\t}\n\t\tif ( options.left != null ) {\n\t\t\tprops.left = ( options.left - curOffset.left ) + curLeft;\n\t\t}\n\n\t\tif ( \"using\" in options ) {\n\t\t\toptions.using.call( elem, props );\n\n\t\t} else {\n\t\t\tif ( typeof props.top === \"number\" ) {\n\t\t\t\tprops.top += \"px\";\n\t\t\t}\n\t\t\tif ( typeof props.left === \"number\" ) {\n\t\t\t\tprops.left += \"px\";\n\t\t\t}\n\t\t\tcurElem.css( props );\n\t\t}\n\t}\n};\n\njQuery.fn.extend( {\n\n\t// offset() relates an element's border box to the document origin\n\toffset: function( options ) {\n\n\t\t// Preserve chaining for setter\n\t\tif ( arguments.length ) {\n\t\t\treturn options === undefined ?\n\t\t\t\tthis :\n\t\t\t\tthis.each( function( i ) {\n\t\t\t\t\tjQuery.offset.setOffset( this, options, i );\n\t\t\t\t} );\n\t\t}\n\n\t\tvar rect, win,\n\t\t\telem = this[ 0 ];\n\n\t\tif ( !elem ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Return zeros for disconnected and hidden (display: none) elements (gh-2310)\n\t\t// Support: IE <=11 only\n\t\t// Running getBoundingClientRect on a\n\t\t// disconnected node in IE throws an error\n\t\tif ( !elem.getClientRects().length ) {\n\t\t\treturn { top: 0, left: 0 };\n\t\t}\n\n\t\t// Get document-relative position by adding viewport scroll to viewport-relative gBCR\n\t\trect = elem.getBoundingClientRect();\n\t\twin = elem.ownerDocument.defaultView;\n\t\treturn {\n\t\t\ttop: rect.top + win.pageYOffset,\n\t\t\tleft: rect.left + win.pageXOffset\n\t\t};\n\t},\n\n\t// position() relates an element's margin box to its offset parent's padding box\n\t// This corresponds to the behavior of CSS absolute positioning\n\tposition: function() {\n\t\tif ( !this[ 0 ] ) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar offsetParent, offset, doc,\n\t\t\telem = this[ 0 ],\n\t\t\tparentOffset = { top: 0, left: 0 };\n\n\t\t// position:fixed elements are offset from the viewport, which itself always has zero offset\n\t\tif ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n\n\t\t\t// Assume position:fixed implies availability of getBoundingClientRect\n\t\t\toffset = elem.getBoundingClientRect();\n\n\t\t} else {\n\t\t\toffset = this.offset();\n\n\t\t\t// Account for the *real* offset parent, which can be the document or its root element\n\t\t\t// when a statically positioned element is identified\n\t\t\tdoc = elem.ownerDocument;\n\t\t\toffsetParent = elem.offsetParent || doc.documentElement;\n\t\t\twhile ( offsetParent &&\n\t\t\t\t( offsetParent === doc.body || offsetParent === doc.documentElement ) &&\n\t\t\t\tjQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\n\t\t\t\toffsetParent = offsetParent.parentNode;\n\t\t\t}\n\t\t\tif ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {\n\n\t\t\t\t// Incorporate borders into its offset, since they are outside its content origin\n\t\t\t\tparentOffset = jQuery( offsetParent ).offset();\n\t\t\t\tparentOffset.top += jQuery.css( offsetParent, \"borderTopWidth\", true );\n\t\t\t\tparentOffset.left += jQuery.css( offsetParent, \"borderLeftWidth\", true );\n\t\t\t}\n\t\t}\n\n\t\t// Subtract parent offsets and element margins\n\t\treturn {\n\t\t\ttop: offset.top - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n\t\t\tleft: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true )\n\t\t};\n\t},\n\n\t// This method will return documentElement in the following cases:\n\t// 1) For the element inside the iframe without offsetParent, this method will return\n\t//    documentElement of the parent window\n\t// 2) For the hidden or detached element\n\t// 3) For body or html element, i.e. in case of the html node - it will return itself\n\t//\n\t// but those exceptions were never presented as a real life use-cases\n\t// and might be considered as more preferable results.\n\t//\n\t// This logic, however, is not guaranteed and can change at any point in the future\n\toffsetParent: function() {\n\t\treturn this.map( function() {\n\t\t\tvar offsetParent = this.offsetParent;\n\n\t\t\twhile ( offsetParent && jQuery.css( offsetParent, \"position\" ) === \"static\" ) {\n\t\t\t\toffsetParent = offsetParent.offsetParent;\n\t\t\t}\n\n\t\t\treturn offsetParent || documentElement;\n\t\t} );\n\t}\n} );\n\n// Create scrollLeft and scrollTop methods\njQuery.each( { scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function( method, prop ) {\n\tvar top = \"pageYOffset\" === prop;\n\n\tjQuery.fn[ method ] = function( val ) {\n\t\treturn access( this, function( elem, method, val ) {\n\n\t\t\t// Coalesce documents and windows\n\t\t\tvar win;\n\t\t\tif ( isWindow( elem ) ) {\n\t\t\t\twin = elem;\n\t\t\t} else if ( elem.nodeType === 9 ) {\n\t\t\t\twin = elem.defaultView;\n\t\t\t}\n\n\t\t\tif ( val === undefined ) {\n\t\t\t\treturn win ? win[ prop ] : elem[ method ];\n\t\t\t}\n\n\t\t\tif ( win ) {\n\t\t\t\twin.scrollTo(\n\t\t\t\t\t!top ? val : win.pageXOffset,\n\t\t\t\t\ttop ? val : win.pageYOffset\n\t\t\t\t);\n\n\t\t\t} else {\n\t\t\t\telem[ method ] = val;\n\t\t\t}\n\t\t}, method, val, arguments.length );\n\t};\n} );\n\n// Support: Safari <=7 - 9.1, Chrome <=37 - 49\n// Add the top/left cssHooks using jQuery.fn.position\n// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347\n// getComputedStyle returns percent when specified for top/left/bottom/right;\n// rather than make the css module depend on the offset module, just check for it here\njQuery.each( [ \"top\", \"left\" ], function( _i, prop ) {\n\tjQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,\n\t\tfunction( elem, computed ) {\n\t\t\tif ( computed ) {\n\t\t\t\tcomputed = curCSS( elem, prop );\n\n\t\t\t\t// If curCSS returns percentage, fallback to offset\n\t\t\t\treturn rnumnonpx.test( computed ) ?\n\t\t\t\t\tjQuery( elem ).position()[ prop ] + \"px\" :\n\t\t\t\t\tcomputed;\n\t\t\t}\n\t\t}\n\t);\n} );\n\n\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n\tjQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name },\n\t\tfunction( defaultExtra, funcName ) {\n\n\t\t// Margin is only for outerHeight, outerWidth\n\t\tjQuery.fn[ funcName ] = function( margin, value ) {\n\t\t\tvar chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n\t\t\t\textra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n\t\t\treturn access( this, function( elem, type, value ) {\n\t\t\t\tvar doc;\n\n\t\t\t\tif ( isWindow( elem ) ) {\n\n\t\t\t\t\t// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)\n\t\t\t\t\treturn funcName.indexOf( \"outer\" ) === 0 ?\n\t\t\t\t\t\telem[ \"inner\" + name ] :\n\t\t\t\t\t\telem.document.documentElement[ \"client\" + name ];\n\t\t\t\t}\n\n\t\t\t\t// Get document width or height\n\t\t\t\tif ( elem.nodeType === 9 ) {\n\t\t\t\t\tdoc = elem.documentElement;\n\n\t\t\t\t\t// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],\n\t\t\t\t\t// whichever is greatest\n\t\t\t\t\treturn Math.max(\n\t\t\t\t\t\telem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n\t\t\t\t\t\telem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n\t\t\t\t\t\tdoc[ \"client\" + name ]\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn value === undefined ?\n\n\t\t\t\t\t// Get width or height on the element, requesting but not forcing parseFloat\n\t\t\t\t\tjQuery.css( elem, type, extra ) :\n\n\t\t\t\t\t// Set width or height on the element\n\t\t\t\t\tjQuery.style( elem, type, value, extra );\n\t\t\t}, type, chainable ? margin : undefined, chainable );\n\t\t};\n\t} );\n} );\n\n\njQuery.each( [\n\t\"ajaxStart\",\n\t\"ajaxStop\",\n\t\"ajaxComplete\",\n\t\"ajaxError\",\n\t\"ajaxSuccess\",\n\t\"ajaxSend\"\n], function( _i, type ) {\n\tjQuery.fn[ type ] = function( fn ) {\n\t\treturn this.on( type, fn );\n\t};\n} );\n\n\n\n\njQuery.fn.extend( {\n\n\tbind: function( types, data, fn ) {\n\t\treturn this.on( types, null, data, fn );\n\t},\n\tunbind: function( types, fn ) {\n\t\treturn this.off( types, null, fn );\n\t},\n\n\tdelegate: function( selector, types, data, fn ) {\n\t\treturn this.on( types, selector, data, fn );\n\t},\n\tundelegate: function( selector, types, fn ) {\n\n\t\t// ( namespace ) or ( selector, types [, fn] )\n\t\treturn arguments.length === 1 ?\n\t\t\tthis.off( selector, \"**\" ) :\n\t\t\tthis.off( types, selector || \"**\", fn );\n\t},\n\n\thover: function( fnOver, fnOut ) {\n\t\treturn this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n\t}\n} );\n\njQuery.each( ( \"blur focus focusin focusout resize scroll click dblclick \" +\n\t\"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n\t\"change select submit keydown keypress keyup contextmenu\" ).split( \" \" ),\n\tfunction( _i, name ) {\n\n\t\t// Handle event binding\n\t\tjQuery.fn[ name ] = function( data, fn ) {\n\t\t\treturn arguments.length > 0 ?\n\t\t\t\tthis.on( name, null, data, fn ) :\n\t\t\t\tthis.trigger( name );\n\t\t};\n\t} );\n\n\n\n\n// Support: Android <=4.0 only\n// Make sure we trim BOM and NBSP\nvar rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\n// Bind a function to a context, optionally partially applying any\n// arguments.\n// jQuery.proxy is deprecated to promote standards (specifically Function#bind)\n// However, it is not slated for removal any time soon\njQuery.proxy = function( fn, context ) {\n\tvar tmp, args, proxy;\n\n\tif ( typeof context === \"string\" ) {\n\t\ttmp = fn[ context ];\n\t\tcontext = fn;\n\t\tfn = tmp;\n\t}\n\n\t// Quick check to determine if target is callable, in the spec\n\t// this throws a TypeError, but we will just return undefined.\n\tif ( !isFunction( fn ) ) {\n\t\treturn undefined;\n\t}\n\n\t// Simulated bind\n\targs = slice.call( arguments, 2 );\n\tproxy = function() {\n\t\treturn fn.apply( context || this, args.concat( slice.call( arguments ) ) );\n\t};\n\n\t// Set the guid of unique handler to the same of original handler, so it can be removed\n\tproxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n\treturn proxy;\n};\n\njQuery.holdReady = function( hold ) {\n\tif ( hold ) {\n\t\tjQuery.readyWait++;\n\t} else {\n\t\tjQuery.ready( true );\n\t}\n};\njQuery.isArray = Array.isArray;\njQuery.parseJSON = JSON.parse;\njQuery.nodeName = nodeName;\njQuery.isFunction = isFunction;\njQuery.isWindow = isWindow;\njQuery.camelCase = camelCase;\njQuery.type = toType;\n\njQuery.now = Date.now;\n\njQuery.isNumeric = function( obj ) {\n\n\t// As of jQuery 3.0, isNumeric is limited to\n\t// strings and numbers (primitives or objects)\n\t// that can be coerced to finite numbers (gh-2662)\n\tvar type = jQuery.type( obj );\n\treturn ( type === \"number\" || type === \"string\" ) &&\n\n\t\t// parseFloat NaNs numeric-cast false positives (\"\")\n\t\t// ...but misinterprets leading-number strings, particularly hex literals (\"0x...\")\n\t\t// subtraction forces infinities to NaN\n\t\t!isNaN( obj - parseFloat( obj ) );\n};\n\njQuery.trim = function( text ) {\n\treturn text == null ?\n\t\t\"\" :\n\t\t( text + \"\" ).replace( rtrim, \"\" );\n};\n\n\n\n// Register as a named AMD module, since jQuery can be concatenated with other\n// files that may use define, but not via a proper concatenation script that\n// understands anonymous AMD modules. A named AMD is safest and most robust\n// way to register. Lowercase jquery is used because AMD module names are\n// derived from file names, and jQuery is normally delivered in a lowercase\n// file name. Do this after creating the global so that if an AMD module wants\n// to call noConflict to hide this version of jQuery, it will work.\n\n// Note that for maximum portability, libraries that are not jQuery should\n// declare themselves as anonymous modules, and avoid setting a global if an\n// AMD loader is present. jQuery is a special case. For more information, see\n// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon\n\nif ( true ) {\n\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n\t\treturn jQuery;\n\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n}\n\n\n\n\nvar\n\n\t// Map over jQuery in case of overwrite\n\t_jQuery = window.jQuery,\n\n\t// Map over the $ in case of overwrite\n\t_$ = window.$;\n\njQuery.noConflict = function( deep ) {\n\tif ( window.$ === jQuery ) {\n\t\twindow.$ = _$;\n\t}\n\n\tif ( deep && window.jQuery === jQuery ) {\n\t\twindow.jQuery = _jQuery;\n\t}\n\n\treturn jQuery;\n};\n\n// Expose jQuery and $ identifiers, even in AMD\n// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)\n// and CommonJS for browser emulators (#13566)\nif ( typeof noGlobal === \"undefined\" ) {\n\twindow.jQuery = window.$ = jQuery;\n}\n\n\n\n\nreturn jQuery;\n} );\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzPzExNTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLEtBQTBCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsWUFBWTs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxrQkFBa0Isa0NBQWtDO0FBQ3BELEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxJQUFJO0FBQ3RDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLElBQUk7QUFDOUM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVEsNkJBQTZCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0IsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxjQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSx1RUFBdUU7QUFDbkY7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qzs7QUFFekM7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaURBQWlEO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxVQUFVLDRDQUE0QztBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0Msc0NBQXNDO0FBQzlFLG9DQUFvQyx1Q0FBdUM7QUFDM0Usb0NBQW9DLHNDQUFzQztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDLHFDQUFxQztBQUNyQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixhQUFhO0FBQ3BDLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7OztBQUdBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxFQUFFO0FBQ0Y7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxzQkFBc0I7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxjQUFjOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVDQUF1QztBQUNqRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsdURBQXVEO0FBQzlFOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLCtDQUErQztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsY0FBYztBQUNuRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsY0FBYyxxQ0FBcUM7QUFDbkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLCtCQUErQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLE9BQU87QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLHFDQUFxQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLFNBQVMsOEJBQThCO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjLFdBQVc7QUFDeEUsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQSxzQkFBc0IsY0FBYyxzQkFBc0IsZ0JBQWdCO0FBQzFFLGdCQUFnQixXQUFXLFlBQVk7QUFDdkMsY0FBYztBQUNkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLCtEQUErRDtBQUMzRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87O0FBRWY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNy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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQ0FBcUM7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxhQUFhOztBQUViOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWE7QUFDYixLQUFLO0FBQ0w7O0FBRUEsV0FBVztBQUNYLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQixnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQixTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FB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cy9qcXVlcnkvZGlzdC9qcXVlcnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjMuNS4xXG4gKiBodHRwczovL2pxdWVyeS5jb20vXG4gKlxuICogSW5jbHVkZXMgU2l6emxlLmpzXG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAyMC0wNS0wNFQyMjo0OVpcbiAqL1xuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuXG5cdFwidXNlIHN0cmljdFwiO1xuXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59ICkoIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gRWRnZSA8PSAxMiAtIDEzKywgRmlyZWZveCA8PTE4IC0gNDUrLCBJRSAxMCAtIDExLCBTYWZhcmkgNS4xIC0gOSssIGlPUyA2IC0gOS4xXG4vLyB0aHJvdyBleGNlcHRpb25zIHdoZW4gbm9uLXN0cmljdCBjb2RlIChlLmcuLCBBU1AuTkVUIDQuNSkgYWNjZXNzZXMgc3RyaWN0IG1vZGVcbi8vIGFyZ3VtZW50cy5jYWxsZWUuY2FsbGVyICh0cmFjLTEzMzM1KS4gQnV0IGFzIG9mIGpRdWVyeSAzLjAgKDIwMTYpLCBzdHJpY3QgbW9kZSBzaG91bGQgYmUgY29tbW9uXG4vLyBlbm91Z2ggdGhhdCBhbGwgc3VjaCBhdHRlbXB0cyBhcmUgZ3VhcmRlZCBpbiBhIHRyeSBibG9jay5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYXJyID0gW107XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgZmxhdCA9IGFyci5mbGF0ID8gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmZsYXQuY2FsbCggYXJyYXkgKTtcbn0gOiBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdHJldHVybiBhcnIuY29uY2F0LmFwcGx5KCBbXSwgYXJyYXkgKTtcbn07XG5cblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cblxuXG5cdHZhciBwcmVzZXJ2ZWRTY3JpcHRBdHRyaWJ1dGVzID0ge1xuXHRcdHR5cGU6IHRydWUsXG5cdFx0c3JjOiB0cnVlLFxuXHRcdG5vbmNlOiB0cnVlLFxuXHRcdG5vTW9kdWxlOiB0cnVlXG5cdH07XG5cblx0ZnVuY3Rpb24gRE9NRXZhbCggY29kZSwgbm9kZSwgZG9jICkge1xuXHRcdGRvYyA9IGRvYyB8fCBkb2N1bWVudDtcblxuXHRcdHZhciBpLCB2YWwsXG5cdFx0XHRzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXG5cdFx0c2NyaXB0LnRleHQgPSBjb2RlO1xuXHRcdGlmICggbm9kZSApIHtcblx0XHRcdGZvciAoIGkgaW4gcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDY0KywgRWRnZSAxOCtcblx0XHRcdFx0Ly8gU29tZSBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBcIm5vbmNlXCIgcHJvcGVydHkgb24gc2NyaXB0cy5cblx0XHRcdFx0Ly8gT24gdGhlIG90aGVyIGhhbmQsIGp1c3QgdXNpbmcgYGdldEF0dHJpYnV0ZWAgaXMgbm90IGVub3VnaCBhc1xuXHRcdFx0XHQvLyB0aGUgYG5vbmNlYCBhdHRyaWJ1dGUgaXMgcmVzZXQgdG8gYW4gZW1wdHkgc3RyaW5nIHdoZW5ldmVyIGl0XG5cdFx0XHRcdC8vIGJlY29tZXMgYnJvd3NpbmctY29udGV4dCBjb25uZWN0ZWQuXG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL2h0bWwvaXNzdWVzLzIzNjlcblx0XHRcdFx0Ly8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI25vbmNlLWF0dHJpYnV0ZXNcblx0XHRcdFx0Ly8gVGhlIGBub2RlLmdldEF0dHJpYnV0ZWAgY2hlY2sgd2FzIGFkZGVkIGZvciB0aGUgc2FrZSBvZlxuXHRcdFx0XHQvLyBgalF1ZXJ5Lmdsb2JhbEV2YWxgIHNvIHRoYXQgaXQgY2FuIGZha2UgYSBub25jZS1jb250YWluaW5nIG5vZGVcblx0XHRcdFx0Ly8gdmlhIGFuIG9iamVjdC5cblx0XHRcdFx0dmFsID0gbm9kZVsgaSBdIHx8IG5vZGUuZ2V0QXR0cmlidXRlICYmIG5vZGUuZ2V0QXR0cmlidXRlKCBpICk7XG5cdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoIGksIHZhbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGRvYy5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIHRvVHlwZSggb2JqICkge1xuXHRpZiAoIG9iaiA9PSBudWxsICkge1xuXHRcdHJldHVybiBvYmogKyBcIlwiO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5IChmdW5jdGlvbmlzaCBSZWdFeHApXG5cdHJldHVybiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiA/XG5cdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHR0eXBlb2Ygb2JqO1xufVxuLyogZ2xvYmFsIFN5bWJvbCAqL1xuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmVzbGludHJjLmpzb24gd291bGQgY3JlYXRlIGEgZGFuZ2VyIG9mIHVzaW5nIHRoZSBnbG9iYWxcbi8vIHVuZ3VhcmRlZCBpbiBhbm90aGVyIHBsYWNlLCBpdCBzZWVtcyBzYWZlciB0byBkZWZpbmUgZ2xvYmFsIG9ubHkgZm9yIHRoaXMgbW9kdWxlXG5cblxuXG52YXJcblx0dmVyc2lvbiA9IFwiMy41LjFcIixcblxuXHQvLyBEZWZpbmUgYSBsb2NhbCBjb3B5IG9mIGpRdWVyeVxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcblx0XHQvLyBOZWVkIGluaXQgaWYgalF1ZXJ5IGlzIGNhbGxlZCAoanVzdCBhbGxvdyBlcnJvciB0byBiZSB0aHJvd24gaWYgbm90IGluY2x1ZGVkKVxuXHRcdHJldHVybiBuZXcgalF1ZXJ5LmZuLmluaXQoIHNlbGVjdG9yLCBjb250ZXh0ICk7XG5cdH07XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGV2ZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiAoIGkgKyAxICkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdG9kZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkuZ3JlcCggdGhpcywgZnVuY3Rpb24oIF9lbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGkgJSAyO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBwcm92aWRlZCBjb250ZXh0OyBmYWxscyBiYWNrIHRvIHRoZSBnbG9iYWwgb25lXG5cdC8vIGlmIG5vdCBzcGVjaWZpZWQuXG5cdGdsb2JhbEV2YWw6IGZ1bmN0aW9uKCBjb2RlLCBvcHRpb25zLCBkb2MgKSB7XG5cdFx0RE9NRXZhbCggY29kZSwgeyBub25jZTogb3B0aW9ucyAmJiBvcHRpb25zLm5vbmNlIH0sIGRvYyApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gcmVzdWx0cyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYWtlQXJyYXk6IGZ1bmN0aW9uKCBhcnIsIHJlc3VsdHMgKSB7XG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XG5cblx0XHRpZiAoIGFyciAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBpc0FycmF5TGlrZSggT2JqZWN0KCBhcnIgKSApICkge1xuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcblx0XHRcdFx0XHR0eXBlb2YgYXJyID09PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRbIGFyciBdIDogYXJyXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmNhbGwoIHJldCwgYXJyICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xuXHRcdHJldHVybiBhcnIgPT0gbnVsbCA/IC0xIDogaW5kZXhPZi5jYWxsKCBhcnIsIGVsZW0sIGkgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRtZXJnZTogZnVuY3Rpb24oIGZpcnN0LCBzZWNvbmQgKSB7XG5cdFx0dmFyIGxlbiA9ICtzZWNvbmQubGVuZ3RoLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRpID0gZmlyc3QubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRmaXJzdFsgaSsrIF0gPSBzZWNvbmRbIGogXTtcblx0XHR9XG5cblx0XHRmaXJzdC5sZW5ndGggPSBpO1xuXG5cdFx0cmV0dXJuIGZpcnN0O1xuXHR9LFxuXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcblx0XHR2YXIgY2FsbGJhY2tJbnZlcnNlLFxuXHRcdFx0bWF0Y2hlcyA9IFtdLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGgsXG5cdFx0XHRjYWxsYmFja0V4cGVjdCA9ICFpbnZlcnQ7XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgb25seSBzYXZpbmcgdGhlIGl0ZW1zXG5cdFx0Ly8gdGhhdCBwYXNzIHRoZSB2YWxpZGF0b3IgZnVuY3Rpb25cblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrSW52ZXJzZSA9ICFjYWxsYmFjayggZWxlbXNbIGkgXSwgaSApO1xuXHRcdFx0aWYgKCBjYWxsYmFja0ludmVyc2UgIT09IGNhbGxiYWNrRXhwZWN0ICkge1xuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbWF0Y2hlcztcblx0fSxcblxuXHQvLyBhcmcgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBhcmcgKSB7XG5cdFx0dmFyIGxlbmd0aCwgdmFsdWUsXG5cdFx0XHRpID0gMCxcblx0XHRcdHJldCA9IFtdO1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIHRyYW5zbGF0aW5nIGVhY2ggb2YgdGhlIGl0ZW1zIHRvIHRoZWlyIG5ldyB2YWx1ZXNcblx0XHRpZiAoIGlzQXJyYXlMaWtlKCBlbGVtcyApICkge1xuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gR28gdGhyb3VnaCBldmVyeSBrZXkgb24gdGhlIG9iamVjdCxcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRcdHJldHVybiBmbGF0KCByZXQgKTtcblx0fSxcblxuXHQvLyBBIGdsb2JhbCBHVUlEIGNvdW50ZXIgZm9yIG9iamVjdHNcblx0Z3VpZDogMSxcblxuXHQvLyBqUXVlcnkuc3VwcG9ydCBpcyBub3QgdXNlZCBpbiBDb3JlIGJ1dCBvdGhlciBwcm9qZWN0cyBhdHRhY2ggdGhlaXJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cblx0c3VwcG9ydDogc3VwcG9ydFxufSApO1xuXG5pZiAoIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiApIHtcblx0alF1ZXJ5LmZuWyBTeW1ib2wuaXRlcmF0b3IgXSA9IGFyclsgU3ltYm9sLml0ZXJhdG9yIF07XG59XG5cbi8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxualF1ZXJ5LmVhY2goIFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvciBTeW1ib2xcIi5zcGxpdCggXCIgXCIgKSxcbmZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogcmVhbCBpT1MgOC4yIG9ubHkgKG5vdCByZXByb2R1Y2libGUgaW4gc2ltdWxhdG9yKVxuXHQvLyBgaW5gIGNoZWNrIHVzZWQgdG8gcHJldmVudCBKSVQgZXJyb3IgKGdoLTIxNDUpXG5cdC8vIGhhc093biBpc24ndCB1c2VkIGhlcmUgZHVlIHRvIGZhbHNlIG5lZ2F0aXZlc1xuXHQvLyByZWdhcmRpbmcgTm9kZWxpc3QgbGVuZ3RoIGluIElFXG5cdHZhciBsZW5ndGggPSAhIW9iaiAmJiBcImxlbmd0aFwiIGluIG9iaiAmJiBvYmoubGVuZ3RoLFxuXHRcdHR5cGUgPSB0b1R5cGUoIG9iaiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggb2JqICkgfHwgaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4zLjVcbiAqIGh0dHBzOi8vc2l6emxlanMuY29tL1xuICpcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9qcy5mb3VuZGF0aW9uL1xuICpcbiAqIERhdGU6IDIwMjAtMDMtMTRcbiAqL1xuKCBmdW5jdGlvbiggd2luZG93ICkge1xudmFyIGksXG5cdHN1cHBvcnQsXG5cdEV4cHIsXG5cdGdldFRleHQsXG5cdGlzWE1MLFxuXHR0b2tlbml6ZSxcblx0Y29tcGlsZSxcblx0c2VsZWN0LFxuXHRvdXRlcm1vc3RDb250ZXh0LFxuXHRzb3J0SW5wdXQsXG5cdGhhc0R1cGxpY2F0ZSxcblxuXHQvLyBMb2NhbCBkb2N1bWVudCB2YXJzXG5cdHNldERvY3VtZW50LFxuXHRkb2N1bWVudCxcblx0ZG9jRWxlbSxcblx0ZG9jdW1lbnRJc0hUTUwsXG5cdHJidWdneVFTQSxcblx0cmJ1Z2d5TWF0Y2hlcyxcblx0bWF0Y2hlcyxcblx0Y29udGFpbnMsXG5cblx0Ly8gSW5zdGFuY2Utc3BlY2lmaWMgZGF0YVxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIDEgKiBuZXcgRGF0ZSgpLFxuXHRwcmVmZXJyZWREb2MgPSB3aW5kb3cuZG9jdW1lbnQsXG5cdGRpcnJ1bnMgPSAwLFxuXHRkb25lID0gMCxcblx0Y2xhc3NDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRjb21waWxlckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEluc3RhbmNlIG1ldGhvZHNcblx0aGFzT3duID0gKCB7fSApLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaE5hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXG5cdC8vIFVzZSBhIHN0cmlwcGVkLWRvd24gaW5kZXhPZiBhcyBpdCdzIGZhc3RlciB0aGFuIG5hdGl2ZVxuXHQvLyBodHRwczovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFsgaSBdID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58XCIgK1xuXHRcdFwiaXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3Mtc3ludGF4LTMvI2lkZW50LXRva2VuLWRpYWdyYW1cblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiP3xcXFxcXFxcXFteXFxcXHJcXFxcblxcXFxmXXxbXFxcXHctXXxbXlxcMC1cXFxceDdmXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBPcGVyYXRvciAoY2FwdHVyZSAyKVxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXG5cblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV1cblx0XHQvLyBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cblx0XHQvLyBUbyByZWR1Y2UgdGhlIG51bWJlciBvZiBzZWxlY3RvcnMgbmVlZGluZyB0b2tlbml6ZSBpbiB0aGUgcHJlRmlsdGVyLCBwcmVmZXIgYXJndW1lbnRzOlxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxuXHRcdFwiKCcoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcIil8XCIgK1xuXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICtcblx0XHR3aGl0ZXNwYWNlICsgXCIrJFwiLCBcImdcIiApLFxuXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyY29tYmluYXRvcnMgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiooWz4rfl18XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICtcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcblx0XHQvLyBXZSB1c2UgdGhpcyBmb3IgUE9TIG1hdGNoaW5nIGluIGBzZWxlY3RgXG5cdFx0XCJuZWVkc0NvbnRleHRcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXFtcXFxcZGEtZkEtRl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3xcXFxcXFxcXChbXlxcXFxyXFxcXG5cXFxcZl0pXCIsIFwiZ1wiICksXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBlc2NhcGUsIG5vbkhleCApIHtcblx0XHR2YXIgaGlnaCA9IFwiMHhcIiArIGVzY2FwZS5zbGljZSggMSApIC0gMHgxMDAwMDtcblxuXHRcdHJldHVybiBub25IZXggP1xuXG5cdFx0XHQvLyBTdHJpcCB0aGUgYmFja3NsYXNoIHByZWZpeCBmcm9tIGEgbm9uLWhleCBlc2NhcGUgc2VxdWVuY2Vcblx0XHRcdG5vbkhleCA6XG5cblx0XHRcdC8vIFJlcGxhY2UgYSBoZXhhZGVjaW1hbCBlc2NhcGUgc2VxdWVuY2Ugd2l0aCB0aGUgZW5jb2RlZCBVbmljb2RlIGNvZGUgcG9pbnRcblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTErXG5cdFx0XHQvLyBGb3IgdmFsdWVzIG91dHNpZGUgdGhlIEJhc2ljIE11bHRpbGluZ3VhbCBQbGFuZSAoQk1QKSwgbWFudWFsbHkgY29uc3RydWN0IGFcblx0XHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICtcblx0XHRcdFx0Y2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdCggYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSApLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcblx0Ly8gRGV0ZWN0IHNpbGVudGx5IGZhaWxpbmcgcHVzaC5hcHBseVxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoTmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoIGVscyApICk7XG5cdFx0fSA6XG5cblx0XHQvLyBTdXBwb3J0OiBJRTw5XG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHZhciBqID0gdGFyZ2V0Lmxlbmd0aCxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAoIHRhcmdldFsgaisrIF0gPSBlbHNbIGkrKyBdICkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XG5cblx0XHRpZiAoIGRvY3VtZW50SXNIVE1MICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgc2VsZWN0b3IgaXMgc3VmZmljaWVudGx5IHNpbXBsZSwgdHJ5IHVzaW5nIGEgXCJnZXQqQnkqXCIgRE9NIG1ldGhvZFxuXHRcdFx0Ly8gKGV4Y2VwdGluZyBEb2N1bWVudEZyYWdtZW50IGNvbnRleHQsIHdoZXJlIHRoZSBtZXRob2RzIGRvbid0IGV4aXN0KVxuXHRcdFx0aWYgKCBub2RlVHlwZSAhPT0gMTEgJiYgKCBtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSApICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKCBtID0gbWF0Y2hbIDEgXSApICkge1xuXG5cdFx0XHRcdFx0Ly8gRG9jdW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmICggZWxlbSA9IG5ld0NvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSApICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDIgXSApIHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdFx0Ly8gQ2xhc3Mgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggKCBtID0gbWF0Y2hbIDMgXSApICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCggIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkgKSAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDggb25seVxuXHRcdFx0XHQvLyBFeGNsdWRlIG9iamVjdCBlbGVtZW50c1xuXHRcdFx0XHQoIG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApICkge1xuXG5cdFx0XHRcdG5ld1NlbGVjdG9yID0gc2VsZWN0b3I7XG5cdFx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xuXG5cdFx0XHRcdC8vIHFTQSBjb25zaWRlcnMgZWxlbWVudHMgb3V0c2lkZSBhIHNjb3Bpbmcgcm9vdCB3aGVuIGV2YWx1YXRpbmcgY2hpbGQgb3Jcblx0XHRcdFx0Ly8gZGVzY2VuZGFudCBjb21iaW5hdG9ycywgd2hpY2ggaXMgbm90IHdoYXQgd2Ugd2FudC5cblx0XHRcdFx0Ly8gSW4gc3VjaCBjYXNlcywgd2Ugd29yayBhcm91bmQgdGhlIGJlaGF2aW9yIGJ5IHByZWZpeGluZyBldmVyeSBzZWxlY3RvciBpbiB0aGVcblx0XHRcdFx0Ly8gbGlzdCB3aXRoIGFuIElEIHNlbGVjdG9yIHJlZmVyZW5jaW5nIHRoZSBzY29wZSBjb250ZXh0LlxuXHRcdFx0XHQvLyBUaGUgdGVjaG5pcXVlIGhhcyB0byBiZSB1c2VkIGFzIHdlbGwgd2hlbiBhIGxlYWRpbmcgY29tYmluYXRvciBpcyB1c2VkXG5cdFx0XHRcdC8vIGFzIHN1Y2ggc2VsZWN0b3JzIGFyZSBub3QgcmVjb2duaXplZCBieSBxdWVyeVNlbGVjdG9yQWxsLlxuXHRcdFx0XHQvLyBUaGFua3MgdG8gQW5kcmV3IER1cG9udCBmb3IgdGhpcyB0ZWNobmlxdWUuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHQoIHJkZXNjZW5kLnRlc3QoIHNlbGVjdG9yICkgfHwgcmNvbWJpbmF0b3JzLnRlc3QoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHRcdC8vIEV4cGFuZCBjb250ZXh0IGZvciBzaWJsaW5nIHNlbGVjdG9yc1xuXHRcdFx0XHRcdG5ld0NvbnRleHQgPSByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dDtcblxuXHRcdFx0XHRcdC8vIFdlIGNhbiB1c2UgOnNjb3BlIGluc3RlYWQgb2YgdGhlIElEIGhhY2sgaWYgdGhlIGJyb3dzZXJcblx0XHRcdFx0XHQvLyBzdXBwb3J0cyBpdCAmIGlmIHdlJ3JlIG5vdCBjaGFuZ2luZyB0aGUgY29udGV4dC5cblx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgIT09IGNvbnRleHQgfHwgIXN1cHBvcnQuc2NvcGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0XHRpZiAoICggbmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApICkgKSB7XG5cdFx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCAoIG5pZCA9IGV4cGFuZG8gKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0Z3JvdXBzWyBpIF0gPSAoIG5pZCA/IFwiI1wiICsgbmlkIDogXCI6c2NvcGVcIiApICsgXCIgXCIgK1xuXHRcdFx0XHRcdFx0XHR0b1NlbGVjdG9yKCBncm91cHNbIGkgXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLFxuXHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUoIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0aWYgKCBuaWQgPT09IGV4cGFuZG8gKSB7XG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQWxsIG90aGVyc1xuXHRyZXR1cm4gc2VsZWN0KCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUga2V5LXZhbHVlIGNhY2hlcyBvZiBsaW1pdGVkIHNpemVcbiAqIEByZXR1cm5zIHtmdW5jdGlvbihzdHJpbmcsIG9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcbiAqXHRwcm9wZXJ0eSBuYW1lIHRoZSAoc3BhY2Utc3VmZml4ZWQpIHN0cmluZyBhbmQgKGlmIHRoZSBjYWNoZSBpcyBsYXJnZXIgdGhhbiBFeHByLmNhY2hlTGVuZ3RoKVxuICpcdGRlbGV0aW5nIHRoZSBvbGRlc3QgZW50cnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cdHZhciBrZXlzID0gW107XG5cblx0ZnVuY3Rpb24gY2FjaGUoIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblxuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKCBjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlICk7XG5cdH1cblx0cmV0dXJuIGNhY2hlO1xufVxuXG4vKipcbiAqIE1hcmsgYSBmdW5jdGlvbiBmb3Igc3BlY2lhbCB1c2UgYnkgU2l6emxlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gbWFya1xuICovXG5mdW5jdGlvbiBtYXJrRnVuY3Rpb24oIGZuICkge1xuXHRmblsgZXhwYW5kbyBdID0gdHJ1ZTtcblx0cmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgdGVzdGluZyB1c2luZyBhbiBlbGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBQYXNzZWQgdGhlIGNyZWF0ZWQgZWxlbWVudCBhbmQgcmV0dXJucyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZmllbGRzZXRcIiApO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSBmaW5hbGx5IHtcblxuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZWwucGFyZW50Tm9kZSApIHtcblx0XHRcdGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIGVsICk7XG5cdFx0fVxuXG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KCBcInxcIiApLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyWyBpIF0gXSA9IGhhbmRsZXI7XG5cdH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZG9jdW1lbnQgb3JkZXIgb2YgdHdvIHNpYmxpbmdzXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGFcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxuICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBsZXNzIHRoYW4gMCBpZiBhIHByZWNlZGVzIGIsIGdyZWF0ZXIgdGhhbiAwIGlmIGEgZm9sbG93cyBiXG4gKi9cbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcblx0dmFyIGN1ciA9IGIgJiYgYSxcblx0XHRkaWZmID0gY3VyICYmIGEubm9kZVR5cGUgPT09IDEgJiYgYi5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0YS5zb3VyY2VJbmRleCAtIGIuc291cmNlSW5kZXg7XG5cblx0Ly8gVXNlIElFIHNvdXJjZUluZGV4IGlmIGF2YWlsYWJsZSBvbiBib3RoIG5vZGVzXG5cdGlmICggZGlmZiApIHtcblx0XHRyZXR1cm4gZGlmZjtcblx0fVxuXG5cdC8vIENoZWNrIGlmIGIgZm9sbG93cyBhXG5cdGlmICggY3VyICkge1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIubmV4dFNpYmxpbmcgKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAoIG5hbWUgPT09IFwiaW5wdXRcIiB8fCBuYW1lID09PSBcImJ1dHRvblwiICkgJiYgZWxlbS50eXBlID09PSB0eXBlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgOmVuYWJsZWQvOmRpc2FibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2FibGVkIHRydWUgZm9yIDpkaXNhYmxlZDsgZmFsc2UgZm9yIDplbmFibGVkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURpc2FibGVkUHNldWRvKCBkaXNhYmxlZCApIHtcblxuXHQvLyBLbm93biA6ZGlzYWJsZWQgZmFsc2UgcG9zaXRpdmVzOiBmaWVsZHNldFtkaXNhYmxlZF0gPiBsZWdlbmQ6bnRoLW9mLXR5cGUobisyKSA6Y2FuLWRpc2FibGVcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gT25seSBjZXJ0YWluIGVsZW1lbnRzIGNhbiBtYXRjaCA6ZW5hYmxlZCBvciA6ZGlzYWJsZWRcblx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zY3JpcHRpbmcuaHRtbCNzZWxlY3Rvci1lbmFibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZGlzYWJsZWRcblx0XHRpZiAoIFwiZm9ybVwiIGluIGVsZW0gKSB7XG5cblx0XHRcdC8vIENoZWNrIGZvciBpbmhlcml0ZWQgZGlzYWJsZWRuZXNzIG9uIHJlbGV2YW50IG5vbi1kaXNhYmxlZCBlbGVtZW50czpcblx0XHRcdC8vICogbGlzdGVkIGZvcm0tYXNzb2NpYXRlZCBlbGVtZW50cyBpbiBhIGRpc2FibGVkIGZpZWxkc2V0XG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY2F0ZWdvcnktbGlzdGVkXG5cdFx0XHQvLyAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm1zLmh0bWwjY29uY2VwdC1mZS1kaXNhYmxlZFxuXHRcdFx0Ly8gKiBvcHRpb24gZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtb3B0aW9uLWRpc2FibGVkXG5cdFx0XHQvLyBBbGwgc3VjaCBlbGVtZW50cyBoYXZlIGEgXCJmb3JtXCIgcHJvcGVydHkuXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSAmJiBlbGVtLmRpc2FibGVkID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHQvLyBPcHRpb24gZWxlbWVudHMgZGVmZXIgdG8gYSBwYXJlbnQgb3B0Z3JvdXAgaWYgcHJlc2VudFxuXHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0XHRcdGlmICggXCJsYWJlbFwiIGluIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLnBhcmVudE5vZGUuZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDExXG5cdFx0XHRcdC8vIFVzZSB0aGUgaXNEaXNhYmxlZCBzaG9ydGN1dCBwcm9wZXJ0eSB0byBjaGVjayBmb3IgZGlzYWJsZWQgZmllbGRzZXQgYW5jZXN0b3JzXG5cdFx0XHRcdHJldHVybiBlbGVtLmlzRGlzYWJsZWQgPT09IGRpc2FibGVkIHx8XG5cblx0XHRcdFx0XHQvLyBXaGVyZSB0aGVyZSBpcyBubyBpc0Rpc2FibGVkLCBjaGVjayBtYW51YWxseVxuXHRcdFx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xuXHRcdFx0XHRcdGVsZW0uaXNEaXNhYmxlZCAhPT0gIWRpc2FibGVkICYmXG5cdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBhcmd1bWVudCApIHtcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcblx0XHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoIGogPSBtYXRjaEluZGV4ZXNbIGkgXSApIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFsgaiBdID0gISggbWF0Y2hlc1sgaiBdID0gc2VlZFsgaiBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0gKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgYSBub2RlIGZvciB2YWxpZGl0eSBhcyBhIFNpenpsZSBjb250ZXh0XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxuICogQHJldHVybnMge0VsZW1lbnR8T2JqZWN0fEJvb2xlYW59IFRoZSBpbnB1dCBub2RlIGlmIGFjY2VwdGFibGUsIG90aGVyd2lzZSBhIGZhbHN5IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xuXHRyZXR1cm4gY29udGV4dCAmJiB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBjb250ZXh0O1xufVxuXG4vLyBFeHBvc2Ugc3VwcG9ydCB2YXJzIGZvciBjb252ZW5pZW5jZVxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XG5cbi8qKlxuICogRGV0ZWN0cyBYTUwgbm9kZXNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IGVsZW0gQW4gZWxlbWVudCBvciBhIGRvY3VtZW50XG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZmYgZWxlbSBpcyBhIG5vbi1IVE1MIFhNTCBub2RlXG4gKi9cbmlzWE1MID0gU2l6emxlLmlzWE1MID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBuYW1lc3BhY2UgPSBlbGVtLm5hbWVzcGFjZVVSSSxcblx0XHRkb2NFbGVtID0gKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIGRvYyA9PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50O1xuXHR9XG5cblx0Ly8gVXBkYXRlIGdsb2JhbCB2YXJpYWJsZXNcblx0ZG9jdW1lbnQgPSBkb2M7XG5cdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cdGRvY3VtZW50SXNIVE1MID0gIWlzWE1MKCBkb2N1bWVudCApO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCtcblx0Ly8gQWNjZXNzaW5nIGlmcmFtZSBkb2N1bWVudHMgYWZ0ZXIgdW5sb2FkIHRocm93cyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3JzIChqUXVlcnkgIzEzOTM2KVxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoIHByZWZlcnJlZERvYyAhPSBkb2N1bWVudCAmJlxuXHRcdCggc3ViV2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcgKSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTdXBwb3J0OiBJRSA4IC0gMTErLCBFZGdlIDEyIC0gMTgrLCBDaHJvbWUgPD0xNiAtIDI1IG9ubHksIEZpcmVmb3ggPD0zLjYgLSAzMSBvbmx5LFxuXHQvLyBTYWZhcmkgNCAtIDUgb25seSwgT3BlcmEgPD0xMS42IC0gMTIueCBvbmx5XG5cdC8vIElFL0VkZ2UgJiBvbGRlciBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSA6c2NvcGUgcHNldWRvLWNsYXNzLlxuXHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wIG9ubHlcblx0Ly8gU2FmYXJpIDYuMCBzdXBwb3J0cyA6c2NvcGUgYnV0IGl0J3MgYW4gYWxpYXMgb2YgOnJvb3QgdGhlcmUuXG5cdHN1cHBvcnQuc2NvcGUgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblx0XHRyZXR1cm4gdHlwZW9mIGVsLnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdCFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpzY29wZSBmaWVsZHNldCBkaXZcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8qIEF0dHJpYnV0ZXNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFN1cHBvcnQ6IElFPDhcblx0Ly8gVmVyaWZ5IHRoYXQgZ2V0QXR0cmlidXRlIHJlYWxseSByZXR1cm5zIGF0dHJpYnV0ZXMgYW5kIG5vdCBwcm9wZXJ0aWVzXG5cdC8vIChleGNlcHRpbmcgSUU4IGJvb2xlYW5zKVxuXHRzdXBwb3J0LmF0dHJpYnV0ZXMgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZSggXCJjbGFzc05hbWVcIiApO1xuXHR9ICk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoIFwiXCIgKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwiKlwiICkubGVuZ3RoO1xuXHR9ICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIElEIGZpbHRlciBhbmQgZmluZFxuXHRpZiAoIHN1cHBvcnQuZ2V0QnlJZCApIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBcImlkXCIgKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFsgXCJJRFwiIF0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRCeUlkICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XG5cdFx0XHRcdHJldHVybiBlbGVtID8gWyBlbGVtIF0gOiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdEV4cHIuZmlsdGVyWyBcIklEXCIgXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBcImlkXCIgKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG5vZGUsIGksIGVsZW1zLFxuXHRcdFx0XHRcdGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXG5cdFx0XHRcdGlmICggZWxlbSApIHtcblxuXHRcdFx0XHRcdC8vIFZlcmlmeSB0aGUgaWQgYXR0cmlidXRlXG5cdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEZhbGwgYmFjayBvbiBnZXRFbGVtZW50c0J5TmFtZVxuXHRcdFx0XHRcdGVsZW1zID0gY29udGV4dC5nZXRFbGVtZW50c0J5TmFtZSggaWQgKTtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1zWyBpKysgXSApICkge1xuXHRcdFx0XHRcdFx0bm9kZSA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbIFwiVEFHXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cblx0XHRcdFx0Ly8gQnkgaGFwcHkgY29pbmNpZGVuY2UsIGEgKGJyb2tlbikgZ0VCVE4gYXBwZWFycyBvbiBEb2N1bWVudEZyYWdtZW50IG5vZGVzIHRvb1xuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIEZpbHRlciBvdXQgcG9zc2libGUgY29tbWVudHNcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kWyBcIkNMQVNTXCIgXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBmdW5jdGlvbiggY2xhc3NOYW1lLCBjb250ZXh0ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIGNsYXNzTmFtZSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBRU0EvbWF0Y2hlc1NlbGVjdG9yXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBRU0EgYW5kIG1hdGNoZXNTZWxlY3RvciBzdXBwb3J0XG5cblx0Ly8gbWF0Y2hlc1NlbGVjdG9yKDphY3RpdmUpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChJRTkvT3BlcmEgMTEuNSlcblx0cmJ1Z2d5TWF0Y2hlcyA9IFtdO1xuXG5cdC8vIHFTYSg6Zm9jdXMpIHJlcG9ydHMgZmFsc2Ugd2hlbiB0cnVlIChDaHJvbWUgMjEpXG5cdC8vIFdlIGFsbG93IHRoaXMgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBJRTgvOSB0aGF0IHRocm93cyBhbiBlcnJvclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXG5cdC8vIFNvLCB3ZSBhbGxvdyA6Zm9jdXMgdG8gcGFzcyB0aHJvdWdoIFFTQSBhbGwgdGhlIHRpbWUgdG8gYXZvaWQgdGhlIElFIGVycm9yXG5cdC8vIFNlZSBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcblx0cmJ1Z2d5UVNBID0gW107XG5cblx0aWYgKCAoIHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkgKSApIHtcblxuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0dmFyIGlucHV0O1xuXG5cdFx0XHQvLyBTZWxlY3QgaXMgc2V0IHRvIGVtcHR5IHN0cmluZyBvbiBwdXJwb3NlXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcblx0XHRcdC8vIHNldHRpbmcgYSBib29sZWFuIGNvbnRlbnQgYXR0cmlidXRlLFxuXHRcdFx0Ly8gc2luY2UgaXRzIHByZXNlbmNlIHNob3VsZCBiZSBlbm91Z2hcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM1OVxuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pbm5lckhUTUwgPSBcIjxhIGlkPSdcIiArIGV4cGFuZG8gKyBcIic+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGlkPSdcIiArIGV4cGFuZG8gKyBcIi1cXHJcXFxcJyBtc2FsbG93Y2FwdHVyZT0nJz5cIiArXG5cdFx0XHRcdFwiPG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4LCBPcGVyYSAxMS0xMi4xNlxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxuXHRcdFx0Ly8gVGhlIHRlc3QgYXR0cmlidXRlIG11c3QgYmUgdW5rbm93biBpbiBPcGVyYSBidXQgXCJzYWZlXCIgZm9yIFdpblJUXG5cdFx0XHQvLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW3NlbGVjdGVkXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIn49XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0XHQvLyBJRSAxMS9FZGdlIGRvbid0IGZpbmQgZWxlbWVudHMgb24gYSBgW25hbWU9JyddYCBxdWVyeSBpbiBzb21lIGNhc2VzLlxuXHRcdFx0Ly8gQWRkaW5nIGEgdGVtcG9yYXJ5IGF0dHJpYnV0ZSB0byB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBzZWxlY3Rpb24gd29ya3Ncblx0XHRcdC8vIGFyb3VuZCB0aGUgaXNzdWUuXG5cdFx0XHQvLyBJbnRlcmVzdGluZ2x5LCBJRSAxMCAmIG9sZGVyIGRvbid0IHNlZW0gdG8gaGF2ZSB0aGUgaXNzdWUuXG5cdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJcIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltuYW1lPScnXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKm5hbWVcIiArIHdoaXRlc3BhY2UgKyBcIio9XCIgK1xuXHRcdFx0XHRcdHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBXZWJraXQvT3BlcmEgLSA6Y2hlY2tlZCBzaG91bGQgcmV0dXJuIHNlbGVjdGVkIG9wdGlvbiBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjpjaGVja2VkXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjpjaGVja2VkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrLCBpT1MgOCtcblx0XHRcdC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzY4NTFcblx0XHRcdC8vIEluLXBhZ2UgYHNlbGVjdG9yI2lkIHNpYmxpbmctY29tYmluYXRvciBzZWxlY3RvcmAgZmFpbHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiYSNcIiArIGV4cGFuZG8gKyBcIisqXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIi4jLitbK35dXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTMuNiAtIDUgb25seVxuXHRcdFx0Ly8gT2xkIEZpcmVmb3ggZG9lc24ndCB0aHJvdyBvbiBhIGJhZGx5LWVzY2FwZWQgaWRlbnRpZmllci5cblx0XHRcdGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiXFxcXFxcZlwiICk7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbXFxcXHJcXFxcblxcXFxmXVwiICk7XG5cdFx0fSApO1xuXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0XHRlbC5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JycgZGlzYWJsZWQ9J2Rpc2FibGVkJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgZGlzYWJsZWQ9J2Rpc2FibGVkJz48b3B0aW9uLz48L3NlbGVjdD5cIjtcblxuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT1kXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqWypeJHwhfl0/PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZGIDMuNSAtIDplbmFibGVkLzpkaXNhYmxlZCBhbmQgaGlkZGVuIGVsZW1lbnRzIChoaWRkZW4gZWxlbWVudHMgYXJlIHN0aWxsIGVuYWJsZWQpXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIjplbmFibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU5LTExK1xuXHRcdFx0Ly8gSUUncyA6ZGlzYWJsZWQgc2VsZWN0b3IgZG9lcyBub3QgcGljayB1cCB0aGUgY2hpbGRyZW4gb2YgZGlzYWJsZWQgZmllbGRzZXRzXG5cdFx0XHRkb2NFbGVtLmFwcGVuZENoaWxkKCBlbCApLmRpc2FibGVkID0gdHJ1ZTtcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZGlzYWJsZWRcIiApLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBPcGVyYSAxMCAtIDExIG9ubHlcblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIiosOnhcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiLC4qOlwiICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yID0gcm5hdGl2ZS50ZXN0KCAoIG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvciApICkgKSApIHtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXG5cdFx0XHQvLyBDaGVjayB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBkbyBtYXRjaGVzU2VsZWN0b3Jcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXG5cdFx0XHRzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoID0gbWF0Y2hlcy5jYWxsKCBlbCwgXCIqXCIgKTtcblxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxuXHRcdFx0Ly8gR2Vja28gZG9lcyBub3QgZXJyb3IsIHJldHVybnMgZmFsc2UgaW5zdGVhZFxuXHRcdFx0bWF0Y2hlcy5jYWxsKCBlbCwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKCBcInxcIiApICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oIFwifFwiICkgKTtcblxuXHQvKiBDb250YWluc1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cdGhhc0NvbXBhcmUgPSBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29tcGFyZURvY3VtZW50UG9zaXRpb24gKTtcblxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcblx0Ly8gUHVycG9zZWZ1bGx5IHNlbGYtZXhjbHVzaXZlXG5cdC8vIEFzIGluLCBhbiBlbGVtZW50IGRvZXMgbm90IGNvbnRhaW4gaXRzZWxmXG5cdGNvbnRhaW5zID0gaGFzQ29tcGFyZSB8fCBybmF0aXZlLnRlc3QoIGRvY0VsZW0uY29udGFpbnMgKSA/XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYWRvd24gPSBhLm5vZGVUeXBlID09PSA5ID8gYS5kb2N1bWVudEVsZW1lbnQgOiBhLFxuXHRcdFx0XHRidXAgPSBiICYmIGIucGFyZW50Tm9kZTtcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxuXHRcdFx0XHRhZG93bi5jb250YWlucyA/XG5cdFx0XHRcdFx0YWRvd24uY29udGFpbnMoIGJ1cCApIDpcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcblx0XHRcdCkgKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoIGIgPSBiLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xuXG5cdC8qIFNvcnRpbmdcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIERvY3VtZW50IG9yZGVyIHNvcnRpbmdcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XG5cdGZ1bmN0aW9uKCBhLCBiICkge1xuXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxuXHRcdHZhciBjb21wYXJlID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtcblx0XHRpZiAoIGNvbXBhcmUgKSB7XG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcblx0XHR9XG5cblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XG5cdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoICFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUgKSApIHtcblxuXHRcdFx0Ly8gQ2hvb3NlIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgaXMgcmVsYXRlZCB0byBvdXIgcHJlZmVycmVkIGRvY3VtZW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBhID09IGRvY3VtZW50IHx8IGEub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYSApICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRpZiAoIGIgPT0gZG9jdW1lbnQgfHwgYi5vd25lckRvY3VtZW50ID09IHByZWZlcnJlZERvYyAmJlxuXHRcdFx0XHRjb250YWlucyggcHJlZmVycmVkRG9jLCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEV4aXQgZWFybHkgaWYgdGhlIG5vZGVzIGFyZSBpZGVudGljYWxcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0dmFyIGN1cixcblx0XHRcdGkgPSAwLFxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxuXHRcdFx0YnVwID0gYi5wYXJlbnROb2RlLFxuXHRcdFx0YXAgPSBbIGEgXSxcblx0XHRcdGJwID0gWyBiIF07XG5cblx0XHQvLyBQYXJlbnRsZXNzIG5vZGVzIGFyZSBlaXRoZXIgZG9jdW1lbnRzIG9yIGRpc2Nvbm5lY3RlZFxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRyZXR1cm4gYSA9PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PSBkb2N1bWVudCA/IDEgOlxuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0XHRhdXAgPyAtMSA6XG5cdFx0XHRcdGJ1cCA/IDEgOlxuXHRcdFx0XHRzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xuXHRcdH0gZWxzZSBpZiAoIGF1cCA9PT0gYnVwICkge1xuXHRcdFx0cmV0dXJuIHNpYmxpbmdDaGVjayggYSwgYiApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSB3ZSBuZWVkIGZ1bGwgbGlzdHMgb2YgdGhlaXIgYW5jZXN0b3JzIGZvciBjb21wYXJpc29uXG5cdFx0Y3VyID0gYTtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKCBjdXIgPSBjdXIucGFyZW50Tm9kZSApICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwWyBpIF0gPT09IGJwWyBpIF0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbIGkgXSwgYnBbIGkgXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG5cdFx0XHRhcFsgaSBdID09IHByZWZlcnJlZERvYyA/IC0xIDpcblx0XHRcdGJwWyBpIF0gPT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIGVxZXFlcSAqL1xuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblxuXHRpZiAoIHN1cHBvcnQubWF0Y2hlc1NlbGVjdG9yICYmIGRvY3VtZW50SXNIVE1MICYmXG5cdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIGV4cHIgKyBcIiBcIiBdICYmXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxuXHRcdCggIXJidWdneVFTQSAgICAgfHwgIXJidWdneVFTQS50ZXN0KCBleHByICkgKSApIHtcblxuXHRcdHRyeSB7XG5cdFx0XHR2YXIgcmV0ID0gbWF0Y2hlcy5jYWxsKCBlbGVtLCBleHByICk7XG5cblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRcdGlmICggcmV0IHx8IHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggfHxcblxuXHRcdFx0XHQvLyBBcyB3ZWxsLCBkaXNjb25uZWN0ZWQgbm9kZXMgYXJlIHNhaWQgdG8gYmUgaW4gYSBkb2N1bWVudFxuXHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxuXHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRpZiAoICggY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgKSAhPSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0fVxuXG5cdHZhciBmbiA9IEV4cHIuYXR0ckhhbmRsZVsgbmFtZS50b0xvd2VyQ2FzZSgpIF0sXG5cblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KCB2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSApICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRudWxsO1xufTtcblxuU2l6emxlLmVzY2FwZSA9IGZ1bmN0aW9uKCBzZWwgKSB7XG5cdHJldHVybiAoIHNlbCArIFwiXCIgKS5yZXBsYWNlKCByY3NzZXNjYXBlLCBmY3NzZXNjYXBlICk7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSByZXN1bHRzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtID09PSByZXN1bHRzWyBpIF0gKSB7XG5cdFx0XHRcdGogPSBkdXBsaWNhdGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2xlYXIgaW5wdXQgYWZ0ZXIgc29ydGluZyB0byByZWxlYXNlIG9iamVjdHNcblx0Ly8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvc2l6emxlL3B1bGwvMjI1XG5cdHNvcnRJbnB1dCA9IG51bGw7XG5cblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXG4gKiBAcGFyYW0ge0FycmF5fEVsZW1lbnR9IGVsZW1cbiAqL1xuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHZhciBub2RlLFxuXHRcdHJldCA9IFwiXCIsXG5cdFx0aSA9IDAsXG5cdFx0bm9kZVR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdGlmICggIW5vZGVUeXBlICkge1xuXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoICggbm9kZSA9IGVsZW1bIGkrKyBdICkgKSB7XG5cblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdHJldCArPSBnZXRUZXh0KCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMyB8fCBub2RlVHlwZSA9PT0gNCApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XG5cdH1cblxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdC8vIE1vdmUgdGhlIGdpdmVuIHZhbHVlIHRvIG1hdGNoWzNdIHdoZXRoZXIgcXVvdGVkIG9yIHVucXVvdGVkXG5cdFx0XHRtYXRjaFsgMyBdID0gKCBtYXRjaFsgMyBdIHx8IG1hdGNoWyA0IF0gfHxcblx0XHRcdFx0bWF0Y2hbIDUgXSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMiBdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWyAzIF0gPSBcIiBcIiArIG1hdGNoWyAzIF0gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbIDEgXSA9IG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsgMSBdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cblx0XHRcdFx0Ly8gbnRoLSogcmVxdWlyZXMgYXJndW1lbnRcblx0XHRcdFx0aWYgKCAhbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWyA0IF0gPSArKCBtYXRjaFsgNCBdID9cblx0XHRcdFx0XHRtYXRjaFsgNSBdICsgKCBtYXRjaFsgNiBdIHx8IDEgKSA6XG5cdFx0XHRcdFx0MiAqICggbWF0Y2hbIDMgXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWyA1IF0gPSArKCAoIG1hdGNoWyA3IF0gKyBtYXRjaFsgOCBdICkgfHwgbWF0Y2hbIDMgXSA9PT0gXCJvZGRcIiApO1xuXG5cdFx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9LFxuXG5cdFx0XCJQU0VVRE9cIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0dmFyIGV4Y2Vzcyxcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbIDYgXSAmJiBtYXRjaFsgMiBdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwclsgXCJDSElMRFwiIF0udGVzdCggbWF0Y2hbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbIDMgXSApIHtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IG1hdGNoWyA0IF0gfHwgbWF0Y2hbIDUgXSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcblx0XHRcdFx0KCBleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSApICYmXG5cblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdCggZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoICkgKSB7XG5cblx0XHRcdFx0Ly8gZXhjZXNzIGlzIGEgbmVnYXRpdmUgaW5kZXhcblx0XHRcdFx0bWF0Y2hbIDAgXSA9IG1hdGNoWyAwIF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsgMiBdID0gdW5xdW90ZWQuc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXR1cm4gb25seSBjYXB0dXJlcyBuZWVkZWQgYnkgdGhlIHBzZXVkbyBmaWx0ZXIgbWV0aG9kICh0eXBlIGFuZCBhcmd1bWVudClcblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgMyApO1xuXHRcdH1cblx0fSxcblxuXHRmaWx0ZXI6IHtcblxuXHRcdFwiVEFHXCI6IGZ1bmN0aW9uKCBub2RlTmFtZVNlbGVjdG9yICkge1xuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbm9kZU5hbWVTZWxlY3RvciA9PT0gXCIqXCIgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XHRcdFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApICkgJiYgY2xhc3NDYWNoZShcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoXG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8XG5cdFx0XHRcdFx0XHRcdFx0dHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHxcblx0XHRcdFx0XHRcdFx0XHRcIlwiXG5cdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gKTtcblx0XHR9LFxuXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBuYW1lLCBvcGVyYXRvciwgY2hlY2sgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0XHRcdGlmICggcmVzdWx0ID09IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhb3BlcmF0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcblxuXHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHRcdC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBfYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHR2YXIgY2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBub2RlSW5kZXgsIHN0YXJ0LFxuXHRcdFx0XHRcdFx0ZGlyID0gc2ltcGxlICE9PSBmb3J3YXJkID8gXCJuZXh0U2libGluZ1wiIDogXCJwcmV2aW91c1NpYmxpbmdcIixcblx0XHRcdFx0XHRcdHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZSxcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRcdFx0dXNlQ2FjaGUgPSAheG1sICYmICFvZlR5cGUsXG5cdFx0XHRcdFx0XHRkaWZmID0gZmFsc2U7XG5cblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gOihmaXJzdHxsYXN0fG9ubHkpLShjaGlsZHxvZi10eXBlKVxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggZGlyICkge1xuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gbm9kZVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdCggZGlmZiA9IG5vZGVJbmRleCA9IDAgKSB8fCBzdGFydC5wb3AoKSApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgPT09IDEgJiYgKytkaWZmICYmIG5vZGUgPT09IGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jcHNldWRvLWNsYXNzZXNcblx0XHRcdC8vIFByaW9yaXRpemUgYnkgY2FzZSBzZW5zaXRpdml0eSBpbiBjYXNlIGN1c3RvbSBwc2V1ZG9zIGFyZSBhZGRlZCB3aXRoIHVwcGVyY2FzZSBsZXR0ZXJzXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXG5cdFx0XHR2YXIgYXJncyxcblx0XHRcdFx0Zm4gPSBFeHByLnBzZXVkb3NbIHBzZXVkbyBdIHx8IEV4cHIuc2V0RmlsdGVyc1sgcHNldWRvLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XG5cblx0XHRcdC8vIFRoZSB1c2VyIG1heSB1c2UgY3JlYXRlUHNldWRvIHRvIGluZGljYXRlIHRoYXRcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXG5cdFx0XHQvLyBqdXN0IGFzIFNpenpsZSBkb2VzXG5cdFx0XHRpZiAoIGZuWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXG5cdFx0XHRpZiAoIGZuLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGFyZ3MgPSBbIHBzZXVkbywgcHNldWRvLCBcIlwiLCBhcmd1bWVudCBdO1xuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cblx0XHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGlkeCBdID0gISggbWF0Y2hlc1sgaWR4IF0gPSBtYXRjaGVkWyBpIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZuO1xuXHRcdH1cblx0fSxcblxuXHRwc2V1ZG9zOiB7XG5cblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblxuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMsIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbIGkgXSA9ICEoIG1hdGNoZXNbIGkgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcblxuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbIDAgXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gU2l6emxlKCBzZWxlY3RvciwgZWxlbSApLmxlbmd0aCA+IDA7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0gKSxcblxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxuXHRcdC8vIGlzIGJhc2VkIHNvbGVseSBvbiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlXG5cdFx0Ly8gYmVpbmcgZXF1YWwgdG8gdGhlIGlkZW50aWZpZXIgQyxcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxuXHRcdC8vIFRoZSBtYXRjaGluZyBvZiBDIGFnYWluc3QgdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZSBpcyBwZXJmb3JtZWQgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuXHRcdC8vIFRoZSBpZGVudGlmaWVyIEMgZG9lcyBub3QgaGF2ZSB0byBiZSBhIHZhbGlkIGxhbmd1YWdlIG5hbWUuXCJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXG5cdFx0XCJsYW5nXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIGxhbmcgKSB7XG5cblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QoIGxhbmcgfHwgXCJcIiApICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggXCJ4bWw6bGFuZ1wiICkgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoIFwibGFuZ1wiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoICggZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSApICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJlxuXHRcdFx0XHQoICFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpICkgJiZcblx0XHRcdFx0ISEoIGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXggKTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCBmYWxzZSApLFxuXHRcdFwiZGlzYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIHRydWUgKSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCApIHx8XG5cdFx0XHRcdCggbm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkICk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5zZWxlY3RlZCA9PT0gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0Ly8gQ29udGVudHNcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbIFwiZW1wdHlcIiBdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKCBhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgKSA9PSBudWxsIHx8XG5cdFx0XHRcdFx0YXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9ICksXG5cblx0XHRcImxhc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIF9tYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9ICksXG5cblx0XHRcImVxXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0gKSxcblxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAxO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID9cblx0XHRcdFx0YXJndW1lbnQgKyBsZW5ndGggOlxuXHRcdFx0XHRhcmd1bWVudCA+IGxlbmd0aCA/XG5cdFx0XHRcdFx0bGVuZ3RoIDpcblx0XHRcdFx0XHRhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbIFwibnRoXCIgXSA9IEV4cHIucHNldWRvc1sgXCJlcVwiIF07XG5cbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXG5mb3IgKCBpIGluIHsgcmFkaW86IHRydWUsIGNoZWNrYm94OiB0cnVlLCBmaWxlOiB0cnVlLCBwYXNzd29yZDogdHJ1ZSwgaW1hZ2U6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVJbnB1dFBzZXVkbyggaSApO1xufVxuZm9yICggaSBpbiB7IHN1Ym1pdDogdHJ1ZSwgcmVzZXQ6IHRydWUgfSApIHtcblx0RXhwci5wc2V1ZG9zWyBpIF0gPSBjcmVhdGVCdXR0b25Qc2V1ZG8oIGkgKTtcbn1cblxuLy8gRWFzeSBBUEkgZm9yIGNyZWF0aW5nIG5ldyBzZXRGaWx0ZXJzXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cbnNldEZpbHRlcnMucHJvdG90eXBlID0gRXhwci5maWx0ZXJzID0gRXhwci5wc2V1ZG9zO1xuRXhwci5zZXRGaWx0ZXJzID0gbmV3IHNldEZpbHRlcnMoKTtcblxudG9rZW5pemUgPSBTaXp6bGUudG9rZW5pemUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHBhcnNlT25seSApIHtcblx0dmFyIG1hdGNoZWQsIG1hdGNoLCB0b2tlbnMsIHR5cGUsXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcblx0XHRjYWNoZWQgPSB0b2tlbkNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCBjYWNoZWQgKSB7XG5cdFx0cmV0dXJuIHBhcnNlT25seSA/IDAgOiBjYWNoZWQuc2xpY2UoIDAgKTtcblx0fVxuXG5cdHNvRmFyID0gc2VsZWN0b3I7XG5cdGdyb3VwcyA9IFtdO1xuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XG5cblx0d2hpbGUgKCBzb0ZhciApIHtcblxuXHRcdC8vIENvbW1hIGFuZCBmaXJzdCBydW5cblx0XHRpZiAoICFtYXRjaGVkIHx8ICggbWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSApICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblxuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFsgMCBdLmxlbmd0aCApIHx8IHNvRmFyO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXBzLnB1c2goICggdG9rZW5zID0gW10gKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAoIG1hdGNoID0gcmNvbWJpbmF0b3JzLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWyAwIF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcblx0XHRcdH0gKTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoICggbWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApICkgJiYgKCAhcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdCggbWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkgKSApICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoICFtYXRjaGVkICkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXG5cdC8vIGlmIHdlJ3JlIGp1c3QgcGFyc2luZ1xuXHQvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yIG9yIHJldHVybiB0b2tlbnNcblx0cmV0dXJuIHBhcnNlT25seSA/XG5cdFx0c29GYXIubGVuZ3RoIDpcblx0XHRzb0ZhciA/XG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbIGkgXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSA6XG5cblx0XHQvLyBDaGVjayBhZ2FpbnN0IGFsbCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudHNcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIG9sZENhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSxcblx0XHRcdFx0bmV3Q2FjaGUgPSBbIGRpcnJ1bnMsIGRvbmVOYW1lIF07XG5cblx0XHRcdC8vIFdlIGNhbid0IHNldCBhcmJpdHJhcnkgZGF0YSBvbiBYTUwgbm9kZXMsIHNvIHRoZXkgZG9uJ3QgYmVuZWZpdCBmcm9tIGNvbWJpbmF0b3IgY2FjaGluZ1xuXHRcdFx0aWYgKCB4bWwgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoIGVsZW1bIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoICggb2xkQ2FjaGUgPSB1bmlxdWVDYWNoZVsga2V5IF0gKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAoIG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKCBuZXdDYWNoZVsgMiBdID0gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1sgaSBdKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gOlxuXHRcdG1hdGNoZXJzWyAwIF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbIGkgXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKCBlbGVtID0gdW5tYXRjaGVkWyBpIF0gKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgcmVzdWx0cywgY29udGV4dCwgeG1sICkge1xuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxuXHRcdFx0cHJlTWFwID0gW10sXG5cdFx0XHRwb3N0TWFwID0gW10sXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBHZXQgaW5pdGlhbCBlbGVtZW50cyBmcm9tIHNlZWQgb3IgY29udGV4dFxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoXG5cdFx0XHRcdHNlbGVjdG9yIHx8IFwiKlwiLFxuXHRcdFx0XHRjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LFxuXHRcdFx0XHRbXVxuXHRcdFx0KSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSBwb3N0RmluZGVyLCBvciBmaWx0ZXJlZCBzZWVkLCBvciBub24tc2VlZCBwb3N0RmlsdGVyIG9yIHByZWV4aXN0aW5nIHJlc3VsdHMsXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cblxuXHRcdFx0XHRcdC8vIC4uLmludGVybWVkaWF0ZSBwcm9jZXNzaW5nIGlzIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFtdIDpcblxuXHRcdFx0XHRcdC8vIC4uLm90aGVyd2lzZSB1c2UgcmVzdWx0cyBkaXJlY3RseVxuXHRcdFx0XHRcdHJlc3VsdHMgOlxuXHRcdFx0XHRtYXRjaGVySW47XG5cblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xuXHRcdGlmICggbWF0Y2hlciApIHtcblx0XHRcdG1hdGNoZXIoIG1hdGNoZXJJbiwgbWF0Y2hlck91dCwgY29udGV4dCwgeG1sICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcG9zdEZpbHRlclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcblx0XHRcdHRlbXAgPSBjb25kZW5zZSggbWF0Y2hlck91dCwgcG9zdE1hcCApO1xuXHRcdFx0cG9zdEZpbHRlciggdGVtcCwgW10sIGNvbnRleHQsIHhtbCApO1xuXG5cdFx0XHQvLyBVbi1tYXRjaCBmYWlsaW5nIGVsZW1lbnRzIGJ5IG1vdmluZyB0aGVtIGJhY2sgdG8gbWF0Y2hlckluXG5cdFx0XHRpID0gdGVtcC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAoIGVsZW0gPSB0ZW1wWyBpIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwWyBpIF0gXSA9ICEoIG1hdGNoZXJJblsgcG9zdE1hcFsgaSBdIF0gPSBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cblx0XHRcdFx0XHQvLyBHZXQgdGhlIGZpbmFsIG1hdGNoZXJPdXQgYnkgY29uZGVuc2luZyB0aGlzIGludGVybWVkaWF0ZSBpbnRvIHBvc3RGaW5kZXIgY29udGV4dHNcblx0XHRcdFx0XHR0ZW1wID0gW107XG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBtYXRjaGVyT3V0WyBpIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxuXHRcdFx0XHRcdFx0XHR0ZW1wLnB1c2goICggbWF0Y2hlckluWyBpIF0gPSBlbGVtICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKCBtYXRjaGVyT3V0ID0gW10gKSwgdGVtcCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBNb3ZlIG1hdGNoZWQgZWxlbWVudHMgZnJvbSBzZWVkIHRvIHJlc3VsdHMgdG8ga2VlcCB0aGVtIHN5bmNocm9uaXplZFxuXHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgJiZcblx0XHRcdFx0XHRcdCggdGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbIGkgXSApID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbIHRlbXAgXSA9ICEoIHJlc3VsdHNbIHRlbXAgXSA9IGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMgKSB7XG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRsZWFkaW5nUmVsYXRpdmUgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIDAgXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlWyBcIiBcIiBdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoIGNoZWNrQ29udGV4dCA9IGNvbnRleHQgKS5ub2RlVHlwZSA/XG5cdFx0XHRcdFx0bWF0Y2hDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSA6XG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xuXG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggbWF0Y2hlciA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaSBdLnR5cGUgXSApICkge1xuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyICkgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbIGkgXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1sgaSBdLm1hdGNoZXMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIHNwZWNpYWwgdXBvbiBzZWVpbmcgYSBwb3NpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGlmICggbWF0Y2hlclsgZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgaiBdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHR0b2tlbnNcblx0XHRcdFx0XHRcdC5zbGljZSggMCwgaSAtIDEgKVxuXHRcdFx0XHRcdFx0LmNvbmNhdCggeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0gKVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKCB0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxuXHRcdFx0XHRlbGVtcyA9IHNlZWQgfHwgYnlFbGVtZW50ICYmIEV4cHIuZmluZFsgXCJUQUdcIiBdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9ICggZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEgKSxcblx0XHRcdFx0bGVuID0gZWxlbXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdFx0Ly8gSUUvRWRnZSBzb21ldGltZXMgdGhyb3cgYSBcIlBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBzdHJpY3QtY29tcGFyaW5nXG5cdFx0XHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0ICYmIGVsZW0ub3duZXJEb2N1bWVudCAhPSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaGVyID0gZWxlbWVudE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0IHx8IGRvY3VtZW50LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblxuXHRcdFx0XHRcdC8vIFRoZXkgd2lsbCBoYXZlIGdvbmUgdGhyb3VnaCBhbGwgcG9zc2libGUgbWF0Y2hlcnNcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0gKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IHNldE1hdGNoZXJzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISggdW5tYXRjaGVkWyBpIF0gfHwgc2V0TWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFsgaSBdID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cblx0XHQvLyBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG9mIHJlY3Vyc2l2ZSBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgdXNlZCB0byBjaGVjayBlYWNoIGVsZW1lbnRcblx0XHRpZiAoICFtYXRjaCApIHtcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHRcdGkgPSBtYXRjaC5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRjYWNoZWQgPSBtYXRjaGVyRnJvbVRva2VucyggbWF0Y2hbIGkgXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZShcblx0XHRcdHNlbGVjdG9yLFxuXHRcdFx0bWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzIClcblx0XHQpO1xuXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXG5cdFx0Y2FjaGVkLnNlbGVjdG9yID0gc2VsZWN0b3I7XG5cdH1cblx0cmV0dXJuIGNhY2hlZDtcbn07XG5cbi8qKlxuICogQSBsb3ctbGV2ZWwgc2VsZWN0aW9uIGZ1bmN0aW9uIHRoYXQgd29ya3Mgd2l0aCBTaXp6bGUncyBjb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbiBidWlsdCB3aXRoIFNpenpsZS5jb21waWxlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGNvbnRleHRcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxuICogQHBhcmFtIHtBcnJheX0gW3NlZWRdIEEgc2V0IG9mIGVsZW1lbnRzIHRvIG1hdGNoIGFnYWluc3RcbiAqL1xuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIGksIHRva2VucywgdG9rZW4sIHR5cGUsIGZpbmQsXG5cdFx0Y29tcGlsZWQgPSB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBzZWxlY3Rvcixcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoIHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IgKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwICk7XG5cdFx0aWYgKCB0b2tlbnMubGVuZ3RoID4gMiAmJiAoIHRva2VuID0gdG9rZW5zWyAwIF0gKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAxIF0udHlwZSBdICkge1xuXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbIFwiSURcIiBdKCB0b2tlbi5tYXRjaGVzWyAwIF1cblx0XHRcdFx0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksIGNvbnRleHQgKSB8fCBbXSApWyAwIF07XG5cdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0Ly8gUHJlY29tcGlsZWQgbWF0Y2hlcnMgd2lsbCBzdGlsbCB2ZXJpZnkgYW5jZXN0cnksIHNvIHN0ZXAgdXAgYSBsZXZlbFxuXHRcdFx0fSBlbHNlIGlmICggY29tcGlsZWQgKSB7XG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcblx0XHRpID0gbWF0Y2hFeHByWyBcIm5lZWRzQ29udGV4dFwiIF0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG9rZW4gPSB0b2tlbnNbIGkgXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAoIHR5cGUgPSB0b2tlbi50eXBlICkgXSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICggZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdICkgKSB7XG5cblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKCBzZWVkID0gZmluZChcblx0XHRcdFx0XHR0b2tlbi5tYXRjaGVzWyAwIF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbIDAgXS50eXBlICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0XG5cdFx0XHRcdCkgKSApIHtcblxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxuXHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRzZWxlY3RvciA9IHNlZWQubGVuZ3RoICYmIHRvU2VsZWN0b3IoIHRva2VucyApO1xuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2VlZCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDb21waWxlIGFuZCBleGVjdXRlIGEgZmlsdGVyaW5nIGZ1bmN0aW9uIGlmIG9uZSBpcyBub3QgcHJvdmlkZWRcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxuXHQoIGNvbXBpbGVkIHx8IGNvbXBpbGUoIHNlbGVjdG9yLCBtYXRjaCApICkoXG5cdFx0c2VlZCxcblx0XHRjb250ZXh0LFxuXHRcdCFkb2N1bWVudElzSFRNTCxcblx0XHRyZXN1bHRzLFxuXHRcdCFjb250ZXh0IHx8IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcblx0KTtcblx0cmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBPbmUtdGltZSBhc3NpZ25tZW50c1xuXG4vLyBTb3J0IHN0YWJpbGl0eVxuc3VwcG9ydC5zb3J0U3RhYmxlID0gZXhwYW5kby5zcGxpdCggXCJcIiApLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oIFwiXCIgKSA9PT0gZXhwYW5kbztcblxuLy8gU3VwcG9ydDogQ2hyb21lIDE0LTM1K1xuLy8gQWx3YXlzIGFzc3VtZSBkdXBsaWNhdGVzIGlmIHRoZXkgYXJlbid0IHBhc3NlZCB0byB0aGUgY29tcGFyaXNvbiBmdW5jdGlvblxuc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzID0gISFoYXNEdXBsaWNhdGU7XG5cbi8vIEluaXRpYWxpemUgYWdhaW5zdCB0aGUgZGVmYXVsdCBkb2N1bWVudFxuc2V0RG9jdW1lbnQoKTtcblxuLy8gU3VwcG9ydDogV2Via2l0PDUzNy4zMiAtIFNhZmFyaSA2LjAuMy9DaHJvbWUgMjUgKGZpeGVkIGluIENocm9tZSAyNylcbi8vIERldGFjaGVkIG5vZGVzIGNvbmZvdW5kaW5nbHkgZm9sbG93ICplYWNoIG90aGVyKlxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGVsLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKSApICYgMTtcbn0gKTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XG5pZiAoICFhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJocmVmXCIgKSA9PT0gXCIjXCI7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggXCJ0eXBlfGhyZWZ8aGVpZ2h0fHdpZHRoXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSwgbmFtZS50b0xvd2VyQ2FzZSgpID09PSBcInR5cGVcIiA/IDEgOiAyICk7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcblx0ZWwuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIF9uYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0gKTtcbn1cblxuLy8gU3VwcG9ydDogSUU8OVxuLy8gVXNlIGdldEF0dHJpYnV0ZU5vZGUgdG8gZmV0Y2ggYm9vbGVhbnMgd2hlbiBnZXRBdHRyaWJ1dGUgbGllc1xuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdHJldHVybiBlbC5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09IG51bGw7XG59ICkgKSB7XG5cdGFkZEhhbmRsZSggYm9vbGVhbnMsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgdmFsO1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW1bIG5hbWUgXSA9PT0gdHJ1ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6XG5cdFx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0XHR2YWwudmFsdWUgOlxuXHRcdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9ICk7XG59XG5cbnJldHVybiBTaXp6bGU7XG5cbn0gKSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIF9pLCB1bnRpbCApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiwgdW50aWwgKTtcblx0fSxcblx0bmV4dDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xuXHR9LFxuXHRuZXh0VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xuXHR9LFxuXHRwcmV2VW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCBlbGVtLmNvbnRlbnREb2N1bWVudCAhPSBudWxsICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExK1xuXHRcdFx0Ly8gPG9iamVjdD4gZWxlbWVudHMgd2l0aCBubyBgZGF0YWAgYXR0cmlidXRlIGhhcyBhbiBvYmplY3Rcblx0XHRcdC8vIGBjb250ZW50RG9jdW1lbnRgIHdpdGggYSBgbnVsbGAgcHJvdG90eXBlLlxuXHRcdFx0Z2V0UHJvdG8oIGVsZW0uY29udGVudERvY3VtZW50ICkgKSB7XG5cblx0XHRcdHJldHVybiBlbGVtLmNvbnRlbnREb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seSwgaU9TIDcgb25seSwgQW5kcm9pZCBCcm93c2VyIDw9NC4zIG9ubHlcblx0XHQvLyBUcmVhdCB0aGUgdGVtcGxhdGUgZWxlbWVudCBhcyBhIHJlZ3VsYXIgb25lIGluIGJyb3dzZXJzIHRoYXRcblx0XHQvLyBkb24ndCBzdXBwb3J0IGl0LlxuXHRcdGlmICggbm9kZU5hbWUoIGVsZW0sIFwidGVtcGxhdGVcIiApICkge1xuXHRcdFx0ZWxlbSA9IGVsZW0uY29udGVudCB8fCBlbGVtO1xuXHRcdH1cblxuXHRcdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBlbGVtLmNoaWxkTm9kZXMgKTtcblx0fVxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCB1bnRpbCwgc2VsZWN0b3IgKSB7XG5cdFx0dmFyIG1hdGNoZWQgPSBqUXVlcnkubWFwKCB0aGlzLCBmbiwgdW50aWwgKTtcblxuXHRcdGlmICggbmFtZS5zbGljZSggLTUgKSAhPT0gXCJVbnRpbFwiICkge1xuXHRcdFx0c2VsZWN0b3IgPSB1bnRpbDtcblx0XHR9XG5cblx0XHRpZiAoIHNlbGVjdG9yICYmIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xuXHRcdFx0aWYgKCAhZ3VhcmFudGVlZFVuaXF1ZVsgbmFtZSBdICkge1xuXHRcdFx0XHRqUXVlcnkudW5pcXVlU29ydCggbWF0Y2hlZCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xuXHRcdFx0aWYgKCBycGFyZW50c3ByZXYudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRtYXRjaGVkLnJldmVyc2UoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcblx0fTtcbn0gKTtcbnZhciBybm90aHRtbHdoaXRlID0gKCAvW15cXHgyMFxcdFxcclxcblxcZl0rL2cgKTtcblxuXG5cbi8vIENvbnZlcnQgU3RyaW5nLWZvcm1hdHRlZCBvcHRpb25zIGludG8gT2JqZWN0LWZvcm1hdHRlZCBvbmVzXG5mdW5jdGlvbiBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHR2YXIgb2JqZWN0ID0ge307XG5cdGpRdWVyeS5lYWNoKCBvcHRpb25zLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xuXHRcdG9iamVjdFsgZmxhZyBdID0gdHJ1ZTtcblx0fSApO1xuXHRyZXR1cm4gb2JqZWN0O1xufVxuXG4vKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgbGlzdCB1c2luZyB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcnM6XG4gKlxuICpcdG9wdGlvbnM6IGFuIG9wdGlvbmFsIGxpc3Qgb2Ygc3BhY2Utc2VwYXJhdGVkIG9wdGlvbnMgdGhhdCB3aWxsIGNoYW5nZSBob3dcbiAqXHRcdFx0dGhlIGNhbGxiYWNrIGxpc3QgYmVoYXZlcyBvciBhIG1vcmUgdHJhZGl0aW9uYWwgb3B0aW9uIG9iamVjdFxuICpcbiAqIEJ5IGRlZmF1bHQgYSBjYWxsYmFjayBsaXN0IHdpbGwgYWN0IGxpa2UgYW4gZXZlbnQgY2FsbGJhY2sgbGlzdCBhbmQgY2FuIGJlXG4gKiBcImZpcmVkXCIgbXVsdGlwbGUgdGltZXMuXG4gKlxuICogUG9zc2libGUgb3B0aW9uczpcbiAqXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdG1lbW9yeTpcdFx0XHR3aWxsIGtlZXAgdHJhY2sgb2YgcHJldmlvdXMgdmFsdWVzIGFuZCB3aWxsIGNhbGwgYW55IGNhbGxiYWNrIGFkZGVkXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXG4gKlx0XHRcdFx0XHR2YWx1ZXMgKGxpa2UgYSBEZWZlcnJlZClcbiAqXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxuICpcbiAqXHRzdG9wT25GYWxzZTpcdGludGVycnVwdCBjYWxsaW5ncyB3aGVuIGEgY2FsbGJhY2sgcmV0dXJucyBmYWxzZVxuICpcbiAqL1xualF1ZXJ5LkNhbGxiYWNrcyA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXG5cdC8vIENvbnZlcnQgb3B0aW9ucyBmcm9tIFN0cmluZy1mb3JtYXR0ZWQgdG8gT2JqZWN0LWZvcm1hdHRlZCBpZiBuZWVkZWRcblx0Ly8gKHdlIGNoZWNrIGluIGNhY2hlIGZpcnN0KVxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xuXHRcdGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSA6XG5cdFx0alF1ZXJ5LmV4dGVuZCgge30sIG9wdGlvbnMgKTtcblxuXHR2YXIgLy8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xuXHRcdGZpcmluZyxcblxuXHRcdC8vIExhc3QgZmlyZSB2YWx1ZSBmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzXG5cdFx0bWVtb3J5LFxuXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcblx0XHRmaXJlZCxcblxuXHRcdC8vIEZsYWcgdG8gcHJldmVudCBmaXJpbmdcblx0XHRsb2NrZWQsXG5cblx0XHQvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxuXHRcdGxpc3QgPSBbXSxcblxuXHRcdC8vIFF1ZXVlIG9mIGV4ZWN1dGlvbiBkYXRhIGZvciByZXBlYXRhYmxlIGxpc3RzXG5cdFx0cXVldWUgPSBbXSxcblxuXHRcdC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IGFkZC9yZW1vdmUgYXMgbmVlZGVkKVxuXHRcdGZpcmluZ0luZGV4ID0gLTEsXG5cblx0XHQvLyBGaXJlIGNhbGxiYWNrc1xuXHRcdGZpcmUgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRW5mb3JjZSBzaW5nbGUtZmlyaW5nXG5cdFx0XHRsb2NrZWQgPSBsb2NrZWQgfHwgb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0bGlzdC5wdXNoKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHRvVHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IG1lbW9yeSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0bG9ja2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICEhbG9ja2VkO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2FsbCBhbGwgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGNvbnRleHQgYW5kIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xuXHRcdFx0XHRpZiAoICFsb2NrZWQgKSB7XG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XG5cdFx0XHRcdFx0YXJncyA9IFsgY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3MgXTtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBhcmdzICk7XG5cdFx0XHRcdFx0aWYgKCAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXG5cdFx0XHRmaXJlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi5maXJlV2l0aCggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiB0aGUgY2FsbGJhY2tzIGhhdmUgYWxyZWFkeSBiZWVuIGNhbGxlZCBhdCBsZWFzdCBvbmNlXG5cdFx0XHRmaXJlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0cmV0dXJuIHNlbGY7XG59O1xuXG5cbmZ1bmN0aW9uIElkZW50aXR5KCB2ICkge1xuXHRyZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIFRocm93ZXIoIGV4ICkge1xuXHR0aHJvdyBleDtcbn1cblxuZnVuY3Rpb24gYWRvcHRWYWx1ZSggdmFsdWUsIHJlc29sdmUsIHJlamVjdCwgbm9WYWx1ZSApIHtcblx0dmFyIG1ldGhvZDtcblxuXHR0cnkge1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIHByb21pc2UgYXNwZWN0IGZpcnN0IHRvIHByaXZpbGVnZSBzeW5jaHJvbm91cyBiZWhhdmlvclxuXHRcdGlmICggdmFsdWUgJiYgaXNGdW5jdGlvbiggKCBtZXRob2QgPSB2YWx1ZS5wcm9taXNlICkgKSApIHtcblx0XHRcdG1ldGhvZC5jYWxsKCB2YWx1ZSApLmRvbmUoIHJlc29sdmUgKS5mYWlsKCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIHRoZW5hYmxlc1xuXHRcdH0gZWxzZSBpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUudGhlbiApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUsIHJlc29sdmUsIHJlamVjdCApO1xuXG5cdFx0Ly8gT3RoZXIgbm9uLXRoZW5hYmxlc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvbnRyb2wgYHJlc29sdmVgIGFyZ3VtZW50cyBieSBsZXR0aW5nIEFycmF5I3NsaWNlIGNhc3QgYm9vbGVhbiBgbm9WYWx1ZWAgdG8gaW50ZWdlcjpcblx0XHRcdC8vICogZmFsc2U6IFsgdmFsdWUgXS5zbGljZSggMCApID0+IHJlc29sdmUoIHZhbHVlIClcblx0XHRcdC8vICogdHJ1ZTogWyB2YWx1ZSBdLnNsaWNlKCAxICkgPT4gcmVzb2x2ZSgpXG5cdFx0XHRyZXNvbHZlLmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXS5zbGljZSggbm9WYWx1ZSApICk7XG5cdFx0fVxuXG5cdC8vIEZvciBQcm9taXNlcy9BKywgY29udmVydCBleGNlcHRpb25zIGludG8gcmVqZWN0aW9uc1xuXHQvLyBTaW5jZSBqUXVlcnkud2hlbiBkb2Vzbid0IHVud3JhcCB0aGVuYWJsZXMsIHdlIGNhbiBza2lwIHRoZSBleHRyYSBjaGVja3MgYXBwZWFyaW5nIGluXG5cdC8vIERlZmVycmVkI3RoZW4gdG8gY29uZGl0aW9uYWxseSBzdXBwcmVzcyByZWplY3Rpb24uXG5cdH0gY2F0Y2ggKCB2YWx1ZSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIG9ubHlcblx0XHQvLyBTdHJpY3QgbW9kZSBmdW5jdGlvbnMgaW52b2tlZCB3aXRob3V0IC5jYWxsLy5hcHBseSBnZXQgZ2xvYmFsLW9iamVjdCBjb250ZXh0XG5cdFx0cmVqZWN0LmFwcGx5KCB1bmRlZmluZWQsIFsgdmFsdWUgXSApO1xuXHR9XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHREZWZlcnJlZDogZnVuY3Rpb24oIGZ1bmMgKSB7XG5cdFx0dmFyIHR1cGxlcyA9IFtcblxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgY2FsbGJhY2tzLFxuXHRcdFx0XHQvLyAuLi4gLnRoZW4gaGFuZGxlcnMsIGFyZ3VtZW50IGluZGV4LCBbZmluYWwgc3RhdGVdXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLCAyIF0sXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMCwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCAxLCBcInJlamVjdGVkXCIgXVxuXHRcdFx0XSxcblx0XHRcdHN0YXRlID0gXCJwZW5kaW5nXCIsXG5cdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGRlZmVycmVkLmRvbmUoIGFyZ3VtZW50cyApLmZhaWwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRcImNhdGNoXCI6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcHJvbWlzZS50aGVuKCBudWxsLCBmbiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0cGlwZTogZnVuY3Rpb24oIC8qIGZuRG9uZSwgZm5GYWlsLCBmblByb2dyZXNzICovICkge1xuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggX2ksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBfa2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIGNoYWluYWJsZSApIHtcblx0XHRyZXR1cm4gZWxlbXM7XG5cdH1cblxuXHQvLyBHZXRzXG5cdGlmICggYnVsayApIHtcblx0XHRyZXR1cm4gZm4uY2FsbCggZWxlbXMgKTtcblx0fVxuXG5cdHJldHVybiBsZW4gPyBmbiggZWxlbXNbIDAgXSwga2V5ICkgOiBlbXB0eUdldDtcbn07XG5cblxuLy8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG52YXIgcm1zUHJlZml4ID0gL14tbXMtLyxcblx0cmRhc2hBbHBoYSA9IC8tKFthLXpdKS9nO1xuXG4vLyBVc2VkIGJ5IGNhbWVsQ2FzZSBhcyBjYWxsYmFjayB0byByZXBsYWNlKClcbmZ1bmN0aW9uIGZjYW1lbENhc2UoIF9hbGwsIGxldHRlciApIHtcblx0cmV0dXJuIGxldHRlci50b1VwcGVyQ2FzZSgpO1xufVxuXG4vLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG4vLyBNaWNyb3NvZnQgZm9yZ290IHRvIGh1bXAgdGhlaXIgdmVuZG9yIHByZWZpeCAoIzk1NzIpXG5mdW5jdGlvbiBjYW1lbENhc2UoIHN0cmluZyApIHtcblx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBybXNQcmVmaXgsIFwibXMtXCIgKS5yZXBsYWNlKCByZGFzaEFscGhhLCBmY2FtZWxDYXNlICk7XG59XG52YXIgYWNjZXB0RGF0YSA9IGZ1bmN0aW9uKCBvd25lciApIHtcblxuXHQvLyBBY2NlcHRzIG9ubHk6XG5cdC8vICAtIE5vZGVcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxuXHQvLyAgICAtIE5vZGUuRE9DVU1FTlRfTk9ERVxuXHQvLyAgLSBPYmplY3Rcblx0Ly8gICAgLSBBbnlcblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGVcblx0XHR2YXIgdmFsdWUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcblx0XHRpZiAoICF2YWx1ZSApIHtcblx0XHRcdHZhbHVlID0ge307XG5cblx0XHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxuXHRcdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cblx0XHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBvd25lciApICkge1xuXG5cdFx0XHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHRcdFx0Ly8gdXNlIHBsYWluIGFzc2lnbm1lbnRcblx0XHRcdFx0aWYgKCBvd25lci5ub2RlVHlwZSApIHtcblx0XHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2Ugc2VjdXJlIGl0IGluIGEgbm9uLWVudW1lcmFibGUgcHJvcGVydHlcblx0XHRcdFx0Ly8gY29uZmlndXJhYmxlIG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHRcdFx0Ly8gZGVsZXRlZCB3aGVuIGRhdGEgaXMgcmVtb3ZlZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3duZXIsIHRoaXMuZXhwYW5kbywge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXHRzZXQ6IGZ1bmN0aW9uKCBvd25lciwgZGF0YSwgdmFsdWUgKSB7XG5cdFx0dmFyIHByb3AsXG5cdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUoIG93bmVyICk7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXG5cdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBkYXRhICkgXSA9IHZhbHVlO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3Ncblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb3B5IHRoZSBwcm9wZXJ0aWVzIG9uZS1ieS1vbmUgdG8gdGhlIGNhY2hlIG9iamVjdFxuXHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xuXHRcdFx0XHRjYWNoZVsgY2FtZWxDYXNlKCBwcm9wICkgXSA9IGRhdGFbIHByb3AgXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNhY2hlO1xuXHR9LFxuXHRnZXQ6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzLmNhY2hlKCBvd25lciApIDpcblxuXHRcdFx0Ly8gQWx3YXlzIHVzZSBjYW1lbENhc2Uga2V5IChnaC0yMjU3KVxuXHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdICYmIG93bmVyWyB0aGlzLmV4cGFuZG8gXVsgY2FtZWxDYXNlKCBrZXkgKSBdO1xuXHR9LFxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcblx0XHQvLyBhcmUgc3BlY2lmaWVkLCBzZXQgb3IgZXh0ZW5kIChleGlzdGluZyBvYmplY3RzKSB3aXRoIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcblx0XHQvLyAgIDIuIEEga2V5IGFuZCB2YWx1ZVxuXHRcdC8vXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XG5cblx0XHQvLyBTaW5jZSB0aGUgXCJzZXRcIiBwYXRoIGNhbiBoYXZlIHR3byBwb3NzaWJsZSBlbnRyeSBwb2ludHNcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cblx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoga2V5O1xuXHR9LFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xuXHRcdHZhciBpLFxuXHRcdFx0Y2FjaGUgPSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cblx0XHRpZiAoIGNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBrZXkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydCBhcnJheSBvciBzcGFjZSBzZXBhcmF0ZWQgc3RyaW5nIG9mIGtleXNcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSgga2V5ICkgKSB7XG5cblx0XHRcdFx0Ly8gSWYga2V5IGlzIGFuIGFycmF5IG9mIGtleXMuLi5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHNldCBjYW1lbENhc2Uga2V5cywgc28gcmVtb3ZlIHRoYXQuXG5cdFx0XHRcdGtleSA9IGtleS5tYXAoIGNhbWVsQ2FzZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5ID0gY2FtZWxDYXNlKCBrZXkgKTtcblxuXHRcdFx0XHQvLyBJZiBhIGtleSB3aXRoIHRoZSBzcGFjZXMgZXhpc3RzLCB1c2UgaXQuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXG5cdFx0XHRcdGtleSA9IGtleSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0WyBrZXkgXSA6XG5cdFx0XHRcdFx0KCBrZXkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpID0ga2V5Lmxlbmd0aDtcblxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGRlbGV0ZSBjYWNoZVsga2V5WyBpIF0gXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgdGhlcmUncyBubyBtb3JlIGRhdGFcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8IGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBjYWNoZSApICkge1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1XG5cdFx0XHQvLyBXZWJraXQgJiBCbGluayBwZXJmb3JtYW5jZSBzdWZmZXJzIHdoZW4gZGVsZXRpbmcgcHJvcGVydGllc1xuXHRcdFx0Ly8gZnJvbSBET00gbm9kZXMsIHNvIHNldCB0byB1bmRlZmluZWQgaW5zdGVhZFxuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3IChidWcgcmVzdHJpY3RlZClcblx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlbGV0ZSBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cdFx0dmFyIGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdHJldHVybiBjYWNoZSAhPT0gdW5kZWZpbmVkICYmICFqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKTtcblx0fVxufTtcbnZhciBkYXRhUHJpdiA9IG5ldyBEYXRhKCk7XG5cbnZhciBkYXRhVXNlciA9IG5ldyBEYXRhKCk7XG5cblxuXG4vL1x0SW1wbGVtZW50YXRpb24gU3VtbWFyeVxuLy9cbi8vXHQxLiBFbmZvcmNlIEFQSSBzdXJmYWNlIGFuZCBzZW1hbnRpYyBjb21wYXRpYmlsaXR5IHdpdGggMS45LnggYnJhbmNoXG4vL1x0Mi4gSW1wcm92ZSB0aGUgbW9kdWxlJ3MgbWFpbnRhaW5hYmlsaXR5IGJ5IHJlZHVjaW5nIHRoZSBzdG9yYWdlXG4vL1x0XHRwYXRocyB0byBhIHNpbmdsZSBtZWNoYW5pc20uXG4vL1x0My4gVXNlIHRoZSBzYW1lIHNpbmdsZSBtZWNoYW5pc20gdG8gc3VwcG9ydCBcInByaXZhdGVcIiBhbmQgXCJ1c2VyXCIgZGF0YS5cbi8vXHQ0LiBfTmV2ZXJfIGV4cG9zZSBcInByaXZhdGVcIiBkYXRhIHRvIHVzZXIgY29kZSAoVE9ETzogRHJvcCBfZGF0YSwgX3JlbW92ZURhdGEpXG4vL1x0NS4gQXZvaWQgZXhwb3NpbmcgaW1wbGVtZW50YXRpb24gZGV0YWlscyBvbiB1c2VyIG9iamVjdHMgKGVnLiBleHBhbmRvIHByb3BlcnRpZXMpXG4vL1x0Ni4gUHJvdmlkZSBhIGNsZWFyIHBhdGggZm9yIGltcGxlbWVudGF0aW9uIHVwZ3JhZGUgdG8gV2Vha01hcCBpbiAyMDE0XG5cbnZhciByYnJhY2UgPSAvXig/Olxce1tcXHdcXFddKlxcfXxcXFtbXFx3XFxXXSpcXF0pJC8sXG5cdHJtdWx0aURhc2ggPSAvW0EtWl0vZztcblxuZnVuY3Rpb24gZ2V0RGF0YSggZGF0YSApIHtcblx0aWYgKCBkYXRhID09PSBcInRydWVcIiApIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJmYWxzZVwiICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdGlmICggZGF0YSA9PT0gXCJudWxsXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xuXHRpZiAoIGRhdGEgPT09ICtkYXRhICsgXCJcIiApIHtcblx0XHRyZXR1cm4gK2RhdGE7XG5cdH1cblxuXHRpZiAoIHJicmFjZS50ZXN0KCBkYXRhICkgKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKTtcblx0fVxuXG5cdHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBkYXRhQXR0ciggZWxlbSwga2V5LCBkYXRhICkge1xuXHR2YXIgbmFtZTtcblxuXHQvLyBJZiBub3RoaW5nIHdhcyBmb3VuZCBpbnRlcm5hbGx5LCB0cnkgdG8gZmV0Y2ggYW55XG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxuXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdG5hbWUgPSBcImRhdGEtXCIgKyBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCk7XG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZGF0YSA9IGdldERhdGEoIGRhdGEgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge31cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHdlIHNldCB0aGUgZGF0YSBzbyBpdCBpc24ndCBjaGFuZ2VkIGxhdGVyXG5cdFx0XHRkYXRhVXNlci5zZXQoIGVsZW0sIGtleSwgZGF0YSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkYXRhID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gZGF0YTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKTtcblx0fSxcblxuXHRkYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVVzZXIuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0cmVtb3ZlRGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cdFx0ZGF0YVVzZXIucmVtb3ZlKCBlbGVtLCBuYW1lICk7XG5cdH0sXG5cblx0Ly8gVE9ETzogTm93IHRoYXQgYWxsIGNhbGxzIHRvIF9kYXRhIGFuZCBfcmVtb3ZlRGF0YSBoYXZlIGJlZW4gcmVwbGFjZWRcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YVByaXYgbWV0aG9kcywgdGhlc2UgY2FuIGJlIGRlcHJlY2F0ZWQuXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XG5cdH0sXG5cblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGF0YTogZnVuY3Rpb24oIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIGksIG5hbWUsIGRhdGEsXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxuXHRcdFx0YXR0cnMgPSBlbGVtICYmIGVsZW0uYXR0cmlidXRlcztcblxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHRoaXMubGVuZ3RoICkge1xuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtICk7XG5cblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICFkYXRhUHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcblx0XHRcdFx0XHRpID0gYXR0cnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBUaGUgYXR0cnMgZWxlbWVudHMgY2FuIGJlIG51bGwgKCMxNDg5NClcblx0XHRcdFx0XHRcdGlmICggYXR0cnNbIGkgXSApIHtcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcblx0XHRcdFx0XHRcdFx0aWYgKCBuYW1lLmluZGV4T2YoIFwiZGF0YS1cIiApID09PSAwICkge1xuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBjYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhO1xuXG5cdFx0XHQvLyBUaGUgY2FsbGluZyBqUXVlcnkgb2JqZWN0IChlbGVtZW50IG1hdGNoZXMpIGlzIG5vdCBlbXB0eVxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcblx0XHRcdC8vIGB2YWx1ZWAgcGFyYW1ldGVyIHdhcyBub3QgdW5kZWZpbmVkLiBBbiBlbXB0eSBqUXVlcnkgb2JqZWN0XG5cdFx0XHQvLyB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBmb3IgZWxlbSA9IHRoaXNbIDAgXSB3aGljaCB3aWxsXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxuXHRcdFx0aWYgKCBlbGVtICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyBUaGUga2V5IHdpbGwgYWx3YXlzIGJlIGNhbWVsQ2FzZWQgaW4gRGF0YVxuXHRcdFx0XHRkYXRhID0gZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxuXHRcdFx0XHQvLyBIVE1MNSBjdXN0b20gZGF0YS0qIGF0dHJzXG5cdFx0XHRcdGRhdGEgPSBkYXRhQXR0ciggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCB0aGUgZGF0YS4uLlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBXZSBhbHdheXMgc3RvcmUgdGhlIGNhbWVsQ2FzZWQga2V5XG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IEFycmF5LmlzQXJyYXkoIGRhdGEgKSApIHtcblx0XHRcdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheSggZGF0YSApICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCggZGF0YSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcXVldWUgfHwgW107XG5cdFx0fVxuXHR9LFxuXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggZWxlbSwgdHlwZSApLFxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCksXG5cdFx0XHRob29rcyA9IGpRdWVyeS5fcXVldWVIb29rcyggZWxlbSwgdHlwZSApLFxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggZWxlbSwgdHlwZSApO1xuXHRcdFx0fTtcblxuXHRcdC8vIElmIHRoZSBmeCBxdWV1ZSBpcyBkZXF1ZXVlZCwgYWx3YXlzIHJlbW92ZSB0aGUgcHJvZ3Jlc3Mgc2VudGluZWxcblx0XHRpZiAoIGZuID09PSBcImlucHJvZ3Jlc3NcIiApIHtcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdHN0YXJ0TGVuZ3RoLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xuXHRcdFx0Ly8gYXV0b21hdGljYWxseSBkZXF1ZXVlZFxuXHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgKSB7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cblx0XHRcdGRlbGV0ZSBob29rcy5zdG9wO1xuXHRcdFx0Zm4uY2FsbCggZWxlbSwgbmV4dCwgaG9va3MgKTtcblx0XHR9XG5cblx0XHRpZiAoICFzdGFydExlbmd0aCAmJiBob29rcyApIHtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gTm90IHB1YmxpYyAtIGdlbmVyYXRlIGEgcXVldWVIb29rcyBvYmplY3QsIG9yIHJldHVybiB0aGUgY3VycmVudCBvbmVcblx0X3F1ZXVlSG9va3M6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlICkge1xuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBrZXksIHtcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKS5hZGQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcblx0XHRcdH0gKVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgc2V0dGVyID0gMjtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRkYXRhID0gdHlwZTtcblx0XHRcdHR5cGUgPSBcImZ4XCI7XG5cdFx0XHRzZXR0ZXItLTtcblx0XHR9XG5cblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPCBzZXR0ZXIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWyAwIF0sIHR5cGUgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGF0YSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdHRoaXMgOlxuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIGEgaG9va3MgZm9yIHRoaXMgcXVldWVcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ4XCIgJiYgcXVldWVbIDAgXSAhPT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHR9LFxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0fSApO1xuXHR9LFxuXHRjbGVhclF1ZXVlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdH0sXG5cblx0Ly8gR2V0IGEgcHJvbWlzZSByZXNvbHZlZCB3aGVuIHF1ZXVlcyBvZiBhIGNlcnRhaW4gdHlwZVxuXHQvLyBhcmUgZW1wdGllZCAoZnggaXMgdGhlIHR5cGUgYnkgZGVmYXVsdClcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcblx0XHR2YXIgdG1wLFxuXHRcdFx0Y291bnQgPSAxLFxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGVsZW1lbnRzID0gdGhpcyxcblx0XHRcdGkgPSB0aGlzLmxlbmd0aCxcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhKCAtLWNvdW50ICkgKSB7XG5cdFx0XHRcdFx0ZGVmZXIucmVzb2x2ZVdpdGgoIGVsZW1lbnRzLCBbIGVsZW1lbnRzIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0bXAgPSBkYXRhUHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xuXHRcdFx0aWYgKCB0bXAgJiYgdG1wLmVtcHR5ICkge1xuXHRcdFx0XHRjb3VudCsrO1xuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc29sdmUoKTtcblx0XHRyZXR1cm4gZGVmZXIucHJvbWlzZSggb2JqICk7XG5cdH1cbn0gKTtcbnZhciBwbnVtID0gKCAvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLyApLnNvdXJjZTtcblxudmFyIHJjc3NOdW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApO1xuXG5cbnZhciBjc3NFeHBhbmQgPSBbIFwiVG9wXCIsIFwiUmlnaHRcIiwgXCJCb3R0b21cIiwgXCJMZWZ0XCIgXTtcblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cblx0dmFyIGlzQXR0YWNoZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xuXHRcdH0sXG5cdFx0Y29tcG9zZWQgPSB7IGNvbXBvc2VkOiB0cnVlIH07XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxMiAtIDE4KywgaU9TIDEwLjAgLSAxMC4yIG9ubHlcblx0Ly8gQ2hlY2sgYXR0YWNobWVudCBhY3Jvc3Mgc2hhZG93IERPTSBib3VuZGFyaWVzIHdoZW4gcG9zc2libGUgKGdoLTM1MDQpXG5cdC8vIFN1cHBvcnQ6IGlPUyAxMC4wLTEwLjIgb25seVxuXHQvLyBFYXJseSBpT1MgMTAgdmVyc2lvbnMgc3VwcG9ydCBgYXR0YWNoU2hhZG93YCBidXQgbm90IGBnZXRSb290Tm9kZWAsXG5cdC8vIGxlYWRpbmcgdG8gZXJyb3JzLiBXZSBuZWVkIHRvIGNoZWNrIGZvciBgZ2V0Um9vdE5vZGVgLlxuXHRpZiAoIGRvY3VtZW50RWxlbWVudC5nZXRSb290Tm9kZSApIHtcblx0XHRpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSB8fFxuXHRcdFx0XHRlbGVtLmdldFJvb3ROb2RlKCBjb21wb3NlZCApID09PSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0fTtcblx0fVxudmFyIGlzSGlkZGVuV2l0aGluVHJlZSA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuV2l0aGluVHJlZSBtaWdodCBiZSBjYWxsZWQgZnJvbSBqUXVlcnkjZmlsdGVyIGZ1bmN0aW9uO1xuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxuXHRcdGVsZW0gPSBlbCB8fCBlbGVtO1xuXG5cdFx0Ly8gSW5saW5lIHN0eWxlIHRydW1wcyBhbGxcblx0XHRyZXR1cm4gZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fFxuXHRcdFx0ZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmXG5cblx0XHRcdC8vIE90aGVyd2lzZSwgY2hlY2sgY29tcHV0ZWQgc3R5bGVcblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MyAtIDQ1XG5cdFx0XHQvLyBEaXNjb25uZWN0ZWQgZWxlbWVudHMgY2FuIGhhdmUgY29tcHV0ZWQgZGlzcGxheTogbm9uZSwgc28gZmlyc3QgY29uZmlybSB0aGF0IGVsZW0gaXNcblx0XHRcdC8vIGluIHRoZSBkb2N1bWVudC5cblx0XHRcdGlzQXR0YWNoZWQoIGVsZW0gKSAmJlxuXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApID09PSBcIm5vbmVcIjtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0ZGl2ID0gZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApLFxuXHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seVxuXHQvLyBDaGVjayBzdGF0ZSBsb3N0IGlmIHRoZSBuYW1lIGlzIHNldCAoIzExMjE3KVxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXG5cdC8vIGBuYW1lYCBhbmQgYHR5cGVgIG11c3QgdXNlIC5zZXRBdHRyaWJ1dGUgZm9yIFdXQSAoIzE0OTAxKVxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcImNoZWNrZWRcIiwgXCJjaGVja2VkXCIgKTtcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJ0XCIgKTtcblxuXHRkaXYuYXBwZW5kQ2hpbGQoIGlucHV0ICk7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSBvbmx5XG5cdC8vIE9sZGVyIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xuXHRzdXBwb3J0LmNoZWNrQ2xvbmUgPSBkaXYuY2xvbmVOb2RlKCB0cnVlICkuY2xvbmVOb2RlKCB0cnVlICkubGFzdENoaWxkLmNoZWNrZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0Ly8gSUUgPD05IHJlcGxhY2VzIDxvcHRpb24+IHRhZ3Mgd2l0aCB0aGVpciBjb250ZW50cyB3aGVuIGluc2VydGVkIG91dHNpZGUgb2Zcblx0Ly8gdGhlIHNlbGVjdCBlbGVtZW50LlxuXHRkaXYuaW5uZXJIVE1MID0gXCI8b3B0aW9uPjwvb3B0aW9uPlwiO1xuXHRzdXBwb3J0Lm9wdGlvbiA9ICEhZGl2Lmxhc3RDaGlsZDtcbn0gKSgpO1xuXG5cbi8vIFdlIGhhdmUgdG8gY2xvc2UgdGhlc2UgdGFncyB0byBzdXBwb3J0IFhIVE1MICgjMTMyMDApXG52YXIgd3JhcE1hcCA9IHtcblxuXHQvLyBYSFRNTCBwYXJzZXJzIGRvIG5vdCBtYWdpY2FsbHkgaW5zZXJ0IGVsZW1lbnRzIGluIHRoZVxuXHQvLyBzYW1lIHdheSB0aGF0IHRhZyBzb3VwIHBhcnNlcnMgZG8uIFNvIHdlIGNhbm5vdCBzaG9ydGVuXG5cdC8vIHRoaXMgYnkgb21pdHRpbmcgPHRib2R5PiBvciBvdGhlciByZXF1aXJlZCBlbGVtZW50cy5cblx0dGhlYWQ6IFsgMSwgXCI8dGFibGU+XCIsIFwiPC90YWJsZT5cIiBdLFxuXHRjb2w6IFsgMiwgXCI8dGFibGU+PGNvbGdyb3VwPlwiLCBcIjwvY29sZ3JvdXA+PC90YWJsZT5cIiBdLFxuXHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXG5cdHRkOiBbIDMsIFwiPHRhYmxlPjx0Ym9keT48dHI+XCIsIFwiPC90cj48L3Rib2R5PjwvdGFibGU+XCIgXSxcblxuXHRfZGVmYXVsdDogWyAwLCBcIlwiLCBcIlwiIF1cbn07XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbmlmICggIXN1cHBvcnQub3B0aW9uICkge1xuXHR3cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb24gPSBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF07XG59XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBPbmx5IGF0dGFjaCBldmVudHMgdG8gb2JqZWN0cyB0aGF0IGFjY2VwdCBkYXRhXG5cdFx0aWYgKCAhYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUoIG51bGwgKTtcblx0XHR9XG5cdFx0aWYgKCAhKCBldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSApICkge1xuXHRcdFx0ZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgPSBmdW5jdGlvbiggZSApIHtcblxuXHRcdFx0XHQvLyBEaXNjYXJkIHRoZSBzZWNvbmQgZXZlbnQgb2YgYSBqUXVlcnkuZXZlbnQudHJpZ2dlcigpIGFuZFxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgalF1ZXJ5ICE9PSBcInVuZGVmaW5lZFwiICYmIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgIT09IGUudHlwZSA/XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gSGFuZGxlIG11bHRpcGxlIGV2ZW50cyBzZXBhcmF0ZWQgYnkgYSBzcGFjZVxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gfHwgW107XG5cdFx0XHR0bXAgPSB0bXBbIDIgXSAmJlxuXHRcdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKTtcblxuXHRcdFx0Ly8gUmVtb3ZlIG1hdGNoaW5nIGV2ZW50c1xuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaiBdO1xuXG5cdFx0XHRcdGlmICggKCBtYXBwZWRUeXBlcyB8fCBvcmlnVHlwZSA9PT0gaGFuZGxlT2JqLm9yaWdUeXBlICkgJiZcblx0XHRcdFx0XHQoICFoYW5kbGVyIHx8IGhhbmRsZXIuZ3VpZCA9PT0gaGFuZGxlT2JqLmd1aWQgKSAmJlxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcblx0XHRcdFx0XHQoICFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gaGFuZGxlT2JqLnNlbGVjdG9yIHx8XG5cdFx0XHRcdFx0XHRzZWxlY3RvciA9PT0gXCIqKlwiICYmIGhhbmRsZU9iai5zZWxlY3RvciApICkge1xuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xuXG5cdFx0XHRcdFx0aWYgKCBoYW5kbGVPYmouc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc3BlY2lhbC5yZW1vdmUgKSB7XG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVtb3ZlIGdlbmVyaWMgZXZlbnQgaGFuZGxlciBpZiB3ZSByZW1vdmVkIHNvbWV0aGluZyBhbmQgbm8gbW9yZSBoYW5kbGVycyBleGlzdFxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXG5cdFx0XHRpZiAoIG9yaWdDb3VudCAmJiAhaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnRlYXJkb3duIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC50ZWFyZG93bi5jYWxsKCBlbGVtLCBuYW1lc3BhY2VzLCBlbGVtRGF0YS5oYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGVsZW1EYXRhLmhhbmRsZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGV2ZW50c1sgdHlwZSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSBkYXRhIGFuZCB0aGUgZXhwYW5kbyBpZiBpdCdzIG5vIGxvbmdlciB1c2VkXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiaGFuZGxlIGV2ZW50c1wiICk7XG5cdFx0fVxuXHR9LFxuXG5cdGRpc3BhdGNoOiBmdW5jdGlvbiggbmF0aXZlRXZlbnQgKSB7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblxuXHRcdFx0Ly8gTWFrZSBhIHdyaXRhYmxlIGpRdWVyeS5FdmVudCBmcm9tIHRoZSBuYXRpdmUgZXZlbnQgb2JqZWN0XG5cdFx0XHRldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICksXG5cblx0XHRcdGhhbmRsZXJzID0gKFxuXHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XG5cblx0aWYgKCBkZXN0Lm5vZGVUeXBlICE9PSAxICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXG5cdGlmICggZGF0YVByaXYuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0cGRhdGFPbGQgPSBkYXRhUHJpdi5nZXQoIHNyYyApO1xuXHRcdGV2ZW50cyA9IHBkYXRhT2xkLmV2ZW50cztcblxuXHRcdGlmICggZXZlbnRzICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkZXN0LCBcImhhbmRsZSBldmVudHNcIiApO1xuXG5cdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBldmVudHNbIHR5cGUgXS5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcblx0aWYgKCBkYXRhVXNlci5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHR1ZGF0YU9sZCA9IGRhdGFVc2VyLmFjY2Vzcyggc3JjICk7XG5cdFx0dWRhdGFDdXIgPSBqUXVlcnkuZXh0ZW5kKCB7fSwgdWRhdGFPbGQgKTtcblxuXHRcdGRhdGFVc2VyLnNldCggZGVzdCwgdWRhdGFDdXIgKTtcblx0fVxufVxuXG4vLyBGaXggSUUgYnVncywgc2VlIHN1cHBvcnQgdGVzdHNcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBub2RlTmFtZSA9IGRlc3Qubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cblx0aWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmIHJjaGVja2FibGVUeXBlLnRlc3QoIHNyYy50eXBlICkgKSB7XG5cdFx0ZGVzdC5jaGVja2VkID0gc3JjLmNoZWNrZWQ7XG5cblx0Ly8gRmFpbHMgdG8gcmV0dXJuIHRoZSBzZWxlY3RlZCBvcHRpb24gdG8gdGhlIGRlZmF1bHQgc2VsZWN0ZWQgc3RhdGUgd2hlbiBjbG9uaW5nIG9wdGlvbnNcblx0fSBlbHNlIGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiB8fCBub2RlTmFtZSA9PT0gXCJ0ZXh0YXJlYVwiICkge1xuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcblx0fVxufVxuXG5mdW5jdGlvbiBkb21NYW5pcCggY29sbGVjdGlvbiwgYXJncywgY2FsbGJhY2ssIGlnbm9yZWQgKSB7XG5cblx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xuXHRhcmdzID0gZmxhdCggYXJncyApO1xuXG5cdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcblx0XHRpID0gMCxcblx0XHRsID0gY29sbGVjdGlvbi5sZW5ndGgsXG5cdFx0aU5vQ2xvbmUgPSBsIC0gMSxcblx0XHR2YWx1ZSA9IGFyZ3NbIDAgXSxcblx0XHR2YWx1ZUlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCB2YWx1ZSApO1xuXG5cdC8vIFdlIGNhbid0IGNsb25lTm9kZSBmcmFnbWVudHMgdGhhdCBjb250YWluIGNoZWNrZWQsIGluIFdlYktpdFxuXHRpZiAoIHZhbHVlSXNGdW5jdGlvbiB8fFxuXHRcdFx0KCBsID4gMSAmJiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXN1cHBvcnQuY2hlY2tDbG9uZSAmJiByY2hlY2tlZC50ZXN0KCB2YWx1ZSApICkgKSB7XG5cdFx0cmV0dXJuIGNvbGxlY3Rpb24uZWFjaCggZnVuY3Rpb24oIGluZGV4ICkge1xuXHRcdFx0dmFyIHNlbGYgPSBjb2xsZWN0aW9uLmVxKCBpbmRleCApO1xuXHRcdFx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyAmJiAoIG5vZGUudHlwZSB8fCBcIlwiICkudG9Mb3dlckNhc2UoKSAgIT09IFwibW9kdWxlXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gT3B0aW9uYWwgQUpBWCBkZXBlbmRlbmN5LCBidXQgd29uJ3QgcnVuIHNjcmlwdHMgaWYgbm90IHByZXNlbnRcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgJiYgIW5vZGUubm9Nb2R1bGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Ll9ldmFsVXJsKCBub2RlLnNyYywge1xuXHRcdFx0XHRcdFx0XHRcdFx0bm9uY2U6IG5vZGUubm9uY2UgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoIFwibm9uY2VcIiApXG5cdFx0XHRcdFx0XHRcdFx0fSwgZG9jICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdERPTUV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICksIG5vZGUsIGRvYyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiByZW1vdmUoIGVsZW0sIHNlbGVjdG9yLCBrZWVwRGF0YSApIHtcblx0dmFyIG5vZGUsXG5cdFx0bm9kZXMgPSBzZWxlY3RvciA/IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBlbGVtICkgOiBlbGVtLFxuXHRcdGkgPSAwO1xuXG5cdGZvciAoIDsgKCBub2RlID0gbm9kZXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRpZiAoICFrZWVwRGF0YSAmJiBub2RlLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBub2RlICkgKTtcblx0XHR9XG5cblx0XHRpZiAoIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdGlmICgga2VlcERhdGEgJiYgaXNBdHRhY2hlZCggbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWw7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEZpeCBJRSBjbG9uaW5nIGlzc3Vlc1xuXHRcdGlmICggIXN1cHBvcnQubm9DbG9uZUNoZWNrZWQgJiYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGVsZW0ubm9kZVR5cGUgPT09IDExICkgJiZcblx0XHRcdFx0IWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXG5cdFx0XHQvLyBXZSBlc2NoZXcgU2l6emxlIGhlcmUgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnM6IGh0dHBzOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciApO1xuXHR9LFxuXG5cdHRleHQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS50ZXh0KCB0aGlzICkgOlxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0YXJnZXQuZmlyc3RDaGlsZCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRiZWZvcmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcy5uZXh0U2libGluZyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gdGhpc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXG5cdFx0XHRcdC8vIFJlbW92ZSBhbnkgcmVtYWluaW5nIG5vZGVzXG5cdFx0XHRcdGVsZW0udGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0ZGF0YUFuZEV2ZW50cyA9IGRhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGZhbHNlIDogZGF0YUFuZEV2ZW50cztcblx0XHRkZWVwRGF0YUFuZEV2ZW50cyA9IGRlZXBEYXRhQW5kRXZlbnRzID09IG51bGwgPyBkYXRhQW5kRXZlbnRzIDogZGVlcERhdGFBbmRFdmVudHM7XG5cblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0aHRtbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBlbGVtID0gdGhpc1sgMCBdIHx8IHt9LFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXG5cdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAhcm5vSW5uZXJodG1sLnRlc3QoIHZhbHVlICkgJiZcblx0XHRcdFx0IXdyYXBNYXBbICggcnRhZ05hbWUuZXhlYyggdmFsdWUgKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKSBdICkge1xuXG5cdFx0XHRcdHZhbHVlID0galF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIHZhbHVlICk7XG5cblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0XHRlbGVtID0gdGhpc1sgaSBdIHx8IHt9O1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgZWxlbWVudCBub2RlcyBhbmQgcHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cdFx0XHRcdFx0XHRcdGVsZW0uaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZWxlbSA9IDA7XG5cblx0XHRcdFx0Ly8gSWYgdXNpbmcgaW5uZXJIVE1MIHRocm93cyBhbiBleGNlcHRpb24sIHVzZSB0aGUgZmFsbGJhY2sgbWV0aG9kXG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge31cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHR0aGlzLmVtcHR5KCkuYXBwZW5kKCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpZ25vcmVkID0gW107XG5cblx0XHQvLyBNYWtlIHRoZSBjaGFuZ2VzLCByZXBsYWNpbmcgZWFjaCBub24taWdub3JlZCBjb250ZXh0IGVsZW1lbnQgd2l0aCB0aGUgbmV3IGNvbnRlbnRcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnROb2RlO1xuXG5cdFx0XHRpZiAoIGpRdWVyeS5pbkFycmF5KCB0aGlzLCBpZ25vcmVkICkgPCAwICkge1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIHRoaXMgKSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0XHRwYXJlbnQucmVwbGFjZUNoaWxkKCBlbGVtLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEZvcmNlIGNhbGxiYWNrIGludm9jYXRpb25cblx0XHR9LCBpZ25vcmVkICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIHtcblx0YXBwZW5kVG86IFwiYXBwZW5kXCIsXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXG5cdGluc2VydEJlZm9yZTogXCJiZWZvcmVcIixcblx0aW5zZXJ0QWZ0ZXI6IFwiYWZ0ZXJcIixcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXG59LCBmdW5jdGlvbiggbmFtZSwgb3JpZ2luYWwgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBlbGVtcyxcblx0XHRcdHJldCA9IFtdLFxuXHRcdFx0aW5zZXJ0ID0galF1ZXJ5KCBzZWxlY3RvciApLFxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xuXHRcdFx0ZWxlbXMgPSBpID09PSBsYXN0ID8gdGhpcyA6IHRoaXMuY2xvbmUoIHRydWUgKTtcblx0XHRcdGpRdWVyeSggaW5zZXJ0WyBpIF0gKVsgb3JpZ2luYWwgXSggZWxlbXMgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5LCBGaXJlZm94IDw9MzAgKCMxNTA5OCwgIzE0MTUwKVxuXHRcdC8vIElFIHRocm93cyBvbiBlbGVtZW50cyBjcmVhdGVkIGluIHBvcHVwc1xuXHRcdC8vIEZGIG1lYW53aGlsZSB0aHJvd3Mgb24gZnJhbWUgZWxlbWVudHMgdGhyb3VnaCBcImRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGVcIlxuXHRcdHZhciB2aWV3ID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXG5cdFx0aWYgKCAhdmlldyB8fCAhdmlldy5vcGVuZXIgKSB7XG5cdFx0XHR2aWV3ID0gd2luZG93O1xuXHRcdH1cblxuXHRcdHJldHVybiB2aWV3LmdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcblx0fTtcblxudmFyIHN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2sgKSB7XG5cdHZhciByZXQsIG5hbWUsXG5cdFx0b2xkID0ge307XG5cblx0Ly8gUmVtZW1iZXIgdGhlIG9sZCB2YWx1ZXMsIGFuZCBpbnNlcnQgdGhlIG5ldyBvbmVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvcHRpb25zWyBuYW1lIF07XG5cdH1cblxuXHRyZXQgPSBjYWxsYmFjay5jYWxsKCBlbGVtICk7XG5cblx0Ly8gUmV2ZXJ0IHRoZSBvbGQgdmFsdWVzXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcblx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSBvbGRbIG5hbWUgXTtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuXG5cbnZhciByYm94U3R5bGUgPSBuZXcgUmVnRXhwKCBjc3NFeHBhbmQuam9pbiggXCJ8XCIgKSwgXCJpXCIgKTtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXG5cdFx0Ly8gVGhpcyBpcyBhIHNpbmdsZXRvbiwgd2UgbmVlZCB0byBleGVjdXRlIGl0IG9ubHkgb25jZVxuXHRcdGlmICggIWRpdiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweDt3aWR0aDo2MHB4O1wiICtcblx0XHRcdFwibWFyZ2luLXRvcDoxcHg7cGFkZGluZzowO2JvcmRlcjowXCI7XG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO2JveC1zaXppbmc6Ym9yZGVyLWJveDtvdmVyZmxvdzpzY3JvbGw7XCIgK1xuXHRcdFx0XCJtYXJnaW46YXV0bztib3JkZXI6MXB4O3BhZGRpbmc6MXB4O1wiICtcblx0XHRcdFwid2lkdGg6NjAlO3RvcDoxJVwiO1xuXHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gNDRcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSByb3VuZFBpeGVsTWVhc3VyZXMoIGRpdlN0eWxlLm1hcmdpbkxlZnQgKSA9PT0gMTI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBTYWZhcmkgPD05LjEgLSAxMC4xLCBpT1MgPD03LjAgLSA5LjNcblx0XHQvLyBTb21lIHN0eWxlcyBjb21lIGJhY2sgd2l0aCBwZXJjZW50YWdlIHZhbHVlcywgZXZlbiB0aG91Z2ggdGhleSBzaG91bGRuJ3Rcblx0XHRkaXYuc3R5bGUucmlnaHQgPSBcIjYwJVwiO1xuXHRcdHBpeGVsQm94U3R5bGVzVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5yaWdodCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdFx0Ly8gRGV0ZWN0IG1pc3JlcG9ydGluZyBvZiBjb250ZW50IGRpbWVuc2lvbnMgZm9yIGJveC1zaXppbmc6Ym9yZGVyLWJveCBlbGVtZW50c1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS53aWR0aCApID09PSAzNjtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdC8vIERldGVjdCBvdmVyZmxvdzpzY3JvbGwgc2NyZXdpbmVzcyAoZ2gtMzY5OSlcblx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD02NFxuXHRcdC8vIERvbid0IGdldCB0cmlja2VkIHdoZW4gem9vbSBhZmZlY3RzIG9mZnNldFdpZHRoIChnaC00MDI5KVxuXHRcdGRpdi5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcblx0XHRzY3JvbGxib3hTaXplVmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXYub2Zmc2V0V2lkdGggLyAzICkgPT09IDEyO1xuXG5cdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblxuXHRcdC8vIE51bGxpZnkgdGhlIGRpdiBzbyBpdCB3b3VsZG4ndCBiZSBzdG9yZWQgaW4gdGhlIG1lbW9yeSBhbmRcblx0XHQvLyBpdCB3aWxsIGFsc28gYmUgYSBzaWduIHRoYXQgY2hlY2tzIGFscmVhZHkgcGVyZm9ybWVkXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHJvdW5kUGl4ZWxNZWFzdXJlcyggbWVhc3VyZSApIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCggcGFyc2VGbG9hdCggbWVhc3VyZSApICk7XG5cdH1cblxuXHR2YXIgcGl4ZWxQb3NpdGlvblZhbCwgYm94U2l6aW5nUmVsaWFibGVWYWwsIHNjcm9sbGJveFNpemVWYWwsIHBpeGVsQm94U3R5bGVzVmFsLFxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsLCByZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH0sXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBCZWhhdmlvciBpbiBJRSA5IGlzIG1vcmUgc3VidGxlIHRoYW4gaW4gbmV3ZXIgdmVyc2lvbnMgJiBpdCBwYXNzZXNcblx0XHQvLyBzb21lIHZlcnNpb25zIG9mIHRoaXMgdGVzdDsgbWFrZSBzdXJlIG5vdCB0byBtYWtlIGl0IHBhc3MgdGhlcmUhXG5cdFx0cmVsaWFibGVUckRpbWVuc2lvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRhYmxlLCB0ciwgdHJDaGlsZCwgdHJTdHlsZTtcblx0XHRcdGlmICggcmVsaWFibGVUckRpbWVuc2lvbnNWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0dGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRhYmxlXCIgKTtcblx0XHRcdFx0dHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInRyXCIgKTtcblx0XHRcdFx0dHJDaGlsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHRcdFx0XHR0YWJsZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0Oi0xMTExMXB4XCI7XG5cdFx0XHRcdHRyLnN0eWxlLmhlaWdodCA9IFwiMXB4XCI7XG5cdFx0XHRcdHRyQ2hpbGQuc3R5bGUuaGVpZ2h0ID0gXCI5cHhcIjtcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnRcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRhYmxlIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyIClcblx0XHRcdFx0XHQuYXBwZW5kQ2hpbGQoIHRyQ2hpbGQgKTtcblxuXHRcdFx0XHR0clN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIHRyICk7XG5cdFx0XHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID0gcGFyc2VJbnQoIHRyU3R5bGUuaGVpZ2h0ICkgPiAzO1xuXG5cdFx0XHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggdGFibGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZVRyRGltZW5zaW9uc1ZhbDtcblx0XHR9XG5cdH0gKTtcbn0gKSgpO1xuXG5cbmZ1bmN0aW9uIGN1ckNTUyggZWxlbSwgbmFtZSwgY29tcHV0ZWQgKSB7XG5cdHZhciB3aWR0aCwgbWluV2lkdGgsIG1heFdpZHRoLCByZXQsXG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDUxK1xuXHRcdC8vIFJldHJpZXZpbmcgc3R5bGUgYmVmb3JlIGNvbXB1dGVkIHNvbWVob3dcblx0XHQvLyBmaXhlcyBhbiBpc3N1ZSB3aXRoIGdldHRpbmcgd3JvbmcgdmFsdWVzXG5cdFx0Ly8gb24gZGV0YWNoZWQgZWxlbWVudHNcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0Y29tcHV0ZWQgPSBjb21wdXRlZCB8fCBnZXRTdHlsZXMoIGVsZW0gKTtcblxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG5lZWRlZCBmb3I6XG5cdC8vICAgLmNzcygnZmlsdGVyJykgKElFIDkgb25seSwgIzEyNTM3KVxuXHQvLyAgIC5jc3MoJy0tY3VzdG9tUHJvcGVydHkpICgjMzE0NClcblx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRyZXQgPSBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCBuYW1lICkgfHwgY29tcHV0ZWRbIG5hbWUgXTtcblxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFpc0F0dGFjaGVkKCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcblx0XHRpZiAoICFzdXBwb3J0LnBpeGVsQm94U3R5bGVzKCkgJiYgcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJib3hTdHlsZS50ZXN0KCBuYW1lICkgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHdpZHRoID0gc3R5bGUud2lkdGg7XG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xuXHRcdFx0bWF4V2lkdGggPSBzdHlsZS5tYXhXaWR0aDtcblxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxuXHRcdFx0c3R5bGUubWluV2lkdGggPSBzdHlsZS5tYXhXaWR0aCA9IHN0eWxlLndpZHRoID0gcmV0O1xuXHRcdFx0cmV0ID0gY29tcHV0ZWQud2lkdGg7XG5cblx0XHRcdC8vIFJldmVydCB0aGUgY2hhbmdlZCB2YWx1ZXNcblx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGg7XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xuXHRcdFx0c3R5bGUubWF4V2lkdGggPSBtYXhXaWR0aDtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmV0ICE9PSB1bmRlZmluZWQgP1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdC8vIElFIHJldHVybnMgekluZGV4IHZhbHVlIGFzIGFuIGludGVnZXIuXG5cdFx0cmV0ICsgXCJcIiA6XG5cdFx0cmV0O1xufVxuXG5cbmZ1bmN0aW9uIGFkZEdldEhvb2tJZiggY29uZGl0aW9uRm4sIGhvb2tGbiApIHtcblxuXHQvLyBEZWZpbmUgdGhlIGhvb2ssIHdlJ2xsIGNoZWNrIG9uIHRoZSBmaXJzdCBydW4gaWYgaXQncyByZWFsbHkgbmVlZGVkLlxuXHRyZXR1cm4ge1xuXHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGNvbmRpdGlvbkZuKCkgKSB7XG5cblx0XHRcdFx0Ly8gSG9vayBub3QgbmVlZGVkIChvciBpdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgaXQgZHVlXG5cdFx0XHRcdC8vIHRvIG1pc3NpbmcgZGVwZW5kZW5jeSksIHJlbW92ZSBpdC5cblx0XHRcdFx0ZGVsZXRlIHRoaXMuZ2V0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIEhvb2sgbmVlZGVkOyByZWRlZmluZSBpdCBzbyB0aGF0IHRoZSBzdXBwb3J0IHRlc3QgaXMgbm90IGV4ZWN1dGVkIGFnYWluLlxuXHRcdFx0cmV0dXJuICggdGhpcy5nZXQgPSBob29rRm4gKS5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fVxuXHR9O1xufVxuXG5cbnZhciBjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJNb3pcIiwgXCJtc1wiIF0sXG5cdGVtcHR5U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkuc3R5bGUsXG5cdHZlbmRvclByb3BzID0ge307XG5cbi8vIFJldHVybiBhIHZlbmRvci1wcmVmaXhlZCBwcm9wZXJ0eSBvciB1bmRlZmluZWRcbmZ1bmN0aW9uIHZlbmRvclByb3BOYW1lKCBuYW1lICkge1xuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG4vLyBSZXR1cm4gYSBwb3RlbnRpYWxseS1tYXBwZWQgalF1ZXJ5LmNzc1Byb3BzIG9yIHZlbmRvciBwcmVmaXhlZCBwcm9wZXJ0eVxuZnVuY3Rpb24gZmluYWxQcm9wTmFtZSggbmFtZSApIHtcblx0dmFyIGZpbmFsID0galF1ZXJ5LmNzc1Byb3BzWyBuYW1lIF0gfHwgdmVuZG9yUHJvcHNbIG5hbWUgXTtcblxuXHRpZiAoIGZpbmFsICkge1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXHRyZXR1cm4gdmVuZG9yUHJvcHNbIG5hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBuYW1lICkgfHwgbmFtZTtcbn1cblxuXG52YXJcblxuXHQvLyBTd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlXG5cdC8vIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxuXHQvLyBTZWUgaGVyZSBmb3IgZGlzcGxheSB2YWx1ZXM6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvQ1NTL2Rpc3BsYXlcblx0cmRpc3BsYXlzd2FwID0gL14obm9uZXx0YWJsZSg/IS1jW2VhXSkuKykvLFxuXHRyY3VzdG9tUHJvcCA9IC9eLS0vLFxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fTtcblxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIF9lbGVtLCB2YWx1ZSwgc3VidHJhY3QgKSB7XG5cblx0Ly8gQW55IHJlbGF0aXZlICgrLy0pIHZhbHVlcyBoYXZlIGFscmVhZHkgYmVlblxuXHQvLyBub3JtYWxpemVkIGF0IHRoaXMgcG9pbnRcblx0dmFyIG1hdGNoZXMgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICk7XG5cdHJldHVybiBtYXRjaGVzID9cblxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXG5cdFx0TWF0aC5tYXgoIDAsIG1hdGNoZXNbIDIgXSAtICggc3VidHJhY3QgfHwgMCApICkgKyAoIG1hdGNoZXNbIDMgXSB8fCBcInB4XCIgKSA6XG5cdFx0dmFsdWU7XG59XG5cbmZ1bmN0aW9uIGJveE1vZGVsQWRqdXN0bWVudCggZWxlbSwgZGltZW5zaW9uLCBib3gsIGlzQm9yZGVyQm94LCBzdHlsZXMsIGNvbXB1dGVkVmFsICkge1xuXHR2YXIgaSA9IGRpbWVuc2lvbiA9PT0gXCJ3aWR0aFwiID8gMSA6IDAsXG5cdFx0ZXh0cmEgPSAwLFxuXHRcdGRlbHRhID0gMDtcblxuXHQvLyBBZGp1c3RtZW50IG1heSBub3QgYmUgbmVjZXNzYXJ5XG5cdGlmICggYm94ID09PSAoIGlzQm9yZGVyQm94ID8gXCJib3JkZXJcIiA6IFwiY29udGVudFwiICkgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XG5cblx0XHQvLyBCb3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW5cblx0XHRpZiAoIGJveCA9PT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdGRlbHRhICs9IGpRdWVyeS5jc3MoIGVsZW0sIGJveCArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgY29udGVudC1ib3gsIHdlJ3JlIHNlZWtpbmcgXCJwYWRkaW5nXCIgb3IgXCJib3JkZXJcIiBvciBcIm1hcmdpblwiXG5cdFx0aWYgKCAhaXNCb3JkZXJCb3ggKSB7XG5cblx0XHRcdC8vIEFkZCBwYWRkaW5nXG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gRm9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIiwgYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBib3ggIT09IFwicGFkZGluZ1wiICkge1xuXHRcdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXG5cdFx0XHQvLyBCdXQgc3RpbGwga2VlcCB0cmFjayBvZiBpdCBvdGhlcndpc2Vcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4dHJhICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHQvLyBJZiB3ZSBnZXQgaGVyZSB3aXRoIGEgYm9yZGVyLWJveCAoY29udGVudCArIHBhZGRpbmcgKyBib3JkZXIpLCB3ZSdyZSBzZWVraW5nIFwiY29udGVudFwiIG9yXG5cdFx0Ly8gXCJwYWRkaW5nXCIgb3IgXCJtYXJnaW5cIlxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiwgc3VidHJhY3QgcGFkZGluZ1xuXHRcdFx0aWYgKCBib3ggPT09IFwiY29udGVudFwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yIFwiY29udGVudFwiIG9yIFwicGFkZGluZ1wiLCBzdWJ0cmFjdCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdFx0XHRkZWx0YSAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFjY291bnQgZm9yIHBvc2l0aXZlIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXIgd2hlbiByZXF1ZXN0ZWQgYnkgcHJvdmlkaW5nIGNvbXB1dGVkVmFsXG5cdGlmICggIWlzQm9yZGVyQm94ICYmIGNvbXB1dGVkVmFsID49IDAgKSB7XG5cblx0XHQvLyBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgYSByb3VuZGVkIHN1bSBvZiBjb250ZW50LCBwYWRkaW5nLCBzY3JvbGwgZ3V0dGVyLCBhbmQgYm9yZGVyXG5cdFx0Ly8gQXNzdW1pbmcgaW50ZWdlciBzY3JvbGwgZ3V0dGVyLCBzdWJ0cmFjdCB0aGUgcmVzdCBhbmQgcm91bmQgZG93blxuXHRcdGRlbHRhICs9IE1hdGgubWF4KCAwLCBNYXRoLmNlaWwoXG5cdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0Y29tcHV0ZWRWYWwgLVxuXHRcdFx0ZGVsdGEgLVxuXHRcdFx0ZXh0cmEgLVxuXHRcdFx0MC41XG5cblx0XHQvLyBJZiBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgaXMgdW5rbm93biwgdGhlbiB3ZSBjYW4ndCBkZXRlcm1pbmUgY29udGVudC1ib3ggc2Nyb2xsIGd1dHRlclxuXHRcdC8vIFVzZSBhbiBleHBsaWNpdCB6ZXJvIHRvIGF2b2lkIE5hTiAoZ2gtMzk2NClcblx0XHQpICkgfHwgMDtcblx0fVxuXG5cdHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApIHtcblxuXHQvLyBTdGFydCB3aXRoIGNvbXB1dGVkIHN0eWxlXG5cdHZhciBzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKSxcblxuXHRcdC8vIFRvIGF2b2lkIGZvcmNpbmcgYSByZWZsb3csIG9ubHkgZmV0Y2ggYm94U2l6aW5nIGlmIHdlIG5lZWQgaXQgKGdoLTQzMjIpLlxuXHRcdC8vIEZha2UgY29udGVudC1ib3ggdW50aWwgd2Uga25vdyBpdCdzIG5lZWRlZCB0byBrbm93IHRoZSB0cnVlIHZhbHVlLlxuXHRcdGJveFNpemluZ05lZWRlZCA9ICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgZXh0cmEsXG5cdFx0aXNCb3JkZXJCb3ggPSBib3hTaXppbmdOZWVkZWQgJiZcblx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IGlzQm9yZGVyQm94LFxuXG5cdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBkaW1lbnNpb24sIHN0eWxlcyApLFxuXHRcdG9mZnNldFByb3AgPSBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApO1xuXG5cdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHQvLyBSZXR1cm4gYSBjb25mb3VuZGluZyBub24tcGl4ZWwgdmFsdWUgb3IgZmVpZ24gaWdub3JhbmNlLCBhcyBhcHByb3ByaWF0ZS5cblx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0aWYgKCAhZXh0cmEgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblx0XHR2YWwgPSBcImF1dG9cIjtcblx0fVxuXG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gVXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3Igd2hlbiBib3ggc2l6aW5nIGlzIHVucmVsaWFibGUuXG5cdC8vIEluIHRob3NlIGNhc2VzLCB0aGUgY29tcHV0ZWQgdmFsdWUgY2FuIGJlIHRydXN0ZWQgdG8gYmUgYm9yZGVyLWJveC5cblx0aWYgKCAoICFzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgJiYgaXNCb3JkZXJCb3ggfHxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDEwIC0gMTErLCBFZGdlIDE1IC0gMTgrXG5cdFx0Ly8gSUUvRWRnZSBtaXNyZXBvcnQgYGdldENvbXB1dGVkU3R5bGVgIG9mIHRhYmxlIHJvd3Mgd2l0aCB3aWR0aC9oZWlnaHRcblx0XHQvLyBzZXQgaW4gQ1NTIHdoaWxlIGBvZmZzZXQqYCBwcm9wZXJ0aWVzIHJlcG9ydCBjb3JyZWN0IHZhbHVlcy5cblx0XHQvLyBJbnRlcmVzdGluZ2x5LCBpbiBzb21lIGNhc2VzIElFIDkgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGlzIGlzc3VlLlxuXHRcdCFzdXBwb3J0LnJlbGlhYmxlVHJEaW1lbnNpb25zKCkgJiYgbm9kZU5hbWUoIGVsZW0sIFwidHJcIiApIHx8XG5cblx0XHQvLyBGYWxsIGJhY2sgdG8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IHdoZW4gdmFsdWUgaXMgXCJhdXRvXCJcblx0XHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMSAtIDQuMyBvbmx5XG5cdFx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciBtaXNyZXBvcnRlZCBpbmxpbmUgZGltZW5zaW9ucyAoZ2gtMzYwMilcblx0XHQhcGFyc2VGbG9hdCggdmFsICkgJiYgalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJpbmxpbmVcIiApICYmXG5cblx0XHQvLyBNYWtlIHN1cmUgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSAmIGNvbm5lY3RlZFxuXHRcdGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XG5cblx0XHQvLyBXaGVyZSBhdmFpbGFibGUsIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBhcHByb3hpbWF0ZSBib3JkZXIgYm94IGRpbWVuc2lvbnMuXG5cdFx0Ly8gV2hlcmUgbm90IGF2YWlsYWJsZSAoZS5nLiwgU1ZHKSwgYXNzdW1lIHVucmVsaWFibGUgYm94LXNpemluZyBhbmQgaW50ZXJwcmV0IHRoZVxuXHRcdC8vIHJldHJpZXZlZCB2YWx1ZSBhcyBhIGNvbnRlbnQgYm94IGRpbWVuc2lvbi5cblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gb2Zmc2V0UHJvcCBpbiBlbGVtO1xuXHRcdGlmICggdmFsdWVJc0JvcmRlckJveCApIHtcblx0XHRcdHZhbCA9IGVsZW1bIG9mZnNldFByb3AgXTtcblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgXCJcIiBhbmQgYXV0b1xuXHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXG5cdC8vIEFkanVzdCBmb3IgdGhlIGVsZW1lbnQncyBib3ggbW9kZWxcblx0cmV0dXJuICggdmFsICtcblx0XHRib3hNb2RlbEFkanVzdG1lbnQoXG5cdFx0XHRlbGVtLFxuXHRcdFx0ZGltZW5zaW9uLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlcyxcblxuXHRcdFx0Ly8gUHJvdmlkZSB0aGUgY3VycmVudCBjb21wdXRlZCBzaXplIHRvIHJlcXVlc3Qgc2Nyb2xsIGd1dHRlciBjYWxjdWxhdGlvbiAoZ2gtMzU4OSlcblx0XHRcdHZhbFxuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIEFkZCBpbiBzdHlsZSBwcm9wZXJ0eSBob29rcyBmb3Igb3ZlcnJpZGluZyB0aGUgZGVmYXVsdFxuXHQvLyBiZWhhdmlvciBvZiBnZXR0aW5nIGFuZCBzZXR0aW5nIGEgc3R5bGUgcHJvcGVydHlcblx0Y3NzSG9va3M6IHtcblx0XHRvcGFjaXR5OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XG5cdFx0XHRcdFx0dmFyIHJldCA9IGN1ckNTUyggZWxlbSwgXCJvcGFjaXR5XCIgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmV0ID09PSBcIlwiID8gXCIxXCIgOiByZXQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gRG9uJ3QgYXV0b21hdGljYWxseSBhZGQgXCJweFwiIHRvIHRoZXNlIHBvc3NpYmx5LXVuaXRsZXNzIHByb3BlcnRpZXNcblx0Y3NzTnVtYmVyOiB7XG5cdFx0XCJhbmltYXRpb25JdGVyYXRpb25Db3VudFwiOiB0cnVlLFxuXHRcdFwiY29sdW1uQ291bnRcIjogdHJ1ZSxcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJmbGV4R3Jvd1wiOiB0cnVlLFxuXHRcdFwiZmxleFNocmlua1wiOiB0cnVlLFxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxuXHRcdFwiZ3JpZEFyZWFcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5cIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5FbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRDb2x1bW5TdGFydFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1wiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd0VuZFwiOiB0cnVlLFxuXHRcdFwiZ3JpZFJvd1N0YXJ0XCI6IHRydWUsXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXG5cdFx0XCJvcGFjaXR5XCI6IHRydWUsXG5cdFx0XCJvcmRlclwiOiB0cnVlLFxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxuXHRcdFwid2lkb3dzXCI6IHRydWUsXG5cdFx0XCJ6SW5kZXhcIjogdHJ1ZSxcblx0XHRcInpvb21cIjogdHJ1ZVxuXHR9LFxuXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcblx0Ly8gc2V0dGluZyBvciBnZXR0aW5nIHRoZSB2YWx1ZVxuXHRjc3NQcm9wczoge30sXG5cblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcblx0c3R5bGU6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSwgZXh0cmEgKSB7XG5cblx0XHQvLyBEb24ndCBzZXQgc3R5bGVzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoICFlbGVtIHx8IGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCB8fCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcblx0XHR2YXIgcmV0LCB0eXBlLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBxdWVyeSB0aGUgdmFsdWUgaWYgaXQgaXMgYSBDU1MgY3VzdG9tIHByb3BlcnR5XG5cdFx0Ly8gc2luY2UgdGhleSBhcmUgdXNlci1kZWZpbmVkLlxuXHRcdGlmICggIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdG5hbWUgPSBmaW5hbFByb3BOYW1lKCBvcmlnTmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEdldHMgaG9vayBmb3IgdGhlIHByZWZpeGVkIHZlcnNpb24sIHRoZW4gdW5wcmVmaXhlZCB2ZXJzaW9uXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0eXBlID0gdHlwZW9mIHZhbHVlO1xuXG5cdFx0XHQvLyBDb252ZXJ0IFwiKz1cIiBvciBcIi09XCIgdG8gcmVsYXRpdmUgbnVtYmVycyAoIzczNDUpXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKCByZXQgPSByY3NzTnVtLmV4ZWMoIHZhbHVlICkgKSAmJiByZXRbIDEgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBhZGp1c3RDU1MoIGVsZW0sIG5hbWUsIHJldCApO1xuXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xuXHRcdFx0XHR0eXBlID0gXCJudW1iZXJcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgbnVsbCBhbmQgTmFOIHZhbHVlcyBhcmVuJ3Qgc2V0ICgjNzExNilcblx0XHRcdGlmICggdmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBudW1iZXIgd2FzIHBhc3NlZCBpbiwgYWRkIHRoZSB1bml0IChleGNlcHQgZm9yIGNlcnRhaW4gQ1NTIHByb3BlcnRpZXMpXG5cdFx0XHQvLyBUaGUgaXNDdXN0b21Qcm9wIGNoZWNrIGNhbiBiZSByZW1vdmVkIGluIGpRdWVyeSA0LjAgd2hlbiB3ZSBvbmx5IGF1dG8tYXBwZW5kXG5cdFx0XHQvLyBcInB4XCIgdG8gYSBmZXcgaGFyZGNvZGVkIHZhbHVlcy5cblx0XHRcdGlmICggdHlwZSA9PT0gXCJudW1iZXJcIiAmJiAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdGlmICggaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0XHRcdHN0eWxlLnNldFByb3BlcnR5KCBuYW1lLCB2YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIG5vbi1jb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIGZhbHNlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdGhlcndpc2UganVzdCBnZXQgdGhlIHZhbHVlIGZyb20gdGhlIHN0eWxlIG9iamVjdFxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XG5cdFx0fVxuXHR9LFxuXG5cdGNzczogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGV4dHJhLCBzdHlsZXMgKSB7XG5cdFx0dmFyIHZhbCwgbnVtLCBob29rcyxcblx0XHRcdG9yaWdOYW1lID0gY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRpc0N1c3RvbVByb3AgPSByY3VzdG9tUHJvcC50ZXN0KCBuYW1lICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWUuIFdlIGRvbid0XG5cdFx0Ly8gd2FudCB0byBtb2RpZnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBUcnkgcHJlZml4ZWQgbmFtZSBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCBuYW1lXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XG5cblx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcblx0XHRcdHZhbCA9IGhvb2tzLmdldCggZWxlbSwgdHJ1ZSwgZXh0cmEgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2UsIGlmIGEgd2F5IHRvIGdldCB0aGUgY29tcHV0ZWQgdmFsdWUgZXhpc3RzLCB1c2UgdGhhdFxuXHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgXCJub3JtYWxcIiB0byBjb21wdXRlZCB2YWx1ZVxuXHRcdGlmICggdmFsID09PSBcIm5vcm1hbFwiICYmIG5hbWUgaW4gY3NzTm9ybWFsVHJhbnNmb3JtICkge1xuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBudW1lcmljIGlmIGZvcmNlZCBvciBhIHF1YWxpZmllciB3YXMgcHJvdmlkZWQgYW5kIHZhbCBsb29rcyBudW1lcmljXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcblx0XHRcdG51bSA9IHBhcnNlRmxvYXQoIHZhbCApO1xuXHRcdFx0cmV0dXJuIGV4dHJhID09PSB0cnVlIHx8IGlzRmluaXRlKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xuXHRcdH1cblxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBfaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgY3NzRm4gPSBqUXVlcnkuZm5bIG5hbWUgXTtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XG5cdFx0XHRjc3NGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICkgOlxuXHRcdFx0dGhpcy5hbmltYXRlKCBnZW5GeCggbmFtZSwgdHJ1ZSApLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG4vLyBHZW5lcmF0ZSBzaG9ydGN1dHMgZm9yIGN1c3RvbSBhbmltYXRpb25zXG5qUXVlcnkuZWFjaCgge1xuXHRzbGlkZURvd246IGdlbkZ4KCBcInNob3dcIiApLFxuXHRzbGlkZVVwOiBnZW5GeCggXCJoaWRlXCIgKSxcblx0c2xpZGVUb2dnbGU6IGdlbkZ4KCBcInRvZ2dsZVwiICksXG5cdGZhZGVJbjogeyBvcGFjaXR5OiBcInNob3dcIiB9LFxuXHRmYWRlT3V0OiB7IG9wYWNpdHk6IFwiaGlkZVwiIH0sXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XG59LCBmdW5jdGlvbiggbmFtZSwgcHJvcHMgKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkudGltZXJzID0gW107XG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgdGltZXIsXG5cdFx0aSA9IDAsXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcblxuXHRmeE5vdyA9IERhdGUubm93KCk7XG5cblx0Zm9yICggOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrICkge1xuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XG5cblx0XHQvLyBSdW4gdGhlIHRpbWVyIGFuZCBzYWZlbHkgcmVtb3ZlIGl0IHdoZW4gZG9uZSAoYWxsb3dpbmcgZm9yIGV4dGVybmFsIHJlbW92YWwpXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XG59O1xuXG5qUXVlcnkuZnguaW50ZXJ2YWwgPSAxMztcbmpRdWVyeS5meC5zdGFydCA9IGZ1bmN0aW9uKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0aW5Qcm9ncmVzcyA9IHRydWU7XG5cdHNjaGVkdWxlKCk7XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRpblByb2dyZXNzID0gbnVsbDtcbn07XG5cbmpRdWVyeS5meC5zcGVlZHMgPSB7XG5cdHNsb3c6IDYwMCxcblx0ZmFzdDogMjAwLFxuXG5cdC8vIERlZmF1bHQgc3BlZWRcblx0X2RlZmF1bHQ6IDQwMFxufTtcblxuXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXG4vLyBodHRwczovL3dlYi5hcmNoaXZlLm9yZy93ZWIvMjAxMDAzMjQwMTQ3NDcvaHR0cDovL2JsaW5kc2lnbmFscy5jb20vaW5kZXgucGhwLzIwMDkvMDcvanF1ZXJ5LWRlbGF5L1xualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XG5cdHRpbWUgPSBqUXVlcnkuZnggPyBqUXVlcnkuZnguc3BlZWRzWyB0aW1lIF0gfHwgdGltZSA6IHRpbWU7XG5cdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSwgZnVuY3Rpb24oIG5leHQsIGhvb2tzICkge1xuXHRcdHZhciB0aW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcblx0XHRob29rcy5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XG5cdFx0fTtcblx0fSApO1xufTtcblxuXG4oIGZ1bmN0aW9uKCkge1xuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcblx0XHRzZWxlY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcInNlbGVjdFwiICksXG5cdFx0b3B0ID0gc2VsZWN0LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9wdGlvblwiICkgKTtcblxuXHRpbnB1dC50eXBlID0gXCJjaGVja2JveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjMgb25seVxuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIE11c3QgYWNjZXNzIHNlbGVjdGVkSW5kZXggdG8gbWFrZSBkZWZhdWx0IG9wdGlvbnMgc2VsZWN0XG5cdHN1cHBvcnQub3B0U2VsZWN0ZWQgPSBvcHQuc2VsZWN0ZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdC8vIEFuIGlucHV0IGxvc2VzIGl0cyB2YWx1ZSBhZnRlciBiZWNvbWluZyBhIHJhZGlvXG5cdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICk7XG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XG5cdGlucHV0LnR5cGUgPSBcInJhZGlvXCI7XG5cdHN1cHBvcnQucmFkaW9WYWx1ZSA9IGlucHV0LnZhbHVlID09PSBcInRcIjtcbn0gKSgpO1xuXG5cbnZhciBib29sSG9vayxcblx0YXR0ckhhbmRsZSA9IGpRdWVyeS5leHByLmF0dHJIYW5kbGU7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBhdHRyaWJ1dGVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcblx0XHRpZiAoIHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHQvLyBBdHRyaWJ1dGUgaG9va3MgYXJlIGRldGVybWluZWQgYnkgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG5cdFx0Ly8gR3JhYiBuZWNlc3NhcnkgaG9vayBpZiBvbmUgaXMgZGVmaW5lZFxuXHRcdGlmICggblR5cGUgIT09IDEgfHwgIWpRdWVyeS5pc1hNTERvYyggZWxlbSApICkge1xuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XG5cdFx0XHRcdFx0dmFyIHZhbCA9IGVsZW0udmFsdWU7XG5cdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCB2YWx1ZSApO1xuXHRcdFx0XHRcdGlmICggdmFsICkge1xuXHRcdFx0XHRcdFx0ZWxlbS52YWx1ZSA9IHZhbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHR2YXIgbmFtZSxcblx0XHRcdGkgPSAwLFxuXG5cdFx0XHQvLyBBdHRyaWJ1dGUgbmFtZXMgY2FuIGNvbnRhaW4gbm9uLUhUTUwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG5cdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNhdHRyaWJ1dGVzLTJcblx0XHRcdGF0dHJOYW1lcyA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhvb2tzIGZvciBib29sZWFuIGF0dHJpYnV0ZXNcbmJvb2xIb29rID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgbmFtZSApIHtcblx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGJvb2xlYW4gYXR0cmlidXRlcyB3aGVuIHNldCB0byBmYWxzZVxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cbn07XG5cbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdHZhciBnZXR0ZXIgPSBhdHRySGFuZGxlWyBuYW1lIF0gfHwgalF1ZXJ5LmZpbmQuYXR0cjtcblxuXHRhdHRySGFuZGxlWyBuYW1lIF0gPSBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHJldCwgaGFuZGxlLFxuXHRcdFx0bG93ZXJjYXNlTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuXHRcdGlmICggIWlzWE1MICkge1xuXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXG5cdFx0XHRoYW5kbGUgPSBhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF07XG5cdFx0XHRhdHRySGFuZGxlWyBsb3dlcmNhc2VOYW1lIF0gPSByZXQ7XG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XG5cdFx0XHRcdGxvd2VyY2FzZU5hbWUgOlxuXHRcdFx0XHRudWxsO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gaGFuZGxlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmV0O1xuXHR9O1xufSApO1xuXG5cblxuXG52YXIgcmZvY3VzYWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJjbGlja2FibGUgPSAvXig/OmF8YXJlYSkkL2k7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5wcm9wLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fSxcblxuXHRyZW1vdmVQcm9wOiBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGRlbGV0ZSB0aGlzWyBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWUgXTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRwcm9wOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IHByb3BlcnRpZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gRml4IG5hbWUgYW5kIGF0dGFjaCBob29rc1xuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcblx0XHRcdGhvb2tzID0galF1ZXJ5LnByb3BIb29rc1sgbmFtZSBdO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAoIGVsZW1bIG5hbWUgXSA9IHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGVsZW1bIG5hbWUgXTtcblx0fSxcblxuXHRwcm9wSG9va3M6IHtcblx0XHR0YWJJbmRleDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0XHRcdC8vIGVsZW0udGFiSW5kZXggZG9lc24ndCBhbHdheXMgcmV0dXJuIHRoZVxuXHRcdFx0XHQvLyBjb3JyZWN0IHZhbHVlIHdoZW4gaXQgaGFzbid0IGJlZW4gZXhwbGljaXRseSBzZXRcblx0XHRcdFx0Ly8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTQxMTE2MjMzMzQ3L2h0dHA6Ly9mbHVpZHByb2plY3Qub3JnL2Jsb2cvMjAwOC8wMS8wOS9nZXR0aW5nLXNldHRpbmctYW5kLXJlbW92aW5nLXRhYmluZGV4LXZhbHVlcy13aXRoLWphdmFzY3JpcHQvXG5cdFx0XHRcdC8vIFVzZSBwcm9wZXIgYXR0cmlidXRlIHJldHJpZXZhbCgjMTIwNzIpXG5cdFx0XHRcdHZhciB0YWJpbmRleCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidGFiaW5kZXhcIiApO1xuXG5cdFx0XHRcdGlmICggdGFiaW5kZXggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRyZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fFxuXHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmXG5cdFx0XHRcdFx0ZWxlbS5ocmVmXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRwcm9wRml4OiB7XG5cdFx0XCJmb3JcIjogXCJodG1sRm9yXCIsXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXG5cdH1cbn0gKTtcblxuLy8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG4vLyBBY2Nlc3NpbmcgdGhlIHNlbGVjdGVkSW5kZXggcHJvcGVydHlcbi8vIGZvcmNlcyB0aGUgYnJvd3NlciB0byByZXNwZWN0IHNldHRpbmcgc2VsZWN0ZWRcbi8vIG9uIHRoZSBvcHRpb25cbi8vIFRoZSBnZXR0ZXIgZW5zdXJlcyBhIGRlZmF1bHQgb3B0aW9uIGlzIHNlbGVjdGVkXG4vLyB3aGVuIGluIGFuIG9wdGdyb3VwXG4vLyBlc2xpbnQgcnVsZSBcIm5vLXVudXNlZC1leHByZXNzaW9uc1wiIGlzIGRpc2FibGVkIGZvciB0aGlzIGNvZGVcbi8vIHNpbmNlIGl0IGNvbnNpZGVycyBzdWNoIGFjY2Vzc2lvbnMgbm9vcFxuaWYgKCAhc3VwcG9ydC5vcHRTZWxlY3RlZCApIHtcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvKiBlc2xpbnQgbm8tdW51c2VkLWV4cHJlc3Npb25zOiBcIm9mZlwiICovXG5cblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH0sXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5zZWxlY3RlZEluZGV4O1xuXG5cdFx0XHRcdGlmICggcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cblx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2UgYWNjb3JkaW5nIHRvIEhUTUwgc3BlY1xuXHQvLyBodHRwczovL2luZnJhLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLWFzY2lpLXdoaXRlc3BhY2Vcblx0ZnVuY3Rpb24gc3RyaXBBbmRDb2xsYXBzZSggdmFsdWUgKSB7XG5cdFx0dmFyIHRva2VucyA9IHZhbHVlLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cdFx0cmV0dXJuIHRva2Vucy5qb2luKCBcIiBcIiApO1xuXHR9XG5cblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxuZnVuY3Rpb24gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICkge1xuXHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9XG5cdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHR9XG5cdHJldHVybiBbXTtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGN1clZhbHVlICkgKyBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5yZW1vdmVDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB0aGlzLmF0dHIoIFwiY2xhc3NcIiwgXCJcIiApO1xuXHRcdH1cblxuXHRcdGNsYXNzZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdGlmICggY2xhc3Nlcy5sZW5ndGggKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBSZW1vdmUgKmFsbCogaW5zdGFuY2VzXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgPSBjdXIucmVwbGFjZSggXCIgXCIgKyBjbGF6eiArIFwiIFwiLCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHN0cmlwQW5kQ29sbGFwc2UoIGN1ciApO1xuXHRcdFx0XHRcdGlmICggY3VyVmFsdWUgIT09IGZpbmFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLCBmaW5hbFZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSwgc3RhdGVWYWwgKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWUsXG5cdFx0XHRpc1ZhbGlkVmFsdWUgPSB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIHR5cGVvZiBzdGF0ZVZhbCA9PT0gXCJib29sZWFuXCIgJiYgaXNWYWxpZFZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKFxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIHRoaXMsIGksIGdldENsYXNzKCB0aGlzICksIHN0YXRlVmFsICksXG5cdFx0XHRcdFx0c3RhdGVWYWxcblx0XHRcdFx0KTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjbGFzc05hbWUsIGksIHNlbGYsIGNsYXNzTmFtZXM7XG5cblx0XHRcdGlmICggaXNWYWxpZFZhbHVlICkge1xuXG5cdFx0XHRcdC8vIFRvZ2dsZSBpbmRpdmlkdWFsIGNsYXNzIG5hbWVzXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRzZWxmID0galF1ZXJ5KCB0aGlzICk7XG5cdFx0XHRcdGNsYXNzTmFtZXMgPSBjbGFzc2VzVG9BcnJheSggdmFsdWUgKTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIHN0cmlwQW5kQ29sbGFwc2UoIGdldENsYXNzKCBlbGVtICkgKSArIFwiIFwiICkuaW5kZXhPZiggY2xhc3NOYW1lICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0dmFsOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGhvb2tzLCByZXQsIHZhbHVlSXNGdW5jdGlvbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF07XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgZWxlbS50eXBlIF0gfHxcblx0XHRcdFx0XHRqUXVlcnkudmFsSG9va3NbIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHRcdGlmICggaG9va3MgJiZcblx0XHRcdFx0XHRcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdFx0KCByZXQgPSBob29rcy5nZXQoIGVsZW0sIFwidmFsdWVcIiApICkgIT09IHVuZGVmaW5lZFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0ID0gZWxlbS52YWx1ZTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXG5cdFx0XHRcdGlmICggdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmV0LnJlcGxhY2UoIHJyZXR1cm4sIFwiXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyBcIlwiIDogcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHR2YWwgPSB2YWx1ZS5jYWxsKCB0aGlzLCBpLCBqUXVlcnkoIHRoaXMgKS52YWwoKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsID0gdmFsdWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHZhbCA9IFwiXCI7XG5cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIHtcblx0XHRcdFx0dmFsID0galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKyBcIlwiO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cblx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyB0aGlzLnR5cGUgXSB8fCBqUXVlcnkudmFsSG9va3NbIHRoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKSBdO1xuXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHZhbEhvb2tzOiB7XG5cdFx0b3B0aW9uOiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHRcdHZhciB2YWwgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInZhbHVlXCIgKTtcblx0XHRcdFx0cmV0dXJuIHZhbCAhPSBudWxsID9cblx0XHRcdFx0XHR2YWwgOlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExIG9ubHlcblx0XHRcdFx0XHQvLyBvcHRpb24udGV4dCB0aHJvd3MgZXhjZXB0aW9ucyAoIzE0Njg2LCAjMTQ4NTgpXG5cdFx0XHRcdFx0Ly8gU3RyaXAgYW5kIGNvbGxhcHNlIHdoaXRlc3BhY2Vcblx0XHRcdFx0XHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNzdHJpcC1hbmQtY29sbGFwc2Utd2hpdGVzcGFjZVxuXHRcdFx0XHRcdHN0cmlwQW5kQ29sbGFwc2UoIGpRdWVyeS50ZXh0KCBlbGVtICkgKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHNlbGVjdDoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBvcHRpb24sIGksXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcblx0XHRcdFx0XHRvbmUgPSBlbGVtLnR5cGUgPT09IFwic2VsZWN0LW9uZVwiLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHRpZiAoIGluZGV4IDwgMCApIHtcblx0XHRcdFx0XHRpID0gbWF4O1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IG9uZSA/IGluZGV4IDogMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIExvb3AgdGhyb3VnaCBhbGwgdGhlIHNlbGVjdGVkIG9wdGlvbnNcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCFvcHRpb24uZGlzYWJsZWQgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhbm9kZU5hbWUoIG9wdGlvbi5wYXJlbnROb2RlLCBcIm9wdGdyb3VwXCIgKSApICkge1xuXG5cdFx0XHRcdFx0XHQvLyBHZXQgdGhlIHNwZWNpZmljIHZhbHVlIGZvciB0aGUgb3B0aW9uXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IGpRdWVyeSggb3B0aW9uICkudmFsKCk7XG5cblx0XHRcdFx0XHRcdC8vIFdlIGRvbid0IG5lZWQgYW4gYXJyYXkgZm9yIG9uZSBzZWxlY3RzXG5cdFx0XHRcdFx0XHRpZiAoIG9uZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxuXHRcdFx0XHRcdFx0dmFsdWVzLnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH0sXG5cblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXG5cdFx0XHRcdFx0b3B0aW9ucyA9IGVsZW0ub3B0aW9ucyxcblx0XHRcdFx0XHR2YWx1ZXMgPSBqUXVlcnkubWFrZUFycmF5KCB2YWx1ZSApLFxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXG5cdFx0XHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbmQtYXNzaWduICovXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS5jaGVja2VkID0galF1ZXJ5LmluQXJyYXkoIGpRdWVyeSggZWxlbSApLnZhbCgpLCB2YWx1ZSApID4gLTEgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdGlmICggIXN1cHBvcnQuY2hlY2tPbiApIHtcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxuXG5cbnN1cHBvcnQuZm9jdXNpbiA9IFwib25mb2N1c2luXCIgaW4gd2luZG93O1xuXG5cbnZhciByZm9jdXNNb3JwaCA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLyxcblx0c3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiggZSApIHtcblx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9O1xuXG5qUXVlcnkuZXh0ZW5kKCBqUXVlcnkuZXZlbnQsIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcblxuXHRcdHZhciBpLCBjdXIsIHRtcCwgYnViYmxlVHlwZSwgb250eXBlLCBoYW5kbGUsIHNwZWNpYWwsIGxhc3RFbGVtZW50LFxuXHRcdFx0ZXZlbnRQYXRoID0gWyBlbGVtIHx8IGRvY3VtZW50IF0sXG5cdFx0XHR0eXBlID0gaGFzT3duLmNhbGwoIGV2ZW50LCBcInR5cGVcIiApID8gZXZlbnQudHlwZSA6IGV2ZW50LFxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KCBcIi5cIiApIDogW107XG5cblx0XHRjdXIgPSBsYXN0RWxlbWVudCA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xuXG5cdFx0Ly8gRG9uJ3QgZG8gZXZlbnRzIG9uIHRleHQgYW5kIGNvbW1lbnQgbm9kZXNcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBmb2N1cy9ibHVyIG1vcnBocyB0byBmb2N1c2luL291dDsgZW5zdXJlIHdlJ3JlIG5vdCBmaXJpbmcgdGhlbSByaWdodCBub3dcblx0XHRpZiAoIHJmb2N1c01vcnBoLnRlc3QoIHR5cGUgKyBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoIFwiLlwiICkgPiAtMSApIHtcblxuXHRcdFx0Ly8gTmFtZXNwYWNlZCB0cmlnZ2VyOyBjcmVhdGUgYSByZWdleHAgdG8gbWF0Y2ggZXZlbnQgdHlwZSBpbiBoYW5kbGUoKVxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoIFwiLlwiICk7XG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xuXHRcdFx0bmFtZXNwYWNlcy5zb3J0KCk7XG5cdFx0fVxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZiggXCI6XCIgKSA8IDAgJiYgXCJvblwiICsgdHlwZTtcblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhIGpRdWVyeS5FdmVudCBvYmplY3QsIE9iamVjdCwgb3IganVzdCBhbiBldmVudCB0eXBlIHN0cmluZ1xuXHRcdGV2ZW50ID0gZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0ZXZlbnQgOlxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCggdHlwZSwgdHlwZW9mIGV2ZW50ID09PSBcIm9iamVjdFwiICYmIGV2ZW50ICk7XG5cblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXG5cdFx0ZXZlbnQuaXNUcmlnZ2VyID0gb25seUhhbmRsZXJzID8gMiA6IDM7XG5cdFx0ZXZlbnQubmFtZXNwYWNlID0gbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApO1xuXHRcdGV2ZW50LnJuYW1lc3BhY2UgPSBldmVudC5uYW1lc3BhY2UgP1xuXHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICkgOlxuXHRcdFx0bnVsbDtcblxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxuXHRcdGV2ZW50LnJlc3VsdCA9IHVuZGVmaW5lZDtcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xuXHRcdH1cblxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3Rcblx0XHRkYXRhID0gZGF0YSA9PSBudWxsID9cblx0XHRcdFsgZXZlbnQgXSA6XG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcblxuXHRcdC8vIEFsbG93IHNwZWNpYWwgZXZlbnRzIHRvIGRyYXcgb3V0c2lkZSB0aGUgbGluZXNcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgc3BlY2lhbC50cmlnZ2VyICYmIHNwZWNpYWwudHJpZ2dlci5hcHBseSggZWxlbSwgZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgZXZlbnQgcHJvcGFnYXRpb24gcGF0aCBpbiBhZHZhbmNlLCBwZXIgVzNDIGV2ZW50cyBzcGVjICgjOTk1MSlcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhc3BlY2lhbC5ub0J1YmJsZSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGxhc3RFbGVtZW50ID0gY3VyO1xuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IChcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IE9iamVjdC5jcmVhdGUoIG51bGwgKVxuXHRcdFx0XHQpWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIHRoZSBldmVudC5cblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxuXHRcdFx0XHRpZiAoIG9udHlwZSAmJiBpc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvbid0IHJlLXRyaWdnZXIgYW4gb25GT08gZXZlbnQgd2hlbiB3ZSBjYWxsIGl0cyBGT08oKSBtZXRob2Rcblx0XHRcdFx0XHR0bXAgPSBlbGVtWyBvbnR5cGUgXTtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSBudWxsO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZXZlbnQgcmUtdHJpZ2dlcmluZyBvZiB0aGUgc2FtZSBldmVudCwgc2luY2Ugd2UgYWxyZWFkeSBidWJibGVkIGl0IGFib3ZlXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XG5cblx0XHRcdFx0XHRpZiAoIGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRcdFx0XHRsYXN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBzdG9wUHJvcGFnYXRpb25DYWxsYmFjayApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlcmVkID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XG5cdFx0XHRcdFx0XHRlbGVtWyBvbnR5cGUgXSA9IHRtcDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xuXHR9LFxuXG5cdC8vIFBpZ2d5YmFjayBvbiBhIGRvbm9yIGV2ZW50IHRvIHNpbXVsYXRlIGEgZGlmZmVyZW50IG9uZVxuXHQvLyBVc2VkIG9ubHkgZm9yIGBmb2N1cyhpbiB8IG91dClgIGV2ZW50c1xuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50ICkge1xuXHRcdHZhciBlID0galF1ZXJ5LmV4dGVuZChcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoKSxcblx0XHRcdGV2ZW50LFxuXHRcdFx0e1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZVxuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggZSwgbnVsbCwgZWxlbSApO1xuXHR9XG5cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCB0eXBlLCBkYXRhICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIHRoaXMgKTtcblx0XHR9ICk7XG5cdH0sXG5cdHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXTtcblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmV2ZW50LnRyaWdnZXIoIHR5cGUsIGRhdGEsIGVsZW0sIHRydWUgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG4vLyBTdXBwb3J0OiBGaXJlZm94IDw9NDRcbi8vIEZpcmVmb3ggZG9lc24ndCBoYXZlIGZvY3VzKGluIHwgb3V0KSBldmVudHNcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njg3Nzg3XG4vL1xuLy8gU3VwcG9ydDogQ2hyb21lIDw9NDggLSA0OSwgU2FmYXJpIDw9OS4wIC0gOS4xXG4vLyBmb2N1cyhpbiB8IG91dCkgZXZlbnRzIGZpcmUgYWZ0ZXIgZm9jdXMgJiBibHVyIGV2ZW50cyxcbi8vIHdoaWNoIGlzIHNwZWMgdmlvbGF0aW9uIC0gaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtZm9jdXNldmVudC1ldmVudC1vcmRlclxuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NDk4NTdcbmlmICggIXN1cHBvcnQuZm9jdXNpbiApIHtcblx0alF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApICk7XG5cdFx0fTtcblxuXHRcdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBmaXggXSA9IHtcblx0XHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBIYW5kbGU6IHJlZ3VsYXIgbm9kZXMgKHZpYSBgdGhpcy5vd25lckRvY3VtZW50YCksIHdpbmRvd1xuXHRcdFx0XHQvLyAodmlhIGB0aGlzLmRvY3VtZW50YCkgJiBkb2N1bWVudCAodmlhIGB0aGlzYCkuXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcy5kb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgKCBhdHRhY2hlcyB8fCAwICkgKyAxICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSB7IGd1aWQ6IERhdGUubm93KCkgfTtcblxudmFyIHJxdWVyeSA9ICggL1xcPy8gKTtcblxuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHlcblx0Ly8gSUUgdGhyb3dzIG9uIHBhcnNlRnJvbVN0cmluZyB3aXRoIGludmFsaWQgaW5wdXQuXG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggQXJyYXkuaXNBcnJheSggb2JqICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cblx0XHRqUXVlcnkuZWFjaCggb2JqLCBmdW5jdGlvbiggaSwgdiApIHtcblx0XHRcdGlmICggdHJhZGl0aW9uYWwgfHwgcmJyYWNrZXQudGVzdCggcHJlZml4ICkgKSB7XG5cblx0XHRcdFx0Ly8gVHJlYXQgZWFjaCBhcnJheSBpdGVtIGFzIGEgc2NhbGFyLlxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEl0ZW0gaXMgbm9uLXNjYWxhciAoYXJyYXkgb3Igb2JqZWN0KSwgZW5jb2RlIGl0cyBudW1lcmljIGluZGV4LlxuXHRcdFx0XHRidWlsZFBhcmFtcyhcblx0XHRcdFx0XHRwcmVmaXggKyBcIltcIiArICggdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdiAhPSBudWxsID8gaSA6IFwiXCIgKSArIFwiXVwiLFxuXHRcdFx0XHRcdHYsXG5cdFx0XHRcdFx0dHJhZGl0aW9uYWwsXG5cdFx0XHRcdFx0YWRkXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXG5cdH0gZWxzZSBpZiAoICF0cmFkaXRpb25hbCAmJiB0b1R5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlT3JGdW5jdGlvbiApIHtcblxuXHRcdFx0Ly8gSWYgdmFsdWUgaXMgYSBmdW5jdGlvbiwgaW52b2tlIGl0IGFuZCB1c2UgaXRzIHJldHVybiB2YWx1ZVxuXHRcdFx0dmFyIHZhbHVlID0gaXNGdW5jdGlvbiggdmFsdWVPckZ1bmN0aW9uICkgP1xuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb24oKSA6XG5cdFx0XHRcdHZhbHVlT3JGdW5jdGlvbjtcblxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArXG5cdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSApO1xuXHRcdH07XG5cblx0aWYgKCBhID09IG51bGwgKSB7XG5cdFx0cmV0dXJuIFwiXCI7XG5cdH1cblxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XG5cblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcblx0XHRqUXVlcnkuZWFjaCggYSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRhZGQoIHRoaXMubmFtZSwgdGhpcy52YWx1ZSApO1xuXHRcdH0gKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcblx0XHQvLyBkaWQgaXQpLCBvdGhlcndpc2UgZW5jb2RlIHBhcmFtcyByZWN1cnNpdmVseS5cblx0XHRmb3IgKCBwcmVmaXggaW4gYSApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSByZXN1bHRpbmcgc2VyaWFsaXphdGlvblxuXHRyZXR1cm4gcy5qb2luKCBcIiZcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBfaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UuZ3VpZCsrICkgK1xuXHRcdFx0XHRcdHVuY2FjaGVkO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQdXQgaGFzaCBhbmQgYW50aS1jYWNoZSBvbiB0aGUgVVJMIHRoYXQgd2lsbCBiZSByZXF1ZXN0ZWQgKGdoLTE3MzIpXG5cdFx0XHRzLnVybCA9IGNhY2hlVVJMICsgdW5jYWNoZWQ7XG5cblx0XHQvLyBDaGFuZ2UgJyUyMCcgdG8gJysnIGlmIHRoaXMgaXMgZW5jb2RlZCBmb3JtIGJvZHkgY29udGVudCAoZ2gtMjY1OClcblx0XHR9IGVsc2UgaWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJlxuXHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgKSB7XG5cdFx0XHRzLmRhdGEgPSBzLmRhdGEucmVwbGFjZSggcjIwLCBcIitcIiApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0aWYgKCBzLmlmTW9kaWZpZWQgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBjb3JyZWN0IGhlYWRlciwgaWYgZGF0YSBpcyBiZWluZyBzZW50XG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5oYXNDb250ZW50ICYmIHMuY29udGVudFR5cGUgIT09IGZhbHNlIHx8IG9wdGlvbnMuY29udGVudFR5cGUgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxuXHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoXG5cdFx0XHRcIkFjY2VwdFwiLFxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSA/XG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdICtcblx0XHRcdFx0XHQoIHMuZGF0YVR5cGVzWyAwIF0gIT09IFwiKlwiID8gXCIsIFwiICsgYWxsVHlwZXMgKyBcIjsgcT0wLjAxXCIgOiBcIlwiICkgOlxuXHRcdFx0XHRzLmFjY2VwdHNbIFwiKlwiIF1cblx0XHQpO1xuXG5cdFx0Ly8gQ2hlY2sgZm9yIGhlYWRlcnMgb3B0aW9uXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBzLmhlYWRlcnNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEFsbG93IGN1c3RvbSBoZWFkZXJzL21pbWV0eXBlcyBhbmQgZWFybHkgYWJvcnRcblx0XHRpZiAoIHMuYmVmb3JlU2VuZCAmJlxuXHRcdFx0KCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBjb21wbGV0ZWQgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGNvbXBsZXRlRGVmZXJyZWQuYWRkKCBzLmNvbXBsZXRlICk7XG5cdFx0anFYSFIuZG9uZSggcy5zdWNjZXNzICk7XG5cdFx0anFYSFIuZmFpbCggcy5lcnJvciApO1xuXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxuXHRcdHRyYW5zcG9ydCA9IGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XG5cdFx0aWYgKCAhdHJhbnNwb3J0ICkge1xuXHRcdFx0ZG9uZSggLTEsIFwiTm8gVHJhbnNwb3J0XCIgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IDE7XG5cblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggXCJhamF4U2VuZFwiLCBbIGpxWEhSLCBzIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYWpheFNlbmQsIHN0b3AgdGhlcmVcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSBmYWxzZTtcblx0XHRcdFx0dHJhbnNwb3J0LnNlbmQoIHJlcXVlc3RIZWFkZXJzLCBkb25lICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBSZXRocm93IHBvc3QtY29tcGxldGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBQcm9wYWdhdGUgb3RoZXJzIGFzIHJlc3VsdHNcblx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBJZ25vcmUgcmVwZWF0IGludm9jYXRpb25zXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xuXHRcdFx0aWYgKCB0aW1lb3V0VGltZXIgKSB7XG5cdFx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxuXHRcdFx0Ly8gKG5vIG1hdHRlciBob3cgbG9uZyB0aGUganFYSFIgb2JqZWN0IHdpbGwgYmUgdXNlZClcblx0XHRcdHRyYW5zcG9ydCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0Ly8gQ2FjaGUgcmVzcG9uc2UgaGVhZGVyc1xuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nID0gaGVhZGVycyB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTZXQgcmVhZHlTdGF0ZVxuXHRcdFx0anFYSFIucmVhZHlTdGF0ZSA9IHN0YXR1cyA+IDAgPyA0IDogMDtcblxuXHRcdFx0Ly8gRGV0ZXJtaW5lIGlmIHN1Y2Nlc3NmdWxcblx0XHRcdGlzU3VjY2VzcyA9IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0O1xuXG5cdFx0XHQvLyBHZXQgcmVzcG9uc2UgZGF0YVxuXHRcdFx0aWYgKCByZXNwb25zZXMgKSB7XG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBVc2UgYSBub29wIGNvbnZlcnRlciBmb3IgbWlzc2luZyBzY3JpcHRcblx0XHRcdGlmICggIWlzU3VjY2VzcyAmJiBqUXVlcnkuaW5BcnJheSggXCJzY3JpcHRcIiwgcy5kYXRhVHlwZXMgKSA+IC0xICkge1xuXHRcdFx0XHRzLmNvbnZlcnRlcnNbIFwidGV4dCBzY3JpcHRcIiBdID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggX2ksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHR2YXIgaTtcblx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XG5cdFx0aWYgKCBpLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCIgKSB7XG5cdFx0XHRzLmNvbnRlbnRUeXBlID0gcy5oZWFkZXJzWyBpIF0gfHwgXCJcIjtcblx0XHR9XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zLCBkb2MgKSB7XG5cdHJldHVybiBqUXVlcnkuYWpheCgge1xuXHRcdHVybDogdXJsLFxuXG5cdFx0Ly8gTWFrZSB0aGlzIGV4cGxpY2l0LCBzaW5jZSB1c2VyIGNhbiBvdmVycmlkZSB0aGlzIHRocm91Z2ggYWpheFNldHVwICgjMTEyNjQpXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcblx0XHRjYWNoZTogdHJ1ZSxcblx0XHRhc3luYzogZmFsc2UsXG5cdFx0Z2xvYmFsOiBmYWxzZSxcblxuXHRcdC8vIE9ubHkgZXZhbHVhdGUgdGhlIHJlc3BvbnNlIGlmIGl0IGlzIHN1Y2Nlc3NmdWwgKGdoLTQxMjYpXG5cdFx0Ly8gZGF0YUZpbHRlciBpcyBub3QgaW52b2tlZCBmb3IgZmFpbHVyZSByZXNwb25zZXMsIHNvIHVzaW5nIGl0IGluc3RlYWRcblx0XHQvLyBvZiB0aGUgZGVmYXVsdCBjb252ZXJ0ZXIgaXMga2x1ZGd5IGJ1dCBpdCB3b3Jrcy5cblx0XHRjb252ZXJ0ZXJzOiB7XG5cdFx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCkge31cblx0XHR9LFxuXHRcdGRhdGFGaWx0ZXI6IGZ1bmN0aW9uKCByZXNwb25zZSApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCByZXNwb25zZSwgb3B0aW9ucywgZG9jICk7XG5cdFx0fVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0XHRodG1sID0gaHRtbC5jYWxsKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcElubmVyKCBodG1sLmNhbGwoIHRoaXMsIGkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XG5cblx0XHRcdGlmICggY29udGVudHMubGVuZ3RoICkge1xuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciBodG1sSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIGh0bWwgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbElzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dGhpcy5wYXJlbnQoIHNlbGVjdG9yICkubm90KCBcImJvZHlcIiApLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLnBzZXVkb3MuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIucHNldWRvcy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhISggZWxlbS5vZmZzZXRXaWR0aCB8fCBlbGVtLm9mZnNldEhlaWdodCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICk7XG59O1xuXG5cblxuXG5qUXVlcnkuYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uKCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG5cdH0gY2F0Y2ggKCBlICkge31cbn07XG5cbnZhciB4aHJTdWNjZXNzU3RhdHVzID0ge1xuXG5cdFx0Ly8gRmlsZSBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyBjb2RlIDAsIGFzc3VtZSAyMDBcblx0XHQwOiAyMDAsXG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub250aW1lb3V0ID1cblx0XHRcdFx0XHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuXG5cdFx0XHRcdFx0XHRcdGlmICggdHlwZSA9PT0gXCJhYm9ydFwiICkge1xuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImVycm9yXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdC8vIE9uIGEgbWFudWFsIG5hdGl2ZSBhYm9ydCwgSUU5IHRocm93c1xuXHRcdFx0XHRcdFx0XHRcdC8vIGVycm9ycyBvbiBhbnkgcHJvcGVydHkgYWNjZXNzIHRoYXQgaXMgbm90IHJlYWR5U3RhdGVcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiB4aHIuc3RhdHVzICE9PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIDAsIFwiZXJyb3JcIiApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBGaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHJTdWNjZXNzU3RhdHVzWyB4aHIuc3RhdHVzIF0gfHwgeGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0LFxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSUU5IGhhcyBubyBYSFIyIGJ1dCB0aHJvd3Mgb24gYmluYXJ5ICh0cmFjLTExNDI2KVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yIFhIUjIgbm9uLXRleHQsIGxldCB0aGUgY2FsbGVyIGhhbmRsZSBpdCAoZ2gtMjQ5OClcblx0XHRcdFx0XHRcdFx0XHRcdCggeGhyLnJlc3BvbnNlVHlwZSB8fCBcInRleHRcIiApICE9PSBcInRleHRcIiAgfHxcblx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiB4aHIucmVzcG9uc2VUZXh0ICE9PSBcInN0cmluZ1wiID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0eyBiaW5hcnk6IHhoci5yZXNwb25zZSB9IDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0eyB0ZXh0OiB4aHIucmVzcG9uc2VUZXh0IH0sXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcblx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblxuXHRcdFx0XHQvLyBMaXN0ZW4gdG8gZXZlbnRzXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xuXHRcdFx0XHRlcnJvckNhbGxiYWNrID0geGhyLm9uZXJyb3IgPSB4aHIub250aW1lb3V0ID0gY2FsbGJhY2soIFwiZXJyb3JcIiApO1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDkgb25seVxuXHRcdFx0XHQvLyBVc2Ugb25yZWFkeXN0YXRlY2hhbmdlIHRvIHJlcGxhY2Ugb25hYm9ydFxuXHRcdFx0XHQvLyB0byBoYW5kbGUgdW5jYXVnaHQgYWJvcnRzXG5cdFx0XHRcdGlmICggeGhyLm9uYWJvcnQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR4aHIub25hYm9ydCA9IGVycm9yQ2FsbGJhY2s7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBDaGVjayByZWFkeVN0YXRlIGJlZm9yZSB0aW1lb3V0IGFzIGl0IGNoYW5nZXNcblx0XHRcdFx0XHRcdGlmICggeGhyLnJlYWR5U3RhdGUgPT09IDQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQWxsb3cgb25lcnJvciB0byBiZSBjYWxsZWQgZmlyc3QsXG5cdFx0XHRcdFx0XHRcdC8vIGJ1dCB0aGF0IHdpbGwgbm90IGhhbmRsZSBhIG5hdGl2ZSBhYm9ydFxuXHRcdFx0XHRcdFx0XHQvLyBBbHNvLCBzYXZlIGVycm9yQ2FsbGJhY2sgdG8gYSB2YXJpYWJsZVxuXHRcdFx0XHRcdFx0XHQvLyBhcyB4aHIub25lcnJvciBjYW5ub3QgYmUgYWNjZXNzZWRcblx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvckNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENyZWF0ZSB0aGUgYWJvcnQgY2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayggXCJhYm9ydFwiICk7XG5cblx0XHRcdFx0dHJ5IHtcblxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcblx0XHRcdFx0XHR4aHIuc2VuZCggb3B0aW9ucy5oYXNDb250ZW50ICYmIG9wdGlvbnMuZGF0YSB8fCBudWxsICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdFx0Ly8gIzE0NjgzOiBPbmx5IHJldGhyb3cgaWYgdGhpcyBoYXNuJ3QgYmVlbiBub3RpZmllZCBhcyBhbiBlcnJvciB5ZXRcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG4vLyBQcmV2ZW50IGF1dG8tZXhlY3V0aW9uIG9mIHNjcmlwdHMgd2hlbiBubyBleHBsaWNpdCBkYXRhVHlwZSB3YXMgcHJvdmlkZWQgKFNlZSBnaC0yNDMyKVxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy5jb250ZW50cy5zY3JpcHQgPSBmYWxzZTtcblx0fVxufSApO1xuXG4vLyBJbnN0YWxsIHNjcmlwdCBkYXRhVHlwZVxualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRhY2NlcHRzOiB7XG5cdFx0c2NyaXB0OiBcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgXCIgK1xuXHRcdFx0XCJhcHBsaWNhdGlvbi9lY21hc2NyaXB0LCBhcHBsaWNhdGlvbi94LWVjbWFzY3JpcHRcIlxuXHR9LFxuXHRjb250ZW50czoge1xuXHRcdHNjcmlwdDogL1xcYig/OmphdmF8ZWNtYSlzY3JpcHRcXGIvXG5cdH0sXG5cdGNvbnZlcnRlcnM6IHtcblx0XHRcInRleHQgc2NyaXB0XCI6IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIHRleHQgKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHMuY2FjaGUgPSBmYWxzZTtcblx0fVxuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cy50eXBlID0gXCJHRVRcIjtcblx0fVxufSApO1xuXG4vLyBCaW5kIHNjcmlwdCB0YWcgaGFjayB0cmFuc3BvcnRcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIG9yIGZvcmNlZC1ieS1hdHRycyByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gfHwgcy5zY3JpcHRBdHRycyApIHtcblx0XHR2YXIgc2NyaXB0LCBjYWxsYmFjaztcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIF8sIGNvbXBsZXRlICkge1xuXHRcdFx0XHRzY3JpcHQgPSBqUXVlcnkoIFwiPHNjcmlwdD5cIiApXG5cdFx0XHRcdFx0LmF0dHIoIHMuc2NyaXB0QXR0cnMgfHwge30gKVxuXHRcdFx0XHRcdC5wcm9wKCB7IGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCwgc3JjOiBzLnVybCB9IClcblx0XHRcdFx0XHQub24oIFwibG9hZCBlcnJvclwiLCBjYWxsYmFjayA9IGZ1bmN0aW9uKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayA9IG51bGw7XG5cdFx0XHRcdFx0XHRpZiAoIGV2dCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIFVzZSBuYXRpdmUgRE9NIG1hbmlwdWxhdGlvbiB0byBhdm9pZCBvdXIgZG9tTWFuaXAgQUpBWCB0cmlja2VyeVxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHRbIDAgXSApO1xuXHRcdFx0fSxcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRjYWxsYmFjaygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fVxufSApO1xuXG5cblxuXG52YXIgb2xkQ2FsbGJhY2tzID0gW10sXG5cdHJqc29ucCA9IC8oPSlcXD8oPz0mfCQpfFxcP1xcPy87XG5cbi8vIERlZmF1bHQganNvbnAgc2V0dGluZ3NcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0anNvbnA6IFwiY2FsbGJhY2tcIixcblx0anNvbnBDYWxsYmFjazogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UuZ3VpZCsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMudG9wID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHRwcm9wcy50b3AgKz0gXCJweFwiO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMubGVmdCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cHJvcHMubGVmdCArPSBcInB4XCI7XG5cdFx0XHR9XG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHQvLyBvZmZzZXQoKSByZWxhdGVzIGFuIGVsZW1lbnQncyBib3JkZXIgYm94IHRvIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b2Zmc2V0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHRcdC8vIFByZXNlcnZlIGNoYWluaW5nIGZvciBzZXR0ZXJcblx0XHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0dGhpcyA6XG5cdFx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5Lm9mZnNldC5zZXRPZmZzZXQoIHRoaXMsIG9wdGlvbnMsIGkgKTtcblx0XHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHZhciByZWN0LCB3aW4sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gemVyb3MgZm9yIGRpc2Nvbm5lY3RlZCBhbmQgaGlkZGVuIChkaXNwbGF5OiBub25lKSBlbGVtZW50cyAoZ2gtMjMxMClcblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0XHQvLyBSdW5uaW5nIGdldEJvdW5kaW5nQ2xpZW50UmVjdCBvbiBhXG5cdFx0Ly8gZGlzY29ubmVjdGVkIG5vZGUgaW4gSUUgdGhyb3dzIGFuIGVycm9yXG5cdFx0aWYgKCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiB7IHRvcDogMCwgbGVmdDogMCB9O1xuXHRcdH1cblxuXHRcdC8vIEdldCBkb2N1bWVudC1yZWxhdGl2ZSBwb3NpdGlvbiBieSBhZGRpbmcgdmlld3BvcnQgc2Nyb2xsIHRvIHZpZXdwb3J0LXJlbGF0aXZlIGdCQ1Jcblx0XHRyZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcmVjdC50b3AgKyB3aW4ucGFnZVlPZmZzZXQsXG5cdFx0XHRsZWZ0OiByZWN0LmxlZnQgKyB3aW4ucGFnZVhPZmZzZXRcblx0XHR9O1xuXHR9LFxuXG5cdC8vIHBvc2l0aW9uKCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgbWFyZ2luIGJveCB0byBpdHMgb2Zmc2V0IHBhcmVudCdzIHBhZGRpbmcgYm94XG5cdC8vIFRoaXMgY29ycmVzcG9uZHMgdG8gdGhlIGJlaGF2aW9yIG9mIENTUyBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCwgZG9jLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdHBhcmVudE9mZnNldCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cblx0XHQvLyBwb3NpdGlvbjpmaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gdGhlIHZpZXdwb3J0LCB3aGljaCBpdHNlbGYgYWx3YXlzIGhhcyB6ZXJvIG9mZnNldFxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcblxuXHRcdFx0Ly8gQXNzdW1lIHBvc2l0aW9uOmZpeGVkIGltcGxpZXMgYXZhaWxhYmlsaXR5IG9mIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB0aGUgKnJlYWwqIG9mZnNldCBwYXJlbnQsIHdoaWNoIGNhbiBiZSB0aGUgZG9jdW1lbnQgb3IgaXRzIHJvb3QgZWxlbWVudFxuXHRcdFx0Ly8gd2hlbiBhIHN0YXRpY2FsbHkgcG9zaXRpb25lZCBlbGVtZW50IGlzIGlkZW50aWZpZWRcblx0XHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudDtcblx0XHRcdG9mZnNldFBhcmVudCA9IGVsZW0ub2Zmc2V0UGFyZW50IHx8IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJlxuXHRcdFx0XHQoIG9mZnNldFBhcmVudCA9PT0gZG9jLmJvZHkgfHwgb2Zmc2V0UGFyZW50ID09PSBkb2MuZG9jdW1lbnRFbGVtZW50ICkgJiZcblx0XHRcdFx0alF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcInBvc2l0aW9uXCIgKSA9PT0gXCJzdGF0aWNcIiApIHtcblxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGlmICggb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudCAhPT0gZWxlbSAmJiBvZmZzZXRQYXJlbnQubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gSW5jb3Jwb3JhdGUgYm9yZGVycyBpbnRvIGl0cyBvZmZzZXQsIHNpbmNlIHRoZXkgYXJlIG91dHNpZGUgaXRzIGNvbnRlbnQgb3JpZ2luXG5cdFx0XHRcdHBhcmVudE9mZnNldCA9IGpRdWVyeSggb2Zmc2V0UGFyZW50ICkub2Zmc2V0KCk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC50b3AgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcblx0XHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50LCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gU3VidHJhY3QgcGFyZW50IG9mZnNldHMgYW5kIGVsZW1lbnQgbWFyZ2luc1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxuXHRcdFx0bGVmdDogb2Zmc2V0LmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luTGVmdFwiLCB0cnVlIClcblx0XHR9O1xuXHR9LFxuXG5cdC8vIFRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIGRvY3VtZW50RWxlbWVudCBpbiB0aGUgZm9sbG93aW5nIGNhc2VzOlxuXHQvLyAxKSBGb3IgdGhlIGVsZW1lbnQgaW5zaWRlIHRoZSBpZnJhbWUgd2l0aG91dCBvZmZzZXRQYXJlbnQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuXG5cdC8vICAgIGRvY3VtZW50RWxlbWVudCBvZiB0aGUgcGFyZW50IHdpbmRvd1xuXHQvLyAyKSBGb3IgdGhlIGhpZGRlbiBvciBkZXRhY2hlZCBlbGVtZW50XG5cdC8vIDMpIEZvciBib2R5IG9yIGh0bWwgZWxlbWVudCwgaS5lLiBpbiBjYXNlIG9mIHRoZSBodG1sIG5vZGUgLSBpdCB3aWxsIHJldHVybiBpdHNlbGZcblx0Ly9cblx0Ly8gYnV0IHRob3NlIGV4Y2VwdGlvbnMgd2VyZSBuZXZlciBwcmVzZW50ZWQgYXMgYSByZWFsIGxpZmUgdXNlLWNhc2VzXG5cdC8vIGFuZCBtaWdodCBiZSBjb25zaWRlcmVkIGFzIG1vcmUgcHJlZmVyYWJsZSByZXN1bHRzLlxuXHQvL1xuXHQvLyBUaGlzIGxvZ2ljLCBob3dldmVyLCBpcyBub3QgZ3VhcmFudGVlZCBhbmQgY2FuIGNoYW5nZSBhdCBhbnkgcG9pbnQgaW4gdGhlIGZ1dHVyZVxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQ7XG5cblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZG9jdW1lbnRFbGVtZW50O1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG4vLyBDcmVhdGUgc2Nyb2xsTGVmdCBhbmQgc2Nyb2xsVG9wIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcblx0dmFyIHRvcCA9IFwicGFnZVlPZmZzZXRcIiA9PT0gcHJvcDtcblxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbWV0aG9kLCB2YWwgKSB7XG5cblx0XHRcdC8vIENvYWxlc2NlIGRvY3VtZW50cyBhbmQgd2luZG93c1xuXHRcdFx0dmFyIHdpbjtcblx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblx0XHRcdFx0d2luID0gZWxlbTtcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW0uZGVmYXVsdFZpZXc7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggdmFsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiB3aW4gPyB3aW5bIHByb3AgXSA6IGVsZW1bIG1ldGhvZCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHdpbiApIHtcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxuXHRcdFx0XHRcdCF0b3AgPyB2YWwgOiB3aW4ucGFnZVhPZmZzZXQsXG5cdFx0XHRcdFx0dG9wID8gdmFsIDogd2luLnBhZ2VZT2Zmc2V0XG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xuXHRcdFx0fVxuXHRcdH0sIG1ldGhvZCwgdmFsLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH07XG59ICk7XG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA8PTcgLSA5LjEsIENocm9tZSA8PTM3IC0gNDlcbi8vIEFkZCB0aGUgdG9wL2xlZnQgY3NzSG9va3MgdXNpbmcgalF1ZXJ5LmZuLnBvc2l0aW9uXG4vLyBXZWJraXQgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjkwODRcbi8vIEJsaW5rIGJ1ZzogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg5MzQ3XG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBfaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggX2ksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9LFxuXG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblxuXHRcdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdFx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XG5cdFx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XG5cdFx0fTtcblx0fSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHlcbi8vIE1ha2Ugc3VyZSB3ZSB0cmltIEJPTSBhbmQgTkJTUFxudmFyIHJ0cmltID0gL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nO1xuXG4vLyBCaW5kIGEgZnVuY3Rpb24gdG8gYSBjb250ZXh0LCBvcHRpb25hbGx5IHBhcnRpYWxseSBhcHBseWluZyBhbnlcbi8vIGFyZ3VtZW50cy5cbi8vIGpRdWVyeS5wcm94eSBpcyBkZXByZWNhdGVkIHRvIHByb21vdGUgc3RhbmRhcmRzIChzcGVjaWZpY2FsbHkgRnVuY3Rpb24jYmluZClcbi8vIEhvd2V2ZXIsIGl0IGlzIG5vdCBzbGF0ZWQgZm9yIHJlbW92YWwgYW55IHRpbWUgc29vblxualF1ZXJ5LnByb3h5ID0gZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xuXHR2YXIgdG1wLCBhcmdzLCBwcm94eTtcblxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdHRtcCA9IGZuWyBjb250ZXh0IF07XG5cdFx0Y29udGV4dCA9IGZuO1xuXHRcdGZuID0gdG1wO1xuXHR9XG5cblx0Ly8gUXVpY2sgY2hlY2sgdG8gZGV0ZXJtaW5lIGlmIHRhcmdldCBpcyBjYWxsYWJsZSwgaW4gdGhlIHNwZWNcblx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0aWYgKCAhaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cblx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMiApO1xuXHRwcm94eSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHR9O1xuXG5cdC8vIFNldCB0aGUgZ3VpZCBvZiB1bmlxdWUgaGFuZGxlciB0byB0aGUgc2FtZSBvZiBvcmlnaW5hbCBoYW5kbGVyLCBzbyBpdCBjYW4gYmUgcmVtb3ZlZFxuXHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRyZXR1cm4gcHJveHk7XG59O1xuXG5qUXVlcnkuaG9sZFJlYWR5ID0gZnVuY3Rpb24oIGhvbGQgKSB7XG5cdGlmICggaG9sZCApIHtcblx0XHRqUXVlcnkucmVhZHlXYWl0Kys7XG5cdH0gZWxzZSB7XG5cdFx0alF1ZXJ5LnJlYWR5KCB0cnVlICk7XG5cdH1cbn07XG5qUXVlcnkuaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5qUXVlcnkucGFyc2VKU09OID0gSlNPTi5wYXJzZTtcbmpRdWVyeS5ub2RlTmFtZSA9IG5vZGVOYW1lO1xualF1ZXJ5LmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xualF1ZXJ5LmlzV2luZG93ID0gaXNXaW5kb3c7XG5qUXVlcnkuY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xualF1ZXJ5LnR5cGUgPSB0b1R5cGU7XG5cbmpRdWVyeS5ub3cgPSBEYXRlLm5vdztcblxualF1ZXJ5LmlzTnVtZXJpYyA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cblx0Ly8gQXMgb2YgalF1ZXJ5IDMuMCwgaXNOdW1lcmljIGlzIGxpbWl0ZWQgdG9cblx0Ly8gc3RyaW5ncyBhbmQgbnVtYmVycyAocHJpbWl0aXZlcyBvciBvYmplY3RzKVxuXHQvLyB0aGF0IGNhbiBiZSBjb2VyY2VkIHRvIGZpbml0ZSBudW1iZXJzIChnaC0yNjYyKVxuXHR2YXIgdHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblx0cmV0dXJuICggdHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcInN0cmluZ1wiICkgJiZcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChcIlwiKVxuXHRcdC8vIC4uLmJ1dCBtaXNpbnRlcnByZXRzIGxlYWRpbmctbnVtYmVyIHN0cmluZ3MsIHBhcnRpY3VsYXJseSBoZXggbGl0ZXJhbHMgKFwiMHguLi5cIilcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cblx0XHQhaXNOYU4oIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApICk7XG59O1xuXG5qUXVlcnkudHJpbSA9IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRyZXR1cm4gdGV4dCA9PSBudWxsID9cblx0XHRcIlwiIDpcblx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcbn07XG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cblxudmFyXG5cblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF9qUXVlcnkgPSB3aW5kb3cualF1ZXJ5LFxuXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXG5cdF8kID0gd2luZG93LiQ7XG5cbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XG5cdGlmICggd2luZG93LiQgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cuJCA9IF8kO1xuXHR9XG5cblx0aWYgKCBkZWVwICYmIHdpbmRvdy5qUXVlcnkgPT09IGpRdWVyeSApIHtcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnk7XG59O1xuXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluIEFNRFxuLy8gKCM3MTAyI2NvbW1lbnQ6MTAsIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNTU3KVxuLy8gYW5kIENvbW1vbkpTIGZvciBicm93c2VyIGVtdWxhdG9ycyAoIzEzNTY2KVxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdHdpbmRvdy5qUXVlcnkgPSB3aW5kb3cuJCA9IGpRdWVyeTtcbn1cblxuXG5cblxucmV0dXJuIGpRdWVyeTtcbn0gKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jquery/dist/jquery.js\n");

/***/ }),

/***/ "./node_modules/objectFitPolyfill/dist/objectFitPolyfill.min.js":
/*!**********************************************************************!*\
  !*** ./node_modules/objectFitPolyfill/dist/objectFitPolyfill.min.js ***!
  \**********************************************************************/
/***/ (() => {

eval("!function(){\"use strict\";if(\"undefined\"!=typeof window){var t=window.navigator.userAgent.match(/Edge\\/(\\d{2})\\./),e=t?parseInt(t[1],10):null,n=!!e&&(16<=e&&e<=18);if(!(\"objectFit\"in document.documentElement.style!=!1)||n){var o=function(t,e,i){var n,o,l,a,d;if((i=i.split(\" \")).length<2&&(i[1]=i[0]),\"x\"===t)n=i[0],o=i[1],l=\"left\",a=\"right\",d=e.clientWidth;else{if(\"y\"!==t)return;n=i[1],o=i[0],l=\"top\",a=\"bottom\",d=e.clientHeight}if(n!==l&&o!==l){if(n!==a&&o!==a)return\"center\"===n||\"50%\"===n?(e.style[l]=\"50%\",void(e.style[\"margin-\"+l]=d/-2+\"px\")):void(0<=n.indexOf(\"%\")?(n=parseInt(n,10))<50?(e.style[l]=n+\"%\",e.style[\"margin-\"+l]=d*(n/-100)+\"px\"):(n=100-n,e.style[a]=n+\"%\",e.style[\"margin-\"+a]=d*(n/-100)+\"px\"):e.style[l]=n);e.style[a]=\"0\"}else e.style[l]=\"0\"},l=function(t){var e=t.dataset?t.dataset.objectFit:t.getAttribute(\"data-object-fit\"),i=t.dataset?t.dataset.objectPosition:t.getAttribute(\"data-object-position\");e=e||\"cover\",i=i||\"50% 50%\";var n=t.parentNode;return function(t){var e=window.getComputedStyle(t,null),i=e.getPropertyValue(\"position\"),n=e.getPropertyValue(\"overflow\"),o=e.getPropertyValue(\"display\");i&&\"static\"!==i||(t.style.position=\"relative\"),\"hidden\"!==n&&(t.style.overflow=\"hidden\"),o&&\"inline\"!==o||(t.style.display=\"block\"),0===t.clientHeight&&(t.style.height=\"100%\"),-1===t.className.indexOf(\"object-fit-polyfill\")&&(t.className=t.className+\" object-fit-polyfill\")}(n),function(t){var e=window.getComputedStyle(t,null),i={\"max-width\":\"none\",\"max-height\":\"none\",\"min-width\":\"0px\",\"min-height\":\"0px\",top:\"auto\",right:\"auto\",bottom:\"auto\",left:\"auto\",\"margin-top\":\"0px\",\"margin-right\":\"0px\",\"margin-bottom\":\"0px\",\"margin-left\":\"0px\"};for(var n in i)e.getPropertyValue(n)!==i[n]&&(t.style[n]=i[n])}(t),t.style.position=\"absolute\",t.style.width=\"auto\",t.style.height=\"auto\",\"scale-down\"===e&&(e=t.clientWidth<n.clientWidth&&t.clientHeight<n.clientHeight?\"none\":\"contain\"),\"none\"===e?(o(\"x\",t,i),void o(\"y\",t,i)):\"fill\"===e?(t.style.width=\"100%\",t.style.height=\"100%\",o(\"x\",t,i),void o(\"y\",t,i)):(t.style.height=\"100%\",void(\"cover\"===e&&t.clientWidth>n.clientWidth||\"contain\"===e&&t.clientWidth<n.clientWidth?(t.style.top=\"0\",t.style.marginTop=\"0\",o(\"x\",t,i)):(t.style.width=\"100%\",t.style.height=\"auto\",t.style.left=\"0\",t.style.marginLeft=\"0\",o(\"y\",t,i))))},i=function(t){if(void 0===t||t instanceof Event)t=document.querySelectorAll(\"[data-object-fit]\");else if(t&&t.nodeName)t=[t];else{if(\"object\"!=typeof t||!t.length||!t[0].nodeName)return!1;t=t}for(var e=0;e<t.length;e++)if(t[e].nodeName){var i=t[e].nodeName.toLowerCase();if(\"img\"===i){if(n)continue;t[e].complete?l(t[e]):t[e].addEventListener(\"load\",function(){l(this)})}else\"video\"===i?0<t[e].readyState?l(t[e]):t[e].addEventListener(\"loadedmetadata\",function(){l(this)}):l(t[e])}return!0};\"loading\"===document.readyState?document.addEventListener(\"DOMContentLoaded\",i):i(),window.addEventListener(\"resize\",i),window.objectFitPolyfill=i}else window.objectFitPolyfill=function(){return!1}}}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0Rml0UG9seWZpbGwvZGlzdC9vYmplY3RGaXRQb2x5ZmlsbC5taW4uanM/NzgyNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLGFBQWEsK0JBQStCLGtEQUFrRCxFQUFFLHVEQUF1RCwyREFBMkQsc0JBQXNCLGNBQWMsbUdBQW1HLEtBQUssa0JBQWtCLGtEQUFrRCxpQkFBaUIseVJBQXlSLGVBQWUsb0JBQW9CLGVBQWUsa0pBQWtKLDRCQUE0QixtQkFBbUIsbUJBQW1CLHdJQUF3SSxrUkFBa1IsZ0JBQWdCLHlDQUF5QyxpTkFBaU4sK0RBQStELDhpQkFBOGlCLGVBQWUsbUZBQW1GLDRCQUE0QixLQUFLLDBEQUEwRCxJQUFJLFlBQVksV0FBVyxzQkFBc0Isa0NBQWtDLGNBQWMsY0FBYyw4REFBOEQsUUFBUSxFQUFFLDRGQUE0RixRQUFRLFVBQVUsVUFBVSxtSkFBbUoseUNBQXlDLFdBQVciLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvb2JqZWN0Rml0UG9seWZpbGwvZGlzdC9vYmplY3RGaXRQb2x5ZmlsbC5taW4uanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93KXt2YXIgdD13aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGR7Mn0pXFwuLyksZT10P3BhcnNlSW50KHRbMV0sMTApOm51bGwsbj0hIWUmJigxNjw9ZSYmZTw9MTgpO2lmKCEoXCJvYmplY3RGaXRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSE9ITEpfHxuKXt2YXIgbz1mdW5jdGlvbih0LGUsaSl7dmFyIG4sbyxsLGEsZDtpZigoaT1pLnNwbGl0KFwiIFwiKSkubGVuZ3RoPDImJihpWzFdPWlbMF0pLFwieFwiPT09dCluPWlbMF0sbz1pWzFdLGw9XCJsZWZ0XCIsYT1cInJpZ2h0XCIsZD1lLmNsaWVudFdpZHRoO2Vsc2V7aWYoXCJ5XCIhPT10KXJldHVybjtuPWlbMV0sbz1pWzBdLGw9XCJ0b3BcIixhPVwiYm90dG9tXCIsZD1lLmNsaWVudEhlaWdodH1pZihuIT09bCYmbyE9PWwpe2lmKG4hPT1hJiZvIT09YSlyZXR1cm5cImNlbnRlclwiPT09bnx8XCI1MCVcIj09PW4/KGUuc3R5bGVbbF09XCI1MCVcIix2b2lkKGUuc3R5bGVbXCJtYXJnaW4tXCIrbF09ZC8tMitcInB4XCIpKTp2b2lkKDA8PW4uaW5kZXhPZihcIiVcIik/KG49cGFyc2VJbnQobiwxMCkpPDUwPyhlLnN0eWxlW2xdPW4rXCIlXCIsZS5zdHlsZVtcIm1hcmdpbi1cIitsXT1kKihuLy0xMDApK1wicHhcIik6KG49MTAwLW4sZS5zdHlsZVthXT1uK1wiJVwiLGUuc3R5bGVbXCJtYXJnaW4tXCIrYV09ZCoobi8tMTAwKStcInB4XCIpOmUuc3R5bGVbbF09bik7ZS5zdHlsZVthXT1cIjBcIn1lbHNlIGUuc3R5bGVbbF09XCIwXCJ9LGw9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRhc2V0P3QuZGF0YXNldC5vYmplY3RGaXQ6dC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW9iamVjdC1maXRcIiksaT10LmRhdGFzZXQ/dC5kYXRhc2V0Lm9iamVjdFBvc2l0aW9uOnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1vYmplY3QtcG9zaXRpb25cIik7ZT1lfHxcImNvdmVyXCIsaT1pfHxcIjUwJSA1MCVcIjt2YXIgbj10LnBhcmVudE5vZGU7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCksaT1lLmdldFByb3BlcnR5VmFsdWUoXCJwb3NpdGlvblwiKSxuPWUuZ2V0UHJvcGVydHlWYWx1ZShcIm92ZXJmbG93XCIpLG89ZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKTtpJiZcInN0YXRpY1wiIT09aXx8KHQuc3R5bGUucG9zaXRpb249XCJyZWxhdGl2ZVwiKSxcImhpZGRlblwiIT09biYmKHQuc3R5bGUub3ZlcmZsb3c9XCJoaWRkZW5cIiksbyYmXCJpbmxpbmVcIiE9PW98fCh0LnN0eWxlLmRpc3BsYXk9XCJibG9ja1wiKSwwPT09dC5jbGllbnRIZWlnaHQmJih0LnN0eWxlLmhlaWdodD1cIjEwMCVcIiksLTE9PT10LmNsYXNzTmFtZS5pbmRleE9mKFwib2JqZWN0LWZpdC1wb2x5ZmlsbFwiKSYmKHQuY2xhc3NOYW1lPXQuY2xhc3NOYW1lK1wiIG9iamVjdC1maXQtcG9seWZpbGxcIil9KG4pLGZ1bmN0aW9uKHQpe3ZhciBlPXdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCksaT17XCJtYXgtd2lkdGhcIjpcIm5vbmVcIixcIm1heC1oZWlnaHRcIjpcIm5vbmVcIixcIm1pbi13aWR0aFwiOlwiMHB4XCIsXCJtaW4taGVpZ2h0XCI6XCIwcHhcIix0b3A6XCJhdXRvXCIscmlnaHQ6XCJhdXRvXCIsYm90dG9tOlwiYXV0b1wiLGxlZnQ6XCJhdXRvXCIsXCJtYXJnaW4tdG9wXCI6XCIwcHhcIixcIm1hcmdpbi1yaWdodFwiOlwiMHB4XCIsXCJtYXJnaW4tYm90dG9tXCI6XCIwcHhcIixcIm1hcmdpbi1sZWZ0XCI6XCIwcHhcIn07Zm9yKHZhciBuIGluIGkpZS5nZXRQcm9wZXJ0eVZhbHVlKG4pIT09aVtuXSYmKHQuc3R5bGVbbl09aVtuXSl9KHQpLHQuc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiLHQuc3R5bGUud2lkdGg9XCJhdXRvXCIsdC5zdHlsZS5oZWlnaHQ9XCJhdXRvXCIsXCJzY2FsZS1kb3duXCI9PT1lJiYoZT10LmNsaWVudFdpZHRoPG4uY2xpZW50V2lkdGgmJnQuY2xpZW50SGVpZ2h0PG4uY2xpZW50SGVpZ2h0P1wibm9uZVwiOlwiY29udGFpblwiKSxcIm5vbmVcIj09PWU/KG8oXCJ4XCIsdCxpKSx2b2lkIG8oXCJ5XCIsdCxpKSk6XCJmaWxsXCI9PT1lPyh0LnN0eWxlLndpZHRoPVwiMTAwJVwiLHQuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLG8oXCJ4XCIsdCxpKSx2b2lkIG8oXCJ5XCIsdCxpKSk6KHQuc3R5bGUuaGVpZ2h0PVwiMTAwJVwiLHZvaWQoXCJjb3ZlclwiPT09ZSYmdC5jbGllbnRXaWR0aD5uLmNsaWVudFdpZHRofHxcImNvbnRhaW5cIj09PWUmJnQuY2xpZW50V2lkdGg8bi5jbGllbnRXaWR0aD8odC5zdHlsZS50b3A9XCIwXCIsdC5zdHlsZS5tYXJnaW5Ub3A9XCIwXCIsbyhcInhcIix0LGkpKToodC5zdHlsZS53aWR0aD1cIjEwMCVcIix0LnN0eWxlLmhlaWdodD1cImF1dG9cIix0LnN0eWxlLmxlZnQ9XCIwXCIsdC5zdHlsZS5tYXJnaW5MZWZ0PVwiMFwiLG8oXCJ5XCIsdCxpKSkpKX0saT1mdW5jdGlvbih0KXtpZih2b2lkIDA9PT10fHx0IGluc3RhbmNlb2YgRXZlbnQpdD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2RhdGEtb2JqZWN0LWZpdF1cIik7ZWxzZSBpZih0JiZ0Lm5vZGVOYW1lKXQ9W3RdO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIHR8fCF0Lmxlbmd0aHx8IXRbMF0ubm9kZU5hbWUpcmV0dXJuITE7dD10fWZvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKHRbZV0ubm9kZU5hbWUpe3ZhciBpPXRbZV0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcImltZ1wiPT09aSl7aWYobiljb250aW51ZTt0W2VdLmNvbXBsZXRlP2wodFtlXSk6dFtlXS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7bCh0aGlzKX0pfWVsc2VcInZpZGVvXCI9PT1pPzA8dFtlXS5yZWFkeVN0YXRlP2wodFtlXSk6dFtlXS5hZGRFdmVudExpc3RlbmVyKFwibG9hZGVkbWV0YWRhdGFcIixmdW5jdGlvbigpe2wodGhpcyl9KTpsKHRbZV0pfXJldHVybiEwfTtcImxvYWRpbmdcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixpKTppKCksd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIixpKSx3aW5kb3cub2JqZWN0Rml0UG9seWZpbGw9aX1lbHNlIHdpbmRvdy5vYmplY3RGaXRQb2x5ZmlsbD1mdW5jdGlvbigpe3JldHVybiExfX19KCk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/objectFitPolyfill/dist/objectFitPolyfill.min.js\n");

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Popper);\n//# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcz9mMGJkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7QUFNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEIsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsUUFBUTtBQUNuQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkLG1CQUFtQjtBQUNuQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGdCQUFnQjs7QUFFdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcsWUFBWTtBQUN2QixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQix5REFBeUQ7O0FBRTlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CLDJCQUEyQjtBQUMzQixnQ0FBZ0M7O0FBRWhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsTUFBTTtBQUNqQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsY0FBYztBQUM1QjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUIsNEJBQTRCO0FBQzVCOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCLGNBQWMsT0FBTztBQUNyQixhQUFhLFdBQVc7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBbUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFlBQVk7QUFDMUIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxJQUFJO0FBQ0o7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0Qjs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsUUFBUTtBQUNyQixhQUFhLE9BQU87QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZCw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQixpREFBaUQsdUNBQXVDLGtEQUFrRDtBQUMxSSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQSx5REFBeUQscUJBQU07QUFDL0Q7QUFDQTs7QUFFQSxpRUFBZSxNQUFNLEVBQUM7QUFDdEIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTYuMVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgdGltZW91dER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA/IHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZiAoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdGx5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/popper.js/dist/esm/popper.js\n");

/***/ }),

/***/ "./node_modules/popper.js/dist/umd/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/umd/popper.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n(function (global, factory) {\n\t true ? module.exports = factory() :\n\t0;\n}(this, (function () { 'use strict';\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\"  or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\n\nPopper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\nreturn Popper;\n\n})));\n//# sourceMappingURL=popper.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlci5qcz9kMmU0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLENBQzJCO0FBQzVCLENBQUMscUJBQXFCOztBQUV0Qjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGtDQUFrQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsSUFBSTtBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNB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QTtBQUNBLDJCQUEyQjtBQUMzQixpREFBaUQsdUNBQXVDLGtEQUFrRDtBQUMxSSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOzs7QUFHQSx5REFBeUQscUJBQU07QUFDL0Q7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvdW1kL3BvcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTYuMVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5Qb3BwZXIgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgdGltZW91dER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA/IHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZiAoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdGx5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5yZXR1cm4gUG9wcGVyO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/popper.js/dist/umd/popper.js\n");

/***/ }),

/***/ "./node_modules/smoothscroll-for-websites/SmoothScroll.js":
/*!****************************************************************!*\
  !*** ./node_modules/smoothscroll-for-websites/SmoothScroll.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;//\n// SmoothScroll for websites v1.4.10 (Balazs Galambosi)\n// http://www.smoothscroll.net/\n//\n// Licensed under the terms of the MIT license.\n//\n// You may use it in your theme if you credit me. \n// It is also free to use on any individual website.\n//\n// Exception:\n// The only restriction is to not publish any  \n// extension for browsers or native application\n// without getting a written permission first.\n//\n\n(function () {\n  \n// Scroll Variables (tweakable)\nvar defaultOptions = {\n\n    // Scrolling Core\n    frameRate        : 150, // [Hz]\n    animationTime    : 400, // [ms]\n    stepSize         : 100, // [px]\n\n    // Pulse (less tweakable)\n    // ratio of \"tail\" to \"acceleration\"\n    pulseAlgorithm   : true,\n    pulseScale       : 4,\n    pulseNormalize   : 1,\n\n    // Acceleration\n    accelerationDelta : 50,  // 50\n    accelerationMax   : 3,   // 3\n\n    // Keyboard Settings\n    keyboardSupport   : true,  // option\n    arrowScroll       : 50,    // [px]\n\n    // Other\n    fixedBackground   : true, \n    excluded          : ''    \n};\n\nvar options = defaultOptions;\n\n\n// Other Variables\nvar isExcluded = false;\nvar isFrame = false;\nvar direction = { x: 0, y: 0 };\nvar initDone  = false;\nvar root = document.documentElement;\nvar activeElement;\nvar observer;\nvar refreshSize;\nvar deltaBuffer = [];\nvar deltaBufferTimer;\nvar isMac = /^Mac/.test(navigator.platform);\n\nvar key = { left: 37, up: 38, right: 39, down: 40, spacebar: 32, \n            pageup: 33, pagedown: 34, end: 35, home: 36 };\nvar arrowKeys = { 37: 1, 38: 1, 39: 1, 40: 1 };\n\n/***********************************************\n * INITIALIZE\n ***********************************************/\n\n/**\n * Tests if smooth scrolling is allowed. Shuts down everything if not.\n */\nfunction initTest() {\n    if (options.keyboardSupport) {\n        addEvent('keydown', keydown);\n    }\n}\n\n/**\n * Sets up scrolls array, determines if frames are involved.\n */\nfunction init() {\n  \n    if (initDone || !document.body) return;\n\n    initDone = true;\n\n    var body = document.body;\n    var html = document.documentElement;\n    var windowHeight = window.innerHeight; \n    var scrollHeight = body.scrollHeight;\n    \n    // check compat mode for root element\n    root = (document.compatMode.indexOf('CSS') >= 0) ? html : body;\n    activeElement = body;\n    \n    initTest();\n\n    // Checks if this script is running in a frame\n    if (top != self) {\n        isFrame = true;\n    }\n\n    /**\n     * Safari 10 fixed it, Chrome fixed it in v45:\n     * This fixes a bug where the areas left and right to \n     * the content does not trigger the onmousewheel event\n     * on some pages. e.g.: html, body { height: 100% }\n     */\n    else if (isOldSafari &&\n             scrollHeight > windowHeight &&\n            (body.offsetHeight <= windowHeight || \n             html.offsetHeight <= windowHeight)) {\n\n        var fullPageElem = document.createElement('div');\n        fullPageElem.style.cssText = 'position:absolute; z-index:-10000; ' +\n                                     'top:0; left:0; right:0; height:' + \n                                      root.scrollHeight + 'px';\n        document.body.appendChild(fullPageElem);\n        \n        // DOM changed (throttled) to fix height\n        var pendingRefresh;\n        refreshSize = function () {\n            if (pendingRefresh) return; // could also be: clearTimeout(pendingRefresh);\n            pendingRefresh = setTimeout(function () {\n                if (isExcluded) return; // could be running after cleanup\n                fullPageElem.style.height = '0';\n                fullPageElem.style.height = root.scrollHeight + 'px';\n                pendingRefresh = null;\n            }, 500); // act rarely to stay fast\n        };\n  \n        setTimeout(refreshSize, 10);\n\n        addEvent('resize', refreshSize);\n\n        // TODO: attributeFilter?\n        var config = {\n            attributes: true, \n            childList: true, \n            characterData: false \n            // subtree: true\n        };\n\n        observer = new MutationObserver(refreshSize);\n        observer.observe(body, config);\n\n        if (root.offsetHeight <= windowHeight) {\n            var clearfix = document.createElement('div');   \n            clearfix.style.clear = 'both';\n            body.appendChild(clearfix);\n        }\n    }\n\n    // disable fixed background\n    if (!options.fixedBackground && !isExcluded) {\n        body.style.backgroundAttachment = 'scroll';\n        html.style.backgroundAttachment = 'scroll';\n    }\n}\n\n/**\n * Removes event listeners and other traces left on the page.\n */\nfunction cleanup() {\n    observer && observer.disconnect();\n    removeEvent(wheelEvent, wheel);\n    removeEvent('mousedown', mousedown);\n    removeEvent('keydown', keydown);\n    removeEvent('resize', refreshSize);\n    removeEvent('load', init);\n}\n\n\n/************************************************\n * SCROLLING \n ************************************************/\n \nvar que = [];\nvar pending = false;\nvar lastScroll = Date.now();\n\n/**\n * Pushes scroll actions to the scrolling queue.\n */\nfunction scrollArray(elem, left, top) {\n    \n    directionCheck(left, top);\n\n    if (options.accelerationMax != 1) {\n        var now = Date.now();\n        var elapsed = now - lastScroll;\n        if (elapsed < options.accelerationDelta) {\n            var factor = (1 + (50 / elapsed)) / 2;\n            if (factor > 1) {\n                factor = Math.min(factor, options.accelerationMax);\n                left *= factor;\n                top  *= factor;\n            }\n        }\n        lastScroll = Date.now();\n    }          \n    \n    // push a scroll command\n    que.push({\n        x: left, \n        y: top, \n        lastX: (left < 0) ? 0.99 : -0.99,\n        lastY: (top  < 0) ? 0.99 : -0.99, \n        start: Date.now()\n    });\n        \n    // don't act if there's a pending queue\n    if (pending) {\n        return;\n    }  \n\n    var scrollRoot = getScrollRoot();\n    var isWindowScroll = (elem === scrollRoot || elem === document.body);\n    \n    // if we haven't already fixed the behavior, \n    // and it needs fixing for this sesh\n    if (elem.$scrollBehavior == null && isScrollBehaviorSmooth(elem)) {\n        elem.$scrollBehavior = elem.style.scrollBehavior;\n        elem.style.scrollBehavior = 'auto';\n    }\n\n    var step = function (time) {\n        \n        var now = Date.now();\n        var scrollX = 0;\n        var scrollY = 0; \n    \n        for (var i = 0; i < que.length; i++) {\n            \n            var item = que[i];\n            var elapsed  = now - item.start;\n            var finished = (elapsed >= options.animationTime);\n            \n            // scroll position: [0, 1]\n            var position = (finished) ? 1 : elapsed / options.animationTime;\n            \n            // easing [optional]\n            if (options.pulseAlgorithm) {\n                position = pulse(position);\n            }\n            \n            // only need the difference\n            var x = (item.x * position - item.lastX) >> 0;\n            var y = (item.y * position - item.lastY) >> 0;\n            \n            // add this to the total scrolling\n            scrollX += x;\n            scrollY += y;            \n            \n            // update last values\n            item.lastX += x;\n            item.lastY += y;\n        \n            // delete and step back if it's over\n            if (finished) {\n                que.splice(i, 1); i--;\n            }           \n        }\n\n        // scroll left and top\n        if (isWindowScroll) {\n            window.scrollBy(scrollX, scrollY);\n        } \n        else {\n            if (scrollX) elem.scrollLeft += scrollX;\n            if (scrollY) elem.scrollTop  += scrollY;                    \n        }\n        \n        // clean up if there's nothing left to do\n        if (!left && !top) {\n            que = [];\n        }\n        \n        if (que.length) { \n            requestFrame(step, elem, (1000 / options.frameRate + 1)); \n        } else { \n            pending = false;\n            // restore default behavior at the end of scrolling sesh\n            if (elem.$scrollBehavior != null) {\n                elem.style.scrollBehavior = elem.$scrollBehavior;\n                elem.$scrollBehavior = null;\n            }\n        }\n    };\n    \n    // start a new queue of actions\n    requestFrame(step, elem, 0);\n    pending = true;\n}\n\n\n/***********************************************\n * EVENTS\n ***********************************************/\n\n/**\n * Mouse wheel handler.\n * @param {Object} event\n */\nfunction wheel(event) {\n\n    if (!initDone) {\n        init();\n    }\n    \n    var target = event.target;\n\n    // leave early if default action is prevented   \n    // or it's a zooming event with CTRL \n    if (event.defaultPrevented || event.ctrlKey) {\n        return true;\n    }\n    \n    // leave embedded content alone (flash & pdf)\n    if (isNodeName(activeElement, 'embed') || \n       (isNodeName(target, 'embed') && /\\.pdf/i.test(target.src)) ||\n        isNodeName(activeElement, 'object') ||\n        target.shadowRoot) {\n        return true;\n    }\n\n    var deltaX = -event.wheelDeltaX || event.deltaX || 0;\n    var deltaY = -event.wheelDeltaY || event.deltaY || 0;\n    \n    if (isMac) {\n        if (event.wheelDeltaX && isDivisible(event.wheelDeltaX, 120)) {\n            deltaX = -120 * (event.wheelDeltaX / Math.abs(event.wheelDeltaX));\n        }\n        if (event.wheelDeltaY && isDivisible(event.wheelDeltaY, 120)) {\n            deltaY = -120 * (event.wheelDeltaY / Math.abs(event.wheelDeltaY));\n        }\n    }\n    \n    // use wheelDelta if deltaX/Y is not available\n    if (!deltaX && !deltaY) {\n        deltaY = -event.wheelDelta || 0;\n    }\n\n    // line based scrolling (Firefox mostly)\n    if (event.deltaMode === 1) {\n        deltaX *= 40;\n        deltaY *= 40;\n    }\n\n    var overflowing = overflowingAncestor(target);\n\n    // nothing to do if there's no element that's scrollable\n    if (!overflowing) {\n        // except Chrome iframes seem to eat wheel events, which we need to \n        // propagate up, if the iframe has nothing overflowing to scroll\n        if (isFrame && isChrome)  {\n            // change target to iframe element itself for the parent frame\n            Object.defineProperty(event, \"target\", {value: window.frameElement});\n            return parent.wheel(event);\n        }\n        return true;\n    }\n    \n    // check if it's a touchpad scroll that should be ignored\n    if (isTouchpad(deltaY)) {\n        return true;\n    }\n\n    // scale by step size\n    // delta is 120 most of the time\n    // synaptics seems to send 1 sometimes\n    if (Math.abs(deltaX) > 1.2) {\n        deltaX *= options.stepSize / 120;\n    }\n    if (Math.abs(deltaY) > 1.2) {\n        deltaY *= options.stepSize / 120;\n    }\n    \n    scrollArray(overflowing, deltaX, deltaY);\n    event.preventDefault();\n    scheduleClearCache();\n}\n\n/**\n * Keydown event handler.\n * @param {Object} event\n */\nfunction keydown(event) {\n\n    var target   = event.target;\n    var modifier = event.ctrlKey || event.altKey || event.metaKey || \n                  (event.shiftKey && event.keyCode !== key.spacebar);\n    \n    // our own tracked active element could've been removed from the DOM\n    if (!document.body.contains(activeElement)) {\n        activeElement = document.activeElement;\n    }\n\n    // do nothing if user is editing text\n    // or using a modifier key (except shift)\n    // or in a dropdown\n    // or inside interactive elements\n    var inputNodeNames = /^(textarea|select|embed|object)$/i;\n    var buttonTypes = /^(button|submit|radio|checkbox|file|color|image)$/i;\n    if ( event.defaultPrevented ||\n         inputNodeNames.test(target.nodeName) ||\n         isNodeName(target, 'input') && !buttonTypes.test(target.type) ||\n         isNodeName(activeElement, 'video') ||\n         isInsideYoutubeVideo(event) ||\n         target.isContentEditable || \n         modifier ) {\n      return true;\n    }\n\n    // [spacebar] should trigger button press, leave it alone\n    if ((isNodeName(target, 'button') ||\n         isNodeName(target, 'input') && buttonTypes.test(target.type)) &&\n        event.keyCode === key.spacebar) {\n      return true;\n    }\n\n    // [arrwow keys] on radio buttons should be left alone\n    if (isNodeName(target, 'input') && target.type == 'radio' &&\n        arrowKeys[event.keyCode])  {\n      return true;\n    }\n    \n    var shift, x = 0, y = 0;\n    var overflowing = overflowingAncestor(activeElement);\n\n    if (!overflowing) {\n        // Chrome iframes seem to eat key events, which we need to \n        // propagate up, if the iframe has nothing overflowing to scroll\n        return (isFrame && isChrome) ? parent.keydown(event) : true;\n    }\n\n    var clientHeight = overflowing.clientHeight; \n\n    if (overflowing == document.body) {\n        clientHeight = window.innerHeight;\n    }\n\n    switch (event.keyCode) {\n        case key.up:\n            y = -options.arrowScroll;\n            break;\n        case key.down:\n            y = options.arrowScroll;\n            break;         \n        case key.spacebar: // (+ shift)\n            shift = event.shiftKey ? 1 : -1;\n            y = -shift * clientHeight * 0.9;\n            break;\n        case key.pageup:\n            y = -clientHeight * 0.9;\n            break;\n        case key.pagedown:\n            y = clientHeight * 0.9;\n            break;\n        case key.home:\n            if (overflowing == document.body && document.scrollingElement)\n                overflowing = document.scrollingElement;\n            y = -overflowing.scrollTop;\n            break;\n        case key.end:\n            var scroll = overflowing.scrollHeight - overflowing.scrollTop;\n            var scrollRemaining = scroll - clientHeight;\n            y = (scrollRemaining > 0) ? scrollRemaining + 10 : 0;\n            break;\n        case key.left:\n            x = -options.arrowScroll;\n            break;\n        case key.right:\n            x = options.arrowScroll;\n            break;            \n        default:\n            return true; // a key we don't care about\n    }\n\n    scrollArray(overflowing, x, y);\n    event.preventDefault();\n    scheduleClearCache();\n}\n\n/**\n * Mousedown event only for updating activeElement\n */\nfunction mousedown(event) {\n    activeElement = event.target;\n}\n\n\n/***********************************************\n * OVERFLOW\n ***********************************************/\n\nvar uniqueID = (function () {\n    var i = 0;\n    return function (el) {\n        return el.uniqueID || (el.uniqueID = i++);\n    };\n})();\n\nvar cacheX = {}; // cleared out after a scrolling session\nvar cacheY = {}; // cleared out after a scrolling session\nvar clearCacheTimer;\nvar smoothBehaviorForElement = {};\n\n//setInterval(function () { cache = {}; }, 10 * 1000);\n\nfunction scheduleClearCache() {\n    clearTimeout(clearCacheTimer);\n    clearCacheTimer = setInterval(function () { \n        cacheX = cacheY = smoothBehaviorForElement = {}; \n    }, 1*1000);\n}\n\nfunction setCache(elems, overflowing, x) {\n    var cache = x ? cacheX : cacheY;\n    for (var i = elems.length; i--;)\n        cache[uniqueID(elems[i])] = overflowing;\n    return overflowing;\n}\n\nfunction getCache(el, x) {\n    return (x ? cacheX : cacheY)[uniqueID(el)];\n}\n\n//  (body)                (root)\n//         | hidden | visible | scroll |  auto  |\n// hidden  |   no   |    no   |   YES  |   YES  |\n// visible |   no   |   YES   |   YES  |   YES  |\n// scroll  |   no   |   YES   |   YES  |   YES  |\n// auto    |   no   |   YES   |   YES  |   YES  |\n\nfunction overflowingAncestor(el) {\n    var elems = [];\n    var body = document.body;\n    var rootScrollHeight = root.scrollHeight;\n    do {\n        var cached = getCache(el, false);\n        if (cached) {\n            return setCache(elems, cached);\n        }\n        elems.push(el);\n        if (rootScrollHeight === el.scrollHeight) {\n            var topOverflowsNotHidden = overflowNotHidden(root) && overflowNotHidden(body);\n            var isOverflowCSS = topOverflowsNotHidden || overflowAutoOrScroll(root);\n            if (isFrame && isContentOverflowing(root) || \n               !isFrame && isOverflowCSS) {\n                return setCache(elems, getScrollRoot()); \n            }\n        } else if (isContentOverflowing(el) && overflowAutoOrScroll(el)) {\n            return setCache(elems, el);\n        }\n    } while ((el = el.parentElement));\n}\n\nfunction isContentOverflowing(el) {\n    return (el.clientHeight + 10 < el.scrollHeight);\n}\n\n// typically for <body> and <html>\nfunction overflowNotHidden(el) {\n    var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');\n    return (overflow !== 'hidden');\n}\n\n// for all other elements\nfunction overflowAutoOrScroll(el) {\n    var overflow = getComputedStyle(el, '').getPropertyValue('overflow-y');\n    return (overflow === 'scroll' || overflow === 'auto');\n}\n\n// for all other elements\nfunction isScrollBehaviorSmooth(el) {\n    var id = uniqueID(el);\n    if (smoothBehaviorForElement[id] == null) {\n        var scrollBehavior = getComputedStyle(el, '')['scroll-behavior'];\n        smoothBehaviorForElement[id] = ('smooth' == scrollBehavior);\n    }\n    return smoothBehaviorForElement[id];\n}\n\n\n/***********************************************\n * HELPERS\n ***********************************************/\n\nfunction addEvent(type, fn, arg) {\n    window.addEventListener(type, fn, arg || false);\n}\n\nfunction removeEvent(type, fn, arg) {\n    window.removeEventListener(type, fn, arg || false);  \n}\n\nfunction isNodeName(el, tag) {\n    return el && (el.nodeName||'').toLowerCase() === tag.toLowerCase();\n}\n\nfunction directionCheck(x, y) {\n    x = (x > 0) ? 1 : -1;\n    y = (y > 0) ? 1 : -1;\n    if (direction.x !== x || direction.y !== y) {\n        direction.x = x;\n        direction.y = y;\n        que = [];\n        lastScroll = 0;\n    }\n}\n\nif (window.localStorage && localStorage.SS_deltaBuffer) {\n    try { // #46 Safari throws in private browsing for localStorage \n        deltaBuffer = localStorage.SS_deltaBuffer.split(',');\n    } catch (e) { } \n}\n\nfunction isTouchpad(deltaY) {\n    if (!deltaY) return;\n    if (!deltaBuffer.length) {\n        deltaBuffer = [deltaY, deltaY, deltaY];\n    }\n    deltaY = Math.abs(deltaY);\n    deltaBuffer.push(deltaY);\n    deltaBuffer.shift();\n    clearTimeout(deltaBufferTimer);\n    deltaBufferTimer = setTimeout(function () {\n        try { // #46 Safari throws in private browsing for localStorage\n            localStorage.SS_deltaBuffer = deltaBuffer.join(',');\n        } catch (e) { }  \n    }, 1000);\n    var dpiScaledWheelDelta = deltaY > 120 && allDeltasDivisableBy(deltaY); // win64 \n    var tp = !allDeltasDivisableBy(120) && !allDeltasDivisableBy(100) && !dpiScaledWheelDelta;\n    if (deltaY < 50) return true;\n    return tp;\n} \n\nfunction isDivisible(n, divisor) {\n    return (Math.floor(n / divisor) == n / divisor);\n}\n\nfunction allDeltasDivisableBy(divisor) {\n    return (isDivisible(deltaBuffer[0], divisor) &&\n            isDivisible(deltaBuffer[1], divisor) &&\n            isDivisible(deltaBuffer[2], divisor));\n}\n\nfunction isInsideYoutubeVideo(event) {\n    var elem = event.target;\n    var isControl = false;\n    if (document.URL.indexOf ('www.youtube.com/watch') != -1) {\n        do {\n            isControl = (elem.classList && \n                         elem.classList.contains('html5-video-controls'));\n            if (isControl) break;\n        } while ((elem = elem.parentNode));\n    }\n    return isControl;\n}\n\nvar requestFrame = (function () {\n      return (window.requestAnimationFrame       || \n              window.webkitRequestAnimationFrame || \n              window.mozRequestAnimationFrame    ||\n              function (callback, element, delay) {\n                 window.setTimeout(callback, delay || (1000/60));\n             });\n})();\n\nvar MutationObserver = (window.MutationObserver || \n                        window.WebKitMutationObserver ||\n                        window.MozMutationObserver);  \n\nvar getScrollRoot = (function() {\n  var SCROLL_ROOT = document.scrollingElement;\n  return function() {\n    if (!SCROLL_ROOT) {\n      var dummy = document.createElement('div');\n      dummy.style.cssText = 'height:10000px;width:1px;';\n      document.body.appendChild(dummy);\n      var bodyScrollTop  = document.body.scrollTop;\n      var docElScrollTop = document.documentElement.scrollTop;\n      window.scrollBy(0, 3);\n      if (document.body.scrollTop != bodyScrollTop)\n        (SCROLL_ROOT = document.body);\n      else \n        (SCROLL_ROOT = document.documentElement);\n      window.scrollBy(0, -3);\n      document.body.removeChild(dummy);\n    }\n    return SCROLL_ROOT;\n  };\n})();\n\n\n/***********************************************\n * PULSE (by Michael Herf)\n ***********************************************/\n \n/**\n * Viscous fluid with a pulse for part and decay for the rest.\n * - Applies a fixed force over an interval (a damped acceleration), and\n * - Lets the exponential bleed away the velocity over a longer interval\n * - Michael Herf, http://stereopsis.com/stopping/\n */\nfunction pulse_(x) {\n    var val, start, expx;\n    // test\n    x = x * options.pulseScale;\n    if (x < 1) { // acceleartion\n        val = x - (1 - Math.exp(-x));\n    } else {     // tail\n        // the previous animation ended here:\n        start = Math.exp(-1);\n        // simple viscous drag\n        x -= 1;\n        expx = 1 - Math.exp(-x);\n        val = start + (expx * (1 - start));\n    }\n    return val * options.pulseNormalize;\n}\n\nfunction pulse(x) {\n    if (x >= 1) return 1;\n    if (x <= 0) return 0;\n\n    if (options.pulseNormalize == 1) {\n        options.pulseNormalize /= pulse_(1);\n    }\n    return pulse_(x);\n}\n\n\n/***********************************************\n * FIRST RUN\n ***********************************************/\n\nvar userAgent = window.navigator.userAgent;\nvar isEdge    = /Edge/.test(userAgent); // thank you MS\nvar isChrome  = /chrome/i.test(userAgent) && !isEdge; \nvar isSafari  = /safari/i.test(userAgent) && !isEdge; \nvar isMobile  = /mobile/i.test(userAgent);\nvar isIEWin7  = /Windows NT 6.1/i.test(userAgent) && /rv:11/i.test(userAgent);\nvar isOldSafari = isSafari && (/Version\\/8/i.test(userAgent) || /Version\\/9/i.test(userAgent));\nvar isEnabledForBrowser = (isChrome || isSafari || isIEWin7) && !isMobile;\n\nvar supportsPassive = false;\ntry {\n  window.addEventListener(\"test\", null, Object.defineProperty({}, 'passive', {\n    get: function () {\n            supportsPassive = true;\n        } \n    }));\n} catch(e) {}\n\nvar wheelOpt = supportsPassive ? { passive: false } : false;\nvar wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel'; \n\nif (wheelEvent && isEnabledForBrowser) {\n    addEvent(wheelEvent, wheel, wheelOpt);\n    addEvent('mousedown', mousedown);\n    addEvent('load', init);\n}\n\n\n/***********************************************\n * PUBLIC INTERFACE\n ***********************************************/\n\nfunction SmoothScroll(optionsToSet) {\n    for (var key in optionsToSet)\n        if (defaultOptions.hasOwnProperty(key)) \n            options[key] = optionsToSet[key];\n}\nSmoothScroll.destroy = cleanup;\n\nif (window.SmoothScrollOptions) // async API\n    SmoothScroll(window.SmoothScrollOptions);\n\nif (true)\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return SmoothScroll;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc21vb3Roc2Nyb2xsLWZvci13ZWJzaXRlcy9TbW9vdGhTY3JvbGwuanM/NGFmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RSw0Q0FBNEMsUUFBUSxTQUFTO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSyxZQUFZLEU7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTLFlBQVksRTtBQUNyQixLQUFLO0FBQ0wsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLENBQUM7O0FBRUQ7QUFDQTtBQUNBLG9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUssT0FBTztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHFEO0FBQ0EscUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxTO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRUQsa0NBQWtDLGlCQUFpQjtBQUNuRCxxRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSSxJQUEwQztBQUM5QyxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTixLQUFLLEVBR2tDOztBQUV2QyxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1mb3Itd2Vic2l0ZXMvU21vb3RoU2Nyb2xsLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vIFNtb290aFNjcm9sbCBmb3Igd2Vic2l0ZXMgdjEuNC4xMCAoQmFsYXpzIEdhbGFtYm9zaSlcbi8vIGh0dHA6Ly93d3cuc21vb3Roc2Nyb2xsLm5ldC9cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlLlxuLy9cbi8vIFlvdSBtYXkgdXNlIGl0IGluIHlvdXIgdGhlbWUgaWYgeW91IGNyZWRpdCBtZS4gXG4vLyBJdCBpcyBhbHNvIGZyZWUgdG8gdXNlIG9uIGFueSBpbmRpdmlkdWFsIHdlYnNpdGUuXG4vL1xuLy8gRXhjZXB0aW9uOlxuLy8gVGhlIG9ubHkgcmVzdHJpY3Rpb24gaXMgdG8gbm90IHB1Ymxpc2ggYW55ICBcbi8vIGV4dGVuc2lvbiBmb3IgYnJvd3NlcnMgb3IgbmF0aXZlIGFwcGxpY2F0aW9uXG4vLyB3aXRob3V0IGdldHRpbmcgYSB3cml0dGVuIHBlcm1pc3Npb24gZmlyc3QuXG4vL1xuXG4oZnVuY3Rpb24gKCkge1xuICBcbi8vIFNjcm9sbCBWYXJpYWJsZXMgKHR3ZWFrYWJsZSlcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblxuICAgIC8vIFNjcm9sbGluZyBDb3JlXG4gICAgZnJhbWVSYXRlICAgICAgICA6IDE1MCwgLy8gW0h6XVxuICAgIGFuaW1hdGlvblRpbWUgICAgOiA0MDAsIC8vIFttc11cbiAgICBzdGVwU2l6ZSAgICAgICAgIDogMTAwLCAvLyBbcHhdXG5cbiAgICAvLyBQdWxzZSAobGVzcyB0d2Vha2FibGUpXG4gICAgLy8gcmF0aW8gb2YgXCJ0YWlsXCIgdG8gXCJhY2NlbGVyYXRpb25cIlxuICAgIHB1bHNlQWxnb3JpdGhtICAgOiB0cnVlLFxuICAgIHB1bHNlU2NhbGUgICAgICAgOiA0LFxuICAgIHB1bHNlTm9ybWFsaXplICAgOiAxLFxuXG4gICAgLy8gQWNjZWxlcmF0aW9uXG4gICAgYWNjZWxlcmF0aW9uRGVsdGEgOiA1MCwgIC8vIDUwXG4gICAgYWNjZWxlcmF0aW9uTWF4ICAgOiAzLCAgIC8vIDNcblxuICAgIC8vIEtleWJvYXJkIFNldHRpbmdzXG4gICAga2V5Ym9hcmRTdXBwb3J0ICAgOiB0cnVlLCAgLy8gb3B0aW9uXG4gICAgYXJyb3dTY3JvbGwgICAgICAgOiA1MCwgICAgLy8gW3B4XVxuXG4gICAgLy8gT3RoZXJcbiAgICBmaXhlZEJhY2tncm91bmQgICA6IHRydWUsIFxuICAgIGV4Y2x1ZGVkICAgICAgICAgIDogJycgICAgXG59O1xuXG52YXIgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuXG5cbi8vIE90aGVyIFZhcmlhYmxlc1xudmFyIGlzRXhjbHVkZWQgPSBmYWxzZTtcbnZhciBpc0ZyYW1lID0gZmFsc2U7XG52YXIgZGlyZWN0aW9uID0geyB4OiAwLCB5OiAwIH07XG52YXIgaW5pdERvbmUgID0gZmFsc2U7XG52YXIgcm9vdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbnZhciBhY3RpdmVFbGVtZW50O1xudmFyIG9ic2VydmVyO1xudmFyIHJlZnJlc2hTaXplO1xudmFyIGRlbHRhQnVmZmVyID0gW107XG52YXIgZGVsdGFCdWZmZXJUaW1lcjtcbnZhciBpc01hYyA9IC9eTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5cbnZhciBrZXkgPSB7IGxlZnQ6IDM3LCB1cDogMzgsIHJpZ2h0OiAzOSwgZG93bjogNDAsIHNwYWNlYmFyOiAzMiwgXG4gICAgICAgICAgICBwYWdldXA6IDMzLCBwYWdlZG93bjogMzQsIGVuZDogMzUsIGhvbWU6IDM2IH07XG52YXIgYXJyb3dLZXlzID0geyAzNzogMSwgMzg6IDEsIDM5OiAxLCA0MDogMSB9O1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIElOSVRJQUxJWkVcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuLyoqXG4gKiBUZXN0cyBpZiBzbW9vdGggc2Nyb2xsaW5nIGlzIGFsbG93ZWQuIFNodXRzIGRvd24gZXZlcnl0aGluZyBpZiBub3QuXG4gKi9cbmZ1bmN0aW9uIGluaXRUZXN0KCkge1xuICAgIGlmIChvcHRpb25zLmtleWJvYXJkU3VwcG9ydCkge1xuICAgICAgICBhZGRFdmVudCgna2V5ZG93bicsIGtleWRvd24pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXRzIHVwIHNjcm9sbHMgYXJyYXksIGRldGVybWluZXMgaWYgZnJhbWVzIGFyZSBpbnZvbHZlZC5cbiAqL1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgXG4gICAgaWYgKGluaXREb25lIHx8ICFkb2N1bWVudC5ib2R5KSByZXR1cm47XG5cbiAgICBpbml0RG9uZSA9IHRydWU7XG5cbiAgICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gICAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHdpbmRvd0hlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDsgXG4gICAgdmFyIHNjcm9sbEhlaWdodCA9IGJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgIFxuICAgIC8vIGNoZWNrIGNvbXBhdCBtb2RlIGZvciByb290IGVsZW1lbnRcbiAgICByb290ID0gKGRvY3VtZW50LmNvbXBhdE1vZGUuaW5kZXhPZignQ1NTJykgPj0gMCkgPyBodG1sIDogYm9keTtcbiAgICBhY3RpdmVFbGVtZW50ID0gYm9keTtcbiAgICBcbiAgICBpbml0VGVzdCgpO1xuXG4gICAgLy8gQ2hlY2tzIGlmIHRoaXMgc2NyaXB0IGlzIHJ1bm5pbmcgaW4gYSBmcmFtZVxuICAgIGlmICh0b3AgIT0gc2VsZikge1xuICAgICAgICBpc0ZyYW1lID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTYWZhcmkgMTAgZml4ZWQgaXQsIENocm9tZSBmaXhlZCBpdCBpbiB2NDU6XG4gICAgICogVGhpcyBmaXhlcyBhIGJ1ZyB3aGVyZSB0aGUgYXJlYXMgbGVmdCBhbmQgcmlnaHQgdG8gXG4gICAgICogdGhlIGNvbnRlbnQgZG9lcyBub3QgdHJpZ2dlciB0aGUgb25tb3VzZXdoZWVsIGV2ZW50XG4gICAgICogb24gc29tZSBwYWdlcy4gZS5nLjogaHRtbCwgYm9keSB7IGhlaWdodDogMTAwJSB9XG4gICAgICovXG4gICAgZWxzZSBpZiAoaXNPbGRTYWZhcmkgJiZcbiAgICAgICAgICAgICBzY3JvbGxIZWlnaHQgPiB3aW5kb3dIZWlnaHQgJiZcbiAgICAgICAgICAgIChib2R5Lm9mZnNldEhlaWdodCA8PSB3aW5kb3dIZWlnaHQgfHwgXG4gICAgICAgICAgICAgaHRtbC5vZmZzZXRIZWlnaHQgPD0gd2luZG93SGVpZ2h0KSkge1xuXG4gICAgICAgIHZhciBmdWxsUGFnZUVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgZnVsbFBhZ2VFbGVtLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7IHotaW5kZXg6LTEwMDAwOyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndG9wOjA7IGxlZnQ6MDsgcmlnaHQ6MDsgaGVpZ2h0OicgKyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdC5zY3JvbGxIZWlnaHQgKyAncHgnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZ1bGxQYWdlRWxlbSk7XG4gICAgICAgIFxuICAgICAgICAvLyBET00gY2hhbmdlZCAodGhyb3R0bGVkKSB0byBmaXggaGVpZ2h0XG4gICAgICAgIHZhciBwZW5kaW5nUmVmcmVzaDtcbiAgICAgICAgcmVmcmVzaFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ1JlZnJlc2gpIHJldHVybjsgLy8gY291bGQgYWxzbyBiZTogY2xlYXJUaW1lb3V0KHBlbmRpbmdSZWZyZXNoKTtcbiAgICAgICAgICAgIHBlbmRpbmdSZWZyZXNoID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzRXhjbHVkZWQpIHJldHVybjsgLy8gY291bGQgYmUgcnVubmluZyBhZnRlciBjbGVhbnVwXG4gICAgICAgICAgICAgICAgZnVsbFBhZ2VFbGVtLnN0eWxlLmhlaWdodCA9ICcwJztcbiAgICAgICAgICAgICAgICBmdWxsUGFnZUVsZW0uc3R5bGUuaGVpZ2h0ID0gcm9vdC5zY3JvbGxIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgICAgIHBlbmRpbmdSZWZyZXNoID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDUwMCk7IC8vIGFjdCByYXJlbHkgdG8gc3RheSBmYXN0XG4gICAgICAgIH07XG4gIFxuICAgICAgICBzZXRUaW1lb3V0KHJlZnJlc2hTaXplLCAxMCk7XG5cbiAgICAgICAgYWRkRXZlbnQoJ3Jlc2l6ZScsIHJlZnJlc2hTaXplKTtcblxuICAgICAgICAvLyBUT0RPOiBhdHRyaWJ1dGVGaWx0ZXI/XG4gICAgICAgIHZhciBjb25maWcgPSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLCBcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSwgXG4gICAgICAgICAgICBjaGFyYWN0ZXJEYXRhOiBmYWxzZSBcbiAgICAgICAgICAgIC8vIHN1YnRyZWU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlZnJlc2hTaXplKTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShib2R5LCBjb25maWcpO1xuXG4gICAgICAgIGlmIChyb290Lm9mZnNldEhlaWdodCA8PSB3aW5kb3dIZWlnaHQpIHtcbiAgICAgICAgICAgIHZhciBjbGVhcmZpeCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAgIFxuICAgICAgICAgICAgY2xlYXJmaXguc3R5bGUuY2xlYXIgPSAnYm90aCc7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGNsZWFyZml4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRpc2FibGUgZml4ZWQgYmFja2dyb3VuZFxuICAgIGlmICghb3B0aW9ucy5maXhlZEJhY2tncm91bmQgJiYgIWlzRXhjbHVkZWQpIHtcbiAgICAgICAgYm9keS5zdHlsZS5iYWNrZ3JvdW5kQXR0YWNobWVudCA9ICdzY3JvbGwnO1xuICAgICAgICBodG1sLnN0eWxlLmJhY2tncm91bmRBdHRhY2htZW50ID0gJ3Njcm9sbCc7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzIGFuZCBvdGhlciB0cmFjZXMgbGVmdCBvbiB0aGUgcGFnZS5cbiAqL1xuZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBvYnNlcnZlciAmJiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgcmVtb3ZlRXZlbnQod2hlZWxFdmVudCwgd2hlZWwpO1xuICAgIHJlbW92ZUV2ZW50KCdtb3VzZWRvd24nLCBtb3VzZWRvd24pO1xuICAgIHJlbW92ZUV2ZW50KCdrZXlkb3duJywga2V5ZG93bik7XG4gICAgcmVtb3ZlRXZlbnQoJ3Jlc2l6ZScsIHJlZnJlc2hTaXplKTtcbiAgICByZW1vdmVFdmVudCgnbG9hZCcsIGluaXQpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFNDUk9MTElORyBcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gXG52YXIgcXVlID0gW107XG52YXIgcGVuZGluZyA9IGZhbHNlO1xudmFyIGxhc3RTY3JvbGwgPSBEYXRlLm5vdygpO1xuXG4vKipcbiAqIFB1c2hlcyBzY3JvbGwgYWN0aW9ucyB0byB0aGUgc2Nyb2xsaW5nIHF1ZXVlLlxuICovXG5mdW5jdGlvbiBzY3JvbGxBcnJheShlbGVtLCBsZWZ0LCB0b3ApIHtcbiAgICBcbiAgICBkaXJlY3Rpb25DaGVjayhsZWZ0LCB0b3ApO1xuXG4gICAgaWYgKG9wdGlvbnMuYWNjZWxlcmF0aW9uTWF4ICE9IDEpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gbGFzdFNjcm9sbDtcbiAgICAgICAgaWYgKGVsYXBzZWQgPCBvcHRpb25zLmFjY2VsZXJhdGlvbkRlbHRhKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9yID0gKDEgKyAoNTAgLyBlbGFwc2VkKSkgLyAyO1xuICAgICAgICAgICAgaWYgKGZhY3RvciA+IDEpIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPSBNYXRoLm1pbihmYWN0b3IsIG9wdGlvbnMuYWNjZWxlcmF0aW9uTWF4KTtcbiAgICAgICAgICAgICAgICBsZWZ0ICo9IGZhY3RvcjtcbiAgICAgICAgICAgICAgICB0b3AgICo9IGZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0U2Nyb2xsID0gRGF0ZS5ub3coKTtcbiAgICB9ICAgICAgICAgIFxuICAgIFxuICAgIC8vIHB1c2ggYSBzY3JvbGwgY29tbWFuZFxuICAgIHF1ZS5wdXNoKHtcbiAgICAgICAgeDogbGVmdCwgXG4gICAgICAgIHk6IHRvcCwgXG4gICAgICAgIGxhc3RYOiAobGVmdCA8IDApID8gMC45OSA6IC0wLjk5LFxuICAgICAgICBsYXN0WTogKHRvcCAgPCAwKSA/IDAuOTkgOiAtMC45OSwgXG4gICAgICAgIHN0YXJ0OiBEYXRlLm5vdygpXG4gICAgfSk7XG4gICAgICAgIFxuICAgIC8vIGRvbid0IGFjdCBpZiB0aGVyZSdzIGEgcGVuZGluZyBxdWV1ZVxuICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9ICBcblxuICAgIHZhciBzY3JvbGxSb290ID0gZ2V0U2Nyb2xsUm9vdCgpO1xuICAgIHZhciBpc1dpbmRvd1Njcm9sbCA9IChlbGVtID09PSBzY3JvbGxSb290IHx8IGVsZW0gPT09IGRvY3VtZW50LmJvZHkpO1xuICAgIFxuICAgIC8vIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBmaXhlZCB0aGUgYmVoYXZpb3IsIFxuICAgIC8vIGFuZCBpdCBuZWVkcyBmaXhpbmcgZm9yIHRoaXMgc2VzaFxuICAgIGlmIChlbGVtLiRzY3JvbGxCZWhhdmlvciA9PSBudWxsICYmIGlzU2Nyb2xsQmVoYXZpb3JTbW9vdGgoZWxlbSkpIHtcbiAgICAgICAgZWxlbS4kc2Nyb2xsQmVoYXZpb3IgPSBlbGVtLnN0eWxlLnNjcm9sbEJlaGF2aW9yO1xuICAgICAgICBlbGVtLnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gJ2F1dG8nO1xuICAgIH1cblxuICAgIHZhciBzdGVwID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgc2Nyb2xsWCA9IDA7XG4gICAgICAgIHZhciBzY3JvbGxZID0gMDsgXG4gICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpdGVtID0gcXVlW2ldO1xuICAgICAgICAgICAgdmFyIGVsYXBzZWQgID0gbm93IC0gaXRlbS5zdGFydDtcbiAgICAgICAgICAgIHZhciBmaW5pc2hlZCA9IChlbGFwc2VkID49IG9wdGlvbnMuYW5pbWF0aW9uVGltZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIHNjcm9sbCBwb3NpdGlvbjogWzAsIDFdXG4gICAgICAgICAgICB2YXIgcG9zaXRpb24gPSAoZmluaXNoZWQpID8gMSA6IGVsYXBzZWQgLyBvcHRpb25zLmFuaW1hdGlvblRpbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGVhc2luZyBbb3B0aW9uYWxdXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wdWxzZUFsZ29yaXRobSkge1xuICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gcHVsc2UocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBvbmx5IG5lZWQgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIHZhciB4ID0gKGl0ZW0ueCAqIHBvc2l0aW9uIC0gaXRlbS5sYXN0WCkgPj4gMDtcbiAgICAgICAgICAgIHZhciB5ID0gKGl0ZW0ueSAqIHBvc2l0aW9uIC0gaXRlbS5sYXN0WSkgPj4gMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gYWRkIHRoaXMgdG8gdGhlIHRvdGFsIHNjcm9sbGluZ1xuICAgICAgICAgICAgc2Nyb2xsWCArPSB4O1xuICAgICAgICAgICAgc2Nyb2xsWSArPSB5OyAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB1cGRhdGUgbGFzdCB2YWx1ZXNcbiAgICAgICAgICAgIGl0ZW0ubGFzdFggKz0geDtcbiAgICAgICAgICAgIGl0ZW0ubGFzdFkgKz0geTtcbiAgICAgICAgXG4gICAgICAgICAgICAvLyBkZWxldGUgYW5kIHN0ZXAgYmFjayBpZiBpdCdzIG92ZXJcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgIHF1ZS5zcGxpY2UoaSwgMSk7IGktLTtcbiAgICAgICAgICAgIH0gICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2Nyb2xsIGxlZnQgYW5kIHRvcFxuICAgICAgICBpZiAoaXNXaW5kb3dTY3JvbGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxCeShzY3JvbGxYLCBzY3JvbGxZKTtcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsWCkgZWxlbS5zY3JvbGxMZWZ0ICs9IHNjcm9sbFg7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsWSkgZWxlbS5zY3JvbGxUb3AgICs9IHNjcm9sbFk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gY2xlYW4gdXAgaWYgdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG9cbiAgICAgICAgaWYgKCFsZWZ0ICYmICF0b3ApIHtcbiAgICAgICAgICAgIHF1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocXVlLmxlbmd0aCkgeyBcbiAgICAgICAgICAgIHJlcXVlc3RGcmFtZShzdGVwLCBlbGVtLCAoMTAwMCAvIG9wdGlvbnMuZnJhbWVSYXRlICsgMSkpOyBcbiAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICBwZW5kaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZXN0b3JlIGRlZmF1bHQgYmVoYXZpb3IgYXQgdGhlIGVuZCBvZiBzY3JvbGxpbmcgc2VzaFxuICAgICAgICAgICAgaWYgKGVsZW0uJHNjcm9sbEJlaGF2aW9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLnNjcm9sbEJlaGF2aW9yID0gZWxlbS4kc2Nyb2xsQmVoYXZpb3I7XG4gICAgICAgICAgICAgICAgZWxlbS4kc2Nyb2xsQmVoYXZpb3IgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBzdGFydCBhIG5ldyBxdWV1ZSBvZiBhY3Rpb25zXG4gICAgcmVxdWVzdEZyYW1lKHN0ZXAsIGVsZW0sIDApO1xuICAgIHBlbmRpbmcgPSB0cnVlO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRVZFTlRTXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbi8qKlxuICogTW91c2Ugd2hlZWwgaGFuZGxlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICovXG5mdW5jdGlvbiB3aGVlbChldmVudCkge1xuXG4gICAgaWYgKCFpbml0RG9uZSkge1xuICAgICAgICBpbml0KCk7XG4gICAgfVxuICAgIFxuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICAvLyBsZWF2ZSBlYXJseSBpZiBkZWZhdWx0IGFjdGlvbiBpcyBwcmV2ZW50ZWQgICBcbiAgICAvLyBvciBpdCdzIGEgem9vbWluZyBldmVudCB3aXRoIENUUkwgXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgZXZlbnQuY3RybEtleSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gbGVhdmUgZW1iZWRkZWQgY29udGVudCBhbG9uZSAoZmxhc2ggJiBwZGYpXG4gICAgaWYgKGlzTm9kZU5hbWUoYWN0aXZlRWxlbWVudCwgJ2VtYmVkJykgfHwgXG4gICAgICAgKGlzTm9kZU5hbWUodGFyZ2V0LCAnZW1iZWQnKSAmJiAvXFwucGRmL2kudGVzdCh0YXJnZXQuc3JjKSkgfHxcbiAgICAgICAgaXNOb2RlTmFtZShhY3RpdmVFbGVtZW50LCAnb2JqZWN0JykgfHxcbiAgICAgICAgdGFyZ2V0LnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGRlbHRhWCA9IC1ldmVudC53aGVlbERlbHRhWCB8fCBldmVudC5kZWx0YVggfHwgMDtcbiAgICB2YXIgZGVsdGFZID0gLWV2ZW50LndoZWVsRGVsdGFZIHx8IGV2ZW50LmRlbHRhWSB8fCAwO1xuICAgIFxuICAgIGlmIChpc01hYykge1xuICAgICAgICBpZiAoZXZlbnQud2hlZWxEZWx0YVggJiYgaXNEaXZpc2libGUoZXZlbnQud2hlZWxEZWx0YVgsIDEyMCkpIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IC0xMjAgKiAoZXZlbnQud2hlZWxEZWx0YVggLyBNYXRoLmFicyhldmVudC53aGVlbERlbHRhWCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudC53aGVlbERlbHRhWSAmJiBpc0RpdmlzaWJsZShldmVudC53aGVlbERlbHRhWSwgMTIwKSkge1xuICAgICAgICAgICAgZGVsdGFZID0gLTEyMCAqIChldmVudC53aGVlbERlbHRhWSAvIE1hdGguYWJzKGV2ZW50LndoZWVsRGVsdGFZKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gdXNlIHdoZWVsRGVsdGEgaWYgZGVsdGFYL1kgaXMgbm90IGF2YWlsYWJsZVxuICAgIGlmICghZGVsdGFYICYmICFkZWx0YVkpIHtcbiAgICAgICAgZGVsdGFZID0gLWV2ZW50LndoZWVsRGVsdGEgfHwgMDtcbiAgICB9XG5cbiAgICAvLyBsaW5lIGJhc2VkIHNjcm9sbGluZyAoRmlyZWZveCBtb3N0bHkpXG4gICAgaWYgKGV2ZW50LmRlbHRhTW9kZSA9PT0gMSkge1xuICAgICAgICBkZWx0YVggKj0gNDA7XG4gICAgICAgIGRlbHRhWSAqPSA0MDtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmZsb3dpbmcgPSBvdmVyZmxvd2luZ0FuY2VzdG9yKHRhcmdldCk7XG5cbiAgICAvLyBub3RoaW5nIHRvIGRvIGlmIHRoZXJlJ3Mgbm8gZWxlbWVudCB0aGF0J3Mgc2Nyb2xsYWJsZVxuICAgIGlmICghb3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgLy8gZXhjZXB0IENocm9tZSBpZnJhbWVzIHNlZW0gdG8gZWF0IHdoZWVsIGV2ZW50cywgd2hpY2ggd2UgbmVlZCB0byBcbiAgICAgICAgLy8gcHJvcGFnYXRlIHVwLCBpZiB0aGUgaWZyYW1lIGhhcyBub3RoaW5nIG92ZXJmbG93aW5nIHRvIHNjcm9sbFxuICAgICAgICBpZiAoaXNGcmFtZSAmJiBpc0Nocm9tZSkgIHtcbiAgICAgICAgICAgIC8vIGNoYW5nZSB0YXJnZXQgdG8gaWZyYW1lIGVsZW1lbnQgaXRzZWxmIGZvciB0aGUgcGFyZW50IGZyYW1lXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwidGFyZ2V0XCIsIHt2YWx1ZTogd2luZG93LmZyYW1lRWxlbWVudH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC53aGVlbChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIC8vIGNoZWNrIGlmIGl0J3MgYSB0b3VjaHBhZCBzY3JvbGwgdGhhdCBzaG91bGQgYmUgaWdub3JlZFxuICAgIGlmIChpc1RvdWNocGFkKGRlbHRhWSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gc2NhbGUgYnkgc3RlcCBzaXplXG4gICAgLy8gZGVsdGEgaXMgMTIwIG1vc3Qgb2YgdGhlIHRpbWVcbiAgICAvLyBzeW5hcHRpY3Mgc2VlbXMgdG8gc2VuZCAxIHNvbWV0aW1lc1xuICAgIGlmIChNYXRoLmFicyhkZWx0YVgpID4gMS4yKSB7XG4gICAgICAgIGRlbHRhWCAqPSBvcHRpb25zLnN0ZXBTaXplIC8gMTIwO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoZGVsdGFZKSA+IDEuMikge1xuICAgICAgICBkZWx0YVkgKj0gb3B0aW9ucy5zdGVwU2l6ZSAvIDEyMDtcbiAgICB9XG4gICAgXG4gICAgc2Nyb2xsQXJyYXkob3ZlcmZsb3dpbmcsIGRlbHRhWCwgZGVsdGFZKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHNjaGVkdWxlQ2xlYXJDYWNoZSgpO1xufVxuXG4vKipcbiAqIEtleWRvd24gZXZlbnQgaGFuZGxlci5cbiAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICovXG5mdW5jdGlvbiBrZXlkb3duKGV2ZW50KSB7XG5cbiAgICB2YXIgdGFyZ2V0ICAgPSBldmVudC50YXJnZXQ7XG4gICAgdmFyIG1vZGlmaWVyID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBcbiAgICAgICAgICAgICAgICAgIChldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXlDb2RlICE9PSBrZXkuc3BhY2ViYXIpO1xuICAgIFxuICAgIC8vIG91ciBvd24gdHJhY2tlZCBhY3RpdmUgZWxlbWVudCBjb3VsZCd2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4gICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8vIGRvIG5vdGhpbmcgaWYgdXNlciBpcyBlZGl0aW5nIHRleHRcbiAgICAvLyBvciB1c2luZyBhIG1vZGlmaWVyIGtleSAoZXhjZXB0IHNoaWZ0KVxuICAgIC8vIG9yIGluIGEgZHJvcGRvd25cbiAgICAvLyBvciBpbnNpZGUgaW50ZXJhY3RpdmUgZWxlbWVudHNcbiAgICB2YXIgaW5wdXROb2RlTmFtZXMgPSAvXih0ZXh0YXJlYXxzZWxlY3R8ZW1iZWR8b2JqZWN0KSQvaTtcbiAgICB2YXIgYnV0dG9uVHlwZXMgPSAvXihidXR0b258c3VibWl0fHJhZGlvfGNoZWNrYm94fGZpbGV8Y29sb3J8aW1hZ2UpJC9pO1xuICAgIGlmICggZXZlbnQuZGVmYXVsdFByZXZlbnRlZCB8fFxuICAgICAgICAgaW5wdXROb2RlTmFtZXMudGVzdCh0YXJnZXQubm9kZU5hbWUpIHx8XG4gICAgICAgICBpc05vZGVOYW1lKHRhcmdldCwgJ2lucHV0JykgJiYgIWJ1dHRvblR5cGVzLnRlc3QodGFyZ2V0LnR5cGUpIHx8XG4gICAgICAgICBpc05vZGVOYW1lKGFjdGl2ZUVsZW1lbnQsICd2aWRlbycpIHx8XG4gICAgICAgICBpc0luc2lkZVlvdXR1YmVWaWRlbyhldmVudCkgfHxcbiAgICAgICAgIHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSB8fCBcbiAgICAgICAgIG1vZGlmaWVyICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gW3NwYWNlYmFyXSBzaG91bGQgdHJpZ2dlciBidXR0b24gcHJlc3MsIGxlYXZlIGl0IGFsb25lXG4gICAgaWYgKChpc05vZGVOYW1lKHRhcmdldCwgJ2J1dHRvbicpIHx8XG4gICAgICAgICBpc05vZGVOYW1lKHRhcmdldCwgJ2lucHV0JykgJiYgYnV0dG9uVHlwZXMudGVzdCh0YXJnZXQudHlwZSkpICYmXG4gICAgICAgIGV2ZW50LmtleUNvZGUgPT09IGtleS5zcGFjZWJhcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gW2FycndvdyBrZXlzXSBvbiByYWRpbyBidXR0b25zIHNob3VsZCBiZSBsZWZ0IGFsb25lXG4gICAgaWYgKGlzTm9kZU5hbWUodGFyZ2V0LCAnaW5wdXQnKSAmJiB0YXJnZXQudHlwZSA9PSAncmFkaW8nICYmXG4gICAgICAgIGFycm93S2V5c1tldmVudC5rZXlDb2RlXSkgIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc2hpZnQsIHggPSAwLCB5ID0gMDtcbiAgICB2YXIgb3ZlcmZsb3dpbmcgPSBvdmVyZmxvd2luZ0FuY2VzdG9yKGFjdGl2ZUVsZW1lbnQpO1xuXG4gICAgaWYgKCFvdmVyZmxvd2luZykge1xuICAgICAgICAvLyBDaHJvbWUgaWZyYW1lcyBzZWVtIHRvIGVhdCBrZXkgZXZlbnRzLCB3aGljaCB3ZSBuZWVkIHRvIFxuICAgICAgICAvLyBwcm9wYWdhdGUgdXAsIGlmIHRoZSBpZnJhbWUgaGFzIG5vdGhpbmcgb3ZlcmZsb3dpbmcgdG8gc2Nyb2xsXG4gICAgICAgIHJldHVybiAoaXNGcmFtZSAmJiBpc0Nocm9tZSkgPyBwYXJlbnQua2V5ZG93bihldmVudCkgOiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBjbGllbnRIZWlnaHQgPSBvdmVyZmxvd2luZy5jbGllbnRIZWlnaHQ7IFxuXG4gICAgaWYgKG92ZXJmbG93aW5nID09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgY2xpZW50SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIH1cblxuICAgIHN3aXRjaCAoZXZlbnQua2V5Q29kZSkge1xuICAgICAgICBjYXNlIGtleS51cDpcbiAgICAgICAgICAgIHkgPSAtb3B0aW9ucy5hcnJvd1Njcm9sbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5kb3duOlxuICAgICAgICAgICAgeSA9IG9wdGlvbnMuYXJyb3dTY3JvbGw7XG4gICAgICAgICAgICBicmVhazsgICAgICAgICBcbiAgICAgICAgY2FzZSBrZXkuc3BhY2ViYXI6IC8vICgrIHNoaWZ0KVxuICAgICAgICAgICAgc2hpZnQgPSBldmVudC5zaGlmdEtleSA/IDEgOiAtMTtcbiAgICAgICAgICAgIHkgPSAtc2hpZnQgKiBjbGllbnRIZWlnaHQgKiAwLjk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXkucGFnZXVwOlxuICAgICAgICAgICAgeSA9IC1jbGllbnRIZWlnaHQgKiAwLjk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBrZXkucGFnZWRvd246XG4gICAgICAgICAgICB5ID0gY2xpZW50SGVpZ2h0ICogMC45O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LmhvbWU6XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dpbmcgPT0gZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50KVxuICAgICAgICAgICAgICAgIG92ZXJmbG93aW5nID0gZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudDtcbiAgICAgICAgICAgIHkgPSAtb3ZlcmZsb3dpbmcuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LmVuZDpcbiAgICAgICAgICAgIHZhciBzY3JvbGwgPSBvdmVyZmxvd2luZy5zY3JvbGxIZWlnaHQgLSBvdmVyZmxvd2luZy5zY3JvbGxUb3A7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsUmVtYWluaW5nID0gc2Nyb2xsIC0gY2xpZW50SGVpZ2h0O1xuICAgICAgICAgICAgeSA9IChzY3JvbGxSZW1haW5pbmcgPiAwKSA/IHNjcm9sbFJlbWFpbmluZyArIDEwIDogMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGtleS5sZWZ0OlxuICAgICAgICAgICAgeCA9IC1vcHRpb25zLmFycm93U2Nyb2xsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2Uga2V5LnJpZ2h0OlxuICAgICAgICAgICAgeCA9IG9wdGlvbnMuYXJyb3dTY3JvbGw7XG4gICAgICAgICAgICBicmVhazsgICAgICAgICAgICBcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBhIGtleSB3ZSBkb24ndCBjYXJlIGFib3V0XG4gICAgfVxuXG4gICAgc2Nyb2xsQXJyYXkob3ZlcmZsb3dpbmcsIHgsIHkpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgc2NoZWR1bGVDbGVhckNhY2hlKCk7XG59XG5cbi8qKlxuICogTW91c2Vkb3duIGV2ZW50IG9ubHkgZm9yIHVwZGF0aW5nIGFjdGl2ZUVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gbW91c2Vkb3duKGV2ZW50KSB7XG4gICAgYWN0aXZlRWxlbWVudCA9IGV2ZW50LnRhcmdldDtcbn1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIE9WRVJGTE9XXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1bmlxdWVJRCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuIGVsLnVuaXF1ZUlEIHx8IChlbC51bmlxdWVJRCA9IGkrKyk7XG4gICAgfTtcbn0pKCk7XG5cbnZhciBjYWNoZVggPSB7fTsgLy8gY2xlYXJlZCBvdXQgYWZ0ZXIgYSBzY3JvbGxpbmcgc2Vzc2lvblxudmFyIGNhY2hlWSA9IHt9OyAvLyBjbGVhcmVkIG91dCBhZnRlciBhIHNjcm9sbGluZyBzZXNzaW9uXG52YXIgY2xlYXJDYWNoZVRpbWVyO1xudmFyIHNtb290aEJlaGF2aW9yRm9yRWxlbWVudCA9IHt9O1xuXG4vL3NldEludGVydmFsKGZ1bmN0aW9uICgpIHsgY2FjaGUgPSB7fTsgfSwgMTAgKiAxMDAwKTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDbGVhckNhY2hlKCkge1xuICAgIGNsZWFyVGltZW91dChjbGVhckNhY2hlVGltZXIpO1xuICAgIGNsZWFyQ2FjaGVUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHsgXG4gICAgICAgIGNhY2hlWCA9IGNhY2hlWSA9IHNtb290aEJlaGF2aW9yRm9yRWxlbWVudCA9IHt9OyBcbiAgICB9LCAxKjEwMDApO1xufVxuXG5mdW5jdGlvbiBzZXRDYWNoZShlbGVtcywgb3ZlcmZsb3dpbmcsIHgpIHtcbiAgICB2YXIgY2FjaGUgPSB4ID8gY2FjaGVYIDogY2FjaGVZO1xuICAgIGZvciAodmFyIGkgPSBlbGVtcy5sZW5ndGg7IGktLTspXG4gICAgICAgIGNhY2hlW3VuaXF1ZUlEKGVsZW1zW2ldKV0gPSBvdmVyZmxvd2luZztcbiAgICByZXR1cm4gb3ZlcmZsb3dpbmc7XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlKGVsLCB4KSB7XG4gICAgcmV0dXJuICh4ID8gY2FjaGVYIDogY2FjaGVZKVt1bmlxdWVJRChlbCldO1xufVxuXG4vLyAgKGJvZHkpICAgICAgICAgICAgICAgIChyb290KVxuLy8gICAgICAgICB8IGhpZGRlbiB8IHZpc2libGUgfCBzY3JvbGwgfCAgYXV0byAgfFxuLy8gaGlkZGVuICB8ICAgbm8gICB8ICAgIG5vICAgfCAgIFlFUyAgfCAgIFlFUyAgfFxuLy8gdmlzaWJsZSB8ICAgbm8gICB8ICAgWUVTICAgfCAgIFlFUyAgfCAgIFlFUyAgfFxuLy8gc2Nyb2xsICB8ICAgbm8gICB8ICAgWUVTICAgfCAgIFlFUyAgfCAgIFlFUyAgfFxuLy8gYXV0byAgICB8ICAgbm8gICB8ICAgWUVTICAgfCAgIFlFUyAgfCAgIFlFUyAgfFxuXG5mdW5jdGlvbiBvdmVyZmxvd2luZ0FuY2VzdG9yKGVsKSB7XG4gICAgdmFyIGVsZW1zID0gW107XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciByb290U2Nyb2xsSGVpZ2h0ID0gcm9vdC5zY3JvbGxIZWlnaHQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgY2FjaGVkID0gZ2V0Q2FjaGUoZWwsIGZhbHNlKTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNldENhY2hlKGVsZW1zLCBjYWNoZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1zLnB1c2goZWwpO1xuICAgICAgICBpZiAocm9vdFNjcm9sbEhlaWdodCA9PT0gZWwuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgdG9wT3ZlcmZsb3dzTm90SGlkZGVuID0gb3ZlcmZsb3dOb3RIaWRkZW4ocm9vdCkgJiYgb3ZlcmZsb3dOb3RIaWRkZW4oYm9keSk7XG4gICAgICAgICAgICB2YXIgaXNPdmVyZmxvd0NTUyA9IHRvcE92ZXJmbG93c05vdEhpZGRlbiB8fCBvdmVyZmxvd0F1dG9PclNjcm9sbChyb290KTtcbiAgICAgICAgICAgIGlmIChpc0ZyYW1lICYmIGlzQ29udGVudE92ZXJmbG93aW5nKHJvb3QpIHx8IFxuICAgICAgICAgICAgICAgIWlzRnJhbWUgJiYgaXNPdmVyZmxvd0NTUykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXRDYWNoZShlbGVtcywgZ2V0U2Nyb2xsUm9vdCgpKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZW50T3ZlcmZsb3dpbmcoZWwpICYmIG92ZXJmbG93QXV0b09yU2Nyb2xsKGVsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldENhY2hlKGVsZW1zLCBlbCk7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlICgoZWwgPSBlbC5wYXJlbnRFbGVtZW50KSk7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGVudE92ZXJmbG93aW5nKGVsKSB7XG4gICAgcmV0dXJuIChlbC5jbGllbnRIZWlnaHQgKyAxMCA8IGVsLnNjcm9sbEhlaWdodCk7XG59XG5cbi8vIHR5cGljYWxseSBmb3IgPGJvZHk+IGFuZCA8aHRtbD5cbmZ1bmN0aW9uIG92ZXJmbG93Tm90SGlkZGVuKGVsKSB7XG4gICAgdmFyIG92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKTtcbiAgICByZXR1cm4gKG92ZXJmbG93ICE9PSAnaGlkZGVuJyk7XG59XG5cbi8vIGZvciBhbGwgb3RoZXIgZWxlbWVudHNcbmZ1bmN0aW9uIG92ZXJmbG93QXV0b09yU2Nyb2xsKGVsKSB7XG4gICAgdmFyIG92ZXJmbG93ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpLmdldFByb3BlcnR5VmFsdWUoJ292ZXJmbG93LXknKTtcbiAgICByZXR1cm4gKG92ZXJmbG93ID09PSAnc2Nyb2xsJyB8fCBvdmVyZmxvdyA9PT0gJ2F1dG8nKTtcbn1cblxuLy8gZm9yIGFsbCBvdGhlciBlbGVtZW50c1xuZnVuY3Rpb24gaXNTY3JvbGxCZWhhdmlvclNtb290aChlbCkge1xuICAgIHZhciBpZCA9IHVuaXF1ZUlEKGVsKTtcbiAgICBpZiAoc21vb3RoQmVoYXZpb3JGb3JFbGVtZW50W2lkXSA9PSBudWxsKSB7XG4gICAgICAgIHZhciBzY3JvbGxCZWhhdmlvciA9IGdldENvbXB1dGVkU3R5bGUoZWwsICcnKVsnc2Nyb2xsLWJlaGF2aW9yJ107XG4gICAgICAgIHNtb290aEJlaGF2aW9yRm9yRWxlbWVudFtpZF0gPSAoJ3Ntb290aCcgPT0gc2Nyb2xsQmVoYXZpb3IpO1xuICAgIH1cbiAgICByZXR1cm4gc21vb3RoQmVoYXZpb3JGb3JFbGVtZW50W2lkXTtcbn1cblxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIEhFTFBFUlNcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuZnVuY3Rpb24gYWRkRXZlbnQodHlwZSwgZm4sIGFyZykge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBhcmcgfHwgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVFdmVudCh0eXBlLCBmbiwgYXJnKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIGFyZyB8fCBmYWxzZSk7ICBcbn1cblxuZnVuY3Rpb24gaXNOb2RlTmFtZShlbCwgdGFnKSB7XG4gICAgcmV0dXJuIGVsICYmIChlbC5ub2RlTmFtZXx8JycpLnRvTG93ZXJDYXNlKCkgPT09IHRhZy50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBkaXJlY3Rpb25DaGVjayh4LCB5KSB7XG4gICAgeCA9ICh4ID4gMCkgPyAxIDogLTE7XG4gICAgeSA9ICh5ID4gMCkgPyAxIDogLTE7XG4gICAgaWYgKGRpcmVjdGlvbi54ICE9PSB4IHx8IGRpcmVjdGlvbi55ICE9PSB5KSB7XG4gICAgICAgIGRpcmVjdGlvbi54ID0geDtcbiAgICAgICAgZGlyZWN0aW9uLnkgPSB5O1xuICAgICAgICBxdWUgPSBbXTtcbiAgICAgICAgbGFzdFNjcm9sbCA9IDA7XG4gICAgfVxufVxuXG5pZiAod2luZG93LmxvY2FsU3RvcmFnZSAmJiBsb2NhbFN0b3JhZ2UuU1NfZGVsdGFCdWZmZXIpIHtcbiAgICB0cnkgeyAvLyAjNDYgU2FmYXJpIHRocm93cyBpbiBwcml2YXRlIGJyb3dzaW5nIGZvciBsb2NhbFN0b3JhZ2UgXG4gICAgICAgIGRlbHRhQnVmZmVyID0gbG9jYWxTdG9yYWdlLlNTX2RlbHRhQnVmZmVyLnNwbGl0KCcsJyk7XG4gICAgfSBjYXRjaCAoZSkgeyB9IFxufVxuXG5mdW5jdGlvbiBpc1RvdWNocGFkKGRlbHRhWSkge1xuICAgIGlmICghZGVsdGFZKSByZXR1cm47XG4gICAgaWYgKCFkZWx0YUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgZGVsdGFCdWZmZXIgPSBbZGVsdGFZLCBkZWx0YVksIGRlbHRhWV07XG4gICAgfVxuICAgIGRlbHRhWSA9IE1hdGguYWJzKGRlbHRhWSk7XG4gICAgZGVsdGFCdWZmZXIucHVzaChkZWx0YVkpO1xuICAgIGRlbHRhQnVmZmVyLnNoaWZ0KCk7XG4gICAgY2xlYXJUaW1lb3V0KGRlbHRhQnVmZmVyVGltZXIpO1xuICAgIGRlbHRhQnVmZmVyVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHsgLy8gIzQ2IFNhZmFyaSB0aHJvd3MgaW4gcHJpdmF0ZSBicm93c2luZyBmb3IgbG9jYWxTdG9yYWdlXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2UuU1NfZGVsdGFCdWZmZXIgPSBkZWx0YUJ1ZmZlci5qb2luKCcsJyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgfSAgXG4gICAgfSwgMTAwMCk7XG4gICAgdmFyIGRwaVNjYWxlZFdoZWVsRGVsdGEgPSBkZWx0YVkgPiAxMjAgJiYgYWxsRGVsdGFzRGl2aXNhYmxlQnkoZGVsdGFZKTsgLy8gd2luNjQgXG4gICAgdmFyIHRwID0gIWFsbERlbHRhc0RpdmlzYWJsZUJ5KDEyMCkgJiYgIWFsbERlbHRhc0RpdmlzYWJsZUJ5KDEwMCkgJiYgIWRwaVNjYWxlZFdoZWVsRGVsdGE7XG4gICAgaWYgKGRlbHRhWSA8IDUwKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gdHA7XG59IFxuXG5mdW5jdGlvbiBpc0RpdmlzaWJsZShuLCBkaXZpc29yKSB7XG4gICAgcmV0dXJuIChNYXRoLmZsb29yKG4gLyBkaXZpc29yKSA9PSBuIC8gZGl2aXNvcik7XG59XG5cbmZ1bmN0aW9uIGFsbERlbHRhc0RpdmlzYWJsZUJ5KGRpdmlzb3IpIHtcbiAgICByZXR1cm4gKGlzRGl2aXNpYmxlKGRlbHRhQnVmZmVyWzBdLCBkaXZpc29yKSAmJlxuICAgICAgICAgICAgaXNEaXZpc2libGUoZGVsdGFCdWZmZXJbMV0sIGRpdmlzb3IpICYmXG4gICAgICAgICAgICBpc0RpdmlzaWJsZShkZWx0YUJ1ZmZlclsyXSwgZGl2aXNvcikpO1xufVxuXG5mdW5jdGlvbiBpc0luc2lkZVlvdXR1YmVWaWRlbyhldmVudCkge1xuICAgIHZhciBlbGVtID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBpc0NvbnRyb2wgPSBmYWxzZTtcbiAgICBpZiAoZG9jdW1lbnQuVVJMLmluZGV4T2YgKCd3d3cueW91dHViZS5jb20vd2F0Y2gnKSAhPSAtMSkge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpc0NvbnRyb2wgPSAoZWxlbS5jbGFzc0xpc3QgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoJ2h0bWw1LXZpZGVvLWNvbnRyb2xzJykpO1xuICAgICAgICAgICAgaWYgKGlzQ29udHJvbCkgYnJlYWs7XG4gICAgICAgIH0gd2hpbGUgKChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSk7XG4gICAgfVxuICAgIHJldHVybiBpc0NvbnRyb2w7XG59XG5cbnZhciByZXF1ZXN0RnJhbWUgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgICAgIHx8IFxuICAgICAgICAgICAgICB3aW5kb3cud2Via2l0UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IFxuICAgICAgICAgICAgICB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lICAgIHx8XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaywgZWxlbWVudCwgZGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIGRlbGF5IHx8ICgxMDAwLzYwKSk7XG4gICAgICAgICAgICAgfSk7XG59KSgpO1xuXG52YXIgTXV0YXRpb25PYnNlcnZlciA9ICh3aW5kb3cuTXV0YXRpb25PYnNlcnZlciB8fCBcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5XZWJLaXRNdXRhdGlvbk9ic2VydmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuTW96TXV0YXRpb25PYnNlcnZlcik7ICBcblxudmFyIGdldFNjcm9sbFJvb3QgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBTQ1JPTExfUk9PVCA9IGRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQ7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIVNDUk9MTF9ST09UKSB7XG4gICAgICB2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGR1bW15LnN0eWxlLmNzc1RleHQgPSAnaGVpZ2h0OjEwMDAwcHg7d2lkdGg6MXB4Oyc7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGR1bW15KTtcbiAgICAgIHZhciBib2R5U2Nyb2xsVG9wICA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xuICAgICAgdmFyIGRvY0VsU2Nyb2xsVG9wID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgIHdpbmRvdy5zY3JvbGxCeSgwLCAzKTtcbiAgICAgIGlmIChkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCAhPSBib2R5U2Nyb2xsVG9wKVxuICAgICAgICAoU0NST0xMX1JPT1QgPSBkb2N1bWVudC5ib2R5KTtcbiAgICAgIGVsc2UgXG4gICAgICAgIChTQ1JPTExfUk9PVCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgICB3aW5kb3cuc2Nyb2xsQnkoMCwgLTMpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkdW1teSk7XG4gICAgfVxuICAgIHJldHVybiBTQ1JPTExfUk9PVDtcbiAgfTtcbn0pKCk7XG5cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBQVUxTRSAoYnkgTWljaGFlbCBIZXJmKVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuIFxuLyoqXG4gKiBWaXNjb3VzIGZsdWlkIHdpdGggYSBwdWxzZSBmb3IgcGFydCBhbmQgZGVjYXkgZm9yIHRoZSByZXN0LlxuICogLSBBcHBsaWVzIGEgZml4ZWQgZm9yY2Ugb3ZlciBhbiBpbnRlcnZhbCAoYSBkYW1wZWQgYWNjZWxlcmF0aW9uKSwgYW5kXG4gKiAtIExldHMgdGhlIGV4cG9uZW50aWFsIGJsZWVkIGF3YXkgdGhlIHZlbG9jaXR5IG92ZXIgYSBsb25nZXIgaW50ZXJ2YWxcbiAqIC0gTWljaGFlbCBIZXJmLCBodHRwOi8vc3RlcmVvcHNpcy5jb20vc3RvcHBpbmcvXG4gKi9cbmZ1bmN0aW9uIHB1bHNlXyh4KSB7XG4gICAgdmFyIHZhbCwgc3RhcnQsIGV4cHg7XG4gICAgLy8gdGVzdFxuICAgIHggPSB4ICogb3B0aW9ucy5wdWxzZVNjYWxlO1xuICAgIGlmICh4IDwgMSkgeyAvLyBhY2NlbGVhcnRpb25cbiAgICAgICAgdmFsID0geCAtICgxIC0gTWF0aC5leHAoLXgpKTtcbiAgICB9IGVsc2UgeyAgICAgLy8gdGFpbFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIGVuZGVkIGhlcmU6XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5leHAoLTEpO1xuICAgICAgICAvLyBzaW1wbGUgdmlzY291cyBkcmFnXG4gICAgICAgIHggLT0gMTtcbiAgICAgICAgZXhweCA9IDEgLSBNYXRoLmV4cCgteCk7XG4gICAgICAgIHZhbCA9IHN0YXJ0ICsgKGV4cHggKiAoMSAtIHN0YXJ0KSk7XG4gICAgfVxuICAgIHJldHVybiB2YWwgKiBvcHRpb25zLnB1bHNlTm9ybWFsaXplO1xufVxuXG5mdW5jdGlvbiBwdWxzZSh4KSB7XG4gICAgaWYgKHggPj0gMSkgcmV0dXJuIDE7XG4gICAgaWYgKHggPD0gMCkgcmV0dXJuIDA7XG5cbiAgICBpZiAob3B0aW9ucy5wdWxzZU5vcm1hbGl6ZSA9PSAxKSB7XG4gICAgICAgIG9wdGlvbnMucHVsc2VOb3JtYWxpemUgLz0gcHVsc2VfKDEpO1xuICAgIH1cbiAgICByZXR1cm4gcHVsc2VfKHgpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogRklSU1QgUlVOXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbnZhciB1c2VyQWdlbnQgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbnZhciBpc0VkZ2UgICAgPSAvRWRnZS8udGVzdCh1c2VyQWdlbnQpOyAvLyB0aGFuayB5b3UgTVNcbnZhciBpc0Nocm9tZSAgPSAvY2hyb21lL2kudGVzdCh1c2VyQWdlbnQpICYmICFpc0VkZ2U7IFxudmFyIGlzU2FmYXJpICA9IC9zYWZhcmkvaS50ZXN0KHVzZXJBZ2VudCkgJiYgIWlzRWRnZTsgXG52YXIgaXNNb2JpbGUgID0gL21vYmlsZS9pLnRlc3QodXNlckFnZW50KTtcbnZhciBpc0lFV2luNyAgPSAvV2luZG93cyBOVCA2LjEvaS50ZXN0KHVzZXJBZ2VudCkgJiYgL3J2OjExL2kudGVzdCh1c2VyQWdlbnQpO1xudmFyIGlzT2xkU2FmYXJpID0gaXNTYWZhcmkgJiYgKC9WZXJzaW9uXFwvOC9pLnRlc3QodXNlckFnZW50KSB8fCAvVmVyc2lvblxcLzkvaS50ZXN0KHVzZXJBZ2VudCkpO1xudmFyIGlzRW5hYmxlZEZvckJyb3dzZXIgPSAoaXNDaHJvbWUgfHwgaXNTYWZhcmkgfHwgaXNJRVdpbjcpICYmICFpc01vYmlsZTtcblxudmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xudHJ5IHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0XCIsIG51bGwsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzdXBwb3J0c1Bhc3NpdmUgPSB0cnVlO1xuICAgICAgICB9IFxuICAgIH0pKTtcbn0gY2F0Y2goZSkge31cblxudmFyIHdoZWVsT3B0ID0gc3VwcG9ydHNQYXNzaXZlID8geyBwYXNzaXZlOiBmYWxzZSB9IDogZmFsc2U7XG52YXIgd2hlZWxFdmVudCA9ICdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA/ICd3aGVlbCcgOiAnbW91c2V3aGVlbCc7IFxuXG5pZiAod2hlZWxFdmVudCAmJiBpc0VuYWJsZWRGb3JCcm93c2VyKSB7XG4gICAgYWRkRXZlbnQod2hlZWxFdmVudCwgd2hlZWwsIHdoZWVsT3B0KTtcbiAgICBhZGRFdmVudCgnbW91c2Vkb3duJywgbW91c2Vkb3duKTtcbiAgICBhZGRFdmVudCgnbG9hZCcsIGluaXQpO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUFVCTElDIElOVEVSRkFDRVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5mdW5jdGlvbiBTbW9vdGhTY3JvbGwob3B0aW9uc1RvU2V0KSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnNUb1NldClcbiAgICAgICAgaWYgKGRlZmF1bHRPcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpIFxuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gb3B0aW9uc1RvU2V0W2tleV07XG59XG5TbW9vdGhTY3JvbGwuZGVzdHJveSA9IGNsZWFudXA7XG5cbmlmICh3aW5kb3cuU21vb3RoU2Nyb2xsT3B0aW9ucykgLy8gYXN5bmMgQVBJXG4gICAgU21vb3RoU2Nyb2xsKHdpbmRvdy5TbW9vdGhTY3JvbGxPcHRpb25zKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTbW9vdGhTY3JvbGw7XG4gICAgfSk7XG5lbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZXhwb3J0cylcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFNtb290aFNjcm9sbDtcbmVsc2VcbiAgICB3aW5kb3cuU21vb3RoU2Nyb2xsID0gU21vb3RoU2Nyb2xsO1xuXG59KSgpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/smoothscroll-for-websites/SmoothScroll.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
(() => {
/*!*********************************!*\
  !*** ./resources/js/scripts.js ***!
  \*********************************/
eval("/*\n|--------------------------------------------------------------------------\n| Core\n|--------------------------------------------------------------------------\n|\n| The start point of the project. Include jQuery, Bootstrap and required\n| plugins and define page object. This file is required.\n|\n*/\n__webpack_require__(/*! ../plugin/js/loaders/core.js */ \"./resources/plugin/js/loaders/core.js\");\n/*\n|--------------------------------------------------------------------------\n| Vendors\n|--------------------------------------------------------------------------\n|\n| Load some plugins and define initializer methods. If you don't need any\n| of the following plugins, simply comment the line.\n|\n| The minified size of each module has stated for your reference. So you'd\n| know how much KB you can save by removing a vendor.\n|\n*/\n// require('../plugin/js/vendors/aos.js');            // 14 kb\n// require('../plugin/js/vendors/constellation.js');  // 03 kb\n// require('../plugin/js/vendors/countdown.js');   // 05 kb\n// require('../plugin/js/vendors/countup.js');     // 13 kb\n// require('../plugin/js/vendors/granim.js');      // 15 kb\n// require('../plugin/js/vendors/jarallax.js');    // 23 kb\n// require('../plugin/js/vendors/lity.js');           // 07 kb\n// require('../plugin/js/vendors/photoswipe.js');  // 45 kb\n// require('../plugin/js/vendors/shuffle.js');     // 25 kb\n// require('../plugin/js/vendors/slick.js');          // 43 kb\n// require('../plugin/js/vendors/typed.js');          // 11 kb\n// require('../plugin/js/vendors/colorthief.js');     // 7 kb\n\n\n__webpack_require__(/*! ../plugin/js/vendors/datatables.js */ \"./resources/plugin/js/vendors/datatables.js\");\n/*\n|--------------------------------------------------------------------------\n| Config file\n|--------------------------------------------------------------------------\n|\n*/\n\n\n__webpack_require__(/*! ../plugin/js/config.js */ \"./resources/plugin/js/config.js\");\n/*\n|--------------------------------------------------------------------------\n| Partials\n|--------------------------------------------------------------------------\n|\n| Split the application code to several files. This file is required.\n|\n*/\n\n\n__webpack_require__(/*! ../plugin/js/loaders/partials.js */ \"./resources/plugin/js/loaders/partials.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc2NyaXB0cy5qcz9iOGQ4Il0sIm5hbWVzIjpbInJlcXVpcmUiXSwibWFwcGluZ3MiOiJBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxtQkFBTyxDQUFDLDJFQUFELENBQVA7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBQSxtQkFBTyxDQUFDLHVGQUFELENBQVA7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBQSxtQkFBTyxDQUFDLCtEQUFELENBQVA7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQUEsbUJBQU8sQ0FBQyxtRkFBRCxDQUFQIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL3NjcmlwdHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29yZVxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58XG58IFRoZSBzdGFydCBwb2ludCBvZiB0aGUgcHJvamVjdC4gSW5jbHVkZSBqUXVlcnksIEJvb3RzdHJhcCBhbmQgcmVxdWlyZWRcbnwgcGx1Z2lucyBhbmQgZGVmaW5lIHBhZ2Ugb2JqZWN0LiBUaGlzIGZpbGUgaXMgcmVxdWlyZWQuXG58XG4qL1xucmVxdWlyZSgnLi4vcGx1Z2luL2pzL2xvYWRlcnMvY29yZS5qcycpO1xuXG4vKlxufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58IFZlbmRvcnNcbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufFxufCBMb2FkIHNvbWUgcGx1Z2lucyBhbmQgZGVmaW5lIGluaXRpYWxpemVyIG1ldGhvZHMuIElmIHlvdSBkb24ndCBuZWVkIGFueVxufCBvZiB0aGUgZm9sbG93aW5nIHBsdWdpbnMsIHNpbXBseSBjb21tZW50IHRoZSBsaW5lLlxufFxufCBUaGUgbWluaWZpZWQgc2l6ZSBvZiBlYWNoIG1vZHVsZSBoYXMgc3RhdGVkIGZvciB5b3VyIHJlZmVyZW5jZS4gU28geW91J2Rcbnwga25vdyBob3cgbXVjaCBLQiB5b3UgY2FuIHNhdmUgYnkgcmVtb3ZpbmcgYSB2ZW5kb3IuXG58XG4qL1xuLy8gcmVxdWlyZSgnLi4vcGx1Z2luL2pzL3ZlbmRvcnMvYW9zLmpzJyk7ICAgICAgICAgICAgLy8gMTQga2Jcbi8vIHJlcXVpcmUoJy4uL3BsdWdpbi9qcy92ZW5kb3JzL2NvbnN0ZWxsYXRpb24uanMnKTsgIC8vIDAzIGtiXG4vLyByZXF1aXJlKCcuLi9wbHVnaW4vanMvdmVuZG9ycy9jb3VudGRvd24uanMnKTsgICAvLyAwNSBrYlxuLy8gcmVxdWlyZSgnLi4vcGx1Z2luL2pzL3ZlbmRvcnMvY291bnR1cC5qcycpOyAgICAgLy8gMTMga2Jcbi8vIHJlcXVpcmUoJy4uL3BsdWdpbi9qcy92ZW5kb3JzL2dyYW5pbS5qcycpOyAgICAgIC8vIDE1IGtiXG4vLyByZXF1aXJlKCcuLi9wbHVnaW4vanMvdmVuZG9ycy9qYXJhbGxheC5qcycpOyAgICAvLyAyMyBrYlxuLy8gcmVxdWlyZSgnLi4vcGx1Z2luL2pzL3ZlbmRvcnMvbGl0eS5qcycpOyAgICAgICAgICAgLy8gMDcga2Jcbi8vIHJlcXVpcmUoJy4uL3BsdWdpbi9qcy92ZW5kb3JzL3Bob3Rvc3dpcGUuanMnKTsgIC8vIDQ1IGtiXG4vLyByZXF1aXJlKCcuLi9wbHVnaW4vanMvdmVuZG9ycy9zaHVmZmxlLmpzJyk7ICAgICAvLyAyNSBrYlxuLy8gcmVxdWlyZSgnLi4vcGx1Z2luL2pzL3ZlbmRvcnMvc2xpY2suanMnKTsgICAgICAgICAgLy8gNDMga2Jcbi8vIHJlcXVpcmUoJy4uL3BsdWdpbi9qcy92ZW5kb3JzL3R5cGVkLmpzJyk7ICAgICAgICAgIC8vIDExIGtiXG4vLyByZXF1aXJlKCcuLi9wbHVnaW4vanMvdmVuZG9ycy9jb2xvcnRoaWVmLmpzJyk7ICAgICAvLyA3IGtiXG5yZXF1aXJlKCcuLi9wbHVnaW4vanMvdmVuZG9ycy9kYXRhdGFibGVzLmpzJyk7XG5cbi8qXG58LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnwgQ29uZmlnIGZpbGVcbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufFxuKi9cbnJlcXVpcmUoJy4uL3BsdWdpbi9qcy9jb25maWcuanMnKTtcblxuLypcbnwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxufCBQYXJ0aWFsc1xufC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG58XG58IFNwbGl0IHRoZSBhcHBsaWNhdGlvbiBjb2RlIHRvIHNldmVyYWwgZmlsZXMuIFRoaXMgZmlsZSBpcyByZXF1aXJlZC5cbnxcbiovXG5yZXF1aXJlKCcuLi9wbHVnaW4vanMvbG9hZGVycy9wYXJ0aWFscy5qcycpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/scripts.js\n");
})();

/******/ })()
;